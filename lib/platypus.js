var platypus =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/pako/index.js":
/*!************************************!*\
  !*** ./node_modules/pako/index.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Top level file is just a mixin of submodules & constants\n\n\nvar assign    = __webpack_require__(/*! ./lib/utils/common */ \"./node_modules/pako/lib/utils/common.js\").assign;\n\nvar deflate   = __webpack_require__(/*! ./lib/deflate */ \"./node_modules/pako/lib/deflate.js\");\nvar inflate   = __webpack_require__(/*! ./lib/inflate */ \"./node_modules/pako/lib/inflate.js\");\nvar constants = __webpack_require__(/*! ./lib/zlib/constants */ \"./node_modules/pako/lib/zlib/constants.js\");\n\nvar pako = {};\n\nassign(pako, deflate, inflate, constants);\n\nmodule.exports = pako;\n\n\n//# sourceURL=webpack://platypus/./node_modules/pako/index.js?");

/***/ }),

/***/ "./node_modules/pako/lib/deflate.js":
/*!******************************************!*\
  !*** ./node_modules/pako/lib/deflate.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\nvar zlib_deflate = __webpack_require__(/*! ./zlib/deflate */ \"./node_modules/pako/lib/zlib/deflate.js\");\nvar utils        = __webpack_require__(/*! ./utils/common */ \"./node_modules/pako/lib/utils/common.js\");\nvar strings      = __webpack_require__(/*! ./utils/strings */ \"./node_modules/pako/lib/utils/strings.js\");\nvar msg          = __webpack_require__(/*! ./zlib/messages */ \"./node_modules/pako/lib/zlib/messages.js\");\nvar ZStream      = __webpack_require__(/*! ./zlib/zstream */ \"./node_modules/pako/lib/zlib/zstream.js\");\n\nvar toString = Object.prototype.toString;\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\nvar Z_NO_FLUSH      = 0;\nvar Z_FINISH        = 4;\n\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\nvar Z_SYNC_FLUSH    = 2;\n\nvar Z_DEFAULT_COMPRESSION = -1;\n\nvar Z_DEFAULT_STRATEGY    = 0;\n\nvar Z_DEFLATED  = 8;\n\n/* ===========================================================================*/\n\n\n/**\n * class Deflate\n *\n * Generic JS-style wrapper for zlib calls. If you don't need\n * streaming behaviour - use more simple functions: [[deflate]],\n * [[deflateRaw]] and [[gzip]].\n **/\n\n/* internal\n * Deflate.chunks -> Array\n *\n * Chunks of output data, if [[Deflate#onData]] not overriden.\n **/\n\n/**\n * Deflate.result -> Uint8Array|Array\n *\n * Compressed result, generated by default [[Deflate#onData]]\n * and [[Deflate#onEnd]] handlers. Filled after you push last chunk\n * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you\n * push a chunk with explicit flush (call [[Deflate#push]] with\n * `Z_SYNC_FLUSH` param).\n **/\n\n/**\n * Deflate.err -> Number\n *\n * Error code after deflate finished. 0 (Z_OK) on success.\n * You will not need it in real life, because deflate errors\n * are possible only on wrong options or bad `onData` / `onEnd`\n * custom handlers.\n **/\n\n/**\n * Deflate.msg -> String\n *\n * Error message, if [[Deflate.err]] != 0\n **/\n\n\n/**\n * new Deflate(options)\n * - options (Object): zlib deflate options.\n *\n * Creates new deflator instance with specified params. Throws exception\n * on bad params. Supported options:\n *\n * - `level`\n * - `windowBits`\n * - `memLevel`\n * - `strategy`\n * - `dictionary`\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Additional options, for internal needs:\n *\n * - `chunkSize` - size of generated data chunks (16K by default)\n * - `raw` (Boolean) - do raw deflate\n * - `gzip` (Boolean) - create gzip wrapper\n * - `to` (String) - if equal to 'string', then result will be \"binary string\"\n *    (each char code [0..255])\n * - `header` (Object) - custom header for gzip\n *   - `text` (Boolean) - true if compressed data believed to be text\n *   - `time` (Number) - modification time, unix timestamp\n *   - `os` (Number) - operation system code\n *   - `extra` (Array) - array of bytes with extra data (max 65536)\n *   - `name` (String) - file name (binary string)\n *   - `comment` (String) - comment (binary string)\n *   - `hcrc` (Boolean) - true if header crc should be added\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])\n *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n *\n * var deflate = new pako.Deflate({ level: 3});\n *\n * deflate.push(chunk1, false);\n * deflate.push(chunk2, true);  // true -> last chunk\n *\n * if (deflate.err) { throw new Error(deflate.err); }\n *\n * console.log(deflate.result);\n * ```\n **/\nfunction Deflate(options) {\n  if (!(this instanceof Deflate)) return new Deflate(options);\n\n  this.options = utils.assign({\n    level: Z_DEFAULT_COMPRESSION,\n    method: Z_DEFLATED,\n    chunkSize: 16384,\n    windowBits: 15,\n    memLevel: 8,\n    strategy: Z_DEFAULT_STRATEGY,\n    to: ''\n  }, options || {});\n\n  var opt = this.options;\n\n  if (opt.raw && (opt.windowBits > 0)) {\n    opt.windowBits = -opt.windowBits;\n  }\n\n  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {\n    opt.windowBits += 16;\n  }\n\n  this.err    = 0;      // error code, if happens (0 = Z_OK)\n  this.msg    = '';     // error message\n  this.ended  = false;  // used to avoid multiple onEnd() calls\n  this.chunks = [];     // chunks of compressed data\n\n  this.strm = new ZStream();\n  this.strm.avail_out = 0;\n\n  var status = zlib_deflate.deflateInit2(\n    this.strm,\n    opt.level,\n    opt.method,\n    opt.windowBits,\n    opt.memLevel,\n    opt.strategy\n  );\n\n  if (status !== Z_OK) {\n    throw new Error(msg[status]);\n  }\n\n  if (opt.header) {\n    zlib_deflate.deflateSetHeader(this.strm, opt.header);\n  }\n\n  if (opt.dictionary) {\n    var dict;\n    // Convert data if needed\n    if (typeof opt.dictionary === 'string') {\n      // If we need to compress text, change encoding to utf8.\n      dict = strings.string2buf(opt.dictionary);\n    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {\n      dict = new Uint8Array(opt.dictionary);\n    } else {\n      dict = opt.dictionary;\n    }\n\n    status = zlib_deflate.deflateSetDictionary(this.strm, dict);\n\n    if (status !== Z_OK) {\n      throw new Error(msg[status]);\n    }\n\n    this._dict_set = true;\n  }\n}\n\n/**\n * Deflate#push(data[, mode]) -> Boolean\n * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be\n *   converted to utf8 byte sequence.\n * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` meansh Z_FINISH.\n *\n * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with\n * new compressed chunks. Returns `true` on success. The last data block must have\n * mode Z_FINISH (or `true`). That will flush internal pending buffers and call\n * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you\n * can use mode Z_SYNC_FLUSH, keeping the compression context.\n *\n * On fail call [[Deflate#onEnd]] with error code and return false.\n *\n * We strongly recommend to use `Uint8Array` on input for best speed (output\n * array format is detected automatically). Also, don't skip last param and always\n * use the same type in your code (boolean or number). That will improve JS speed.\n *\n * For regular `Array`-s make sure all elements are [0..255].\n *\n * ##### Example\n *\n * ```javascript\n * push(chunk, false); // push one of data chunks\n * ...\n * push(chunk, true);  // push last chunk\n * ```\n **/\nDeflate.prototype.push = function (data, mode) {\n  var strm = this.strm;\n  var chunkSize = this.options.chunkSize;\n  var status, _mode;\n\n  if (this.ended) { return false; }\n\n  _mode = (mode === ~~mode) ? mode : ((mode === true) ? Z_FINISH : Z_NO_FLUSH);\n\n  // Convert data if needed\n  if (typeof data === 'string') {\n    // If we need to compress text, change encoding to utf8.\n    strm.input = strings.string2buf(data);\n  } else if (toString.call(data) === '[object ArrayBuffer]') {\n    strm.input = new Uint8Array(data);\n  } else {\n    strm.input = data;\n  }\n\n  strm.next_in = 0;\n  strm.avail_in = strm.input.length;\n\n  do {\n    if (strm.avail_out === 0) {\n      strm.output = new utils.Buf8(chunkSize);\n      strm.next_out = 0;\n      strm.avail_out = chunkSize;\n    }\n    status = zlib_deflate.deflate(strm, _mode);    /* no bad return value */\n\n    if (status !== Z_STREAM_END && status !== Z_OK) {\n      this.onEnd(status);\n      this.ended = true;\n      return false;\n    }\n    if (strm.avail_out === 0 || (strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH))) {\n      if (this.options.to === 'string') {\n        this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));\n      } else {\n        this.onData(utils.shrinkBuf(strm.output, strm.next_out));\n      }\n    }\n  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);\n\n  // Finalize on the last chunk.\n  if (_mode === Z_FINISH) {\n    status = zlib_deflate.deflateEnd(this.strm);\n    this.onEnd(status);\n    this.ended = true;\n    return status === Z_OK;\n  }\n\n  // callback interim results if Z_SYNC_FLUSH.\n  if (_mode === Z_SYNC_FLUSH) {\n    this.onEnd(Z_OK);\n    strm.avail_out = 0;\n    return true;\n  }\n\n  return true;\n};\n\n\n/**\n * Deflate#onData(chunk) -> Void\n * - chunk (Uint8Array|Array|String): ouput data. Type of array depends\n *   on js engine support. When string output requested, each chunk\n *   will be string.\n *\n * By default, stores data blocks in `chunks[]` property and glue\n * those in `onEnd`. Override this handler, if you need another behaviour.\n **/\nDeflate.prototype.onData = function (chunk) {\n  this.chunks.push(chunk);\n};\n\n\n/**\n * Deflate#onEnd(status) -> Void\n * - status (Number): deflate status. 0 (Z_OK) on success,\n *   other if not.\n *\n * Called once after you tell deflate that the input stream is\n * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)\n * or if an error happened. By default - join collected chunks,\n * free memory and fill `results` / `err` properties.\n **/\nDeflate.prototype.onEnd = function (status) {\n  // On success - join\n  if (status === Z_OK) {\n    if (this.options.to === 'string') {\n      this.result = this.chunks.join('');\n    } else {\n      this.result = utils.flattenChunks(this.chunks);\n    }\n  }\n  this.chunks = [];\n  this.err = status;\n  this.msg = this.strm.msg;\n};\n\n\n/**\n * deflate(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * Compress `data` with deflate algorithm and `options`.\n *\n * Supported options are:\n *\n * - level\n * - windowBits\n * - memLevel\n * - strategy\n * - dictionary\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Sugar (options):\n *\n * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n *   negative windowBits implicitly.\n * - `to` (String) - if equal to 'string', then result will be \"binary string\"\n *    (each char code [0..255])\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);\n *\n * console.log(pako.deflate(data));\n * ```\n **/\nfunction deflate(input, options) {\n  var deflator = new Deflate(options);\n\n  deflator.push(input, true);\n\n  // That will never happens, if you don't cheat with options :)\n  if (deflator.err) { throw deflator.msg; }\n\n  return deflator.result;\n}\n\n\n/**\n * deflateRaw(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but creates raw data, without wrapper\n * (header and adler32 crc).\n **/\nfunction deflateRaw(input, options) {\n  options = options || {};\n  options.raw = true;\n  return deflate(input, options);\n}\n\n\n/**\n * gzip(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but create gzip wrapper instead of\n * deflate one.\n **/\nfunction gzip(input, options) {\n  options = options || {};\n  options.gzip = true;\n  return deflate(input, options);\n}\n\n\nexports.Deflate = Deflate;\nexports.deflate = deflate;\nexports.deflateRaw = deflateRaw;\nexports.gzip = gzip;\n\n\n//# sourceURL=webpack://platypus/./node_modules/pako/lib/deflate.js?");

/***/ }),

/***/ "./node_modules/pako/lib/inflate.js":
/*!******************************************!*\
  !*** ./node_modules/pako/lib/inflate.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\nvar zlib_inflate = __webpack_require__(/*! ./zlib/inflate */ \"./node_modules/pako/lib/zlib/inflate.js\");\nvar utils        = __webpack_require__(/*! ./utils/common */ \"./node_modules/pako/lib/utils/common.js\");\nvar strings      = __webpack_require__(/*! ./utils/strings */ \"./node_modules/pako/lib/utils/strings.js\");\nvar c            = __webpack_require__(/*! ./zlib/constants */ \"./node_modules/pako/lib/zlib/constants.js\");\nvar msg          = __webpack_require__(/*! ./zlib/messages */ \"./node_modules/pako/lib/zlib/messages.js\");\nvar ZStream      = __webpack_require__(/*! ./zlib/zstream */ \"./node_modules/pako/lib/zlib/zstream.js\");\nvar GZheader     = __webpack_require__(/*! ./zlib/gzheader */ \"./node_modules/pako/lib/zlib/gzheader.js\");\n\nvar toString = Object.prototype.toString;\n\n/**\n * class Inflate\n *\n * Generic JS-style wrapper for zlib calls. If you don't need\n * streaming behaviour - use more simple functions: [[inflate]]\n * and [[inflateRaw]].\n **/\n\n/* internal\n * inflate.chunks -> Array\n *\n * Chunks of output data, if [[Inflate#onData]] not overriden.\n **/\n\n/**\n * Inflate.result -> Uint8Array|Array|String\n *\n * Uncompressed result, generated by default [[Inflate#onData]]\n * and [[Inflate#onEnd]] handlers. Filled after you push last chunk\n * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you\n * push a chunk with explicit flush (call [[Inflate#push]] with\n * `Z_SYNC_FLUSH` param).\n **/\n\n/**\n * Inflate.err -> Number\n *\n * Error code after inflate finished. 0 (Z_OK) on success.\n * Should be checked if broken data possible.\n **/\n\n/**\n * Inflate.msg -> String\n *\n * Error message, if [[Inflate.err]] != 0\n **/\n\n\n/**\n * new Inflate(options)\n * - options (Object): zlib inflate options.\n *\n * Creates new inflator instance with specified params. Throws exception\n * on bad params. Supported options:\n *\n * - `windowBits`\n * - `dictionary`\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Additional options, for internal needs:\n *\n * - `chunkSize` - size of generated data chunks (16K by default)\n * - `raw` (Boolean) - do raw inflate\n * - `to` (String) - if equal to 'string', then result will be converted\n *   from utf8 to utf16 (javascript) string. When string output requested,\n *   chunk length can differ from `chunkSize`, depending on content.\n *\n * By default, when no options set, autodetect deflate/gzip data format via\n * wrapper header.\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])\n *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n *\n * var inflate = new pako.Inflate({ level: 3});\n *\n * inflate.push(chunk1, false);\n * inflate.push(chunk2, true);  // true -> last chunk\n *\n * if (inflate.err) { throw new Error(inflate.err); }\n *\n * console.log(inflate.result);\n * ```\n **/\nfunction Inflate(options) {\n  if (!(this instanceof Inflate)) return new Inflate(options);\n\n  this.options = utils.assign({\n    chunkSize: 16384,\n    windowBits: 0,\n    to: ''\n  }, options || {});\n\n  var opt = this.options;\n\n  // Force window size for `raw` data, if not set directly,\n  // because we have no header for autodetect.\n  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {\n    opt.windowBits = -opt.windowBits;\n    if (opt.windowBits === 0) { opt.windowBits = -15; }\n  }\n\n  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate\n  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&\n      !(options && options.windowBits)) {\n    opt.windowBits += 32;\n  }\n\n  // Gzip header has no info about windows size, we can do autodetect only\n  // for deflate. So, if window size not set, force it to max when gzip possible\n  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {\n    // bit 3 (16) -> gzipped data\n    // bit 4 (32) -> autodetect gzip/deflate\n    if ((opt.windowBits & 15) === 0) {\n      opt.windowBits |= 15;\n    }\n  }\n\n  this.err    = 0;      // error code, if happens (0 = Z_OK)\n  this.msg    = '';     // error message\n  this.ended  = false;  // used to avoid multiple onEnd() calls\n  this.chunks = [];     // chunks of compressed data\n\n  this.strm   = new ZStream();\n  this.strm.avail_out = 0;\n\n  var status  = zlib_inflate.inflateInit2(\n    this.strm,\n    opt.windowBits\n  );\n\n  if (status !== c.Z_OK) {\n    throw new Error(msg[status]);\n  }\n\n  this.header = new GZheader();\n\n  zlib_inflate.inflateGetHeader(this.strm, this.header);\n}\n\n/**\n * Inflate#push(data[, mode]) -> Boolean\n * - data (Uint8Array|Array|ArrayBuffer|String): input data\n * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` meansh Z_FINISH.\n *\n * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with\n * new output chunks. Returns `true` on success. The last data block must have\n * mode Z_FINISH (or `true`). That will flush internal pending buffers and call\n * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you\n * can use mode Z_SYNC_FLUSH, keeping the decompression context.\n *\n * On fail call [[Inflate#onEnd]] with error code and return false.\n *\n * We strongly recommend to use `Uint8Array` on input for best speed (output\n * format is detected automatically). Also, don't skip last param and always\n * use the same type in your code (boolean or number). That will improve JS speed.\n *\n * For regular `Array`-s make sure all elements are [0..255].\n *\n * ##### Example\n *\n * ```javascript\n * push(chunk, false); // push one of data chunks\n * ...\n * push(chunk, true);  // push last chunk\n * ```\n **/\nInflate.prototype.push = function (data, mode) {\n  var strm = this.strm;\n  var chunkSize = this.options.chunkSize;\n  var dictionary = this.options.dictionary;\n  var status, _mode;\n  var next_out_utf8, tail, utf8str;\n  var dict;\n\n  // Flag to properly process Z_BUF_ERROR on testing inflate call\n  // when we check that all output data was flushed.\n  var allowBufError = false;\n\n  if (this.ended) { return false; }\n  _mode = (mode === ~~mode) ? mode : ((mode === true) ? c.Z_FINISH : c.Z_NO_FLUSH);\n\n  // Convert data if needed\n  if (typeof data === 'string') {\n    // Only binary strings can be decompressed on practice\n    strm.input = strings.binstring2buf(data);\n  } else if (toString.call(data) === '[object ArrayBuffer]') {\n    strm.input = new Uint8Array(data);\n  } else {\n    strm.input = data;\n  }\n\n  strm.next_in = 0;\n  strm.avail_in = strm.input.length;\n\n  do {\n    if (strm.avail_out === 0) {\n      strm.output = new utils.Buf8(chunkSize);\n      strm.next_out = 0;\n      strm.avail_out = chunkSize;\n    }\n\n    status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);    /* no bad return value */\n\n    if (status === c.Z_NEED_DICT && dictionary) {\n      // Convert data if needed\n      if (typeof dictionary === 'string') {\n        dict = strings.string2buf(dictionary);\n      } else if (toString.call(dictionary) === '[object ArrayBuffer]') {\n        dict = new Uint8Array(dictionary);\n      } else {\n        dict = dictionary;\n      }\n\n      status = zlib_inflate.inflateSetDictionary(this.strm, dict);\n\n    }\n\n    if (status === c.Z_BUF_ERROR && allowBufError === true) {\n      status = c.Z_OK;\n      allowBufError = false;\n    }\n\n    if (status !== c.Z_STREAM_END && status !== c.Z_OK) {\n      this.onEnd(status);\n      this.ended = true;\n      return false;\n    }\n\n    if (strm.next_out) {\n      if (strm.avail_out === 0 || status === c.Z_STREAM_END || (strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH))) {\n\n        if (this.options.to === 'string') {\n\n          next_out_utf8 = strings.utf8border(strm.output, strm.next_out);\n\n          tail = strm.next_out - next_out_utf8;\n          utf8str = strings.buf2string(strm.output, next_out_utf8);\n\n          // move tail\n          strm.next_out = tail;\n          strm.avail_out = chunkSize - tail;\n          if (tail) { utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0); }\n\n          this.onData(utf8str);\n\n        } else {\n          this.onData(utils.shrinkBuf(strm.output, strm.next_out));\n        }\n      }\n    }\n\n    // When no more input data, we should check that internal inflate buffers\n    // are flushed. The only way to do it when avail_out = 0 - run one more\n    // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.\n    // Here we set flag to process this error properly.\n    //\n    // NOTE. Deflate does not return error in this case and does not needs such\n    // logic.\n    if (strm.avail_in === 0 && strm.avail_out === 0) {\n      allowBufError = true;\n    }\n\n  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);\n\n  if (status === c.Z_STREAM_END) {\n    _mode = c.Z_FINISH;\n  }\n\n  // Finalize on the last chunk.\n  if (_mode === c.Z_FINISH) {\n    status = zlib_inflate.inflateEnd(this.strm);\n    this.onEnd(status);\n    this.ended = true;\n    return status === c.Z_OK;\n  }\n\n  // callback interim results if Z_SYNC_FLUSH.\n  if (_mode === c.Z_SYNC_FLUSH) {\n    this.onEnd(c.Z_OK);\n    strm.avail_out = 0;\n    return true;\n  }\n\n  return true;\n};\n\n\n/**\n * Inflate#onData(chunk) -> Void\n * - chunk (Uint8Array|Array|String): ouput data. Type of array depends\n *   on js engine support. When string output requested, each chunk\n *   will be string.\n *\n * By default, stores data blocks in `chunks[]` property and glue\n * those in `onEnd`. Override this handler, if you need another behaviour.\n **/\nInflate.prototype.onData = function (chunk) {\n  this.chunks.push(chunk);\n};\n\n\n/**\n * Inflate#onEnd(status) -> Void\n * - status (Number): inflate status. 0 (Z_OK) on success,\n *   other if not.\n *\n * Called either after you tell inflate that the input stream is\n * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)\n * or if an error happened. By default - join collected chunks,\n * free memory and fill `results` / `err` properties.\n **/\nInflate.prototype.onEnd = function (status) {\n  // On success - join\n  if (status === c.Z_OK) {\n    if (this.options.to === 'string') {\n      // Glue & convert here, until we teach pako to send\n      // utf8 alligned strings to onData\n      this.result = this.chunks.join('');\n    } else {\n      this.result = utils.flattenChunks(this.chunks);\n    }\n  }\n  this.chunks = [];\n  this.err = status;\n  this.msg = this.strm.msg;\n};\n\n\n/**\n * inflate(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * Decompress `data` with inflate/ungzip and `options`. Autodetect\n * format via wrapper header by default. That's why we don't provide\n * separate `ungzip` method.\n *\n * Supported options are:\n *\n * - windowBits\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information.\n *\n * Sugar (options):\n *\n * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n *   negative windowBits implicitly.\n * - `to` (String) - if equal to 'string', then result will be converted\n *   from utf8 to utf16 (javascript) string. When string output requested,\n *   chunk length can differ from `chunkSize`, depending on content.\n *\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])\n *   , output;\n *\n * try {\n *   output = pako.inflate(input);\n * } catch (err)\n *   console.log(err);\n * }\n * ```\n **/\nfunction inflate(input, options) {\n  var inflator = new Inflate(options);\n\n  inflator.push(input, true);\n\n  // That will never happens, if you don't cheat with options :)\n  if (inflator.err) { throw inflator.msg; }\n\n  return inflator.result;\n}\n\n\n/**\n * inflateRaw(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * The same as [[inflate]], but creates raw data, without wrapper\n * (header and adler32 crc).\n **/\nfunction inflateRaw(input, options) {\n  options = options || {};\n  options.raw = true;\n  return inflate(input, options);\n}\n\n\n/**\n * ungzip(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * Just shortcut to [[inflate]], because it autodetects format\n * by header.content. Done for convenience.\n **/\n\n\nexports.Inflate = Inflate;\nexports.inflate = inflate;\nexports.inflateRaw = inflateRaw;\nexports.ungzip  = inflate;\n\n\n//# sourceURL=webpack://platypus/./node_modules/pako/lib/inflate.js?");

/***/ }),

/***/ "./node_modules/pako/lib/utils/common.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/utils/common.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\nvar TYPED_OK =  (typeof Uint8Array !== 'undefined') &&\n                (typeof Uint16Array !== 'undefined') &&\n                (typeof Int32Array !== 'undefined');\n\n\nexports.assign = function (obj /*from1, from2, from3, ...*/) {\n  var sources = Array.prototype.slice.call(arguments, 1);\n  while (sources.length) {\n    var source = sources.shift();\n    if (!source) { continue; }\n\n    if (typeof source !== 'object') {\n      throw new TypeError(source + 'must be non-object');\n    }\n\n    for (var p in source) {\n      if (source.hasOwnProperty(p)) {\n        obj[p] = source[p];\n      }\n    }\n  }\n\n  return obj;\n};\n\n\n// reduce buffer size, avoiding mem copy\nexports.shrinkBuf = function (buf, size) {\n  if (buf.length === size) { return buf; }\n  if (buf.subarray) { return buf.subarray(0, size); }\n  buf.length = size;\n  return buf;\n};\n\n\nvar fnTyped = {\n  arraySet: function (dest, src, src_offs, len, dest_offs) {\n    if (src.subarray && dest.subarray) {\n      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);\n      return;\n    }\n    // Fallback to ordinary array\n    for (var i = 0; i < len; i++) {\n      dest[dest_offs + i] = src[src_offs + i];\n    }\n  },\n  // Join array of chunks to single array.\n  flattenChunks: function (chunks) {\n    var i, l, len, pos, chunk, result;\n\n    // calculate data length\n    len = 0;\n    for (i = 0, l = chunks.length; i < l; i++) {\n      len += chunks[i].length;\n    }\n\n    // join chunks\n    result = new Uint8Array(len);\n    pos = 0;\n    for (i = 0, l = chunks.length; i < l; i++) {\n      chunk = chunks[i];\n      result.set(chunk, pos);\n      pos += chunk.length;\n    }\n\n    return result;\n  }\n};\n\nvar fnUntyped = {\n  arraySet: function (dest, src, src_offs, len, dest_offs) {\n    for (var i = 0; i < len; i++) {\n      dest[dest_offs + i] = src[src_offs + i];\n    }\n  },\n  // Join array of chunks to single array.\n  flattenChunks: function (chunks) {\n    return [].concat.apply([], chunks);\n  }\n};\n\n\n// Enable/Disable typed arrays use, for testing\n//\nexports.setTyped = function (on) {\n  if (on) {\n    exports.Buf8  = Uint8Array;\n    exports.Buf16 = Uint16Array;\n    exports.Buf32 = Int32Array;\n    exports.assign(exports, fnTyped);\n  } else {\n    exports.Buf8  = Array;\n    exports.Buf16 = Array;\n    exports.Buf32 = Array;\n    exports.assign(exports, fnUntyped);\n  }\n};\n\nexports.setTyped(TYPED_OK);\n\n\n//# sourceURL=webpack://platypus/./node_modules/pako/lib/utils/common.js?");

/***/ }),

/***/ "./node_modules/pako/lib/utils/strings.js":
/*!************************************************!*\
  !*** ./node_modules/pako/lib/utils/strings.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// String encode/decode helpers\n\n\n\nvar utils = __webpack_require__(/*! ./common */ \"./node_modules/pako/lib/utils/common.js\");\n\n\n// Quick check if we can use fast array to bin string conversion\n//\n// - apply(Array) can fail on Android 2.2\n// - apply(Uint8Array) can fail on iOS 5.1 Safary\n//\nvar STR_APPLY_OK = true;\nvar STR_APPLY_UIA_OK = true;\n\ntry { String.fromCharCode.apply(null, [ 0 ]); } catch (__) { STR_APPLY_OK = false; }\ntry { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }\n\n\n// Table with utf8 lengths (calculated by first byte of sequence)\n// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n// because max possible codepoint is 0x10ffff\nvar _utf8len = new utils.Buf8(256);\nfor (var q = 0; q < 256; q++) {\n  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);\n}\n_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start\n\n\n// convert string to array (typed, when possible)\nexports.string2buf = function (str) {\n  var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;\n\n  // count binary size\n  for (m_pos = 0; m_pos < str_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n      c2 = str.charCodeAt(m_pos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n  }\n\n  // allocate buffer\n  buf = new utils.Buf8(buf_len);\n\n  // convert\n  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n      c2 = str.charCodeAt(m_pos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n    if (c < 0x80) {\n      /* one byte */\n      buf[i++] = c;\n    } else if (c < 0x800) {\n      /* two bytes */\n      buf[i++] = 0xC0 | (c >>> 6);\n      buf[i++] = 0x80 | (c & 0x3f);\n    } else if (c < 0x10000) {\n      /* three bytes */\n      buf[i++] = 0xE0 | (c >>> 12);\n      buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n      buf[i++] = 0x80 | (c & 0x3f);\n    } else {\n      /* four bytes */\n      buf[i++] = 0xf0 | (c >>> 18);\n      buf[i++] = 0x80 | (c >>> 12 & 0x3f);\n      buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n      buf[i++] = 0x80 | (c & 0x3f);\n    }\n  }\n\n  return buf;\n};\n\n// Helper (used in 2 places)\nfunction buf2binstring(buf, len) {\n  // use fallback for big arrays to avoid stack overflow\n  if (len < 65537) {\n    if ((buf.subarray && STR_APPLY_UIA_OK) || (!buf.subarray && STR_APPLY_OK)) {\n      return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));\n    }\n  }\n\n  var result = '';\n  for (var i = 0; i < len; i++) {\n    result += String.fromCharCode(buf[i]);\n  }\n  return result;\n}\n\n\n// Convert byte array to binary string\nexports.buf2binstring = function (buf) {\n  return buf2binstring(buf, buf.length);\n};\n\n\n// Convert binary string (typed, when possible)\nexports.binstring2buf = function (str) {\n  var buf = new utils.Buf8(str.length);\n  for (var i = 0, len = buf.length; i < len; i++) {\n    buf[i] = str.charCodeAt(i);\n  }\n  return buf;\n};\n\n\n// convert array to string\nexports.buf2string = function (buf, max) {\n  var i, out, c, c_len;\n  var len = max || buf.length;\n\n  // Reserve max possible length (2 words per char)\n  // NB: by unknown reasons, Array is significantly faster for\n  //     String.fromCharCode.apply than Uint16Array.\n  var utf16buf = new Array(len * 2);\n\n  for (out = 0, i = 0; i < len;) {\n    c = buf[i++];\n    // quick process ascii\n    if (c < 0x80) { utf16buf[out++] = c; continue; }\n\n    c_len = _utf8len[c];\n    // skip 5 & 6 byte codes\n    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }\n\n    // apply mask on first byte\n    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;\n    // join the rest\n    while (c_len > 1 && i < len) {\n      c = (c << 6) | (buf[i++] & 0x3f);\n      c_len--;\n    }\n\n    // terminated by end of string?\n    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }\n\n    if (c < 0x10000) {\n      utf16buf[out++] = c;\n    } else {\n      c -= 0x10000;\n      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);\n      utf16buf[out++] = 0xdc00 | (c & 0x3ff);\n    }\n  }\n\n  return buf2binstring(utf16buf, out);\n};\n\n\n// Calculate max possible position in utf8 buffer,\n// that will not break sequence. If that's not possible\n// - (very small limits) return max size as is.\n//\n// buf[] - utf8 bytes array\n// max   - length limit (mandatory);\nexports.utf8border = function (buf, max) {\n  var pos;\n\n  max = max || buf.length;\n  if (max > buf.length) { max = buf.length; }\n\n  // go back from last position, until start of sequence found\n  pos = max - 1;\n  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }\n\n  // Fuckup - very small and broken sequence,\n  // return max, because we should return something anyway.\n  if (pos < 0) { return max; }\n\n  // If we came to start of buffer - that means vuffer is too small,\n  // return max too.\n  if (pos === 0) { return max; }\n\n  return (pos + _utf8len[buf[pos]] > max) ? pos : max;\n};\n\n\n//# sourceURL=webpack://platypus/./node_modules/pako/lib/utils/strings.js?");

/***/ }),

/***/ "./node_modules/pako/lib/zlib/adler32.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/adler32.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// Note: adler32 takes 12% for level 0 and 2% for level 6.\n// It doesn't worth to make additional optimizationa as in original.\n// Small size is preferable.\n\nfunction adler32(adler, buf, len, pos) {\n  var s1 = (adler & 0xffff) |0,\n      s2 = ((adler >>> 16) & 0xffff) |0,\n      n = 0;\n\n  while (len !== 0) {\n    // Set limit ~ twice less than 5552, to keep\n    // s2 in 31-bits, because we force signed ints.\n    // in other case %= will fail.\n    n = len > 2000 ? 2000 : len;\n    len -= n;\n\n    do {\n      s1 = (s1 + buf[pos++]) |0;\n      s2 = (s2 + s1) |0;\n    } while (--n);\n\n    s1 %= 65521;\n    s2 %= 65521;\n  }\n\n  return (s1 | (s2 << 16)) |0;\n}\n\n\nmodule.exports = adler32;\n\n\n//# sourceURL=webpack://platypus/./node_modules/pako/lib/zlib/adler32.js?");

/***/ }),

/***/ "./node_modules/pako/lib/zlib/constants.js":
/*!*************************************************!*\
  !*** ./node_modules/pako/lib/zlib/constants.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\nmodule.exports = {\n\n  /* Allowed flush values; see deflate() and inflate() below for details */\n  Z_NO_FLUSH:         0,\n  Z_PARTIAL_FLUSH:    1,\n  Z_SYNC_FLUSH:       2,\n  Z_FULL_FLUSH:       3,\n  Z_FINISH:           4,\n  Z_BLOCK:            5,\n  Z_TREES:            6,\n\n  /* Return codes for the compression/decompression functions. Negative values\n  * are errors, positive values are used for special but normal events.\n  */\n  Z_OK:               0,\n  Z_STREAM_END:       1,\n  Z_NEED_DICT:        2,\n  Z_ERRNO:           -1,\n  Z_STREAM_ERROR:    -2,\n  Z_DATA_ERROR:      -3,\n  //Z_MEM_ERROR:     -4,\n  Z_BUF_ERROR:       -5,\n  //Z_VERSION_ERROR: -6,\n\n  /* compression levels */\n  Z_NO_COMPRESSION:         0,\n  Z_BEST_SPEED:             1,\n  Z_BEST_COMPRESSION:       9,\n  Z_DEFAULT_COMPRESSION:   -1,\n\n\n  Z_FILTERED:               1,\n  Z_HUFFMAN_ONLY:           2,\n  Z_RLE:                    3,\n  Z_FIXED:                  4,\n  Z_DEFAULT_STRATEGY:       0,\n\n  /* Possible values of the data_type field (though see inflate()) */\n  Z_BINARY:                 0,\n  Z_TEXT:                   1,\n  //Z_ASCII:                1, // = Z_TEXT (deprecated)\n  Z_UNKNOWN:                2,\n\n  /* The deflate compression method */\n  Z_DEFLATED:               8\n  //Z_NULL:                 null // Use -1 or null inline, depending on var type\n};\n\n\n//# sourceURL=webpack://platypus/./node_modules/pako/lib/zlib/constants.js?");

/***/ }),

/***/ "./node_modules/pako/lib/zlib/crc32.js":
/*!*********************************************!*\
  !*** ./node_modules/pako/lib/zlib/crc32.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// Note: we can't get significant speed boost here.\n// So write code to minimize size - no pregenerated tables\n// and array tools dependencies.\n\n\n// Use ordinary array, since untyped makes no boost here\nfunction makeTable() {\n  var c, table = [];\n\n  for (var n = 0; n < 256; n++) {\n    c = n;\n    for (var k = 0; k < 8; k++) {\n      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));\n    }\n    table[n] = c;\n  }\n\n  return table;\n}\n\n// Create table on load. Just 255 signed longs. Not a problem.\nvar crcTable = makeTable();\n\n\nfunction crc32(crc, buf, len, pos) {\n  var t = crcTable,\n      end = pos + len;\n\n  crc ^= -1;\n\n  for (var i = pos; i < end; i++) {\n    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];\n  }\n\n  return (crc ^ (-1)); // >>> 0;\n}\n\n\nmodule.exports = crc32;\n\n\n//# sourceURL=webpack://platypus/./node_modules/pako/lib/zlib/crc32.js?");

/***/ }),

/***/ "./node_modules/pako/lib/zlib/deflate.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/deflate.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils   = __webpack_require__(/*! ../utils/common */ \"./node_modules/pako/lib/utils/common.js\");\nvar trees   = __webpack_require__(/*! ./trees */ \"./node_modules/pako/lib/zlib/trees.js\");\nvar adler32 = __webpack_require__(/*! ./adler32 */ \"./node_modules/pako/lib/zlib/adler32.js\");\nvar crc32   = __webpack_require__(/*! ./crc32 */ \"./node_modules/pako/lib/zlib/crc32.js\");\nvar msg     = __webpack_require__(/*! ./messages */ \"./node_modules/pako/lib/zlib/messages.js\");\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n/* Allowed flush values; see deflate() and inflate() below for details */\nvar Z_NO_FLUSH      = 0;\nvar Z_PARTIAL_FLUSH = 1;\n//var Z_SYNC_FLUSH    = 2;\nvar Z_FULL_FLUSH    = 3;\nvar Z_FINISH        = 4;\nvar Z_BLOCK         = 5;\n//var Z_TREES         = 6;\n\n\n/* Return codes for the compression/decompression functions. Negative values\n * are errors, positive values are used for special but normal events.\n */\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\n//var Z_NEED_DICT     = 2;\n//var Z_ERRNO         = -1;\nvar Z_STREAM_ERROR  = -2;\nvar Z_DATA_ERROR    = -3;\n//var Z_MEM_ERROR     = -4;\nvar Z_BUF_ERROR     = -5;\n//var Z_VERSION_ERROR = -6;\n\n\n/* compression levels */\n//var Z_NO_COMPRESSION      = 0;\n//var Z_BEST_SPEED          = 1;\n//var Z_BEST_COMPRESSION    = 9;\nvar Z_DEFAULT_COMPRESSION = -1;\n\n\nvar Z_FILTERED            = 1;\nvar Z_HUFFMAN_ONLY        = 2;\nvar Z_RLE                 = 3;\nvar Z_FIXED               = 4;\nvar Z_DEFAULT_STRATEGY    = 0;\n\n/* Possible values of the data_type field (though see inflate()) */\n//var Z_BINARY              = 0;\n//var Z_TEXT                = 1;\n//var Z_ASCII               = 1; // = Z_TEXT\nvar Z_UNKNOWN             = 2;\n\n\n/* The deflate compression method */\nvar Z_DEFLATED  = 8;\n\n/*============================================================================*/\n\n\nvar MAX_MEM_LEVEL = 9;\n/* Maximum value for memLevel in deflateInit2 */\nvar MAX_WBITS = 15;\n/* 32K LZ77 window */\nvar DEF_MEM_LEVEL = 8;\n\n\nvar LENGTH_CODES  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\nvar LITERALS      = 256;\n/* number of literal bytes 0..255 */\nvar L_CODES       = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\nvar D_CODES       = 30;\n/* number of distance codes */\nvar BL_CODES      = 19;\n/* number of codes used to transfer the bit lengths */\nvar HEAP_SIZE     = 2 * L_CODES + 1;\n/* maximum heap size */\nvar MAX_BITS  = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nvar MIN_MATCH = 3;\nvar MAX_MATCH = 258;\nvar MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);\n\nvar PRESET_DICT = 0x20;\n\nvar INIT_STATE = 42;\nvar EXTRA_STATE = 69;\nvar NAME_STATE = 73;\nvar COMMENT_STATE = 91;\nvar HCRC_STATE = 103;\nvar BUSY_STATE = 113;\nvar FINISH_STATE = 666;\n\nvar BS_NEED_MORE      = 1; /* block not completed, need more input or more output */\nvar BS_BLOCK_DONE     = 2; /* block flush performed */\nvar BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */\nvar BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */\n\nvar OS_CODE = 0x03; // Unix :) . Don't detect, use this default.\n\nfunction err(strm, errorCode) {\n  strm.msg = msg[errorCode];\n  return errorCode;\n}\n\nfunction rank(f) {\n  return ((f) << 1) - ((f) > 4 ? 9 : 0);\n}\n\nfunction zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\n\n/* =========================================================================\n * Flush as much pending output as possible. All deflate() output goes\n * through this function so some applications may wish to modify it\n * to avoid allocating a large strm->output buffer and copying into it.\n * (See also read_buf()).\n */\nfunction flush_pending(strm) {\n  var s = strm.state;\n\n  //_tr_flush_bits(s);\n  var len = s.pending;\n  if (len > strm.avail_out) {\n    len = strm.avail_out;\n  }\n  if (len === 0) { return; }\n\n  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);\n  strm.next_out += len;\n  s.pending_out += len;\n  strm.total_out += len;\n  strm.avail_out -= len;\n  s.pending -= len;\n  if (s.pending === 0) {\n    s.pending_out = 0;\n  }\n}\n\n\nfunction flush_block_only(s, last) {\n  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);\n  s.block_start = s.strstart;\n  flush_pending(s.strm);\n}\n\n\nfunction put_byte(s, b) {\n  s.pending_buf[s.pending++] = b;\n}\n\n\n/* =========================================================================\n * Put a short in the pending buffer. The 16-bit value is put in MSB order.\n * IN assertion: the stream state is correct and there is enough room in\n * pending_buf.\n */\nfunction putShortMSB(s, b) {\n//  put_byte(s, (Byte)(b >> 8));\n//  put_byte(s, (Byte)(b & 0xff));\n  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;\n  s.pending_buf[s.pending++] = b & 0xff;\n}\n\n\n/* ===========================================================================\n * Read a new buffer from the current input stream, update the adler32\n * and total number of bytes read.  All deflate() input goes through\n * this function so some applications may wish to modify it to avoid\n * allocating a large strm->input buffer and copying from it.\n * (See also flush_pending()).\n */\nfunction read_buf(strm, buf, start, size) {\n  var len = strm.avail_in;\n\n  if (len > size) { len = size; }\n  if (len === 0) { return 0; }\n\n  strm.avail_in -= len;\n\n  // zmemcpy(buf, strm->next_in, len);\n  utils.arraySet(buf, strm.input, strm.next_in, len, start);\n  if (strm.state.wrap === 1) {\n    strm.adler = adler32(strm.adler, buf, len, start);\n  }\n\n  else if (strm.state.wrap === 2) {\n    strm.adler = crc32(strm.adler, buf, len, start);\n  }\n\n  strm.next_in += len;\n  strm.total_in += len;\n\n  return len;\n}\n\n\n/* ===========================================================================\n * Set match_start to the longest match starting at the given string and\n * return its length. Matches shorter or equal to prev_length are discarded,\n * in which case the result is equal to prev_length and match_start is\n * garbage.\n * IN assertions: cur_match is the head of the hash chain for the current\n *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n * OUT assertion: the match length is not greater than s->lookahead.\n */\nfunction longest_match(s, cur_match) {\n  var chain_length = s.max_chain_length;      /* max hash chain length */\n  var scan = s.strstart; /* current string */\n  var match;                       /* matched string */\n  var len;                           /* length of current match */\n  var best_len = s.prev_length;              /* best match length so far */\n  var nice_match = s.nice_match;             /* stop if match long enough */\n  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?\n      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;\n\n  var _win = s.window; // shortcut\n\n  var wmask = s.w_mask;\n  var prev  = s.prev;\n\n  /* Stop when cur_match becomes <= limit. To simplify the code,\n   * we prevent matches with the string of window index 0.\n   */\n\n  var strend = s.strstart + MAX_MATCH;\n  var scan_end1  = _win[scan + best_len - 1];\n  var scan_end   = _win[scan + best_len];\n\n  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n   * It is easy to get rid of this optimization if necessary.\n   */\n  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n\n  /* Do not waste too much time if we already have a good match: */\n  if (s.prev_length >= s.good_match) {\n    chain_length >>= 2;\n  }\n  /* Do not look for matches beyond the end of the input. This is necessary\n   * to make deflate deterministic.\n   */\n  if (nice_match > s.lookahead) { nice_match = s.lookahead; }\n\n  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\n\n  do {\n    // Assert(cur_match < s->strstart, \"no future\");\n    match = cur_match;\n\n    /* Skip to next match if the match length cannot increase\n     * or if the match length is less than 2.  Note that the checks below\n     * for insufficient lookahead only occur occasionally for performance\n     * reasons.  Therefore uninitialized memory will be accessed, and\n     * conditional jumps will be made that depend on those values.\n     * However the length of the match is limited to the lookahead, so\n     * the output of deflate is not affected by the uninitialized values.\n     */\n\n    if (_win[match + best_len]     !== scan_end  ||\n        _win[match + best_len - 1] !== scan_end1 ||\n        _win[match]                !== _win[scan] ||\n        _win[++match]              !== _win[scan + 1]) {\n      continue;\n    }\n\n    /* The check at best_len-1 can be removed because it will be made\n     * again later. (This heuristic is not always a win.)\n     * It is not necessary to compare scan[2] and match[2] since they\n     * are always equal when the other bytes match, given that\n     * the hash keys are equal and that HASH_BITS >= 8.\n     */\n    scan += 2;\n    match++;\n    // Assert(*scan == *match, \"match[2]?\");\n\n    /* We check for insufficient lookahead only every 8th comparison;\n     * the 256th check will be made at strstart+258.\n     */\n    do {\n      /*jshint noempty:false*/\n    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             scan < strend);\n\n    // Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n\n    len = MAX_MATCH - (strend - scan);\n    scan = strend - MAX_MATCH;\n\n    if (len > best_len) {\n      s.match_start = cur_match;\n      best_len = len;\n      if (len >= nice_match) {\n        break;\n      }\n      scan_end1  = _win[scan + best_len - 1];\n      scan_end   = _win[scan + best_len];\n    }\n  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);\n\n  if (best_len <= s.lookahead) {\n    return best_len;\n  }\n  return s.lookahead;\n}\n\n\n/* ===========================================================================\n * Fill the window when the lookahead becomes insufficient.\n * Updates strstart and lookahead.\n *\n * IN assertion: lookahead < MIN_LOOKAHEAD\n * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n *    At least one byte has been read, or avail_in == 0; reads are\n *    performed for at least two bytes (required for the zip translate_eol\n *    option -- not supported here).\n */\nfunction fill_window(s) {\n  var _w_size = s.w_size;\n  var p, n, m, more, str;\n\n  //Assert(s->lookahead < MIN_LOOKAHEAD, \"already enough lookahead\");\n\n  do {\n    more = s.window_size - s.lookahead - s.strstart;\n\n    // JS ints have 32 bit, block below not needed\n    /* Deal with !@#$% 64K limit: */\n    //if (sizeof(int) <= 2) {\n    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n    //        more = wsize;\n    //\n    //  } else if (more == (unsigned)(-1)) {\n    //        /* Very unlikely, but possible on 16 bit machine if\n    //         * strstart == 0 && lookahead == 1 (input done a byte at time)\n    //         */\n    //        more--;\n    //    }\n    //}\n\n\n    /* If the window is almost full and there is insufficient lookahead,\n     * move the upper half to the lower one to make room in the upper half.\n     */\n    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n\n      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);\n      s.match_start -= _w_size;\n      s.strstart -= _w_size;\n      /* we now have strstart >= MAX_DIST */\n      s.block_start -= _w_size;\n\n      /* Slide the hash table (could be avoided with 32 bit values\n       at the expense of memory usage). We slide even when level == 0\n       to keep the hash table consistent if we switch back to level > 0\n       later. (Using level 0 permanently is not an optimal usage of\n       zlib, so we don't care about this pathological case.)\n       */\n\n      n = s.hash_size;\n      p = n;\n      do {\n        m = s.head[--p];\n        s.head[p] = (m >= _w_size ? m - _w_size : 0);\n      } while (--n);\n\n      n = _w_size;\n      p = n;\n      do {\n        m = s.prev[--p];\n        s.prev[p] = (m >= _w_size ? m - _w_size : 0);\n        /* If n is not on any hash chain, prev[n] is garbage but\n         * its value will never be used.\n         */\n      } while (--n);\n\n      more += _w_size;\n    }\n    if (s.strm.avail_in === 0) {\n      break;\n    }\n\n    /* If there was no sliding:\n     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n     *    more == window_size - lookahead - strstart\n     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n     * => more >= window_size - 2*WSIZE + 2\n     * In the BIG_MEM or MMAP case (not yet supported),\n     *   window_size == input_size + MIN_LOOKAHEAD  &&\n     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n     * Otherwise, window_size == 2*WSIZE so more >= 2.\n     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n     */\n    //Assert(more >= 2, \"more < 2\");\n    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);\n    s.lookahead += n;\n\n    /* Initialize the hash value now that we have some input: */\n    if (s.lookahead + s.insert >= MIN_MATCH) {\n      str = s.strstart - s.insert;\n      s.ins_h = s.window[str];\n\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;\n//#if MIN_MATCH != 3\n//        Call update_hash() MIN_MATCH-3 more times\n//#endif\n      while (s.insert) {\n        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n\n        s.prev[str & s.w_mask] = s.head[s.ins_h];\n        s.head[s.ins_h] = str;\n        str++;\n        s.insert--;\n        if (s.lookahead + s.insert < MIN_MATCH) {\n          break;\n        }\n      }\n    }\n    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n     * but this is not important since only literal bytes will be emitted.\n     */\n\n  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);\n\n  /* If the WIN_INIT bytes after the end of the current data have never been\n   * written, then zero those bytes in order to avoid memory check reports of\n   * the use of uninitialized (or uninitialised as Julian writes) bytes by\n   * the longest match routines.  Update the high water mark for the next\n   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\n   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\n   */\n//  if (s.high_water < s.window_size) {\n//    var curr = s.strstart + s.lookahead;\n//    var init = 0;\n//\n//    if (s.high_water < curr) {\n//      /* Previous high water mark below current data -- zero WIN_INIT\n//       * bytes or up to end of window, whichever is less.\n//       */\n//      init = s.window_size - curr;\n//      if (init > WIN_INIT)\n//        init = WIN_INIT;\n//      zmemzero(s->window + curr, (unsigned)init);\n//      s->high_water = curr + init;\n//    }\n//    else if (s->high_water < (ulg)curr + WIN_INIT) {\n//      /* High water mark at or above current data, but below current data\n//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\n//       * to end of window, whichever is less.\n//       */\n//      init = (ulg)curr + WIN_INIT - s->high_water;\n//      if (init > s->window_size - s->high_water)\n//        init = s->window_size - s->high_water;\n//      zmemzero(s->window + s->high_water, (unsigned)init);\n//      s->high_water += init;\n//    }\n//  }\n//\n//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n//    \"not enough room for search\");\n}\n\n/* ===========================================================================\n * Copy without compression as much as possible from the input stream, return\n * the current block state.\n * This function does not insert new strings in the dictionary since\n * uncompressible data is probably not useful. This function is used\n * only for the level=0 compression option.\n * NOTE: this function should be optimized to avoid extra copying from\n * window to pending_buf.\n */\nfunction deflate_stored(s, flush) {\n  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited\n   * to pending_buf_size, and each stored block has a 5 byte header:\n   */\n  var max_block_size = 0xffff;\n\n  if (max_block_size > s.pending_buf_size - 5) {\n    max_block_size = s.pending_buf_size - 5;\n  }\n\n  /* Copy as much as possible from input to output: */\n  for (;;) {\n    /* Fill the window as much as possible: */\n    if (s.lookahead <= 1) {\n\n      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||\n      //  s->block_start >= (long)s->w_size, \"slide too late\");\n//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||\n//        s.block_start >= s.w_size)) {\n//        throw  new Error(\"slide too late\");\n//      }\n\n      fill_window(s);\n      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n\n      if (s.lookahead === 0) {\n        break;\n      }\n      /* flush the current block */\n    }\n    //Assert(s->block_start >= 0L, \"block gone\");\n//    if (s.block_start < 0) throw new Error(\"block gone\");\n\n    s.strstart += s.lookahead;\n    s.lookahead = 0;\n\n    /* Emit a stored block if pending_buf will be full: */\n    var max_start = s.block_start + max_block_size;\n\n    if (s.strstart === 0 || s.strstart >= max_start) {\n      /* strstart == 0 is possible when wraparound on 16-bit machine */\n      s.lookahead = s.strstart - max_start;\n      s.strstart = max_start;\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n\n\n    }\n    /* Flush if we may have to slide, otherwise block_start may become\n     * negative and the data will be gone:\n     */\n    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n\n  s.insert = 0;\n\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n\n  if (s.strstart > s.block_start) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n\n  return BS_NEED_MORE;\n}\n\n/* ===========================================================================\n * Compress as much as possible from the input stream, return the current\n * block state.\n * This function does not perform lazy evaluation of matches and inserts\n * new strings in the dictionary only for unmatched strings or for short\n * matches. It is used only for the fast compression options.\n */\nfunction deflate_fast(s, flush) {\n  var hash_head;        /* head of the hash chain */\n  var bflush;           /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) {\n        break; /* flush the current block */\n      }\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     * At this point we have always match_length < MIN_MATCH\n     */\n    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n    }\n    if (s.match_length >= MIN_MATCH) {\n      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only\n\n      /*** _tr_tally_dist(s, s.strstart - s.match_start,\n                     s.match_length - MIN_MATCH, bflush); ***/\n      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n\n      /* Insert new strings in the hash table only if the match length\n       * is not too large. This saves time but degrades compression.\n       */\n      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {\n        s.match_length--; /* string at strstart already in table */\n        do {\n          s.strstart++;\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n          /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n           * always MIN_MATCH bytes ahead.\n           */\n        } while (--s.match_length !== 0);\n        s.strstart++;\n      } else\n      {\n        s.strstart += s.match_length;\n        s.match_length = 0;\n        s.ins_h = s.window[s.strstart];\n        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */\n        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;\n\n//#if MIN_MATCH != 3\n//                Call UPDATE_HASH() MIN_MATCH-3 more times\n//#endif\n        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not\n         * matter since it will be recomputed at next deflate call.\n         */\n      }\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s.window[s.strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* ===========================================================================\n * Same as above, but achieves better compression. We use a lazy\n * evaluation for matches: a match is finally adopted only if there is\n * no better match at the next window position.\n */\nfunction deflate_slow(s, flush) {\n  var hash_head;          /* head of hash chain */\n  var bflush;              /* set if current block must be flushed */\n\n  var max_insert;\n\n  /* Process the input block. */\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     */\n    s.prev_length = s.match_length;\n    s.prev_match = s.match_start;\n    s.match_length = MIN_MATCH - 1;\n\n    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&\n        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n\n      if (s.match_length <= 5 &&\n         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {\n\n        /* If prev_match is also MIN_MATCH, match_start is garbage\n         * but we will ignore the current match anyway.\n         */\n        s.match_length = MIN_MATCH - 1;\n      }\n    }\n    /* If there was a match at the previous step and the current\n     * match is not better, output the previous match:\n     */\n    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {\n      max_insert = s.strstart + s.lookahead - MIN_MATCH;\n      /* Do not insert strings in hash table beyond this. */\n\n      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);\n\n      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,\n                     s.prev_length - MIN_MATCH, bflush);***/\n      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);\n      /* Insert in hash table all strings up to the end of the match.\n       * strstart-1 and strstart are already inserted. If there is not\n       * enough lookahead, the last two strings are not inserted in\n       * the hash table.\n       */\n      s.lookahead -= s.prev_length - 1;\n      s.prev_length -= 2;\n      do {\n        if (++s.strstart <= max_insert) {\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n        }\n      } while (--s.prev_length !== 0);\n      s.match_available = 0;\n      s.match_length = MIN_MATCH - 1;\n      s.strstart++;\n\n      if (bflush) {\n        /*** FLUSH_BLOCK(s, 0); ***/\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n      }\n\n    } else if (s.match_available) {\n      /* If there was no match at the previous position, output a\n       * single literal. If there was a match but the current match\n       * is longer, truncate the previous match to a single literal.\n       */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n\n      if (bflush) {\n        /*** FLUSH_BLOCK_ONLY(s, 0) ***/\n        flush_block_only(s, false);\n        /***/\n      }\n      s.strstart++;\n      s.lookahead--;\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n    } else {\n      /* There is no previous match to compare with, wait for\n       * the next step to decide.\n       */\n      s.match_available = 1;\n      s.strstart++;\n      s.lookahead--;\n    }\n  }\n  //Assert (flush != Z_NO_FLUSH, \"no flush?\");\n  if (s.match_available) {\n    //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n\n    s.match_available = 0;\n  }\n  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n\n  return BS_BLOCK_DONE;\n}\n\n\n/* ===========================================================================\n * For Z_RLE, simply look for runs of bytes, generate matches only of distance\n * one.  Do not maintain a hash table.  (It will be regenerated if this run of\n * deflate switches away from Z_RLE.)\n */\nfunction deflate_rle(s, flush) {\n  var bflush;            /* set if current block must be flushed */\n  var prev;              /* byte at distance one to match */\n  var scan, strend;      /* scan goes up to strend for length of run */\n\n  var _win = s.window;\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the longest run, plus one for the unrolled loop.\n     */\n    if (s.lookahead <= MAX_MATCH) {\n      fill_window(s);\n      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* See how many times the previous byte repeats */\n    s.match_length = 0;\n    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {\n      scan = s.strstart - 1;\n      prev = _win[scan];\n      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\n        strend = s.strstart + MAX_MATCH;\n        do {\n          /*jshint noempty:false*/\n        } while (prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 scan < strend);\n        s.match_length = MAX_MATCH - (strend - scan);\n        if (s.match_length > s.lookahead) {\n          s.match_length = s.lookahead;\n        }\n      }\n      //Assert(scan <= s->window+(uInt)(s->window_size-1), \"wild scan\");\n    }\n\n    /* Emit match if have run of MIN_MATCH or longer, else emit literal */\n    if (s.match_length >= MIN_MATCH) {\n      //check_match(s, s.strstart, s.strstart - 1, s.match_length);\n\n      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/\n      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n      s.strstart += s.match_length;\n      s.match_length = 0;\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* ===========================================================================\n * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.\n * (It will be regenerated if this run of deflate switches away from Huffman.)\n */\nfunction deflate_huff(s, flush) {\n  var bflush;             /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we have a literal to write. */\n    if (s.lookahead === 0) {\n      fill_window(s);\n      if (s.lookahead === 0) {\n        if (flush === Z_NO_FLUSH) {\n          return BS_NEED_MORE;\n        }\n        break;      /* flush the current block */\n      }\n    }\n\n    /* Output a literal byte */\n    s.match_length = 0;\n    //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n    s.lookahead--;\n    s.strstart++;\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* Values for max_lazy_match, good_match and max_chain_length, depending on\n * the desired pack level (0..9). The values given below have been tuned to\n * exclude worst case performance for pathological files. Better values may be\n * found for specific files.\n */\nfunction Config(good_length, max_lazy, nice_length, max_chain, func) {\n  this.good_length = good_length;\n  this.max_lazy = max_lazy;\n  this.nice_length = nice_length;\n  this.max_chain = max_chain;\n  this.func = func;\n}\n\nvar configuration_table;\n\nconfiguration_table = [\n  /*      good lazy nice chain */\n  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */\n  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */\n  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */\n  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */\n\n  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */\n  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */\n  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */\n  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */\n  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */\n  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */\n];\n\n\n/* ===========================================================================\n * Initialize the \"longest match\" routines for a new zlib stream\n */\nfunction lm_init(s) {\n  s.window_size = 2 * s.w_size;\n\n  /*** CLEAR_HASH(s); ***/\n  zero(s.head); // Fill with NIL (= 0);\n\n  /* Set the default configuration parameters:\n   */\n  s.max_lazy_match = configuration_table[s.level].max_lazy;\n  s.good_match = configuration_table[s.level].good_length;\n  s.nice_match = configuration_table[s.level].nice_length;\n  s.max_chain_length = configuration_table[s.level].max_chain;\n\n  s.strstart = 0;\n  s.block_start = 0;\n  s.lookahead = 0;\n  s.insert = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  s.ins_h = 0;\n}\n\n\nfunction DeflateState() {\n  this.strm = null;            /* pointer back to this zlib stream */\n  this.status = 0;            /* as the name implies */\n  this.pending_buf = null;      /* output still pending */\n  this.pending_buf_size = 0;  /* size of pending_buf */\n  this.pending_out = 0;       /* next pending byte to output to the stream */\n  this.pending = 0;           /* nb of bytes in the pending buffer */\n  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\n  this.gzhead = null;         /* gzip header information to write */\n  this.gzindex = 0;           /* where in extra, name, or comment */\n  this.method = Z_DEFLATED; /* can only be DEFLATED */\n  this.last_flush = -1;   /* value of flush param for previous deflate call */\n\n  this.w_size = 0;  /* LZ77 window size (32K by default) */\n  this.w_bits = 0;  /* log2(w_size)  (8..16) */\n  this.w_mask = 0;  /* w_size - 1 */\n\n  this.window = null;\n  /* Sliding window. Input bytes are read into the second half of the window,\n   * and move to the first half later to keep a dictionary of at least wSize\n   * bytes. With this organization, matches are limited to a distance of\n   * wSize-MAX_MATCH bytes, but this ensures that IO is always\n   * performed with a length multiple of the block size.\n   */\n\n  this.window_size = 0;\n  /* Actual size of window: 2*wSize, except when the user input buffer\n   * is directly used as sliding window.\n   */\n\n  this.prev = null;\n  /* Link to older string with same hash index. To limit the size of this\n   * array to 64K, this link is maintained only for the last 32K strings.\n   * An index in this array is thus a window index modulo 32K.\n   */\n\n  this.head = null;   /* Heads of the hash chains or NIL. */\n\n  this.ins_h = 0;       /* hash index of string to be inserted */\n  this.hash_size = 0;   /* number of elements in hash table */\n  this.hash_bits = 0;   /* log2(hash_size) */\n  this.hash_mask = 0;   /* hash_size-1 */\n\n  this.hash_shift = 0;\n  /* Number of bits by which ins_h must be shifted at each input\n   * step. It must be such that after MIN_MATCH steps, the oldest\n   * byte no longer takes part in the hash key, that is:\n   *   hash_shift * MIN_MATCH >= hash_bits\n   */\n\n  this.block_start = 0;\n  /* Window position at the beginning of the current output block. Gets\n   * negative when the window is moved backwards.\n   */\n\n  this.match_length = 0;      /* length of best match */\n  this.prev_match = 0;        /* previous match */\n  this.match_available = 0;   /* set if previous match exists */\n  this.strstart = 0;          /* start of string to insert */\n  this.match_start = 0;       /* start of matching string */\n  this.lookahead = 0;         /* number of valid bytes ahead in window */\n\n  this.prev_length = 0;\n  /* Length of the best match at previous step. Matches not greater than this\n   * are discarded. This is used in the lazy match evaluation.\n   */\n\n  this.max_chain_length = 0;\n  /* To speed up deflation, hash chains are never searched beyond this\n   * length.  A higher limit improves compression ratio but degrades the\n   * speed.\n   */\n\n  this.max_lazy_match = 0;\n  /* Attempt to find a better match only when the current match is strictly\n   * smaller than this value. This mechanism is used only for compression\n   * levels >= 4.\n   */\n  // That's alias to max_lazy_match, don't use directly\n  //this.max_insert_length = 0;\n  /* Insert new strings in the hash table only if the match length is not\n   * greater than this length. This saves time but degrades compression.\n   * max_insert_length is used only for compression levels <= 3.\n   */\n\n  this.level = 0;     /* compression level (1..9) */\n  this.strategy = 0;  /* favor or force Huffman coding*/\n\n  this.good_match = 0;\n  /* Use a faster search when the previous match is longer than this */\n\n  this.nice_match = 0; /* Stop searching when current match exceeds this */\n\n              /* used by trees.c: */\n\n  /* Didn't use ct_data typedef below to suppress compiler warning */\n\n  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\n  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\n  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\n\n  // Use flat array of DOUBLE size, with interleaved fata,\n  // because JS does not support effective\n  this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);\n  this.dyn_dtree  = new utils.Buf16((2 * D_CODES + 1) * 2);\n  this.bl_tree    = new utils.Buf16((2 * BL_CODES + 1) * 2);\n  zero(this.dyn_ltree);\n  zero(this.dyn_dtree);\n  zero(this.bl_tree);\n\n  this.l_desc   = null;         /* desc. for literal tree */\n  this.d_desc   = null;         /* desc. for distance tree */\n  this.bl_desc  = null;         /* desc. for bit length tree */\n\n  //ush bl_count[MAX_BITS+1];\n  this.bl_count = new utils.Buf16(MAX_BITS + 1);\n  /* number of codes at each bit length for an optimal tree */\n\n  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */\n  this.heap = new utils.Buf16(2 * L_CODES + 1);  /* heap used to build the Huffman trees */\n  zero(this.heap);\n\n  this.heap_len = 0;               /* number of elements in the heap */\n  this.heap_max = 0;               /* element of largest frequency */\n  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n   * The same heap array is used to build all trees.\n   */\n\n  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];\n  zero(this.depth);\n  /* Depth of each subtree used as tie breaker for trees of equal frequency\n   */\n\n  this.l_buf = 0;          /* buffer index for literals or lengths */\n\n  this.lit_bufsize = 0;\n  /* Size of match buffer for literals/lengths.  There are 4 reasons for\n   * limiting lit_bufsize to 64K:\n   *   - frequencies can be kept in 16 bit counters\n   *   - if compression is not successful for the first block, all input\n   *     data is still in the window so we can still emit a stored block even\n   *     when input comes from standard input.  (This can also be done for\n   *     all blocks if lit_bufsize is not greater than 32K.)\n   *   - if compression is not successful for a file smaller than 64K, we can\n   *     even emit a stored file instead of a stored block (saving 5 bytes).\n   *     This is applicable only for zip (not gzip or zlib).\n   *   - creating new Huffman trees less frequently may not provide fast\n   *     adaptation to changes in the input data statistics. (Take for\n   *     example a binary file with poorly compressible code followed by\n   *     a highly compressible string table.) Smaller buffer sizes give\n   *     fast adaptation but have of course the overhead of transmitting\n   *     trees more frequently.\n   *   - I can't count above 4\n   */\n\n  this.last_lit = 0;      /* running index in l_buf */\n\n  this.d_buf = 0;\n  /* Buffer index for distances. To simplify the code, d_buf and l_buf have\n   * the same number of elements. To use different lengths, an extra flag\n   * array would be necessary.\n   */\n\n  this.opt_len = 0;       /* bit length of current block with optimal trees */\n  this.static_len = 0;    /* bit length of current block with static trees */\n  this.matches = 0;       /* number of string matches in current block */\n  this.insert = 0;        /* bytes at end of window left to insert */\n\n\n  this.bi_buf = 0;\n  /* Output buffer. bits are inserted starting at the bottom (least\n   * significant bits).\n   */\n  this.bi_valid = 0;\n  /* Number of valid bits in bi_buf.  All bits above the last valid bit\n   * are always zero.\n   */\n\n  // Used for window memory init. We safely ignore it for JS. That makes\n  // sense only for pointers and memory check tools.\n  //this.high_water = 0;\n  /* High water mark offset in window for initialized bytes -- bytes above\n   * this are set to zero in order to avoid memory check warnings when\n   * longest match routines access bytes past the input.  This is then\n   * updated to the new high water mark.\n   */\n}\n\n\nfunction deflateResetKeep(strm) {\n  var s;\n\n  if (!strm || !strm.state) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n  strm.total_in = strm.total_out = 0;\n  strm.data_type = Z_UNKNOWN;\n\n  s = strm.state;\n  s.pending = 0;\n  s.pending_out = 0;\n\n  if (s.wrap < 0) {\n    s.wrap = -s.wrap;\n    /* was made negative by deflate(..., Z_FINISH); */\n  }\n  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);\n  strm.adler = (s.wrap === 2) ?\n    0  // crc32(0, Z_NULL, 0)\n  :\n    1; // adler32(0, Z_NULL, 0)\n  s.last_flush = Z_NO_FLUSH;\n  trees._tr_init(s);\n  return Z_OK;\n}\n\n\nfunction deflateReset(strm) {\n  var ret = deflateResetKeep(strm);\n  if (ret === Z_OK) {\n    lm_init(strm.state);\n  }\n  return ret;\n}\n\n\nfunction deflateSetHeader(strm, head) {\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }\n  strm.state.gzhead = head;\n  return Z_OK;\n}\n\n\nfunction deflateInit2(strm, level, method, windowBits, memLevel, strategy) {\n  if (!strm) { // === Z_NULL\n    return Z_STREAM_ERROR;\n  }\n  var wrap = 1;\n\n  if (level === Z_DEFAULT_COMPRESSION) {\n    level = 6;\n  }\n\n  if (windowBits < 0) { /* suppress zlib wrapper */\n    wrap = 0;\n    windowBits = -windowBits;\n  }\n\n  else if (windowBits > 15) {\n    wrap = 2;           /* write gzip wrapper instead */\n    windowBits -= 16;\n  }\n\n\n  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||\n    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||\n    strategy < 0 || strategy > Z_FIXED) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n\n  if (windowBits === 8) {\n    windowBits = 9;\n  }\n  /* until 256-byte window bug fixed */\n\n  var s = new DeflateState();\n\n  strm.state = s;\n  s.strm = strm;\n\n  s.wrap = wrap;\n  s.gzhead = null;\n  s.w_bits = windowBits;\n  s.w_size = 1 << s.w_bits;\n  s.w_mask = s.w_size - 1;\n\n  s.hash_bits = memLevel + 7;\n  s.hash_size = 1 << s.hash_bits;\n  s.hash_mask = s.hash_size - 1;\n  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);\n\n  s.window = new utils.Buf8(s.w_size * 2);\n  s.head = new utils.Buf16(s.hash_size);\n  s.prev = new utils.Buf16(s.w_size);\n\n  // Don't need mem init magic for JS.\n  //s.high_water = 0;  /* nothing written to s->window yet */\n\n  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */\n\n  s.pending_buf_size = s.lit_bufsize * 4;\n\n  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);\n  //s->pending_buf = (uchf *) overlay;\n  s.pending_buf = new utils.Buf8(s.pending_buf_size);\n\n  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)\n  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);\n  s.d_buf = 1 * s.lit_bufsize;\n\n  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;\n  s.l_buf = (1 + 2) * s.lit_bufsize;\n\n  s.level = level;\n  s.strategy = strategy;\n  s.method = method;\n\n  return deflateReset(strm);\n}\n\nfunction deflateInit(strm, level) {\n  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);\n}\n\n\nfunction deflate(strm, flush) {\n  var old_flush, s;\n  var beg, val; // for gzip header write only\n\n  if (!strm || !strm.state ||\n    flush > Z_BLOCK || flush < 0) {\n    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;\n  }\n\n  s = strm.state;\n\n  if (!strm.output ||\n      (!strm.input && strm.avail_in !== 0) ||\n      (s.status === FINISH_STATE && flush !== Z_FINISH)) {\n    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);\n  }\n\n  s.strm = strm; /* just in case */\n  old_flush = s.last_flush;\n  s.last_flush = flush;\n\n  /* Write the header */\n  if (s.status === INIT_STATE) {\n\n    if (s.wrap === 2) { // GZIP header\n      strm.adler = 0;  //crc32(0L, Z_NULL, 0);\n      put_byte(s, 31);\n      put_byte(s, 139);\n      put_byte(s, 8);\n      if (!s.gzhead) { // s->gzhead == Z_NULL\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, s.level === 9 ? 2 :\n                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                     4 : 0));\n        put_byte(s, OS_CODE);\n        s.status = BUSY_STATE;\n      }\n      else {\n        put_byte(s, (s.gzhead.text ? 1 : 0) +\n                    (s.gzhead.hcrc ? 2 : 0) +\n                    (!s.gzhead.extra ? 0 : 4) +\n                    (!s.gzhead.name ? 0 : 8) +\n                    (!s.gzhead.comment ? 0 : 16)\n                );\n        put_byte(s, s.gzhead.time & 0xff);\n        put_byte(s, (s.gzhead.time >> 8) & 0xff);\n        put_byte(s, (s.gzhead.time >> 16) & 0xff);\n        put_byte(s, (s.gzhead.time >> 24) & 0xff);\n        put_byte(s, s.level === 9 ? 2 :\n                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                     4 : 0));\n        put_byte(s, s.gzhead.os & 0xff);\n        if (s.gzhead.extra && s.gzhead.extra.length) {\n          put_byte(s, s.gzhead.extra.length & 0xff);\n          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);\n        }\n        if (s.gzhead.hcrc) {\n          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);\n        }\n        s.gzindex = 0;\n        s.status = EXTRA_STATE;\n      }\n    }\n    else // DEFLATE header\n    {\n      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;\n      var level_flags = -1;\n\n      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {\n        level_flags = 0;\n      } else if (s.level < 6) {\n        level_flags = 1;\n      } else if (s.level === 6) {\n        level_flags = 2;\n      } else {\n        level_flags = 3;\n      }\n      header |= (level_flags << 6);\n      if (s.strstart !== 0) { header |= PRESET_DICT; }\n      header += 31 - (header % 31);\n\n      s.status = BUSY_STATE;\n      putShortMSB(s, header);\n\n      /* Save the adler32 of the preset dictionary: */\n      if (s.strstart !== 0) {\n        putShortMSB(s, strm.adler >>> 16);\n        putShortMSB(s, strm.adler & 0xffff);\n      }\n      strm.adler = 1; // adler32(0L, Z_NULL, 0);\n    }\n  }\n\n//#ifdef GZIP\n  if (s.status === EXTRA_STATE) {\n    if (s.gzhead.extra/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n\n      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            break;\n          }\n        }\n        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);\n        s.gzindex++;\n      }\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (s.gzindex === s.gzhead.extra.length) {\n        s.gzindex = 0;\n        s.status = NAME_STATE;\n      }\n    }\n    else {\n      s.status = NAME_STATE;\n    }\n  }\n  if (s.status === NAME_STATE) {\n    if (s.gzhead.name/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n      //int val;\n\n      do {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            val = 1;\n            break;\n          }\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.name.length) {\n          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (val === 0) {\n        s.gzindex = 0;\n        s.status = COMMENT_STATE;\n      }\n    }\n    else {\n      s.status = COMMENT_STATE;\n    }\n  }\n  if (s.status === COMMENT_STATE) {\n    if (s.gzhead.comment/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n      //int val;\n\n      do {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            val = 1;\n            break;\n          }\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.comment.length) {\n          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (val === 0) {\n        s.status = HCRC_STATE;\n      }\n    }\n    else {\n      s.status = HCRC_STATE;\n    }\n  }\n  if (s.status === HCRC_STATE) {\n    if (s.gzhead.hcrc) {\n      if (s.pending + 2 > s.pending_buf_size) {\n        flush_pending(strm);\n      }\n      if (s.pending + 2 <= s.pending_buf_size) {\n        put_byte(s, strm.adler & 0xff);\n        put_byte(s, (strm.adler >> 8) & 0xff);\n        strm.adler = 0; //crc32(0L, Z_NULL, 0);\n        s.status = BUSY_STATE;\n      }\n    }\n    else {\n      s.status = BUSY_STATE;\n    }\n  }\n//#endif\n\n  /* Flush as much pending output as possible */\n  if (s.pending !== 0) {\n    flush_pending(strm);\n    if (strm.avail_out === 0) {\n      /* Since avail_out is 0, deflate will be called again with\n       * more output space, but possibly with both pending and\n       * avail_in equal to zero. There won't be anything to do,\n       * but this is not an error situation so make sure we\n       * return OK instead of BUF_ERROR at next call of deflate:\n       */\n      s.last_flush = -1;\n      return Z_OK;\n    }\n\n    /* Make sure there is something to do and avoid duplicate consecutive\n     * flushes. For repeated and useless calls with Z_FINISH, we keep\n     * returning Z_STREAM_END instead of Z_BUF_ERROR.\n     */\n  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&\n    flush !== Z_FINISH) {\n    return err(strm, Z_BUF_ERROR);\n  }\n\n  /* User must not provide more input after the first FINISH: */\n  if (s.status === FINISH_STATE && strm.avail_in !== 0) {\n    return err(strm, Z_BUF_ERROR);\n  }\n\n  /* Start a new block or continue the current one.\n   */\n  if (strm.avail_in !== 0 || s.lookahead !== 0 ||\n    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {\n    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :\n      (s.strategy === Z_RLE ? deflate_rle(s, flush) :\n        configuration_table[s.level].func(s, flush));\n\n    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {\n      s.status = FINISH_STATE;\n    }\n    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n      if (strm.avail_out === 0) {\n        s.last_flush = -1;\n        /* avoid BUF_ERROR next call, see above */\n      }\n      return Z_OK;\n      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call\n       * of deflate should use the same flush parameter to make sure\n       * that the flush is complete. So we don't have to output an\n       * empty block here, this will be done at next call. This also\n       * ensures that for a very small output buffer, we emit at most\n       * one empty block.\n       */\n    }\n    if (bstate === BS_BLOCK_DONE) {\n      if (flush === Z_PARTIAL_FLUSH) {\n        trees._tr_align(s);\n      }\n      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */\n\n        trees._tr_stored_block(s, 0, 0, false);\n        /* For a full flush, this empty block will be recognized\n         * as a special marker by inflate_sync().\n         */\n        if (flush === Z_FULL_FLUSH) {\n          /*** CLEAR_HASH(s); ***/             /* forget history */\n          zero(s.head); // Fill with NIL (= 0);\n\n          if (s.lookahead === 0) {\n            s.strstart = 0;\n            s.block_start = 0;\n            s.insert = 0;\n          }\n        }\n      }\n      flush_pending(strm);\n      if (strm.avail_out === 0) {\n        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */\n        return Z_OK;\n      }\n    }\n  }\n  //Assert(strm->avail_out > 0, \"bug2\");\n  //if (strm.avail_out <= 0) { throw new Error(\"bug2\");}\n\n  if (flush !== Z_FINISH) { return Z_OK; }\n  if (s.wrap <= 0) { return Z_STREAM_END; }\n\n  /* Write the trailer */\n  if (s.wrap === 2) {\n    put_byte(s, strm.adler & 0xff);\n    put_byte(s, (strm.adler >> 8) & 0xff);\n    put_byte(s, (strm.adler >> 16) & 0xff);\n    put_byte(s, (strm.adler >> 24) & 0xff);\n    put_byte(s, strm.total_in & 0xff);\n    put_byte(s, (strm.total_in >> 8) & 0xff);\n    put_byte(s, (strm.total_in >> 16) & 0xff);\n    put_byte(s, (strm.total_in >> 24) & 0xff);\n  }\n  else\n  {\n    putShortMSB(s, strm.adler >>> 16);\n    putShortMSB(s, strm.adler & 0xffff);\n  }\n\n  flush_pending(strm);\n  /* If avail_out is zero, the application will call deflate again\n   * to flush the rest.\n   */\n  if (s.wrap > 0) { s.wrap = -s.wrap; }\n  /* write the trailer only once! */\n  return s.pending !== 0 ? Z_OK : Z_STREAM_END;\n}\n\nfunction deflateEnd(strm) {\n  var status;\n\n  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  status = strm.state.status;\n  if (status !== INIT_STATE &&\n    status !== EXTRA_STATE &&\n    status !== NAME_STATE &&\n    status !== COMMENT_STATE &&\n    status !== HCRC_STATE &&\n    status !== BUSY_STATE &&\n    status !== FINISH_STATE\n  ) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n  strm.state = null;\n\n  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;\n}\n\n\n/* =========================================================================\n * Initializes the compression dictionary from the given byte\n * sequence without producing any compressed output.\n */\nfunction deflateSetDictionary(strm, dictionary) {\n  var dictLength = dictionary.length;\n\n  var s;\n  var str, n;\n  var wrap;\n  var avail;\n  var next;\n  var input;\n  var tmpDict;\n\n  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  s = strm.state;\n  wrap = s.wrap;\n\n  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {\n    return Z_STREAM_ERROR;\n  }\n\n  /* when using zlib wrappers, compute Adler-32 for provided dictionary */\n  if (wrap === 1) {\n    /* adler32(strm->adler, dictionary, dictLength); */\n    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);\n  }\n\n  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */\n\n  /* if dictionary would fill window, just replace the history */\n  if (dictLength >= s.w_size) {\n    if (wrap === 0) {            /* already empty otherwise */\n      /*** CLEAR_HASH(s); ***/\n      zero(s.head); // Fill with NIL (= 0);\n      s.strstart = 0;\n      s.block_start = 0;\n      s.insert = 0;\n    }\n    /* use the tail */\n    // dictionary = dictionary.slice(dictLength - s.w_size);\n    tmpDict = new utils.Buf8(s.w_size);\n    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);\n    dictionary = tmpDict;\n    dictLength = s.w_size;\n  }\n  /* insert dictionary into window and hash */\n  avail = strm.avail_in;\n  next = strm.next_in;\n  input = strm.input;\n  strm.avail_in = dictLength;\n  strm.next_in = 0;\n  strm.input = dictionary;\n  fill_window(s);\n  while (s.lookahead >= MIN_MATCH) {\n    str = s.strstart;\n    n = s.lookahead - (MIN_MATCH - 1);\n    do {\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n\n      s.prev[str & s.w_mask] = s.head[s.ins_h];\n\n      s.head[s.ins_h] = str;\n      str++;\n    } while (--n);\n    s.strstart = str;\n    s.lookahead = MIN_MATCH - 1;\n    fill_window(s);\n  }\n  s.strstart += s.lookahead;\n  s.block_start = s.strstart;\n  s.insert = s.lookahead;\n  s.lookahead = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  strm.next_in = next;\n  strm.input = input;\n  strm.avail_in = avail;\n  s.wrap = wrap;\n  return Z_OK;\n}\n\n\nexports.deflateInit = deflateInit;\nexports.deflateInit2 = deflateInit2;\nexports.deflateReset = deflateReset;\nexports.deflateResetKeep = deflateResetKeep;\nexports.deflateSetHeader = deflateSetHeader;\nexports.deflate = deflate;\nexports.deflateEnd = deflateEnd;\nexports.deflateSetDictionary = deflateSetDictionary;\nexports.deflateInfo = 'pako deflate (from Nodeca project)';\n\n/* Not implemented\nexports.deflateBound = deflateBound;\nexports.deflateCopy = deflateCopy;\nexports.deflateParams = deflateParams;\nexports.deflatePending = deflatePending;\nexports.deflatePrime = deflatePrime;\nexports.deflateTune = deflateTune;\n*/\n\n\n//# sourceURL=webpack://platypus/./node_modules/pako/lib/zlib/deflate.js?");

/***/ }),

/***/ "./node_modules/pako/lib/zlib/gzheader.js":
/*!************************************************!*\
  !*** ./node_modules/pako/lib/zlib/gzheader.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\nfunction GZheader() {\n  /* true if compressed data believed to be text */\n  this.text       = 0;\n  /* modification time */\n  this.time       = 0;\n  /* extra flags (not used when writing a gzip file) */\n  this.xflags     = 0;\n  /* operating system */\n  this.os         = 0;\n  /* pointer to extra field or Z_NULL if none */\n  this.extra      = null;\n  /* extra field length (valid if extra != Z_NULL) */\n  this.extra_len  = 0; // Actually, we don't need it in JS,\n                       // but leave for few code modifications\n\n  //\n  // Setup limits is not necessary because in js we should not preallocate memory\n  // for inflate use constant limit in 65536 bytes\n  //\n\n  /* space at extra (only when reading header) */\n  // this.extra_max  = 0;\n  /* pointer to zero-terminated file name or Z_NULL */\n  this.name       = '';\n  /* space at name (only when reading header) */\n  // this.name_max   = 0;\n  /* pointer to zero-terminated comment or Z_NULL */\n  this.comment    = '';\n  /* space at comment (only when reading header) */\n  // this.comm_max   = 0;\n  /* true if there was or will be a header crc */\n  this.hcrc       = 0;\n  /* true when done reading gzip header (not used when writing a gzip file) */\n  this.done       = false;\n}\n\nmodule.exports = GZheader;\n\n\n//# sourceURL=webpack://platypus/./node_modules/pako/lib/zlib/gzheader.js?");

/***/ }),

/***/ "./node_modules/pako/lib/zlib/inffast.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/inffast.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// See state defs from inflate.js\nvar BAD = 30;       /* got a data error -- remain here until reset */\nvar TYPE = 12;      /* i: waiting for type bits, including last-flag bit */\n\n/*\n   Decode literal, length, and distance codes and write out the resulting\n   literal and match bytes until either not enough input or output is\n   available, an end-of-block is encountered, or a data error is encountered.\n   When large enough input and output buffers are supplied to inflate(), for\n   example, a 16K input buffer and a 64K output buffer, more than 95% of the\n   inflate execution time is spent in this routine.\n\n   Entry assumptions:\n\n        state.mode === LEN\n        strm.avail_in >= 6\n        strm.avail_out >= 258\n        start >= strm.avail_out\n        state.bits < 8\n\n   On return, state.mode is one of:\n\n        LEN -- ran out of enough output space or enough available input\n        TYPE -- reached end of block code, inflate() to interpret next block\n        BAD -- error in block data\n\n   Notes:\n\n    - The maximum input bits used by a length/distance pair is 15 bits for the\n      length code, 5 bits for the length extra, 15 bits for the distance code,\n      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.\n      Therefore if strm.avail_in >= 6, then there is enough input to avoid\n      checking for available input while decoding.\n\n    - The maximum bytes that a single length/distance pair can output is 258\n      bytes, which is the maximum length that can be coded.  inflate_fast()\n      requires strm.avail_out >= 258 for each loop to avoid checking for\n      output space.\n */\nmodule.exports = function inflate_fast(strm, start) {\n  var state;\n  var _in;                    /* local strm.input */\n  var last;                   /* have enough input while in < last */\n  var _out;                   /* local strm.output */\n  var beg;                    /* inflate()'s initial strm.output */\n  var end;                    /* while out < end, enough space available */\n//#ifdef INFLATE_STRICT\n  var dmax;                   /* maximum distance from zlib header */\n//#endif\n  var wsize;                  /* window size or zero if not using window */\n  var whave;                  /* valid bytes in the window */\n  var wnext;                  /* window write index */\n  // Use `s_window` instead `window`, avoid conflict with instrumentation tools\n  var s_window;               /* allocated sliding window, if wsize != 0 */\n  var hold;                   /* local strm.hold */\n  var bits;                   /* local strm.bits */\n  var lcode;                  /* local strm.lencode */\n  var dcode;                  /* local strm.distcode */\n  var lmask;                  /* mask for first level of length codes */\n  var dmask;                  /* mask for first level of distance codes */\n  var here;                   /* retrieved table entry */\n  var op;                     /* code bits, operation, extra bits, or */\n                              /*  window position, window bytes to copy */\n  var len;                    /* match length, unused bytes */\n  var dist;                   /* match distance */\n  var from;                   /* where to copy match from */\n  var from_source;\n\n\n  var input, output; // JS specific, because we have no pointers\n\n  /* copy state to local variables */\n  state = strm.state;\n  //here = state.here;\n  _in = strm.next_in;\n  input = strm.input;\n  last = _in + (strm.avail_in - 5);\n  _out = strm.next_out;\n  output = strm.output;\n  beg = _out - (start - strm.avail_out);\n  end = _out + (strm.avail_out - 257);\n//#ifdef INFLATE_STRICT\n  dmax = state.dmax;\n//#endif\n  wsize = state.wsize;\n  whave = state.whave;\n  wnext = state.wnext;\n  s_window = state.window;\n  hold = state.hold;\n  bits = state.bits;\n  lcode = state.lencode;\n  dcode = state.distcode;\n  lmask = (1 << state.lenbits) - 1;\n  dmask = (1 << state.distbits) - 1;\n\n\n  /* decode literals and length/distances until end-of-block or not enough\n     input data or output space */\n\n  top:\n  do {\n    if (bits < 15) {\n      hold += input[_in++] << bits;\n      bits += 8;\n      hold += input[_in++] << bits;\n      bits += 8;\n    }\n\n    here = lcode[hold & lmask];\n\n    dolen:\n    for (;;) { // Goto emulation\n      op = here >>> 24/*here.bits*/;\n      hold >>>= op;\n      bits -= op;\n      op = (here >>> 16) & 0xff/*here.op*/;\n      if (op === 0) {                          /* literal */\n        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n        //        \"inflate:         literal '%c'\\n\" :\n        //        \"inflate:         literal 0x%02x\\n\", here.val));\n        output[_out++] = here & 0xffff/*here.val*/;\n      }\n      else if (op & 16) {                     /* length base */\n        len = here & 0xffff/*here.val*/;\n        op &= 15;                           /* number of extra bits */\n        if (op) {\n          if (bits < op) {\n            hold += input[_in++] << bits;\n            bits += 8;\n          }\n          len += hold & ((1 << op) - 1);\n          hold >>>= op;\n          bits -= op;\n        }\n        //Tracevv((stderr, \"inflate:         length %u\\n\", len));\n        if (bits < 15) {\n          hold += input[_in++] << bits;\n          bits += 8;\n          hold += input[_in++] << bits;\n          bits += 8;\n        }\n        here = dcode[hold & dmask];\n\n        dodist:\n        for (;;) { // goto emulation\n          op = here >>> 24/*here.bits*/;\n          hold >>>= op;\n          bits -= op;\n          op = (here >>> 16) & 0xff/*here.op*/;\n\n          if (op & 16) {                      /* distance base */\n            dist = here & 0xffff/*here.val*/;\n            op &= 15;                       /* number of extra bits */\n            if (bits < op) {\n              hold += input[_in++] << bits;\n              bits += 8;\n              if (bits < op) {\n                hold += input[_in++] << bits;\n                bits += 8;\n              }\n            }\n            dist += hold & ((1 << op) - 1);\n//#ifdef INFLATE_STRICT\n            if (dist > dmax) {\n              strm.msg = 'invalid distance too far back';\n              state.mode = BAD;\n              break top;\n            }\n//#endif\n            hold >>>= op;\n            bits -= op;\n            //Tracevv((stderr, \"inflate:         distance %u\\n\", dist));\n            op = _out - beg;                /* max distance in output */\n            if (dist > op) {                /* see if copy from window */\n              op = dist - op;               /* distance back in window */\n              if (op > whave) {\n                if (state.sane) {\n                  strm.msg = 'invalid distance too far back';\n                  state.mode = BAD;\n                  break top;\n                }\n\n// (!) This block is disabled in zlib defailts,\n// don't enable it for binary compatibility\n//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n//                if (len <= op - whave) {\n//                  do {\n//                    output[_out++] = 0;\n//                  } while (--len);\n//                  continue top;\n//                }\n//                len -= op - whave;\n//                do {\n//                  output[_out++] = 0;\n//                } while (--op > whave);\n//                if (op === 0) {\n//                  from = _out - dist;\n//                  do {\n//                    output[_out++] = output[from++];\n//                  } while (--len);\n//                  continue top;\n//                }\n//#endif\n              }\n              from = 0; // window index\n              from_source = s_window;\n              if (wnext === 0) {           /* very common case */\n                from += wsize - op;\n                if (op < len) {         /* some from window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = _out - dist;  /* rest from output */\n                  from_source = output;\n                }\n              }\n              else if (wnext < op) {      /* wrap around window */\n                from += wsize + wnext - op;\n                op -= wnext;\n                if (op < len) {         /* some from end of window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = 0;\n                  if (wnext < len) {  /* some from start of window */\n                    op = wnext;\n                    len -= op;\n                    do {\n                      output[_out++] = s_window[from++];\n                    } while (--op);\n                    from = _out - dist;      /* rest from output */\n                    from_source = output;\n                  }\n                }\n              }\n              else {                      /* contiguous in window */\n                from += wnext - op;\n                if (op < len) {         /* some from window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = _out - dist;  /* rest from output */\n                  from_source = output;\n                }\n              }\n              while (len > 2) {\n                output[_out++] = from_source[from++];\n                output[_out++] = from_source[from++];\n                output[_out++] = from_source[from++];\n                len -= 3;\n              }\n              if (len) {\n                output[_out++] = from_source[from++];\n                if (len > 1) {\n                  output[_out++] = from_source[from++];\n                }\n              }\n            }\n            else {\n              from = _out - dist;          /* copy direct from output */\n              do {                        /* minimum length is three */\n                output[_out++] = output[from++];\n                output[_out++] = output[from++];\n                output[_out++] = output[from++];\n                len -= 3;\n              } while (len > 2);\n              if (len) {\n                output[_out++] = output[from++];\n                if (len > 1) {\n                  output[_out++] = output[from++];\n                }\n              }\n            }\n          }\n          else if ((op & 64) === 0) {          /* 2nd level distance code */\n            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n            continue dodist;\n          }\n          else {\n            strm.msg = 'invalid distance code';\n            state.mode = BAD;\n            break top;\n          }\n\n          break; // need to emulate goto via \"continue\"\n        }\n      }\n      else if ((op & 64) === 0) {              /* 2nd level length code */\n        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n        continue dolen;\n      }\n      else if (op & 32) {                     /* end-of-block */\n        //Tracevv((stderr, \"inflate:         end of block\\n\"));\n        state.mode = TYPE;\n        break top;\n      }\n      else {\n        strm.msg = 'invalid literal/length code';\n        state.mode = BAD;\n        break top;\n      }\n\n      break; // need to emulate goto via \"continue\"\n    }\n  } while (_in < last && _out < end);\n\n  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */\n  len = bits >> 3;\n  _in -= len;\n  bits -= len << 3;\n  hold &= (1 << bits) - 1;\n\n  /* update state and return */\n  strm.next_in = _in;\n  strm.next_out = _out;\n  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));\n  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));\n  state.hold = hold;\n  state.bits = bits;\n  return;\n};\n\n\n//# sourceURL=webpack://platypus/./node_modules/pako/lib/zlib/inffast.js?");

/***/ }),

/***/ "./node_modules/pako/lib/zlib/inflate.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/inflate.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\nvar utils         = __webpack_require__(/*! ../utils/common */ \"./node_modules/pako/lib/utils/common.js\");\nvar adler32       = __webpack_require__(/*! ./adler32 */ \"./node_modules/pako/lib/zlib/adler32.js\");\nvar crc32         = __webpack_require__(/*! ./crc32 */ \"./node_modules/pako/lib/zlib/crc32.js\");\nvar inflate_fast  = __webpack_require__(/*! ./inffast */ \"./node_modules/pako/lib/zlib/inffast.js\");\nvar inflate_table = __webpack_require__(/*! ./inftrees */ \"./node_modules/pako/lib/zlib/inftrees.js\");\n\nvar CODES = 0;\nvar LENS = 1;\nvar DISTS = 2;\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n/* Allowed flush values; see deflate() and inflate() below for details */\n//var Z_NO_FLUSH      = 0;\n//var Z_PARTIAL_FLUSH = 1;\n//var Z_SYNC_FLUSH    = 2;\n//var Z_FULL_FLUSH    = 3;\nvar Z_FINISH        = 4;\nvar Z_BLOCK         = 5;\nvar Z_TREES         = 6;\n\n\n/* Return codes for the compression/decompression functions. Negative values\n * are errors, positive values are used for special but normal events.\n */\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\nvar Z_NEED_DICT     = 2;\n//var Z_ERRNO         = -1;\nvar Z_STREAM_ERROR  = -2;\nvar Z_DATA_ERROR    = -3;\nvar Z_MEM_ERROR     = -4;\nvar Z_BUF_ERROR     = -5;\n//var Z_VERSION_ERROR = -6;\n\n/* The deflate compression method */\nvar Z_DEFLATED  = 8;\n\n\n/* STATES ====================================================================*/\n/* ===========================================================================*/\n\n\nvar    HEAD = 1;       /* i: waiting for magic header */\nvar    FLAGS = 2;      /* i: waiting for method and flags (gzip) */\nvar    TIME = 3;       /* i: waiting for modification time (gzip) */\nvar    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */\nvar    EXLEN = 5;      /* i: waiting for extra length (gzip) */\nvar    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */\nvar    NAME = 7;       /* i: waiting for end of file name (gzip) */\nvar    COMMENT = 8;    /* i: waiting for end of comment (gzip) */\nvar    HCRC = 9;       /* i: waiting for header crc (gzip) */\nvar    DICTID = 10;    /* i: waiting for dictionary check value */\nvar    DICT = 11;      /* waiting for inflateSetDictionary() call */\nvar        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */\nvar        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */\nvar        STORED = 14;    /* i: waiting for stored size (length and complement) */\nvar        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */\nvar        COPY = 16;      /* i/o: waiting for input or output to copy stored block */\nvar        TABLE = 17;     /* i: waiting for dynamic block table lengths */\nvar        LENLENS = 18;   /* i: waiting for code length code lengths */\nvar        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */\nvar            LEN_ = 20;      /* i: same as LEN below, but only first time in */\nvar            LEN = 21;       /* i: waiting for length/lit/eob code */\nvar            LENEXT = 22;    /* i: waiting for length extra bits */\nvar            DIST = 23;      /* i: waiting for distance code */\nvar            DISTEXT = 24;   /* i: waiting for distance extra bits */\nvar            MATCH = 25;     /* o: waiting for output space to copy string */\nvar            LIT = 26;       /* o: waiting for output space to write literal */\nvar    CHECK = 27;     /* i: waiting for 32-bit check value */\nvar    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */\nvar    DONE = 29;      /* finished check, done -- remain here until reset */\nvar    BAD = 30;       /* got a data error -- remain here until reset */\nvar    MEM = 31;       /* got an inflate() memory error -- remain here until reset */\nvar    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */\n\n/* ===========================================================================*/\n\n\n\nvar ENOUGH_LENS = 852;\nvar ENOUGH_DISTS = 592;\n//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);\n\nvar MAX_WBITS = 15;\n/* 32K LZ77 window */\nvar DEF_WBITS = MAX_WBITS;\n\n\nfunction zswap32(q) {\n  return  (((q >>> 24) & 0xff) +\n          ((q >>> 8) & 0xff00) +\n          ((q & 0xff00) << 8) +\n          ((q & 0xff) << 24));\n}\n\n\nfunction InflateState() {\n  this.mode = 0;             /* current inflate mode */\n  this.last = false;          /* true if processing last block */\n  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\n  this.havedict = false;      /* true if dictionary provided */\n  this.flags = 0;             /* gzip header method and flags (0 if zlib) */\n  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */\n  this.check = 0;             /* protected copy of check value */\n  this.total = 0;             /* protected copy of output count */\n  // TODO: may be {}\n  this.head = null;           /* where to save gzip header information */\n\n  /* sliding window */\n  this.wbits = 0;             /* log base 2 of requested window size */\n  this.wsize = 0;             /* window size or zero if not using window */\n  this.whave = 0;             /* valid bytes in the window */\n  this.wnext = 0;             /* window write index */\n  this.window = null;         /* allocated sliding window, if needed */\n\n  /* bit accumulator */\n  this.hold = 0;              /* input bit accumulator */\n  this.bits = 0;              /* number of bits in \"in\" */\n\n  /* for string and stored block copying */\n  this.length = 0;            /* literal or length of data to copy */\n  this.offset = 0;            /* distance back to copy string from */\n\n  /* for table and code decoding */\n  this.extra = 0;             /* extra bits needed */\n\n  /* fixed and dynamic code tables */\n  this.lencode = null;          /* starting table for length/literal codes */\n  this.distcode = null;         /* starting table for distance codes */\n  this.lenbits = 0;           /* index bits for lencode */\n  this.distbits = 0;          /* index bits for distcode */\n\n  /* dynamic table building */\n  this.ncode = 0;             /* number of code length code lengths */\n  this.nlen = 0;              /* number of length code lengths */\n  this.ndist = 0;             /* number of distance code lengths */\n  this.have = 0;              /* number of code lengths in lens[] */\n  this.next = null;              /* next available space in codes[] */\n\n  this.lens = new utils.Buf16(320); /* temporary storage for code lengths */\n  this.work = new utils.Buf16(288); /* work area for code table building */\n\n  /*\n   because we don't have pointers in js, we use lencode and distcode directly\n   as buffers so we don't need codes\n  */\n  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */\n  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */\n  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */\n  this.sane = 0;                   /* if false, allow invalid distance too far */\n  this.back = 0;                   /* bits back of last unprocessed length/lit */\n  this.was = 0;                    /* initial length of match */\n}\n\nfunction inflateResetKeep(strm) {\n  var state;\n\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n  strm.total_in = strm.total_out = state.total = 0;\n  strm.msg = ''; /*Z_NULL*/\n  if (state.wrap) {       /* to support ill-conceived Java test suite */\n    strm.adler = state.wrap & 1;\n  }\n  state.mode = HEAD;\n  state.last = 0;\n  state.havedict = 0;\n  state.dmax = 32768;\n  state.head = null/*Z_NULL*/;\n  state.hold = 0;\n  state.bits = 0;\n  //state.lencode = state.distcode = state.next = state.codes;\n  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);\n  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);\n\n  state.sane = 1;\n  state.back = -1;\n  //Tracev((stderr, \"inflate: reset\\n\"));\n  return Z_OK;\n}\n\nfunction inflateReset(strm) {\n  var state;\n\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n  state.wsize = 0;\n  state.whave = 0;\n  state.wnext = 0;\n  return inflateResetKeep(strm);\n\n}\n\nfunction inflateReset2(strm, windowBits) {\n  var wrap;\n  var state;\n\n  /* get the state */\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n\n  /* extract wrap request from windowBits parameter */\n  if (windowBits < 0) {\n    wrap = 0;\n    windowBits = -windowBits;\n  }\n  else {\n    wrap = (windowBits >> 4) + 1;\n    if (windowBits < 48) {\n      windowBits &= 15;\n    }\n  }\n\n  /* set number of window bits, free window if different */\n  if (windowBits && (windowBits < 8 || windowBits > 15)) {\n    return Z_STREAM_ERROR;\n  }\n  if (state.window !== null && state.wbits !== windowBits) {\n    state.window = null;\n  }\n\n  /* update state and reset the rest of it */\n  state.wrap = wrap;\n  state.wbits = windowBits;\n  return inflateReset(strm);\n}\n\nfunction inflateInit2(strm, windowBits) {\n  var ret;\n  var state;\n\n  if (!strm) { return Z_STREAM_ERROR; }\n  //strm.msg = Z_NULL;                 /* in case we return an error */\n\n  state = new InflateState();\n\n  //if (state === Z_NULL) return Z_MEM_ERROR;\n  //Tracev((stderr, \"inflate: allocated\\n\"));\n  strm.state = state;\n  state.window = null/*Z_NULL*/;\n  ret = inflateReset2(strm, windowBits);\n  if (ret !== Z_OK) {\n    strm.state = null/*Z_NULL*/;\n  }\n  return ret;\n}\n\nfunction inflateInit(strm) {\n  return inflateInit2(strm, DEF_WBITS);\n}\n\n\n/*\n Return state with length and distance decoding tables and index sizes set to\n fixed code decoding.  Normally this returns fixed tables from inffixed.h.\n If BUILDFIXED is defined, then instead this routine builds the tables the\n first time it's called, and returns those tables the first time and\n thereafter.  This reduces the size of the code by about 2K bytes, in\n exchange for a little execution time.  However, BUILDFIXED should not be\n used for threaded applications, since the rewriting of the tables and virgin\n may not be thread-safe.\n */\nvar virgin = true;\n\nvar lenfix, distfix; // We have no pointers in JS, so keep tables separate\n\nfunction fixedtables(state) {\n  /* build fixed huffman tables if first call (may not be thread safe) */\n  if (virgin) {\n    var sym;\n\n    lenfix = new utils.Buf32(512);\n    distfix = new utils.Buf32(32);\n\n    /* literal/length table */\n    sym = 0;\n    while (sym < 144) { state.lens[sym++] = 8; }\n    while (sym < 256) { state.lens[sym++] = 9; }\n    while (sym < 280) { state.lens[sym++] = 7; }\n    while (sym < 288) { state.lens[sym++] = 8; }\n\n    inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });\n\n    /* distance table */\n    sym = 0;\n    while (sym < 32) { state.lens[sym++] = 5; }\n\n    inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });\n\n    /* do this just once */\n    virgin = false;\n  }\n\n  state.lencode = lenfix;\n  state.lenbits = 9;\n  state.distcode = distfix;\n  state.distbits = 5;\n}\n\n\n/*\n Update the window with the last wsize (normally 32K) bytes written before\n returning.  If window does not exist yet, create it.  This is only called\n when a window is already in use, or when output has been written during this\n inflate call, but the end of the deflate stream has not been reached yet.\n It is also called to create a window for dictionary data when a dictionary\n is loaded.\n\n Providing output buffers larger than 32K to inflate() should provide a speed\n advantage, since only the last 32K of output is copied to the sliding window\n upon return from inflate(), and since all distances after the first 32K of\n output will fall in the output data, making match copies simpler and faster.\n The advantage may be dependent on the size of the processor's data caches.\n */\nfunction updatewindow(strm, src, end, copy) {\n  var dist;\n  var state = strm.state;\n\n  /* if it hasn't been done already, allocate space for the window */\n  if (state.window === null) {\n    state.wsize = 1 << state.wbits;\n    state.wnext = 0;\n    state.whave = 0;\n\n    state.window = new utils.Buf8(state.wsize);\n  }\n\n  /* copy state->wsize or less output bytes into the circular window */\n  if (copy >= state.wsize) {\n    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);\n    state.wnext = 0;\n    state.whave = state.wsize;\n  }\n  else {\n    dist = state.wsize - state.wnext;\n    if (dist > copy) {\n      dist = copy;\n    }\n    //zmemcpy(state->window + state->wnext, end - copy, dist);\n    utils.arraySet(state.window, src, end - copy, dist, state.wnext);\n    copy -= dist;\n    if (copy) {\n      //zmemcpy(state->window, end - copy, copy);\n      utils.arraySet(state.window, src, end - copy, copy, 0);\n      state.wnext = copy;\n      state.whave = state.wsize;\n    }\n    else {\n      state.wnext += dist;\n      if (state.wnext === state.wsize) { state.wnext = 0; }\n      if (state.whave < state.wsize) { state.whave += dist; }\n    }\n  }\n  return 0;\n}\n\nfunction inflate(strm, flush) {\n  var state;\n  var input, output;          // input/output buffers\n  var next;                   /* next input INDEX */\n  var put;                    /* next output INDEX */\n  var have, left;             /* available input and output */\n  var hold;                   /* bit buffer */\n  var bits;                   /* bits in bit buffer */\n  var _in, _out;              /* save starting available input and output */\n  var copy;                   /* number of stored or match bytes to copy */\n  var from;                   /* where to copy match bytes from */\n  var from_source;\n  var here = 0;               /* current decoding table entry */\n  var here_bits, here_op, here_val; // paked \"here\" denormalized (JS specific)\n  //var last;                   /* parent table entry */\n  var last_bits, last_op, last_val; // paked \"last\" denormalized (JS specific)\n  var len;                    /* length to copy for repeats, bits to drop */\n  var ret;                    /* return code */\n  var hbuf = new utils.Buf8(4);    /* buffer for gzip header crc calculation */\n  var opts;\n\n  var n; // temporary var for NEED_BITS\n\n  var order = /* permutation of code lengths */\n    [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];\n\n\n  if (!strm || !strm.state || !strm.output ||\n      (!strm.input && strm.avail_in !== 0)) {\n    return Z_STREAM_ERROR;\n  }\n\n  state = strm.state;\n  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */\n\n\n  //--- LOAD() ---\n  put = strm.next_out;\n  output = strm.output;\n  left = strm.avail_out;\n  next = strm.next_in;\n  input = strm.input;\n  have = strm.avail_in;\n  hold = state.hold;\n  bits = state.bits;\n  //---\n\n  _in = have;\n  _out = left;\n  ret = Z_OK;\n\n  inf_leave: // goto emulation\n  for (;;) {\n    switch (state.mode) {\n    case HEAD:\n      if (state.wrap === 0) {\n        state.mode = TYPEDO;\n        break;\n      }\n      //=== NEEDBITS(16);\n      while (bits < 16) {\n        if (have === 0) { break inf_leave; }\n        have--;\n        hold += input[next++] << bits;\n        bits += 8;\n      }\n      //===//\n      if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */\n        state.check = 0/*crc32(0L, Z_NULL, 0)*/;\n        //=== CRC2(state.check, hold);\n        hbuf[0] = hold & 0xff;\n        hbuf[1] = (hold >>> 8) & 0xff;\n        state.check = crc32(state.check, hbuf, 2, 0);\n        //===//\n\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = FLAGS;\n        break;\n      }\n      state.flags = 0;           /* expect zlib header */\n      if (state.head) {\n        state.head.done = false;\n      }\n      if (!(state.wrap & 1) ||   /* check if zlib header allowed */\n        (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {\n        strm.msg = 'incorrect header check';\n        state.mode = BAD;\n        break;\n      }\n      if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {\n        strm.msg = 'unknown compression method';\n        state.mode = BAD;\n        break;\n      }\n      //--- DROPBITS(4) ---//\n      hold >>>= 4;\n      bits -= 4;\n      //---//\n      len = (hold & 0x0f)/*BITS(4)*/ + 8;\n      if (state.wbits === 0) {\n        state.wbits = len;\n      }\n      else if (len > state.wbits) {\n        strm.msg = 'invalid window size';\n        state.mode = BAD;\n        break;\n      }\n      state.dmax = 1 << len;\n      //Tracev((stderr, \"inflate:   zlib header ok\\n\"));\n      strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;\n      state.mode = hold & 0x200 ? DICTID : TYPE;\n      //=== INITBITS();\n      hold = 0;\n      bits = 0;\n      //===//\n      break;\n    case FLAGS:\n      //=== NEEDBITS(16); */\n      while (bits < 16) {\n        if (have === 0) { break inf_leave; }\n        have--;\n        hold += input[next++] << bits;\n        bits += 8;\n      }\n      //===//\n      state.flags = hold;\n      if ((state.flags & 0xff) !== Z_DEFLATED) {\n        strm.msg = 'unknown compression method';\n        state.mode = BAD;\n        break;\n      }\n      if (state.flags & 0xe000) {\n        strm.msg = 'unknown header flags set';\n        state.mode = BAD;\n        break;\n      }\n      if (state.head) {\n        state.head.text = ((hold >> 8) & 1);\n      }\n      if (state.flags & 0x0200) {\n        //=== CRC2(state.check, hold);\n        hbuf[0] = hold & 0xff;\n        hbuf[1] = (hold >>> 8) & 0xff;\n        state.check = crc32(state.check, hbuf, 2, 0);\n        //===//\n      }\n      //=== INITBITS();\n      hold = 0;\n      bits = 0;\n      //===//\n      state.mode = TIME;\n      /* falls through */\n    case TIME:\n      //=== NEEDBITS(32); */\n      while (bits < 32) {\n        if (have === 0) { break inf_leave; }\n        have--;\n        hold += input[next++] << bits;\n        bits += 8;\n      }\n      //===//\n      if (state.head) {\n        state.head.time = hold;\n      }\n      if (state.flags & 0x0200) {\n        //=== CRC4(state.check, hold)\n        hbuf[0] = hold & 0xff;\n        hbuf[1] = (hold >>> 8) & 0xff;\n        hbuf[2] = (hold >>> 16) & 0xff;\n        hbuf[3] = (hold >>> 24) & 0xff;\n        state.check = crc32(state.check, hbuf, 4, 0);\n        //===\n      }\n      //=== INITBITS();\n      hold = 0;\n      bits = 0;\n      //===//\n      state.mode = OS;\n      /* falls through */\n    case OS:\n      //=== NEEDBITS(16); */\n      while (bits < 16) {\n        if (have === 0) { break inf_leave; }\n        have--;\n        hold += input[next++] << bits;\n        bits += 8;\n      }\n      //===//\n      if (state.head) {\n        state.head.xflags = (hold & 0xff);\n        state.head.os = (hold >> 8);\n      }\n      if (state.flags & 0x0200) {\n        //=== CRC2(state.check, hold);\n        hbuf[0] = hold & 0xff;\n        hbuf[1] = (hold >>> 8) & 0xff;\n        state.check = crc32(state.check, hbuf, 2, 0);\n        //===//\n      }\n      //=== INITBITS();\n      hold = 0;\n      bits = 0;\n      //===//\n      state.mode = EXLEN;\n      /* falls through */\n    case EXLEN:\n      if (state.flags & 0x0400) {\n        //=== NEEDBITS(16); */\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.length = hold;\n        if (state.head) {\n          state.head.extra_len = hold;\n        }\n        if (state.flags & 0x0200) {\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32(state.check, hbuf, 2, 0);\n          //===//\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n      }\n      else if (state.head) {\n        state.head.extra = null/*Z_NULL*/;\n      }\n      state.mode = EXTRA;\n      /* falls through */\n    case EXTRA:\n      if (state.flags & 0x0400) {\n        copy = state.length;\n        if (copy > have) { copy = have; }\n        if (copy) {\n          if (state.head) {\n            len = state.head.extra_len - state.length;\n            if (!state.head.extra) {\n              // Use untyped array for more conveniend processing later\n              state.head.extra = new Array(state.head.extra_len);\n            }\n            utils.arraySet(\n              state.head.extra,\n              input,\n              next,\n              // extra field is limited to 65536 bytes\n              // - no need for additional size check\n              copy,\n              /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/\n              len\n            );\n            //zmemcpy(state.head.extra + len, next,\n            //        len + copy > state.head.extra_max ?\n            //        state.head.extra_max - len : copy);\n          }\n          if (state.flags & 0x0200) {\n            state.check = crc32(state.check, input, copy, next);\n          }\n          have -= copy;\n          next += copy;\n          state.length -= copy;\n        }\n        if (state.length) { break inf_leave; }\n      }\n      state.length = 0;\n      state.mode = NAME;\n      /* falls through */\n    case NAME:\n      if (state.flags & 0x0800) {\n        if (have === 0) { break inf_leave; }\n        copy = 0;\n        do {\n          // TODO: 2 or 1 bytes?\n          len = input[next + copy++];\n          /* use constant limit because in js we should not preallocate memory */\n          if (state.head && len &&\n              (state.length < 65536 /*state.head.name_max*/)) {\n            state.head.name += String.fromCharCode(len);\n          }\n        } while (len && copy < have);\n\n        if (state.flags & 0x0200) {\n          state.check = crc32(state.check, input, copy, next);\n        }\n        have -= copy;\n        next += copy;\n        if (len) { break inf_leave; }\n      }\n      else if (state.head) {\n        state.head.name = null;\n      }\n      state.length = 0;\n      state.mode = COMMENT;\n      /* falls through */\n    case COMMENT:\n      if (state.flags & 0x1000) {\n        if (have === 0) { break inf_leave; }\n        copy = 0;\n        do {\n          len = input[next + copy++];\n          /* use constant limit because in js we should not preallocate memory */\n          if (state.head && len &&\n              (state.length < 65536 /*state.head.comm_max*/)) {\n            state.head.comment += String.fromCharCode(len);\n          }\n        } while (len && copy < have);\n        if (state.flags & 0x0200) {\n          state.check = crc32(state.check, input, copy, next);\n        }\n        have -= copy;\n        next += copy;\n        if (len) { break inf_leave; }\n      }\n      else if (state.head) {\n        state.head.comment = null;\n      }\n      state.mode = HCRC;\n      /* falls through */\n    case HCRC:\n      if (state.flags & 0x0200) {\n        //=== NEEDBITS(16); */\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if (hold !== (state.check & 0xffff)) {\n          strm.msg = 'header crc mismatch';\n          state.mode = BAD;\n          break;\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n      }\n      if (state.head) {\n        state.head.hcrc = ((state.flags >> 9) & 1);\n        state.head.done = true;\n      }\n      strm.adler = state.check = 0;\n      state.mode = TYPE;\n      break;\n    case DICTID:\n      //=== NEEDBITS(32); */\n      while (bits < 32) {\n        if (have === 0) { break inf_leave; }\n        have--;\n        hold += input[next++] << bits;\n        bits += 8;\n      }\n      //===//\n      strm.adler = state.check = zswap32(hold);\n      //=== INITBITS();\n      hold = 0;\n      bits = 0;\n      //===//\n      state.mode = DICT;\n      /* falls through */\n    case DICT:\n      if (state.havedict === 0) {\n        //--- RESTORE() ---\n        strm.next_out = put;\n        strm.avail_out = left;\n        strm.next_in = next;\n        strm.avail_in = have;\n        state.hold = hold;\n        state.bits = bits;\n        //---\n        return Z_NEED_DICT;\n      }\n      strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;\n      state.mode = TYPE;\n      /* falls through */\n    case TYPE:\n      if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }\n      /* falls through */\n    case TYPEDO:\n      if (state.last) {\n        //--- BYTEBITS() ---//\n        hold >>>= bits & 7;\n        bits -= bits & 7;\n        //---//\n        state.mode = CHECK;\n        break;\n      }\n      //=== NEEDBITS(3); */\n      while (bits < 3) {\n        if (have === 0) { break inf_leave; }\n        have--;\n        hold += input[next++] << bits;\n        bits += 8;\n      }\n      //===//\n      state.last = (hold & 0x01)/*BITS(1)*/;\n      //--- DROPBITS(1) ---//\n      hold >>>= 1;\n      bits -= 1;\n      //---//\n\n      switch ((hold & 0x03)/*BITS(2)*/) {\n      case 0:                             /* stored block */\n        //Tracev((stderr, \"inflate:     stored block%s\\n\",\n        //        state.last ? \" (last)\" : \"\"));\n        state.mode = STORED;\n        break;\n      case 1:                             /* fixed block */\n        fixedtables(state);\n        //Tracev((stderr, \"inflate:     fixed codes block%s\\n\",\n        //        state.last ? \" (last)\" : \"\"));\n        state.mode = LEN_;             /* decode codes */\n        if (flush === Z_TREES) {\n          //--- DROPBITS(2) ---//\n          hold >>>= 2;\n          bits -= 2;\n          //---//\n          break inf_leave;\n        }\n        break;\n      case 2:                             /* dynamic block */\n        //Tracev((stderr, \"inflate:     dynamic codes block%s\\n\",\n        //        state.last ? \" (last)\" : \"\"));\n        state.mode = TABLE;\n        break;\n      case 3:\n        strm.msg = 'invalid block type';\n        state.mode = BAD;\n      }\n      //--- DROPBITS(2) ---//\n      hold >>>= 2;\n      bits -= 2;\n      //---//\n      break;\n    case STORED:\n      //--- BYTEBITS() ---// /* go to byte boundary */\n      hold >>>= bits & 7;\n      bits -= bits & 7;\n      //---//\n      //=== NEEDBITS(32); */\n      while (bits < 32) {\n        if (have === 0) { break inf_leave; }\n        have--;\n        hold += input[next++] << bits;\n        bits += 8;\n      }\n      //===//\n      if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {\n        strm.msg = 'invalid stored block lengths';\n        state.mode = BAD;\n        break;\n      }\n      state.length = hold & 0xffff;\n      //Tracev((stderr, \"inflate:       stored length %u\\n\",\n      //        state.length));\n      //=== INITBITS();\n      hold = 0;\n      bits = 0;\n      //===//\n      state.mode = COPY_;\n      if (flush === Z_TREES) { break inf_leave; }\n      /* falls through */\n    case COPY_:\n      state.mode = COPY;\n      /* falls through */\n    case COPY:\n      copy = state.length;\n      if (copy) {\n        if (copy > have) { copy = have; }\n        if (copy > left) { copy = left; }\n        if (copy === 0) { break inf_leave; }\n        //--- zmemcpy(put, next, copy); ---\n        utils.arraySet(output, input, next, copy, put);\n        //---//\n        have -= copy;\n        next += copy;\n        left -= copy;\n        put += copy;\n        state.length -= copy;\n        break;\n      }\n      //Tracev((stderr, \"inflate:       stored end\\n\"));\n      state.mode = TYPE;\n      break;\n    case TABLE:\n      //=== NEEDBITS(14); */\n      while (bits < 14) {\n        if (have === 0) { break inf_leave; }\n        have--;\n        hold += input[next++] << bits;\n        bits += 8;\n      }\n      //===//\n      state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;\n      //--- DROPBITS(5) ---//\n      hold >>>= 5;\n      bits -= 5;\n      //---//\n      state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;\n      //--- DROPBITS(5) ---//\n      hold >>>= 5;\n      bits -= 5;\n      //---//\n      state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;\n      //--- DROPBITS(4) ---//\n      hold >>>= 4;\n      bits -= 4;\n      //---//\n//#ifndef PKZIP_BUG_WORKAROUND\n      if (state.nlen > 286 || state.ndist > 30) {\n        strm.msg = 'too many length or distance symbols';\n        state.mode = BAD;\n        break;\n      }\n//#endif\n      //Tracev((stderr, \"inflate:       table sizes ok\\n\"));\n      state.have = 0;\n      state.mode = LENLENS;\n      /* falls through */\n    case LENLENS:\n      while (state.have < state.ncode) {\n        //=== NEEDBITS(3);\n        while (bits < 3) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);\n        //--- DROPBITS(3) ---//\n        hold >>>= 3;\n        bits -= 3;\n        //---//\n      }\n      while (state.have < 19) {\n        state.lens[order[state.have++]] = 0;\n      }\n      // We have separate tables & no pointers. 2 commented lines below not needed.\n      //state.next = state.codes;\n      //state.lencode = state.next;\n      // Switch to use dynamic table\n      state.lencode = state.lendyn;\n      state.lenbits = 7;\n\n      opts = { bits: state.lenbits };\n      ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);\n      state.lenbits = opts.bits;\n\n      if (ret) {\n        strm.msg = 'invalid code lengths set';\n        state.mode = BAD;\n        break;\n      }\n      //Tracev((stderr, \"inflate:       code lengths ok\\n\"));\n      state.have = 0;\n      state.mode = CODELENS;\n      /* falls through */\n    case CODELENS:\n      while (state.have < state.nlen + state.ndist) {\n        for (;;) {\n          here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/\n          here_bits = here >>> 24;\n          here_op = (here >>> 16) & 0xff;\n          here_val = here & 0xffff;\n\n          if ((here_bits) <= bits) { break; }\n          //--- PULLBYTE() ---//\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n          //---//\n        }\n        if (here_val < 16) {\n          //--- DROPBITS(here.bits) ---//\n          hold >>>= here_bits;\n          bits -= here_bits;\n          //---//\n          state.lens[state.have++] = here_val;\n        }\n        else {\n          if (here_val === 16) {\n            //=== NEEDBITS(here.bits + 2);\n            n = here_bits + 2;\n            while (bits < n) {\n              if (have === 0) { break inf_leave; }\n              have--;\n              hold += input[next++] << bits;\n              bits += 8;\n            }\n            //===//\n            //--- DROPBITS(here.bits) ---//\n            hold >>>= here_bits;\n            bits -= here_bits;\n            //---//\n            if (state.have === 0) {\n              strm.msg = 'invalid bit length repeat';\n              state.mode = BAD;\n              break;\n            }\n            len = state.lens[state.have - 1];\n            copy = 3 + (hold & 0x03);//BITS(2);\n            //--- DROPBITS(2) ---//\n            hold >>>= 2;\n            bits -= 2;\n            //---//\n          }\n          else if (here_val === 17) {\n            //=== NEEDBITS(here.bits + 3);\n            n = here_bits + 3;\n            while (bits < n) {\n              if (have === 0) { break inf_leave; }\n              have--;\n              hold += input[next++] << bits;\n              bits += 8;\n            }\n            //===//\n            //--- DROPBITS(here.bits) ---//\n            hold >>>= here_bits;\n            bits -= here_bits;\n            //---//\n            len = 0;\n            copy = 3 + (hold & 0x07);//BITS(3);\n            //--- DROPBITS(3) ---//\n            hold >>>= 3;\n            bits -= 3;\n            //---//\n          }\n          else {\n            //=== NEEDBITS(here.bits + 7);\n            n = here_bits + 7;\n            while (bits < n) {\n              if (have === 0) { break inf_leave; }\n              have--;\n              hold += input[next++] << bits;\n              bits += 8;\n            }\n            //===//\n            //--- DROPBITS(here.bits) ---//\n            hold >>>= here_bits;\n            bits -= here_bits;\n            //---//\n            len = 0;\n            copy = 11 + (hold & 0x7f);//BITS(7);\n            //--- DROPBITS(7) ---//\n            hold >>>= 7;\n            bits -= 7;\n            //---//\n          }\n          if (state.have + copy > state.nlen + state.ndist) {\n            strm.msg = 'invalid bit length repeat';\n            state.mode = BAD;\n            break;\n          }\n          while (copy--) {\n            state.lens[state.have++] = len;\n          }\n        }\n      }\n\n      /* handle error breaks in while */\n      if (state.mode === BAD) { break; }\n\n      /* check for end-of-block code (better have one) */\n      if (state.lens[256] === 0) {\n        strm.msg = 'invalid code -- missing end-of-block';\n        state.mode = BAD;\n        break;\n      }\n\n      /* build code tables -- note: do not change the lenbits or distbits\n         values here (9 and 6) without reading the comments in inftrees.h\n         concerning the ENOUGH constants, which depend on those values */\n      state.lenbits = 9;\n\n      opts = { bits: state.lenbits };\n      ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);\n      // We have separate tables & no pointers. 2 commented lines below not needed.\n      // state.next_index = opts.table_index;\n      state.lenbits = opts.bits;\n      // state.lencode = state.next;\n\n      if (ret) {\n        strm.msg = 'invalid literal/lengths set';\n        state.mode = BAD;\n        break;\n      }\n\n      state.distbits = 6;\n      //state.distcode.copy(state.codes);\n      // Switch to use dynamic table\n      state.distcode = state.distdyn;\n      opts = { bits: state.distbits };\n      ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);\n      // We have separate tables & no pointers. 2 commented lines below not needed.\n      // state.next_index = opts.table_index;\n      state.distbits = opts.bits;\n      // state.distcode = state.next;\n\n      if (ret) {\n        strm.msg = 'invalid distances set';\n        state.mode = BAD;\n        break;\n      }\n      //Tracev((stderr, 'inflate:       codes ok\\n'));\n      state.mode = LEN_;\n      if (flush === Z_TREES) { break inf_leave; }\n      /* falls through */\n    case LEN_:\n      state.mode = LEN;\n      /* falls through */\n    case LEN:\n      if (have >= 6 && left >= 258) {\n        //--- RESTORE() ---\n        strm.next_out = put;\n        strm.avail_out = left;\n        strm.next_in = next;\n        strm.avail_in = have;\n        state.hold = hold;\n        state.bits = bits;\n        //---\n        inflate_fast(strm, _out);\n        //--- LOAD() ---\n        put = strm.next_out;\n        output = strm.output;\n        left = strm.avail_out;\n        next = strm.next_in;\n        input = strm.input;\n        have = strm.avail_in;\n        hold = state.hold;\n        bits = state.bits;\n        //---\n\n        if (state.mode === TYPE) {\n          state.back = -1;\n        }\n        break;\n      }\n      state.back = 0;\n      for (;;) {\n        here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/\n        here_bits = here >>> 24;\n        here_op = (here >>> 16) & 0xff;\n        here_val = here & 0xffff;\n\n        if (here_bits <= bits) { break; }\n        //--- PULLBYTE() ---//\n        if (have === 0) { break inf_leave; }\n        have--;\n        hold += input[next++] << bits;\n        bits += 8;\n        //---//\n      }\n      if (here_op && (here_op & 0xf0) === 0) {\n        last_bits = here_bits;\n        last_op = here_op;\n        last_val = here_val;\n        for (;;) {\n          here = state.lencode[last_val +\n                  ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];\n          here_bits = here >>> 24;\n          here_op = (here >>> 16) & 0xff;\n          here_val = here & 0xffff;\n\n          if ((last_bits + here_bits) <= bits) { break; }\n          //--- PULLBYTE() ---//\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n          //---//\n        }\n        //--- DROPBITS(last.bits) ---//\n        hold >>>= last_bits;\n        bits -= last_bits;\n        //---//\n        state.back += last_bits;\n      }\n      //--- DROPBITS(here.bits) ---//\n      hold >>>= here_bits;\n      bits -= here_bits;\n      //---//\n      state.back += here_bits;\n      state.length = here_val;\n      if (here_op === 0) {\n        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n        //        \"inflate:         literal '%c'\\n\" :\n        //        \"inflate:         literal 0x%02x\\n\", here.val));\n        state.mode = LIT;\n        break;\n      }\n      if (here_op & 32) {\n        //Tracevv((stderr, \"inflate:         end of block\\n\"));\n        state.back = -1;\n        state.mode = TYPE;\n        break;\n      }\n      if (here_op & 64) {\n        strm.msg = 'invalid literal/length code';\n        state.mode = BAD;\n        break;\n      }\n      state.extra = here_op & 15;\n      state.mode = LENEXT;\n      /* falls through */\n    case LENEXT:\n      if (state.extra) {\n        //=== NEEDBITS(state.extra);\n        n = state.extra;\n        while (bits < n) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;\n        //--- DROPBITS(state.extra) ---//\n        hold >>>= state.extra;\n        bits -= state.extra;\n        //---//\n        state.back += state.extra;\n      }\n      //Tracevv((stderr, \"inflate:         length %u\\n\", state.length));\n      state.was = state.length;\n      state.mode = DIST;\n      /* falls through */\n    case DIST:\n      for (;;) {\n        here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/\n        here_bits = here >>> 24;\n        here_op = (here >>> 16) & 0xff;\n        here_val = here & 0xffff;\n\n        if ((here_bits) <= bits) { break; }\n        //--- PULLBYTE() ---//\n        if (have === 0) { break inf_leave; }\n        have--;\n        hold += input[next++] << bits;\n        bits += 8;\n        //---//\n      }\n      if ((here_op & 0xf0) === 0) {\n        last_bits = here_bits;\n        last_op = here_op;\n        last_val = here_val;\n        for (;;) {\n          here = state.distcode[last_val +\n                  ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];\n          here_bits = here >>> 24;\n          here_op = (here >>> 16) & 0xff;\n          here_val = here & 0xffff;\n\n          if ((last_bits + here_bits) <= bits) { break; }\n          //--- PULLBYTE() ---//\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n          //---//\n        }\n        //--- DROPBITS(last.bits) ---//\n        hold >>>= last_bits;\n        bits -= last_bits;\n        //---//\n        state.back += last_bits;\n      }\n      //--- DROPBITS(here.bits) ---//\n      hold >>>= here_bits;\n      bits -= here_bits;\n      //---//\n      state.back += here_bits;\n      if (here_op & 64) {\n        strm.msg = 'invalid distance code';\n        state.mode = BAD;\n        break;\n      }\n      state.offset = here_val;\n      state.extra = (here_op) & 15;\n      state.mode = DISTEXT;\n      /* falls through */\n    case DISTEXT:\n      if (state.extra) {\n        //=== NEEDBITS(state.extra);\n        n = state.extra;\n        while (bits < n) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;\n        //--- DROPBITS(state.extra) ---//\n        hold >>>= state.extra;\n        bits -= state.extra;\n        //---//\n        state.back += state.extra;\n      }\n//#ifdef INFLATE_STRICT\n      if (state.offset > state.dmax) {\n        strm.msg = 'invalid distance too far back';\n        state.mode = BAD;\n        break;\n      }\n//#endif\n      //Tracevv((stderr, \"inflate:         distance %u\\n\", state.offset));\n      state.mode = MATCH;\n      /* falls through */\n    case MATCH:\n      if (left === 0) { break inf_leave; }\n      copy = _out - left;\n      if (state.offset > copy) {         /* copy from window */\n        copy = state.offset - copy;\n        if (copy > state.whave) {\n          if (state.sane) {\n            strm.msg = 'invalid distance too far back';\n            state.mode = BAD;\n            break;\n          }\n// (!) This block is disabled in zlib defailts,\n// don't enable it for binary compatibility\n//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n//          Trace((stderr, \"inflate.c too far\\n\"));\n//          copy -= state.whave;\n//          if (copy > state.length) { copy = state.length; }\n//          if (copy > left) { copy = left; }\n//          left -= copy;\n//          state.length -= copy;\n//          do {\n//            output[put++] = 0;\n//          } while (--copy);\n//          if (state.length === 0) { state.mode = LEN; }\n//          break;\n//#endif\n        }\n        if (copy > state.wnext) {\n          copy -= state.wnext;\n          from = state.wsize - copy;\n        }\n        else {\n          from = state.wnext - copy;\n        }\n        if (copy > state.length) { copy = state.length; }\n        from_source = state.window;\n      }\n      else {                              /* copy from output */\n        from_source = output;\n        from = put - state.offset;\n        copy = state.length;\n      }\n      if (copy > left) { copy = left; }\n      left -= copy;\n      state.length -= copy;\n      do {\n        output[put++] = from_source[from++];\n      } while (--copy);\n      if (state.length === 0) { state.mode = LEN; }\n      break;\n    case LIT:\n      if (left === 0) { break inf_leave; }\n      output[put++] = state.length;\n      left--;\n      state.mode = LEN;\n      break;\n    case CHECK:\n      if (state.wrap) {\n        //=== NEEDBITS(32);\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          // Use '|' insdead of '+' to make sure that result is signed\n          hold |= input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        _out -= left;\n        strm.total_out += _out;\n        state.total += _out;\n        if (_out) {\n          strm.adler = state.check =\n              /*UPDATE(state.check, put - _out, _out);*/\n              (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));\n\n        }\n        _out = left;\n        // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too\n        if ((state.flags ? hold : zswap32(hold)) !== state.check) {\n          strm.msg = 'incorrect data check';\n          state.mode = BAD;\n          break;\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        //Tracev((stderr, \"inflate:   check matches trailer\\n\"));\n      }\n      state.mode = LENGTH;\n      /* falls through */\n    case LENGTH:\n      if (state.wrap && state.flags) {\n        //=== NEEDBITS(32);\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if (hold !== (state.total & 0xffffffff)) {\n          strm.msg = 'incorrect length check';\n          state.mode = BAD;\n          break;\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        //Tracev((stderr, \"inflate:   length matches trailer\\n\"));\n      }\n      state.mode = DONE;\n      /* falls through */\n    case DONE:\n      ret = Z_STREAM_END;\n      break inf_leave;\n    case BAD:\n      ret = Z_DATA_ERROR;\n      break inf_leave;\n    case MEM:\n      return Z_MEM_ERROR;\n    case SYNC:\n      /* falls through */\n    default:\n      return Z_STREAM_ERROR;\n    }\n  }\n\n  // inf_leave <- here is real place for \"goto inf_leave\", emulated via \"break inf_leave\"\n\n  /*\n     Return from inflate(), updating the total counts and the check value.\n     If there was no progress during the inflate() call, return a buffer\n     error.  Call updatewindow() to create and/or update the window state.\n     Note: a memory error from inflate() is non-recoverable.\n   */\n\n  //--- RESTORE() ---\n  strm.next_out = put;\n  strm.avail_out = left;\n  strm.next_in = next;\n  strm.avail_in = have;\n  state.hold = hold;\n  state.bits = bits;\n  //---\n\n  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&\n                      (state.mode < CHECK || flush !== Z_FINISH))) {\n    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {\n      state.mode = MEM;\n      return Z_MEM_ERROR;\n    }\n  }\n  _in -= strm.avail_in;\n  _out -= strm.avail_out;\n  strm.total_in += _in;\n  strm.total_out += _out;\n  state.total += _out;\n  if (state.wrap && _out) {\n    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/\n      (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));\n  }\n  strm.data_type = state.bits + (state.last ? 64 : 0) +\n                    (state.mode === TYPE ? 128 : 0) +\n                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);\n  if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {\n    ret = Z_BUF_ERROR;\n  }\n  return ret;\n}\n\nfunction inflateEnd(strm) {\n\n  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  var state = strm.state;\n  if (state.window) {\n    state.window = null;\n  }\n  strm.state = null;\n  return Z_OK;\n}\n\nfunction inflateGetHeader(strm, head) {\n  var state;\n\n  /* check state */\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }\n\n  /* save header structure */\n  state.head = head;\n  head.done = false;\n  return Z_OK;\n}\n\nfunction inflateSetDictionary(strm, dictionary) {\n  var dictLength = dictionary.length;\n\n  var state;\n  var dictid;\n  var ret;\n\n  /* check state */\n  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR; }\n  state = strm.state;\n\n  if (state.wrap !== 0 && state.mode !== DICT) {\n    return Z_STREAM_ERROR;\n  }\n\n  /* check for correct dictionary identifier */\n  if (state.mode === DICT) {\n    dictid = 1; /* adler32(0, null, 0)*/\n    /* dictid = adler32(dictid, dictionary, dictLength); */\n    dictid = adler32(dictid, dictionary, dictLength, 0);\n    if (dictid !== state.check) {\n      return Z_DATA_ERROR;\n    }\n  }\n  /* copy dictionary to window using updatewindow(), which will amend the\n   existing dictionary if appropriate */\n  ret = updatewindow(strm, dictionary, dictLength, dictLength);\n  if (ret) {\n    state.mode = MEM;\n    return Z_MEM_ERROR;\n  }\n  state.havedict = 1;\n  // Tracev((stderr, \"inflate:   dictionary set\\n\"));\n  return Z_OK;\n}\n\nexports.inflateReset = inflateReset;\nexports.inflateReset2 = inflateReset2;\nexports.inflateResetKeep = inflateResetKeep;\nexports.inflateInit = inflateInit;\nexports.inflateInit2 = inflateInit2;\nexports.inflate = inflate;\nexports.inflateEnd = inflateEnd;\nexports.inflateGetHeader = inflateGetHeader;\nexports.inflateSetDictionary = inflateSetDictionary;\nexports.inflateInfo = 'pako inflate (from Nodeca project)';\n\n/* Not implemented\nexports.inflateCopy = inflateCopy;\nexports.inflateGetDictionary = inflateGetDictionary;\nexports.inflateMark = inflateMark;\nexports.inflatePrime = inflatePrime;\nexports.inflateSync = inflateSync;\nexports.inflateSyncPoint = inflateSyncPoint;\nexports.inflateUndermine = inflateUndermine;\n*/\n\n\n//# sourceURL=webpack://platypus/./node_modules/pako/lib/zlib/inflate.js?");

/***/ }),

/***/ "./node_modules/pako/lib/zlib/inftrees.js":
/*!************************************************!*\
  !*** ./node_modules/pako/lib/zlib/inftrees.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\nvar utils = __webpack_require__(/*! ../utils/common */ \"./node_modules/pako/lib/utils/common.js\");\n\nvar MAXBITS = 15;\nvar ENOUGH_LENS = 852;\nvar ENOUGH_DISTS = 592;\n//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);\n\nvar CODES = 0;\nvar LENS = 1;\nvar DISTS = 2;\n\nvar lbase = [ /* Length codes 257..285 base */\n  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0\n];\n\nvar lext = [ /* Length codes 257..285 extra */\n  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,\n  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78\n];\n\nvar dbase = [ /* Distance codes 0..29 base */\n  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n  8193, 12289, 16385, 24577, 0, 0\n];\n\nvar dext = [ /* Distance codes 0..29 extra */\n  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,\n  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,\n  28, 28, 29, 29, 64, 64\n];\n\nmodule.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts)\n{\n  var bits = opts.bits;\n      //here = opts.here; /* table entry for duplication */\n\n  var len = 0;               /* a code's length in bits */\n  var sym = 0;               /* index of code symbols */\n  var min = 0, max = 0;          /* minimum and maximum code lengths */\n  var root = 0;              /* number of index bits for root table */\n  var curr = 0;              /* number of index bits for current table */\n  var drop = 0;              /* code bits to drop for sub-table */\n  var left = 0;                   /* number of prefix codes available */\n  var used = 0;              /* code entries in table used */\n  var huff = 0;              /* Huffman code */\n  var incr;              /* for incrementing code, index */\n  var fill;              /* index for replicating entries */\n  var low;               /* low bits for current root entry */\n  var mask;              /* mask for low root bits */\n  var next;             /* next available space in table */\n  var base = null;     /* base value table to use */\n  var base_index = 0;\n//  var shoextra;    /* extra bits table to use */\n  var end;                    /* use base and extra for symbol > end */\n  var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */\n  var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */\n  var extra = null;\n  var extra_index = 0;\n\n  var here_bits, here_op, here_val;\n\n  /*\n   Process a set of code lengths to create a canonical Huffman code.  The\n   code lengths are lens[0..codes-1].  Each length corresponds to the\n   symbols 0..codes-1.  The Huffman code is generated by first sorting the\n   symbols by length from short to long, and retaining the symbol order\n   for codes with equal lengths.  Then the code starts with all zero bits\n   for the first code of the shortest length, and the codes are integer\n   increments for the same length, and zeros are appended as the length\n   increases.  For the deflate format, these bits are stored backwards\n   from their more natural integer increment ordering, and so when the\n   decoding tables are built in the large loop below, the integer codes\n   are incremented backwards.\n\n   This routine assumes, but does not check, that all of the entries in\n   lens[] are in the range 0..MAXBITS.  The caller must assure this.\n   1..MAXBITS is interpreted as that code length.  zero means that that\n   symbol does not occur in this code.\n\n   The codes are sorted by computing a count of codes for each length,\n   creating from that a table of starting indices for each length in the\n   sorted table, and then entering the symbols in order in the sorted\n   table.  The sorted table is work[], with that space being provided by\n   the caller.\n\n   The length counts are used for other purposes as well, i.e. finding\n   the minimum and maximum length codes, determining if there are any\n   codes at all, checking for a valid set of lengths, and looking ahead\n   at length counts to determine sub-table sizes when building the\n   decoding tables.\n   */\n\n  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */\n  for (len = 0; len <= MAXBITS; len++) {\n    count[len] = 0;\n  }\n  for (sym = 0; sym < codes; sym++) {\n    count[lens[lens_index + sym]]++;\n  }\n\n  /* bound code lengths, force root to be within code lengths */\n  root = bits;\n  for (max = MAXBITS; max >= 1; max--) {\n    if (count[max] !== 0) { break; }\n  }\n  if (root > max) {\n    root = max;\n  }\n  if (max === 0) {                     /* no symbols to code at all */\n    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */\n    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;\n    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;\n    table[table_index++] = (1 << 24) | (64 << 16) | 0;\n\n\n    //table.op[opts.table_index] = 64;\n    //table.bits[opts.table_index] = 1;\n    //table.val[opts.table_index++] = 0;\n    table[table_index++] = (1 << 24) | (64 << 16) | 0;\n\n    opts.bits = 1;\n    return 0;     /* no symbols, but wait for decoding to report error */\n  }\n  for (min = 1; min < max; min++) {\n    if (count[min] !== 0) { break; }\n  }\n  if (root < min) {\n    root = min;\n  }\n\n  /* check for an over-subscribed or incomplete set of lengths */\n  left = 1;\n  for (len = 1; len <= MAXBITS; len++) {\n    left <<= 1;\n    left -= count[len];\n    if (left < 0) {\n      return -1;\n    }        /* over-subscribed */\n  }\n  if (left > 0 && (type === CODES || max !== 1)) {\n    return -1;                      /* incomplete set */\n  }\n\n  /* generate offsets into symbol table for each length for sorting */\n  offs[1] = 0;\n  for (len = 1; len < MAXBITS; len++) {\n    offs[len + 1] = offs[len] + count[len];\n  }\n\n  /* sort symbols by length, by symbol order within each length */\n  for (sym = 0; sym < codes; sym++) {\n    if (lens[lens_index + sym] !== 0) {\n      work[offs[lens[lens_index + sym]]++] = sym;\n    }\n  }\n\n  /*\n   Create and fill in decoding tables.  In this loop, the table being\n   filled is at next and has curr index bits.  The code being used is huff\n   with length len.  That code is converted to an index by dropping drop\n   bits off of the bottom.  For codes where len is less than drop + curr,\n   those top drop + curr - len bits are incremented through all values to\n   fill the table with replicated entries.\n\n   root is the number of index bits for the root table.  When len exceeds\n   root, sub-tables are created pointed to by the root entry with an index\n   of the low root bits of huff.  This is saved in low to check for when a\n   new sub-table should be started.  drop is zero when the root table is\n   being filled, and drop is root when sub-tables are being filled.\n\n   When a new sub-table is needed, it is necessary to look ahead in the\n   code lengths to determine what size sub-table is needed.  The length\n   counts are used for this, and so count[] is decremented as codes are\n   entered in the tables.\n\n   used keeps track of how many table entries have been allocated from the\n   provided *table space.  It is checked for LENS and DIST tables against\n   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in\n   the initial root table size constants.  See the comments in inftrees.h\n   for more information.\n\n   sym increments through all symbols, and the loop terminates when\n   all codes of length max, i.e. all codes, have been processed.  This\n   routine permits incomplete codes, so another loop after this one fills\n   in the rest of the decoding tables with invalid code markers.\n   */\n\n  /* set up for code type */\n  // poor man optimization - use if-else instead of switch,\n  // to avoid deopts in old v8\n  if (type === CODES) {\n    base = extra = work;    /* dummy value--not used */\n    end = 19;\n\n  } else if (type === LENS) {\n    base = lbase;\n    base_index -= 257;\n    extra = lext;\n    extra_index -= 257;\n    end = 256;\n\n  } else {                    /* DISTS */\n    base = dbase;\n    extra = dext;\n    end = -1;\n  }\n\n  /* initialize opts for loop */\n  huff = 0;                   /* starting code */\n  sym = 0;                    /* starting code symbol */\n  len = min;                  /* starting code length */\n  next = table_index;              /* current table to fill in */\n  curr = root;                /* current table index bits */\n  drop = 0;                   /* current bits to drop from code for index */\n  low = -1;                   /* trigger new sub-table when len > root */\n  used = 1 << root;          /* use root table entries */\n  mask = used - 1;            /* mask for comparing low */\n\n  /* check available table space */\n  if ((type === LENS && used > ENOUGH_LENS) ||\n    (type === DISTS && used > ENOUGH_DISTS)) {\n    return 1;\n  }\n\n  var i = 0;\n  /* process all codes and make table entries */\n  for (;;) {\n    i++;\n    /* create table entry */\n    here_bits = len - drop;\n    if (work[sym] < end) {\n      here_op = 0;\n      here_val = work[sym];\n    }\n    else if (work[sym] > end) {\n      here_op = extra[extra_index + work[sym]];\n      here_val = base[base_index + work[sym]];\n    }\n    else {\n      here_op = 32 + 64;         /* end of block */\n      here_val = 0;\n    }\n\n    /* replicate for those indices with low len bits equal to huff */\n    incr = 1 << (len - drop);\n    fill = 1 << curr;\n    min = fill;                 /* save offset to next table */\n    do {\n      fill -= incr;\n      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;\n    } while (fill !== 0);\n\n    /* backwards increment the len-bit code huff */\n    incr = 1 << (len - 1);\n    while (huff & incr) {\n      incr >>= 1;\n    }\n    if (incr !== 0) {\n      huff &= incr - 1;\n      huff += incr;\n    } else {\n      huff = 0;\n    }\n\n    /* go to next symbol, update count, len */\n    sym++;\n    if (--count[len] === 0) {\n      if (len === max) { break; }\n      len = lens[lens_index + work[sym]];\n    }\n\n    /* create new sub-table if needed */\n    if (len > root && (huff & mask) !== low) {\n      /* if first time, transition to sub-tables */\n      if (drop === 0) {\n        drop = root;\n      }\n\n      /* increment past last table */\n      next += min;            /* here min is 1 << curr */\n\n      /* determine length of next table */\n      curr = len - drop;\n      left = 1 << curr;\n      while (curr + drop < max) {\n        left -= count[curr + drop];\n        if (left <= 0) { break; }\n        curr++;\n        left <<= 1;\n      }\n\n      /* check for enough space */\n      used += 1 << curr;\n      if ((type === LENS && used > ENOUGH_LENS) ||\n        (type === DISTS && used > ENOUGH_DISTS)) {\n        return 1;\n      }\n\n      /* point entry in root table to sub-table */\n      low = huff & mask;\n      /*table.op[low] = curr;\n      table.bits[low] = root;\n      table.val[low] = next - opts.table_index;*/\n      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;\n    }\n  }\n\n  /* fill in remaining table entry if code is incomplete (guaranteed to have\n   at most one remaining entry, since if the code is incomplete, the\n   maximum code length that was allowed to get this far is one bit) */\n  if (huff !== 0) {\n    //table.op[next + huff] = 64;            /* invalid code marker */\n    //table.bits[next + huff] = len - drop;\n    //table.val[next + huff] = 0;\n    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;\n  }\n\n  /* set return parameters */\n  //opts.table_index += used;\n  opts.bits = root;\n  return 0;\n};\n\n\n//# sourceURL=webpack://platypus/./node_modules/pako/lib/zlib/inftrees.js?");

/***/ }),

/***/ "./node_modules/pako/lib/zlib/messages.js":
/*!************************************************!*\
  !*** ./node_modules/pako/lib/zlib/messages.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = {\n  2:      'need dictionary',     /* Z_NEED_DICT       2  */\n  1:      'stream end',          /* Z_STREAM_END      1  */\n  0:      '',                    /* Z_OK              0  */\n  '-1':   'file error',          /* Z_ERRNO         (-1) */\n  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */\n  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */\n  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */\n  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */\n  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */\n};\n\n\n//# sourceURL=webpack://platypus/./node_modules/pako/lib/zlib/messages.js?");

/***/ }),

/***/ "./node_modules/pako/lib/zlib/trees.js":
/*!*********************************************!*\
  !*** ./node_modules/pako/lib/zlib/trees.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\nvar utils = __webpack_require__(/*! ../utils/common */ \"./node_modules/pako/lib/utils/common.js\");\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n//var Z_FILTERED          = 1;\n//var Z_HUFFMAN_ONLY      = 2;\n//var Z_RLE               = 3;\nvar Z_FIXED               = 4;\n//var Z_DEFAULT_STRATEGY  = 0;\n\n/* Possible values of the data_type field (though see inflate()) */\nvar Z_BINARY              = 0;\nvar Z_TEXT                = 1;\n//var Z_ASCII             = 1; // = Z_TEXT\nvar Z_UNKNOWN             = 2;\n\n/*============================================================================*/\n\n\nfunction zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\n// From zutil.h\n\nvar STORED_BLOCK = 0;\nvar STATIC_TREES = 1;\nvar DYN_TREES    = 2;\n/* The three kinds of block type */\n\nvar MIN_MATCH    = 3;\nvar MAX_MATCH    = 258;\n/* The minimum and maximum match lengths */\n\n// From deflate.h\n/* ===========================================================================\n * Internal compression state.\n */\n\nvar LENGTH_CODES  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\n\nvar LITERALS      = 256;\n/* number of literal bytes 0..255 */\n\nvar L_CODES       = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\n\nvar D_CODES       = 30;\n/* number of distance codes */\n\nvar BL_CODES      = 19;\n/* number of codes used to transfer the bit lengths */\n\nvar HEAP_SIZE     = 2 * L_CODES + 1;\n/* maximum heap size */\n\nvar MAX_BITS      = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nvar Buf_size      = 16;\n/* size of bit buffer in bi_buf */\n\n\n/* ===========================================================================\n * Constants\n */\n\nvar MAX_BL_BITS = 7;\n/* Bit length codes must not exceed MAX_BL_BITS bits */\n\nvar END_BLOCK   = 256;\n/* end of block literal code */\n\nvar REP_3_6     = 16;\n/* repeat previous bit length 3-6 times (2 bits of repeat count) */\n\nvar REPZ_3_10   = 17;\n/* repeat a zero length 3-10 times  (3 bits of repeat count) */\n\nvar REPZ_11_138 = 18;\n/* repeat a zero length 11-138 times  (7 bits of repeat count) */\n\n/* eslint-disable comma-spacing,array-bracket-spacing */\nvar extra_lbits =   /* extra bits for each length code */\n  [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];\n\nvar extra_dbits =   /* extra bits for each distance code */\n  [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];\n\nvar extra_blbits =  /* extra bits for each bit length code */\n  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];\n\nvar bl_order =\n  [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];\n/* eslint-enable comma-spacing,array-bracket-spacing */\n\n/* The lengths of the bit length codes are sent in order of decreasing\n * probability, to avoid transmitting the lengths for unused bit length codes.\n */\n\n/* ===========================================================================\n * Local data. These are initialized only once.\n */\n\n// We pre-fill arrays with 0 to avoid uninitialized gaps\n\nvar DIST_CODE_LEN = 512; /* see definition of array dist_code below */\n\n// !!!! Use flat array insdead of structure, Freq = i*2, Len = i*2+1\nvar static_ltree  = new Array((L_CODES + 2) * 2);\nzero(static_ltree);\n/* The static literal tree. Since the bit lengths are imposed, there is no\n * need for the L_CODES extra codes used during heap construction. However\n * The codes 286 and 287 are needed to build a canonical tree (see _tr_init\n * below).\n */\n\nvar static_dtree  = new Array(D_CODES * 2);\nzero(static_dtree);\n/* The static distance tree. (Actually a trivial tree since all codes use\n * 5 bits.)\n */\n\nvar _dist_code    = new Array(DIST_CODE_LEN);\nzero(_dist_code);\n/* Distance codes. The first 256 values correspond to the distances\n * 3 .. 258, the last 256 values correspond to the top 8 bits of\n * the 15 bit distances.\n */\n\nvar _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);\nzero(_length_code);\n/* length code for each normalized match length (0 == MIN_MATCH) */\n\nvar base_length   = new Array(LENGTH_CODES);\nzero(base_length);\n/* First normalized length for each code (0 = MIN_MATCH) */\n\nvar base_dist     = new Array(D_CODES);\nzero(base_dist);\n/* First normalized distance for each code (0 = distance of 1) */\n\n\nfunction StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {\n\n  this.static_tree  = static_tree;  /* static tree or NULL */\n  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */\n  this.extra_base   = extra_base;   /* base index for extra_bits */\n  this.elems        = elems;        /* max number of elements in the tree */\n  this.max_length   = max_length;   /* max bit length for the codes */\n\n  // show if `static_tree` has data or dummy - needed for monomorphic objects\n  this.has_stree    = static_tree && static_tree.length;\n}\n\n\nvar static_l_desc;\nvar static_d_desc;\nvar static_bl_desc;\n\n\nfunction TreeDesc(dyn_tree, stat_desc) {\n  this.dyn_tree = dyn_tree;     /* the dynamic tree */\n  this.max_code = 0;            /* largest code with non zero frequency */\n  this.stat_desc = stat_desc;   /* the corresponding static tree */\n}\n\n\n\nfunction d_code(dist) {\n  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];\n}\n\n\n/* ===========================================================================\n * Output a short LSB first on the stream.\n * IN assertion: there is enough room in pendingBuf.\n */\nfunction put_short(s, w) {\n//    put_byte(s, (uch)((w) & 0xff));\n//    put_byte(s, (uch)((ush)(w) >> 8));\n  s.pending_buf[s.pending++] = (w) & 0xff;\n  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;\n}\n\n\n/* ===========================================================================\n * Send a value on a given number of bits.\n * IN assertion: length <= 16 and value fits in length bits.\n */\nfunction send_bits(s, value, length) {\n  if (s.bi_valid > (Buf_size - length)) {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    put_short(s, s.bi_buf);\n    s.bi_buf = value >> (Buf_size - s.bi_valid);\n    s.bi_valid += length - Buf_size;\n  } else {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    s.bi_valid += length;\n  }\n}\n\n\nfunction send_code(s, c, tree) {\n  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);\n}\n\n\n/* ===========================================================================\n * Reverse the first len bits of a code, using straightforward code (a faster\n * method would use a table)\n * IN assertion: 1 <= len <= 15\n */\nfunction bi_reverse(code, len) {\n  var res = 0;\n  do {\n    res |= code & 1;\n    code >>>= 1;\n    res <<= 1;\n  } while (--len > 0);\n  return res >>> 1;\n}\n\n\n/* ===========================================================================\n * Flush the bit buffer, keeping at most 7 bits in it.\n */\nfunction bi_flush(s) {\n  if (s.bi_valid === 16) {\n    put_short(s, s.bi_buf);\n    s.bi_buf = 0;\n    s.bi_valid = 0;\n\n  } else if (s.bi_valid >= 8) {\n    s.pending_buf[s.pending++] = s.bi_buf & 0xff;\n    s.bi_buf >>= 8;\n    s.bi_valid -= 8;\n  }\n}\n\n\n/* ===========================================================================\n * Compute the optimal bit lengths for a tree and update the total bit length\n * for the current block.\n * IN assertion: the fields freq and dad are set, heap[heap_max] and\n *    above are the tree nodes sorted by increasing frequency.\n * OUT assertions: the field len is set to the optimal bit length, the\n *     array bl_count contains the frequencies for each bit length.\n *     The length opt_len is updated; static_len is also updated if stree is\n *     not null.\n */\nfunction gen_bitlen(s, desc)\n//    deflate_state *s;\n//    tree_desc *desc;    /* the tree descriptor */\n{\n  var tree            = desc.dyn_tree;\n  var max_code        = desc.max_code;\n  var stree           = desc.stat_desc.static_tree;\n  var has_stree       = desc.stat_desc.has_stree;\n  var extra           = desc.stat_desc.extra_bits;\n  var base            = desc.stat_desc.extra_base;\n  var max_length      = desc.stat_desc.max_length;\n  var h;              /* heap index */\n  var n, m;           /* iterate over the tree elements */\n  var bits;           /* bit length */\n  var xbits;          /* extra bits */\n  var f;              /* frequency */\n  var overflow = 0;   /* number of elements with bit length too large */\n\n  for (bits = 0; bits <= MAX_BITS; bits++) {\n    s.bl_count[bits] = 0;\n  }\n\n  /* In a first pass, compute the optimal bit lengths (which may\n   * overflow in the case of the bit length tree).\n   */\n  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */\n\n  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {\n    n = s.heap[h];\n    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;\n    if (bits > max_length) {\n      bits = max_length;\n      overflow++;\n    }\n    tree[n * 2 + 1]/*.Len*/ = bits;\n    /* We overwrite tree[n].Dad which is no longer needed */\n\n    if (n > max_code) { continue; } /* not a leaf node */\n\n    s.bl_count[bits]++;\n    xbits = 0;\n    if (n >= base) {\n      xbits = extra[n - base];\n    }\n    f = tree[n * 2]/*.Freq*/;\n    s.opt_len += f * (bits + xbits);\n    if (has_stree) {\n      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);\n    }\n  }\n  if (overflow === 0) { return; }\n\n  // Trace((stderr,\"\\nbit length overflow\\n\"));\n  /* This happens for example on obj2 and pic of the Calgary corpus */\n\n  /* Find the first bit length which could increase: */\n  do {\n    bits = max_length - 1;\n    while (s.bl_count[bits] === 0) { bits--; }\n    s.bl_count[bits]--;      /* move one leaf down the tree */\n    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */\n    s.bl_count[max_length]--;\n    /* The brother of the overflow item also moves one step up,\n     * but this does not affect bl_count[max_length]\n     */\n    overflow -= 2;\n  } while (overflow > 0);\n\n  /* Now recompute all bit lengths, scanning in increasing frequency.\n   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n   * lengths instead of fixing only the wrong ones. This idea is taken\n   * from 'ar' written by Haruhiko Okumura.)\n   */\n  for (bits = max_length; bits !== 0; bits--) {\n    n = s.bl_count[bits];\n    while (n !== 0) {\n      m = s.heap[--h];\n      if (m > max_code) { continue; }\n      if (tree[m * 2 + 1]/*.Len*/ !== bits) {\n        // Trace((stderr,\"code %d bits %d->%d\\n\", m, tree[m].Len, bits));\n        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;\n        tree[m * 2 + 1]/*.Len*/ = bits;\n      }\n      n--;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Generate the codes for a given tree and bit counts (which need not be\n * optimal).\n * IN assertion: the array bl_count contains the bit length statistics for\n * the given tree and the field len is set for all tree elements.\n * OUT assertion: the field code is set for all tree elements of non\n *     zero code length.\n */\nfunction gen_codes(tree, max_code, bl_count)\n//    ct_data *tree;             /* the tree to decorate */\n//    int max_code;              /* largest code with non zero frequency */\n//    ushf *bl_count;            /* number of codes at each bit length */\n{\n  var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */\n  var code = 0;              /* running code value */\n  var bits;                  /* bit index */\n  var n;                     /* code index */\n\n  /* The distribution counts are first used to generate the code values\n   * without bit reversal.\n   */\n  for (bits = 1; bits <= MAX_BITS; bits++) {\n    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;\n  }\n  /* Check that the bit counts in bl_count are consistent. The last code\n   * must be all ones.\n   */\n  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n  //        \"inconsistent bit counts\");\n  //Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n\n  for (n = 0;  n <= max_code; n++) {\n    var len = tree[n * 2 + 1]/*.Len*/;\n    if (len === 0) { continue; }\n    /* Now reverse the bits */\n    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);\n\n    //Tracecv(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));\n  }\n}\n\n\n/* ===========================================================================\n * Initialize the various 'constant' tables.\n */\nfunction tr_static_init() {\n  var n;        /* iterates over tree elements */\n  var bits;     /* bit counter */\n  var length;   /* length value */\n  var code;     /* code value */\n  var dist;     /* distance index */\n  var bl_count = new Array(MAX_BITS + 1);\n  /* number of codes at each bit length for an optimal tree */\n\n  // do check in _tr_init()\n  //if (static_init_done) return;\n\n  /* For some embedded targets, global variables are not initialized: */\n/*#ifdef NO_INIT_GLOBAL_POINTERS\n  static_l_desc.static_tree = static_ltree;\n  static_l_desc.extra_bits = extra_lbits;\n  static_d_desc.static_tree = static_dtree;\n  static_d_desc.extra_bits = extra_dbits;\n  static_bl_desc.extra_bits = extra_blbits;\n#endif*/\n\n  /* Initialize the mapping length (0..255) -> length code (0..28) */\n  length = 0;\n  for (code = 0; code < LENGTH_CODES - 1; code++) {\n    base_length[code] = length;\n    for (n = 0; n < (1 << extra_lbits[code]); n++) {\n      _length_code[length++] = code;\n    }\n  }\n  //Assert (length == 256, \"tr_static_init: length != 256\");\n  /* Note that the length 255 (match length 258) can be represented\n   * in two different ways: code 284 + 5 bits or code 285, so we\n   * overwrite length_code[255] to use the best encoding:\n   */\n  _length_code[length - 1] = code;\n\n  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n  dist = 0;\n  for (code = 0; code < 16; code++) {\n    base_dist[code] = dist;\n    for (n = 0; n < (1 << extra_dbits[code]); n++) {\n      _dist_code[dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: dist != 256\");\n  dist >>= 7; /* from now on, all distances are divided by 128 */\n  for (; code < D_CODES; code++) {\n    base_dist[code] = dist << 7;\n    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {\n      _dist_code[256 + dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n\n  /* Construct the codes of the static literal tree */\n  for (bits = 0; bits <= MAX_BITS; bits++) {\n    bl_count[bits] = 0;\n  }\n\n  n = 0;\n  while (n <= 143) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  while (n <= 255) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 9;\n    n++;\n    bl_count[9]++;\n  }\n  while (n <= 279) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 7;\n    n++;\n    bl_count[7]++;\n  }\n  while (n <= 287) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  /* Codes 286 and 287 do not exist, but we must include them in the\n   * tree construction to get a canonical Huffman tree (longest code\n   * all ones)\n   */\n  gen_codes(static_ltree, L_CODES + 1, bl_count);\n\n  /* The static distance tree is trivial: */\n  for (n = 0; n < D_CODES; n++) {\n    static_dtree[n * 2 + 1]/*.Len*/ = 5;\n    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);\n  }\n\n  // Now data ready and we can init static trees\n  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);\n  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);\n  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);\n\n  //static_init_done = true;\n}\n\n\n/* ===========================================================================\n * Initialize a new block.\n */\nfunction init_block(s) {\n  var n; /* iterates over tree elements */\n\n  /* Initialize the trees. */\n  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }\n  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }\n  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }\n\n  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;\n  s.opt_len = s.static_len = 0;\n  s.last_lit = s.matches = 0;\n}\n\n\n/* ===========================================================================\n * Flush the bit buffer and align the output on a byte boundary\n */\nfunction bi_windup(s)\n{\n  if (s.bi_valid > 8) {\n    put_short(s, s.bi_buf);\n  } else if (s.bi_valid > 0) {\n    //put_byte(s, (Byte)s->bi_buf);\n    s.pending_buf[s.pending++] = s.bi_buf;\n  }\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n}\n\n/* ===========================================================================\n * Copy a stored block, storing first the length and its\n * one's complement if requested.\n */\nfunction copy_block(s, buf, len, header)\n//DeflateState *s;\n//charf    *buf;    /* the input data */\n//unsigned len;     /* its length */\n//int      header;  /* true if block header must be written */\n{\n  bi_windup(s);        /* align on byte boundary */\n\n  if (header) {\n    put_short(s, len);\n    put_short(s, ~len);\n  }\n//  while (len--) {\n//    put_byte(s, *buf++);\n//  }\n  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);\n  s.pending += len;\n}\n\n/* ===========================================================================\n * Compares to subtrees, using the tree depth as tie breaker when\n * the subtrees have equal frequency. This minimizes the worst case length.\n */\nfunction smaller(tree, n, m, depth) {\n  var _n2 = n * 2;\n  var _m2 = m * 2;\n  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||\n         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));\n}\n\n/* ===========================================================================\n * Restore the heap property by moving down the tree starting at node k,\n * exchanging a node with the smallest of its two sons if necessary, stopping\n * when the heap property is re-established (each father smaller than its\n * two sons).\n */\nfunction pqdownheap(s, tree, k)\n//    deflate_state *s;\n//    ct_data *tree;  /* the tree to restore */\n//    int k;               /* node to move down */\n{\n  var v = s.heap[k];\n  var j = k << 1;  /* left son of k */\n  while (j <= s.heap_len) {\n    /* Set j to the smallest of the two sons: */\n    if (j < s.heap_len &&\n      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {\n      j++;\n    }\n    /* Exit if v is smaller than both sons */\n    if (smaller(tree, v, s.heap[j], s.depth)) { break; }\n\n    /* Exchange v with the smallest son */\n    s.heap[k] = s.heap[j];\n    k = j;\n\n    /* And continue down the tree, setting j to the left son of k */\n    j <<= 1;\n  }\n  s.heap[k] = v;\n}\n\n\n// inlined manually\n// var SMALLEST = 1;\n\n/* ===========================================================================\n * Send the block data compressed using the given Huffman trees\n */\nfunction compress_block(s, ltree, dtree)\n//    deflate_state *s;\n//    const ct_data *ltree; /* literal tree */\n//    const ct_data *dtree; /* distance tree */\n{\n  var dist;           /* distance of matched string */\n  var lc;             /* match length or unmatched char (if dist == 0) */\n  var lx = 0;         /* running index in l_buf */\n  var code;           /* the code to send */\n  var extra;          /* number of extra bits to send */\n\n  if (s.last_lit !== 0) {\n    do {\n      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);\n      lc = s.pending_buf[s.l_buf + lx];\n      lx++;\n\n      if (dist === 0) {\n        send_code(s, lc, ltree); /* send a literal byte */\n        //Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n      } else {\n        /* Here, lc is the match length - MIN_MATCH */\n        code = _length_code[lc];\n        send_code(s, code + LITERALS + 1, ltree); /* send the length code */\n        extra = extra_lbits[code];\n        if (extra !== 0) {\n          lc -= base_length[code];\n          send_bits(s, lc, extra);       /* send the extra length bits */\n        }\n        dist--; /* dist is now the match distance - 1 */\n        code = d_code(dist);\n        //Assert (code < D_CODES, \"bad d_code\");\n\n        send_code(s, code, dtree);       /* send the distance code */\n        extra = extra_dbits[code];\n        if (extra !== 0) {\n          dist -= base_dist[code];\n          send_bits(s, dist, extra);   /* send the extra distance bits */\n        }\n      } /* literal or match pair ? */\n\n      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */\n      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,\n      //       \"pendingBuf overflow\");\n\n    } while (lx < s.last_lit);\n  }\n\n  send_code(s, END_BLOCK, ltree);\n}\n\n\n/* ===========================================================================\n * Construct one Huffman tree and assigns the code bit strings and lengths.\n * Update the total bit length for the current block.\n * IN assertion: the field freq is set for all tree elements.\n * OUT assertions: the fields len and code are set to the optimal bit length\n *     and corresponding code. The length opt_len is updated; static_len is\n *     also updated if stree is not null. The field max_code is set.\n */\nfunction build_tree(s, desc)\n//    deflate_state *s;\n//    tree_desc *desc; /* the tree descriptor */\n{\n  var tree     = desc.dyn_tree;\n  var stree    = desc.stat_desc.static_tree;\n  var has_stree = desc.stat_desc.has_stree;\n  var elems    = desc.stat_desc.elems;\n  var n, m;          /* iterate over heap elements */\n  var max_code = -1; /* largest code with non zero frequency */\n  var node;          /* new node being created */\n\n  /* Construct the initial heap, with least frequent element in\n   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n   * heap[0] is not used.\n   */\n  s.heap_len = 0;\n  s.heap_max = HEAP_SIZE;\n\n  for (n = 0; n < elems; n++) {\n    if (tree[n * 2]/*.Freq*/ !== 0) {\n      s.heap[++s.heap_len] = max_code = n;\n      s.depth[n] = 0;\n\n    } else {\n      tree[n * 2 + 1]/*.Len*/ = 0;\n    }\n  }\n\n  /* The pkzip format requires that at least one distance code exists,\n   * and that at least one bit should be sent even if there is only one\n   * possible code. So to avoid special checks later on we force at least\n   * two codes of non zero frequency.\n   */\n  while (s.heap_len < 2) {\n    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);\n    tree[node * 2]/*.Freq*/ = 1;\n    s.depth[node] = 0;\n    s.opt_len--;\n\n    if (has_stree) {\n      s.static_len -= stree[node * 2 + 1]/*.Len*/;\n    }\n    /* node is 0 or 1 so it does not have extra bits */\n  }\n  desc.max_code = max_code;\n\n  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n   * establish sub-heaps of increasing lengths:\n   */\n  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }\n\n  /* Construct the Huffman tree by repeatedly combining the least two\n   * frequent nodes.\n   */\n  node = elems;              /* next internal node of the tree */\n  do {\n    //pqremove(s, tree, n);  /* n = node of least frequency */\n    /*** pqremove ***/\n    n = s.heap[1/*SMALLEST*/];\n    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n    /***/\n\n    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */\n\n    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */\n    s.heap[--s.heap_max] = m;\n\n    /* Create a new node father of n and m */\n    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;\n    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;\n    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;\n\n    /* and insert the new node in the heap */\n    s.heap[1/*SMALLEST*/] = node++;\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n\n  } while (s.heap_len >= 2);\n\n  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];\n\n  /* At this point, the fields freq and dad are set. We can now\n   * generate the bit lengths.\n   */\n  gen_bitlen(s, desc);\n\n  /* The field len is now set, we can generate the bit codes */\n  gen_codes(tree, max_code, s.bl_count);\n}\n\n\n/* ===========================================================================\n * Scan a literal or distance tree to determine the frequencies of the codes\n * in the bit length tree.\n */\nfunction scan_tree(s, tree, max_code)\n//    deflate_state *s;\n//    ct_data *tree;   /* the tree to be scanned */\n//    int max_code;    /* and its largest code of non zero frequency */\n{\n  var n;                     /* iterates over all tree elements */\n  var prevlen = -1;          /* last emitted length */\n  var curlen;                /* length of current code */\n\n  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n  var count = 0;             /* repeat count of the current code */\n  var max_count = 7;         /* max repeat count */\n  var min_count = 4;         /* min repeat count */\n\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      s.bl_tree[curlen * 2]/*.Freq*/ += count;\n\n    } else if (curlen !== 0) {\n\n      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }\n      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;\n\n    } else if (count <= 10) {\n      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;\n\n    } else {\n      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;\n    }\n\n    count = 0;\n    prevlen = curlen;\n\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Send a literal or distance tree in compressed form, using the codes in\n * bl_tree.\n */\nfunction send_tree(s, tree, max_code)\n//    deflate_state *s;\n//    ct_data *tree; /* the tree to be scanned */\n//    int max_code;       /* and its largest code of non zero frequency */\n{\n  var n;                     /* iterates over all tree elements */\n  var prevlen = -1;          /* last emitted length */\n  var curlen;                /* length of current code */\n\n  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n  var count = 0;             /* repeat count of the current code */\n  var max_count = 7;         /* max repeat count */\n  var min_count = 4;         /* min repeat count */\n\n  /* tree[max_code+1].Len = -1; */  /* guard already set */\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);\n\n    } else if (curlen !== 0) {\n      if (curlen !== prevlen) {\n        send_code(s, curlen, s.bl_tree);\n        count--;\n      }\n      //Assert(count >= 3 && count <= 6, \" 3_6?\");\n      send_code(s, REP_3_6, s.bl_tree);\n      send_bits(s, count - 3, 2);\n\n    } else if (count <= 10) {\n      send_code(s, REPZ_3_10, s.bl_tree);\n      send_bits(s, count - 3, 3);\n\n    } else {\n      send_code(s, REPZ_11_138, s.bl_tree);\n      send_bits(s, count - 11, 7);\n    }\n\n    count = 0;\n    prevlen = curlen;\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Construct the Huffman tree for the bit lengths and return the index in\n * bl_order of the last bit length code to send.\n */\nfunction build_bl_tree(s) {\n  var max_blindex;  /* index of last bit length code of non zero freq */\n\n  /* Determine the bit length frequencies for literal and distance trees */\n  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);\n  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);\n\n  /* Build the bit length tree: */\n  build_tree(s, s.bl_desc);\n  /* opt_len now includes the length of the tree representations, except\n   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n   */\n\n  /* Determine the number of bit length codes to send. The pkzip format\n   * requires that at least 4 bit length codes be sent. (appnote.txt says\n   * 3 but the actual value used is 4.)\n   */\n  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {\n    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {\n      break;\n    }\n  }\n  /* Update opt_len to include the bit length tree and counts */\n  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;\n  //Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n  //        s->opt_len, s->static_len));\n\n  return max_blindex;\n}\n\n\n/* ===========================================================================\n * Send the header for a block using dynamic Huffman trees: the counts, the\n * lengths of the bit length codes, the literal tree and the distance tree.\n * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n */\nfunction send_all_trees(s, lcodes, dcodes, blcodes)\n//    deflate_state *s;\n//    int lcodes, dcodes, blcodes; /* number of codes for each tree */\n{\n  var rank;                    /* index in bl_order */\n\n  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n  //        \"too many codes\");\n  //Tracev((stderr, \"\\nbl counts: \"));\n  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */\n  send_bits(s, dcodes - 1,   5);\n  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */\n  for (rank = 0; rank < blcodes; rank++) {\n    //Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);\n  }\n  //Tracev((stderr, \"\\nbl tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */\n  //Tracev((stderr, \"\\nlit tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */\n  //Tracev((stderr, \"\\ndist tree: sent %ld\", s->bits_sent));\n}\n\n\n/* ===========================================================================\n * Check if the data type is TEXT or BINARY, using the following algorithm:\n * - TEXT if the two conditions below are satisfied:\n *    a) There are no non-portable control characters belonging to the\n *       \"black list\" (0..6, 14..25, 28..31).\n *    b) There is at least one printable character belonging to the\n *       \"white list\" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\n * - BINARY otherwise.\n * - The following partially-portable control characters form a\n *   \"gray list\" that is ignored in this detection algorithm:\n *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\n * IN assertion: the fields Freq of dyn_ltree are set.\n */\nfunction detect_data_type(s) {\n  /* black_mask is the bit mask of black-listed bytes\n   * set bits 0..6, 14..25, and 28..31\n   * 0xf3ffc07f = binary 11110011111111111100000001111111\n   */\n  var black_mask = 0xf3ffc07f;\n  var n;\n\n  /* Check for non-textual (\"black-listed\") bytes. */\n  for (n = 0; n <= 31; n++, black_mask >>>= 1) {\n    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {\n      return Z_BINARY;\n    }\n  }\n\n  /* Check for textual (\"white-listed\") bytes. */\n  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||\n      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {\n    return Z_TEXT;\n  }\n  for (n = 32; n < LITERALS; n++) {\n    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {\n      return Z_TEXT;\n    }\n  }\n\n  /* There are no \"black-listed\" or \"white-listed\" bytes:\n   * this stream either is empty or has tolerated (\"gray-listed\") bytes only.\n   */\n  return Z_BINARY;\n}\n\n\nvar static_init_done = false;\n\n/* ===========================================================================\n * Initialize the tree data structures for a new zlib stream.\n */\nfunction _tr_init(s)\n{\n\n  if (!static_init_done) {\n    tr_static_init();\n    static_init_done = true;\n  }\n\n  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);\n  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);\n  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);\n\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n\n  /* Initialize the first block of the first file: */\n  init_block(s);\n}\n\n\n/* ===========================================================================\n * Send a stored block\n */\nfunction _tr_stored_block(s, buf, stored_len, last)\n//DeflateState *s;\n//charf *buf;       /* input block */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */\n  copy_block(s, buf, stored_len, true); /* with header */\n}\n\n\n/* ===========================================================================\n * Send one empty static block to give enough lookahead for inflate.\n * This takes 10 bits, of which 7 may remain in the bit buffer.\n */\nfunction _tr_align(s) {\n  send_bits(s, STATIC_TREES << 1, 3);\n  send_code(s, END_BLOCK, static_ltree);\n  bi_flush(s);\n}\n\n\n/* ===========================================================================\n * Determine the best encoding for the current block: dynamic trees, static\n * trees or store, and output the encoded block to the zip file.\n */\nfunction _tr_flush_block(s, buf, stored_len, last)\n//DeflateState *s;\n//charf *buf;       /* input block, or NULL if too old */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n  var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */\n  var max_blindex = 0;        /* index of last bit length code of non zero freq */\n\n  /* Build the Huffman trees unless a stored block is forced */\n  if (s.level > 0) {\n\n    /* Check if the file is binary or text */\n    if (s.strm.data_type === Z_UNKNOWN) {\n      s.strm.data_type = detect_data_type(s);\n    }\n\n    /* Construct the literal and distance trees */\n    build_tree(s, s.l_desc);\n    // Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n\n    build_tree(s, s.d_desc);\n    // Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n    /* At this point, opt_len and static_len are the total bit lengths of\n     * the compressed block data, excluding the tree representations.\n     */\n\n    /* Build the bit length tree for the above two trees, and get the index\n     * in bl_order of the last bit length code to send.\n     */\n    max_blindex = build_bl_tree(s);\n\n    /* Determine the best encoding. Compute the block lengths in bytes. */\n    opt_lenb = (s.opt_len + 3 + 7) >>> 3;\n    static_lenb = (s.static_len + 3 + 7) >>> 3;\n\n    // Tracev((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u \",\n    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\n    //        s->last_lit));\n\n    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }\n\n  } else {\n    // Assert(buf != (char*)0, \"lost buf\");\n    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */\n  }\n\n  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {\n    /* 4: two words for the lengths */\n\n    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n     * Otherwise we can't have processed more than WSIZE input bytes since\n     * the last block flush, because compression would have been\n     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n     * transform a block into a stored block.\n     */\n    _tr_stored_block(s, buf, stored_len, last);\n\n  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {\n\n    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);\n    compress_block(s, static_ltree, static_dtree);\n\n  } else {\n    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);\n    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);\n    compress_block(s, s.dyn_ltree, s.dyn_dtree);\n  }\n  // Assert (s->compressed_len == s->bits_sent, \"bad compressed size\");\n  /* The above check is made mod 2^32, for files larger than 512 MB\n   * and uLong implemented on 32 bits.\n   */\n  init_block(s);\n\n  if (last) {\n    bi_windup(s);\n  }\n  // Tracev((stderr,\"\\ncomprlen %lu(%lu) \", s->compressed_len>>3,\n  //       s->compressed_len-7*last));\n}\n\n/* ===========================================================================\n * Save the match info and tally the frequency counts. Return true if\n * the current block must be flushed.\n */\nfunction _tr_tally(s, dist, lc)\n//    deflate_state *s;\n//    unsigned dist;  /* distance of matched string */\n//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */\n{\n  //var out_length, in_length, dcode;\n\n  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;\n  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;\n\n  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;\n  s.last_lit++;\n\n  if (dist === 0) {\n    /* lc is the unmatched char */\n    s.dyn_ltree[lc * 2]/*.Freq*/++;\n  } else {\n    s.matches++;\n    /* Here, lc is the match length - MIN_MATCH */\n    dist--;             /* dist = match distance - 1 */\n    //Assert((ush)dist < (ush)MAX_DIST(s) &&\n    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n    //       (ush)d_code(dist) < (ush)D_CODES,  \"_tr_tally: bad match\");\n\n    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;\n    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;\n  }\n\n// (!) This block is disabled in zlib defailts,\n// don't enable it for binary compatibility\n\n//#ifdef TRUNCATE_BLOCK\n//  /* Try to guess if it is profitable to stop the current block here */\n//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {\n//    /* Compute an upper bound for the compressed length */\n//    out_length = s.last_lit*8;\n//    in_length = s.strstart - s.block_start;\n//\n//    for (dcode = 0; dcode < D_CODES; dcode++) {\n//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);\n//    }\n//    out_length >>>= 3;\n//    //Tracev((stderr,\"\\nlast_lit %u, in %ld, out ~%ld(%ld%%) \",\n//    //       s->last_lit, in_length, out_length,\n//    //       100L - out_length*100L/in_length));\n//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {\n//      return true;\n//    }\n//  }\n//#endif\n\n  return (s.last_lit === s.lit_bufsize - 1);\n  /* We avoid equality with lit_bufsize because of wraparound at 64K\n   * on 16 bit machines and because stored blocks are restricted to\n   * 64K-1 bytes.\n   */\n}\n\nexports._tr_init  = _tr_init;\nexports._tr_stored_block = _tr_stored_block;\nexports._tr_flush_block  = _tr_flush_block;\nexports._tr_tally = _tr_tally;\nexports._tr_align = _tr_align;\n\n\n//# sourceURL=webpack://platypus/./node_modules/pako/lib/zlib/trees.js?");

/***/ }),

/***/ "./node_modules/pako/lib/zlib/zstream.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/zstream.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\nfunction ZStream() {\n  /* next input byte */\n  this.input = null; // JS specific, because we have no pointers\n  this.next_in = 0;\n  /* number of bytes available at input */\n  this.avail_in = 0;\n  /* total number of input bytes read so far */\n  this.total_in = 0;\n  /* next output byte should be put there */\n  this.output = null; // JS specific, because we have no pointers\n  this.next_out = 0;\n  /* remaining free space at output */\n  this.avail_out = 0;\n  /* total number of bytes output so far */\n  this.total_out = 0;\n  /* last error message, NULL if no error */\n  this.msg = ''/*Z_NULL*/;\n  /* not visible by applications */\n  this.state = null;\n  /* best guess about the data type: binary or text */\n  this.data_type = 2/*Z_UNKNOWN*/;\n  /* adler32 value of the uncompressed data */\n  this.adler = 0;\n}\n\nmodule.exports = ZStream;\n\n\n//# sourceURL=webpack://platypus/./node_modules/pako/lib/zlib/zstream.js?");

/***/ }),

/***/ "./node_modules/recycle/recycle.js":
/*!*****************************************!*\
  !*** ./node_modules/recycle/recycle.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* global Array, console, Object */\n\nconst recycleProp = {\n        value: false,\n        writable: true\n    },\n    caches = {},\n    Container = function () {\n        this.contains = null;\n        this.previous = null;\n    };\n    \nlet containers = null; // link-list of cached, unused containers for caches.\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    add: function (ClassObject, name, setUp, tearDown, mixinMethods, debug) {\n        var isArray = (ClassObject === Array),\n            cache = null;\n\n        if (!name) {\n            console.warn('Recycle: Must define a name for this cache.');\n            return null;\n        }\n        \n        if (caches[name]) {\n            if (ClassObject !== caches[name].ClassObject) {\n                console.warn('Recycle: There is already a cache named \"' + name + '\" that is being used for another object type.');\n            }\n            return caches[name];\n        }\n        \n        cache = caches[name] = {\n            ClassObject: ClassObject,\n            list: null,\n            setUp: null,\n            recycle: null,\n            pop: isArray ? function () {\n                var list = this.list,\n                    item = null;\n\n                if (list) {\n                    this.list = list.previous;\n                    item = list.contains;\n                    list.previous = containers;\n                    containers = list;\n                    return item;\n                } else {\n                    return [];\n                }\n            } : function () {\n                var list = this.list,\n                    item = null;\n\n                if (list) {\n                    this.list = list.previous;\n                    item = list.contains;\n                    list.previous = containers;\n                    containers = list;\n                    return item;\n                } else {\n                    return Object.create(this.ClassObject.prototype);\n                }\n            },\n            push: function (item) {\n                var available = containers;\n\n                if (available) {\n                    containers = available.previous;\n                } else {\n                    available = Object.create(Container.prototype);\n                }\n\n                available.previous = this.list;\n                this.list = available;\n                available.contains = item;\n            },\n            getLength: function () {\n                var i = 0,\n                    item = this.list;\n\n                while (item) {\n                    i += 1;\n                    item = item.previous;\n                }\n\n                return i;\n            }\n        };\n\n        // Handle object instantiation\n        if (setUp) {\n            cache.setUp = function () {\n                var newObject = this.pop();\n\n                setUp.apply(newObject, arguments);\n\n                return newObject;\n            };\n        } else if (isArray) {\n            cache.setUp = function () {\n                var arr = this.pop(),\n                    i = 0;\n        \n                for (i = 0; i < arguments.length; i++) {\n                    arr[i] = arguments[i];\n                }\n\n                return arr;\n            };\n        } else {\n            cache.setUp = cache.pop;\n        }\n\n        // Handle object release\n        if (tearDown) {\n            cache.recycle = function (item, ...args) {\n                tearDown.apply(item, ...args);\n                this.push(item);\n            };\n        } else if (isArray) {\n            cache.recycle = function (arr, depth) {\n                var i = 0;\n                \n                if (depth > 1) {\n                    i = arr.length;\n                    depth -= 1;\n                    while (i--) {\n                        this.recycle(arr[i], depth);\n                    }\n                }\n                arr.length = 0;\n                this.push(arr);\n            };\n        } else {\n            cache.recycle = cache.push;\n        }\n\n        // Add debug wrapper if needed\n        if (debug) {\n            cache.setUp = function (cacheSetUp, ...args) {\n                var newObject = cacheSetUp(...args);\n\n                if (typeof newObject.recycled === 'undefined') {\n                    Object.defineProperty(newObject, 'recycled', recycleProp);\n                } else {\n                    newObject.recycled = false;\n                }\n\n                return newObject;\n            }.bind(cache, cache.setUp.bind(cache));\n\n            cache.recycle = function (recycle, instance, ...args) {\n                if (instance.recycled) {\n                    console.warn('Recycle: WHOA! I have already been recycled!', instance);\n                } else {\n                    instance.recycled = true;\n                    recycle(instance, ...args);\n                }\n            }.bind(cache, cache.recycle.bind(cache));\n\n            if (isArray) {\n                cache.recycle = function (recycle, instance, ...args) {\n                    if (!Array.isArray(instance)) {\n                        console.warn('Recycle: Adding a non-Array to the array cache!');\n                    }\n                    recycle(instance, ...args);\n                }.bind(cache, cache.recycle.bind(cache));\n            }\n        }\n\n        if (mixinMethods) {\n            Object.defineProperties(ClassObject, {\n                setUp: {\n                    value: cache.setUp.bind(cache)\n                },\n                recycle: {\n                    value: cache.recycle.bind(cache)\n                }\n            });\n            Object.defineProperty(ClassObject.prototype, 'recycle', {\n                value: function (...args) {\n                    cache.recycle(this, ...args);\n                }\n            });\n        }\n\n        return cache;\n    },\n\n    cache: caches\n});\n\n\n//# sourceURL=webpack://platypus/./node_modules/recycle/recycle.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack://platypus/(webpack)/buildin/global.js?");

/***/ }),

/***/ "./package.json":
/*!**********************!*\
  !*** ./package.json ***!
  \**********************/
/*! exports provided: name, version, description, license, main, module, url, logo, repository, scripts, dependencies, devDependencies, engine, default */
/***/ (function(module) {

eval("module.exports = {\"name\":\"platypus\",\"version\":\"2.0.0-beta\",\"description\":\"Platypus Docs\",\"license\":\"MIT\",\"main\":\"lib/platypus.js\",\"module\":\"src/index.js\",\"url\":\"https://github.com/PBS-KIDS/Platypus\",\"logo\":\"assets/platypus-title.png\",\"repository\":{\"type\":\"git\",\"url\":\"https://github.com/PBS-KIDS/Platypus\"},\"scripts\":{\"start\":\"webpack-dev-server --env.dev\",\"build:release\":\"webpack --env.prod\",\"build:debug\":\"webpack --env.dev\"},\"dependencies\":{\"@tweenjs/tween.js\":\"18.3.1\",\"pixi-sound\":\"3.0.3\",\"pixi-spine\":\"2.1.4\",\"pixi.js\":\"5.2.0\",\"recycle\":\"https://github.com/gopherwood/recycle.git#master\",\"springroll\":\"2.2.0\"},\"devDependencies\":{\"grunt\":\"^0.4.5\",\"grunt-contrib-compress\":\"^0.13.0\",\"grunt-contrib-concat\":\"^1.0.1\",\"grunt-contrib-copy\":\"^0.8.0\",\"grunt-contrib-uglify\":\"^0.9.1\",\"grunt-contrib-yuidoc\":\"^0.8.0\",\"lodash\":\"^3.10.0\",\"pako\":\"^0.2.8\",\"webpack\":\"^4.35.2\",\"webpack-cli\":\"^3.3.5\"},\"engine\":\"node >= 0.10.22\"};\n\n//# sourceURL=webpack://platypus/./package.json?");

/***/ }),

/***/ "./src/AABB.js":
/*!*********************!*\
  !*** ./src/AABB.js ***!
  \*********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! config */ \"./src/config/development.js\");\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(config__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var recycle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! recycle */ \"./node_modules/recycle/recycle.js\");\n/**\n * This class defines an axis-aligned bounding box (AABB) which is used during the collision process to determine if two objects are colliding. This is used in a few places including [CollisionBasic](platypus.components.CollisionBasic.html) and [[Collision-Shape]].\n *\n * @namespace platypus\n * @class AABB\n * @constructor\n * @param x {number} The x position of the AABB. The x is always located in the center of the object.\n * @param y {number} The y position of the AABB. The y is always located in the center of the object.\n * @param width {number} The width of the AABB.\n * @param height {number} The height of the AABB.\n * @return {platypus.AABB} Returns the new aabb object.\n */\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    var AABB = function (x, y, width, height) {\n            if (x instanceof AABB) {\n                this.set(x);\n            } else {\n                this.empty = true;\n                this.setAll(x, y, width, height);\n            }\n        },\n        proto = AABB.prototype;\n    \n    /**\n     * Sets all of the properties of the AABB.\n     *\n     * @method setAll\n     * @param x {number} The x position of the AABB. The x is always located in the center of the object.\n     * @param y {number} The y position of the AABB. The y is always located in the center of the object.\n     * @param width {number} The width of the AABB.\n     * @param height {number} The height of the AABB.\n     * @chainable\n     */\n    proto.setAll = function (x, y, width, height) {\n        this.empty = false;\n        this.x = x;\n        this.y = y;\n        this.resize(width, height);\n        return this;\n    };\n    \n    /**\n     * Sets bounds of the AABB.\n     *\n     * @method setBounds\n     * @param left {number} The left side of the AABB.\n     * @param top {number} The top side of the AABB.\n     * @param right {number} The right side of the AABB.\n     * @param bottom {number} The bottom side of the AABB.\n     * @chainable\n     */\n    proto.setBounds = function (left, top, right, bottom) {\n        this.empty = false;\n        this.x = (right + left) / 2;\n        this.y = (top + bottom) / 2;\n        this.resize(right - left, bottom - top);\n        return this;\n    };\n    \n    /**\n     * Sets the AABB values to those of the provided AABB.\n     *\n     * @method set\n     * @param aabb {platypus.AABB} The AABB to copy values.\n     * @chainable\n     */\n    proto.set = function (aabb) {\n        /**\n         * Whether the AABB encloses a valid space.\n         *\n         * @property empty\n         * @type boolean\n         */\n        this.empty = aabb.empty;\n        \n        /**\n         * The x position of the AABB. The x is always located in the center of the object.\n         *\n         * @property x\n         * @type number\n         */\n        this.x = aabb.x;\n        \n        /**\n         * The y position of the AABB. The y is always located in the center of the object.\n         *\n         * @property y\n         * @type number\n         */\n        this.y = aabb.y;\n        \n        /**\n         * The width of the AABB.\n         *\n         * @property width\n         * @type number\n         */\n        this.width  = aabb.width;\n        \n        /**\n         * The height of the AABB.\n         *\n         * @property height\n         * @type number\n         */\n        this.height = aabb.height;\n        \n        /**\n         * Half the width of the AABB.\n         *\n         * @property halfWidth\n         * @type number\n         */\n        this.halfWidth = aabb.halfWidth;\n        \n        /**\n         * Half the height of the AABB.\n         *\n         * @property halfHeight\n         * @type number\n         */\n        this.halfHeight = aabb.halfHeight;\n        \n        /**\n         * The x-position of the left edge of the AABB.\n         *\n         * @property left\n         * @type number\n         */\n        this.left = aabb.left;\n        \n        /**\n         * The x-position of the right edge of the AABB.\n         *\n         * @property right\n         * @type number\n         */\n        this.right = aabb.right;\n        \n        /**\n         * The y-position of the top edge of the AABB.\n         *\n         * @property top\n         * @type number\n         */\n        this.top = aabb.top;\n        \n        /**\n         * The y-position of the bottom edge of the AABB.\n         *\n         * @property bottom\n         * @type number\n         */\n        this.bottom = aabb.bottom;\n        \n        return this;\n    };\n    \n    /**\n     * Returns a string listing AABB dimensions.\n     *\n     * @method toString\n     * @return String\n     */\n    proto.toString = function () {\n        return '[AABB: ' + this.width + 'x' + this.height + ' (' + this.x + ', ' + this.y + ')]';\n    };\n\n    /**\n     * Resets all the values in the AABB so that the AABB can be reused.\n     *\n     * @method reset\n     * @chainable\n     */\n    proto.reset = function () {\n        this.empty = true;\n        return this;\n    };\n    \n    /**\n     * Resizes the AABB.\n     *\n     * @method resize\n     * @param width {number} The new width of the AABB\n     * @param height {number} The new height of the AABB\n     * @chainable\n     */\n    proto.resize = function (width, height) {\n        var w = width || 0,\n            h = height || 0,\n            hw = w / 2,\n            hh = h / 2;\n        \n        this.width  = w;\n        this.height = h;\n        this.halfWidth = hw;\n        this.halfHeight = hh;\n        if (typeof this.x === 'number') {\n            this.left = -hw + this.x;\n            this.right = hw + this.x;\n        } else {\n            this.empty = true;\n        }\n        if (typeof this.y === 'number') {\n            this.top = -hh + this.y;\n            this.bottom = hh + this.y;\n        } else {\n            this.empty = true;\n        }\n        return this;\n    };\n    \n    /**\n     * Changes the size and position of the bounding box so that it contains the current area and the area described in the incoming AABB.\n     *\n     * @method include\n     * @param aabb {platypus.AABB} The AABB whose area will be included in the area of the current AABB.\n     * @chainable\n     */\n    proto.include = function (aabb) {\n        if (this.empty) {\n            this.set(aabb);\n        } else {\n            if (this.left > aabb.left) {\n                this.left = aabb.left;\n            }\n            if (this.right < aabb.right) {\n                this.right = aabb.right;\n            }\n            if (this.top > aabb.top) {\n                this.top = aabb.top;\n            }\n            if (this.bottom < aabb.bottom) {\n                this.bottom = aabb.bottom;\n            }\n            \n            this.width      = this.right  - this.left;\n            this.height     = this.bottom - this.top;\n            this.halfWidth  = this.width / 2;\n            this.halfHeight = this.height / 2;\n            this.x          = this.left + this.halfWidth;\n            this.y          = this.top  + this.halfHeight;\n        }\n        \n        return this;\n    };\n    \n    /**\n     * Moves the AABB to the specified location.\n     *\n     * @method move\n     * @param x {number} The new x position of the AABB.\n     * @param y {number} The new y position of the AABB.\n     * @chainable\n     */\n    proto.move = function (x, y) {\n        this.moveX(x);\n        this.moveY(y);\n        return this;\n    };\n\n    /**\n     * Moves the AABB to the specified location.\n     *\n     * @method moveX\n     * @param x {number} The new x position of the AABB.\n     * @chainable\n     */\n    proto.moveX = function (x) {\n        this.x = x;\n        this.left   = -this.halfWidth + x;\n        this.right  = this.halfWidth + x;\n        return this;\n    };\n\n    /**\n     * Moves the AABB to the specified location.\n     *\n     * @method moveY\n     * @param y {number} The new y position of the AABB.\n     * @chainable\n     */\n    proto.moveY = function (y) {\n        this.y = y;\n        this.top    = -this.halfHeight + y;\n        this.bottom = this.halfHeight + y;\n        return this;\n    };\n    \n    /**\n     * Moves the AABB to the specified location.\n     *\n     * @method moveXBy\n     * @param deltaX {number} The change in x position of the AABB.\n     * @chainable\n     */\n    proto.moveXBy = function (deltaX) {\n        return this.moveX(this.x + deltaX);\n    };\n\n    /**\n     * Moves the AABB to the specified location.\n     *\n     * @method moveYBy\n     * @param deltaY {number} The change in y position of the AABB.\n     * @chainable\n     */\n    proto.moveYBy = function (deltaY) {\n        return this.moveY(this.y + deltaY);\n    };\n\n    /**\n     * Expresses whether this AABB matches the provided AABB.\n     *\n     * @method equals\n     * @param aabb {platypus.AABB} The AABB to check against.\n     * @return {Boolean} Returns `true` if the AABB's match.\n     */\n    proto.equals = function (aabb) {\n        return !this.empty && !aabb.empty && (this.left === aabb.left) && (this.top === aabb.top) && (this.right === aabb.right) && (this.bottom === aabb.bottom);\n    };\n\n    /**\n     * Expresses whether this AABB contains the given AABB.\n     *\n     * @method contains\n     * @param aabb {platypus.AABB} The AABB to check against\n     * @return {boolean} Returns `true` if this AABB contains the other AABB.\n     */\n    proto.contains = function (aabb) {\n        return (aabb.top >= this.top) && (aabb.bottom <= this.bottom) && (aabb.left >= this.left) && (aabb.right <= this.right);\n    };\n    \n    /**\n     * Expresses whether this AABB contains the given point.\n     *\n     * @method containsVector\n     * @param vector {platypus.Vector} The vector to check.\n     * @return {boolean} Returns `true` if this AABB contains the vector.\n     */\n    proto.containsVector = function (vector) {\n        return this.containsPoint(vector.x, vector.y);\n    };\n    \n    /**\n     * Expresses whether this AABB contains the given point.\n     *\n     * @method containsPoint\n     * @param x {number} The x-axis value.\n     * @param y {number} The y-axis value.\n     * @return {boolean} Returns `true` if this AABB contains the point.\n     */\n    proto.containsPoint = function (x, y) {\n        return (y >= this.top) && (y <= this.bottom) && (x >= this.left) && (x <= this.right);\n    };\n    \n    /**\n     * Expresses whether this AABB collides with the given AABB. This is similar to `intersects` but returns true for overlapping only, not touching edges.\n     *\n     * @method collides\n     * @param aabb {platypus.AABB} The AABB to check against\n     * @return {boolean} Returns `true` if this AABB collides with the other AABB.\n     */\n    proto.collides = function (aabb) {\n        return (aabb.bottom > this.top) && (aabb.top < this.bottom) && (aabb.right > this.left) && (aabb.left < this.right);\n    };\n\n    /**\n     * Expresses whether this AABB collides with the given point. This is an exclusive version of containsPoint.\n     *\n     * @method collidesPoint\n     * @param x {number} The x-axis value.\n     * @param y {number} The y-axis value.\n     * @return {boolean} Returns `true` if this AABB collides with the point.\n     */\n    proto.collidesPoint = function (x, y) {\n        return (y > this.top) && (y < this.bottom) && (x > this.left) && (x < this.right);\n    };\n    \n    /**\n     * Expresses whether this AABB intersects the given AABB. This is similar to `collides` but returns true for overlapping or touching edges.\n     *\n     * @method intersects\n     * @param aabb {platypus.AABB} The AABB to check against\n     * @return {boolean} Returns `true` if this AABB intersects the other AABB.\n     */\n    proto.intersects = function (aabb) {\n        return (aabb.bottom >= this.top) && (aabb.top <= this.bottom) && (aabb.right >= this.left) && (aabb.left <= this.right);\n    };\n\n    /**\n     * Returns the area of the intersection. If the AABB's do not intersect, `0` is returned.\n     *\n     * @method getIntersectionArea\n     * @param aabb {AABB} The AABB this AABB intersects with.\n     * @return {Number} Returns the area of the intersected AABB's.\n     */\n    proto.getIntersectionArea = function (aabb) {\n        var max    = Math.max,\n            min    = Math.min;\n        \n        if (this.intersects(aabb)) {\n            return (min(this.bottom, aabb.bottom) - max(this.top,  aabb.top)) * (min(this.right,  aabb.right) - max(this.left, aabb.left));\n        } else {\n            return 0;\n        }\n    };\n    \n    /**\n     * Returns an AABB from cache or creates a new one if none are available.\n     *\n     * @method AABB.setUp\n     * @return {platypus.AABB} The instantiated AABB.\n     */\n    /**\n     * Returns a AABB back to the cache.\n     *\n     * @method AABB.recycle\n     * @param aabb {platypus.AABB} The AABB to be recycled.\n     */\n    /**\n     * Relinquishes properties of the AABB and recycles it.\n     *\n     * @method recycle\n     */\n    recycle__WEBPACK_IMPORTED_MODULE_1__[\"default\"].add(AABB, 'AABB', AABB, null, true, config__WEBPACK_IMPORTED_MODULE_0___default.a.dev);\n    \n    return AABB;\n}());\n\n//# sourceURL=webpack://platypus/./src/AABB.js?");

/***/ }),

/***/ "./src/ActionState.js":
/*!****************************!*\
  !*** ./src/ActionState.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Data_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Data.js */ \"./src/Data.js\");\n/* harmony import */ var _StateMap_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./StateMap.js */ \"./src/StateMap.js\");\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! config */ \"./src/config/development.js\");\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(config__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var recycle__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! recycle */ \"./node_modules/recycle/recycle.js\");\n/**\n * This class defines an action state based on one or more inputs. This is used by [EntityController](platypus.components.EntityController.html) to produce event messages listing whether a particular action is \"triggered\", \"pressed\", and/or \"released\".\n *\n * @namespace platypus\n * @class ActionState\n * @constructor\n * @param event {String} The name of the event to trigger on the Entity.\n * @param states {Object} A list of key/value pairs describing what states should be `true` or `false` on the Entity for this action to be triggered.\n * @param trigger {Function} The function to be called if one or more inputs are active and the current state of the Entity is valid.\n * @return {ActionState} Returns the new ActionState object.\n */\n\n\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    var ActionState = function (event, states, trigger) {\n            /**\n             * The name of the event to trigger on the Entity.\n             *\n             * @property event\n             * @type String\n             */\n            this.event     = event;\n\n            /**\n             * The function to call if the ActionState is active.\n             *\n             * @property trigger\n             * @type Function\n             */\n            this.trigger   = trigger;\n            \n            /**\n             * Whether any of the ActionState's inputs are active.\n             *\n             * @property active\n             * @type Boolean\n             */\n            this.active    = false;\n\n            /**\n             * Whether any of the ActionState's inputs were active last update.\n             *\n             * @property wasActive\n             * @type Boolean\n             */\n            this.wasActive = false;\n\n            /**\n             * Whether the Entity's state is valid for this ActionState.\n             *\n             * @property valid\n             * @type Boolean\n             */\n            this.valid     = true;\n\n            /**\n             * Whether the Entity's state was valid for this ActionState last update.\n             *\n             * @property wasValid\n             * @type Boolean\n             */\n            this.wasValid  = true;\n\n            /**\n             * The state of the Entity that is valid for this ActionState.\n             *\n             * @property states\n             * @type platypus.StateMap\n             */\n            this.states = _StateMap_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp(states);\n\n            /**\n             * The list of input toggles to track control input.\n             *\n             * @property inputs\n             * @type Array\n             */\n            this.inputs = _utils_array_js__WEBPACK_IMPORTED_MODULE_2__[\"arrayCache\"].setUp();\n\n            /**\n             * The message that is passed to the Entity if the ActionState is active.\n             *\n             * @property stateSummary\n             * @type platypus.Data\n             */\n            this.stateSummary = _Data_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp(\n                \"pressed\",   false,\n                \"released\",  false,\n                \"triggered\", false\n            );\n        },\n        orArray = function (element) {\n            return element;\n        },\n        proto = ActionState.prototype;\n\n    /**\n     * Updates the state of the action by checking the state of the Entity and whether any inputs are active.\n     *\n     * @method update\n     * @param state {Object} The Entity's `state` property to compare against the ActionState's valid state.\n     * @return {Boolean} Whether the ActionState is triggered, pressed, or released.\n     */\n    proto.update = function (state) {\n        var ss = this.stateSummary;\n        \n        this.valid     = state.includes(this.states);\n        this.active    = this.inputs.some(orArray);\n        \n        ss.pressed     = this.valid && this.active;\n        ss.released    = this.wasActive && ((!this.valid && this.wasValid) || (this.valid && !this.active));\n        ss.triggered   = this.valid && this.active && !this.wasActive;\n        \n        this.wasValid  = this.valid;\n        this.wasActive = this.active;\n        \n        return ss.pressed || ss.released || ss.triggered;\n    };\n    \n    /**\n     * Triggers events on the Entity related to the ActionState's state. This is necessarily separate from the `update` method since triggered events could affect entity state. The messages have the following form and are only triggered if one of the values is `true`:\n     *\n     *     {\n     *         \"triggered\": true,\n     *         \"pressed\": true,\n     *         \"released\": false\n     *     }\n     *\n     * Here is a mapping of the various event messages depending on the ActionState's state.\n     *\n     *     ActionState State:\n     *          wasValid:  0 0 0 0  0 0 0 0  1 1 1 1  1 1 1 1\n     *             valid:  0 0 0 0  1 1 1 1  0 0 0 0  1 1 1 1\n     *         wasActive:  0 0 1 1  0 0 1 1  0 0 1 1  0 0 1 1\n     *            active:  0 1 0 1  0 1 0 1  0 1 0 1  0 1 0 1\n     *     Events:\n     *         triggered:  0 0 0 0  0 1 0 0  0 0 0 0  0 1 0 0\n     *           pressed:  0 0 0 0  0 1 0 1  0 0 0 0  0 1 0 1\n     *          released:  0 0 0 0  0 0 1 0  0 0 1 1  0 0 1 0\n     *\n     * @method resolve\n     */\n    proto.resolve = function () {\n        this.trigger(this.event, this.stateSummary);\n    };\n    \n    /**\n     * Returns an ActionState from cache or creates a new one if none are available.\n     *\n     * @method ActionState.setUp\n     * @return {platypus.ActionState} The instantiated ActionState.\n     */\n    /**\n     * Returns an ActionState back to the cache. Prefer the ActionState's recycle method since it recycles property objects as well.\n     *\n     * @method ActionState.recycle\n     * @param {platypus.ActionState} The ActionState to be recycled.\n     */\n    /**\n     * Relinquishes properties of the ActionState and recycles it.\n     *\n     * @method recycle\n     */\n    recycle__WEBPACK_IMPORTED_MODULE_4__[\"default\"].add(ActionState, 'ActionState', ActionState, function () {\n        this.states.recycle();\n        this.stateSummary.recycle();\n        _utils_array_js__WEBPACK_IMPORTED_MODULE_2__[\"arrayCache\"].recycle(this.inputs);\n    }, true, config__WEBPACK_IMPORTED_MODULE_3___default.a.dev);\n\n    return ActionState;\n}());\n\n//# sourceURL=webpack://platypus/./src/ActionState.js?");

/***/ }),

/***/ "./src/AssetManager.js":
/*!*****************************!*\
  !*** ./src/AssetManager.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return AssetManager; });\n/* harmony import */ var _Data_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Data.js */ \"./src/Data.js\");\n/* harmony import */ var _DataMap_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DataMap.js */ \"./src/DataMap.js\");\n/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! pixi.js */ \"pixi.js\");\n/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(pixi_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/array.js */ \"./src/utils/array.js\");\n/**\n * This class is instantiated by Platypus at `platypus.assetCache` to track assets: loading assets needed for particular layers and unloading assets once they're no longer needed.\n *\n * @namespace platypus\n * @class AssetManager\n * @constructor\n**/\n/* global platypus, setTimeout */\n\n\n\n\n\nconst\n    fn = /^(?:\\w+:\\/{2}\\w+(?:\\.\\w+)*\\/?)?(?:[\\/.]*?(?:[^?]+)?\\/)?(?:([^\\/?]+)\\.(\\w+|{\\w+(?:,\\w+)*}))(?:\\?\\S*)?$/,\n    folders = {\n        png: 'images',\n        jpg: 'images',\n        jpeg: 'images',\n        ogg: 'audio',\n        mp3: 'audio',\n        m4a: 'audio',\n        wav: 'audio',\n        \"{ogg,mp3}\": 'audio'\n    },\n    formatAsset = function (asset) { //TODO: Make this behavior less opaque.\n        const\n            standardPath = asset.src || asset,\n            path = platypus.supports.ie ? standardPath.replace('{ogg,mp3}', 'mp3') : standardPath,\n            match = path.match(fn);\n            \n        return _Data_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp(\n            'id', asset.id || (match ? match[1] : path),\n            'src', (platypus.game.options[folders[match[2].toLowerCase()]] || '') + path\n        );\n    };\n\nclass AssetManager {\n    constructor () {\n        this.assets = _DataMap_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp();\n        this.counts = _Data_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp();\n    }\n\n    /**\n     * This method removes an asset from memory if it's the last needed instance of the asset.\n     *\n     * @method delete\n     * @param {*} id\n     * @return {Boolean} Returns `true` if asset was removed from asset cache.\n     */\n    delete (id) {\n        const assets = this.assets;\n\n        if (assets.has(id)) {\n            const counts = this.counts;\n\n            counts[id] -= 1;\n            if (counts[id] === 0) {\n                const asset = assets.get(id);\n                \n                if (asset && asset.src) {\n                    asset.src = '';\n                }\n                assets.delete(id);\n            }\n\n            return !counts[id];\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Returns a loaded instance of a given asset.\n     *\n     * @method get\n     * @param {*} id\n     * @return {Object} Returns the asset if defined.\n     */\n    get (id) {\n        return this.assets.get(id);\n    }\n\n    /**\n     * Returns whether a given asset is currently loaded by the AssetManager.\n     *\n     * @method has\n     * @param {*} id\n     * @return {Object} Returns `true` if the asset is loaded and `false` if not.\n     */\n    has (id) {\n        return this.assets.has(id);\n    }\n\n    /**\n     * Sets a mapping between an id and a loaded asset. If the mapping already exists, simply increment the count for a given id.\n     *\n     * @method set\n     * @param {*} id\n     * @param {*} value The loaded asset.\n     * @param {Number} count The number of assets needed.\n     */\n    set (id, value, count = 1) {\n        const\n            assets = this.assets,\n            counts = this.counts;\n\n        if (assets.has(id)) {\n            counts[id] += count;\n        } else {\n            assets.set(id, value);\n            counts[id] = count;\n        }\n    }\n\n    /**\n     * Loads a list of assets.\n     *\n     * @method load\n     * @param {Array} list A list of assets to load.\n     * @param {Function} one This function is called as each asset is loaded.\n     * @param {Function} all This function is called once all assets in the list are loaded.\n     */\n    load (list, one, all) {\n        const\n            counts = this.counts,\n            needsLoading = _utils_array_js__WEBPACK_IMPORTED_MODULE_3__[\"arrayCache\"].setUp(),\n            adds = _Data_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp();\n\n        for (let i = 0; i < list.length; i++) {\n            const\n                item = formatAsset(list[i]),\n                id = item.id || item.src || item;\n\n            if (this.has(id)) {\n                counts[id] += 1;\n            } else if (adds.hasOwnProperty(id)) {\n                adds[id] += 1;\n            } else {\n                adds[id] = 1;\n                needsLoading.push(item);\n            }\n        }\n\n        if (needsLoading.length) {\n            const queue = new pixi_js__WEBPACK_IMPORTED_MODULE_2__[\"Loader\"](),\n                total = needsLoading.length;\n            let progress = 0;\n\n            queue.onLoad.add((loader, response) => {\n                this.set(response.name, response.data, adds[response.name]);\n                progress += 1;\n                if (one) {\n                    one(progress / total);\n                }\n            });\n\n            if (all) {\n                queue.onComplete.add(all);\n            }\n            \n            for (let i = 0; i < total; i++) {\n                const\n                    item = needsLoading[i],\n                    id = item.id || item.src || item;\n\n                queue.add(id, item.src || item, item);\n            }\n\n            queue.load();\n        } else if (all) {\n            setTimeout(() => { // To run in same async sequence as above.\n                all();\n            }, 1);\n        }\n\n        _utils_array_js__WEBPACK_IMPORTED_MODULE_3__[\"arrayCache\"].recycle(needsLoading);\n    }\n\n    /**\n     * Unloads a list of assets. This is identical to passing each item in the list to `.delete()`.\n     *\n     * @method unload\n     * @param {Array} list A list of assets to unload.\n     */\n    unload (list) {\n        var i = list.length;\n\n        while (i--) {\n            this.delete(list[i].id || list[i]);\n        }\n    }\n}\n\n\n//# sourceURL=webpack://platypus/./src/AssetManager.js?");

/***/ }),

/***/ "./src/Async.js":
/*!**********************!*\
  !*** ./src/Async.js ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! config */ \"./src/config/development.js\");\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(config__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var recycle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! recycle */ \"./node_modules/recycle/recycle.js\");\n/**\n * This class defines an asynchronous set up wherein multiple calls can be made and a final function will be run once the calls are completed. Something like `Promise.all` but better for avoiding garbage collection.\n *\n * @namespace platypus\n * @class Async\n * @constructor\n * @param functions {Array} An array of functions where each function accepts a `callback` parameter and runs `callback()` on completion to notify the completion of the call.\n * @param callback {Function} The function to run once the list of functions has finished.\n * @return {platypus.Async} Returns the new Async object.\n */\n/*global clearTimeout, setTimeout */\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    var callback = function (finalCB) {\n            this.increment -= 1;\n            if (!this.increment) {\n                this.resolve = finalCB;\n                this.timeout = setTimeout(finalCB, 0); //ensure async to keep code flow consistent.\n            }\n        },\n        final = function (callback) {\n            this.resolve = null;\n            callback();\n            this.recycle();\n        },\n        Async = function (arr, finalCallback) {\n            const finalCB = final.bind(this, finalCallback),\n                length = arr.length;\n\n            if (!length) {\n                this.resolve = finalCB;\n                this.timeout = setTimeout(finalCB, 0); //ensure async to keep code flow consistent.\n            } else {\n                const cb = callback.bind(this, finalCB);\n                let i = 0;\n\n                this.increment = length;\n                this.resolve = null;\n\n                for (i = 0; i < length; i++) {\n                    arr[i](cb);\n                }\n            }\n        };\n\n    /**\n     * Attempts to resolve the async call immediately if possible.\n     *\n     * @method attemptResolution\n     * @return {Boolean} Returns `true` if async is done, `false` if not.\n     */\n    Async.prototype.attemptResolution = function () {\n        if (this.resolve) {\n            clearTimeout(this.timeout);\n            this.resolve();\n            return true;\n        } else {\n            return false;\n        }\n    };\n    \n    /**\n     * Returns an Async from cache or creates a new one if none are available.\n     *\n     * @method Async.setUp\n     * @return {platypus.Async} The instantiated Async.\n     */\n    /**\n     * Returns an Async back to the cache.\n     *\n     * @method Async.recycle\n     * @param async {platypus.Async} The Async to be recycled.\n     */\n    /**\n     * Relinquishes properties of the Async and recycles it.\n     *\n     * @method recycle\n     */\n    recycle__WEBPACK_IMPORTED_MODULE_1__[\"default\"].add(Async, 'Async', Async, function () {\n        this.increment = 0;\n        this.resolve = null;\n        this.timeout = 0;\n    }, true, config__WEBPACK_IMPORTED_MODULE_0___default.a.dev);\n\n    return Async;\n}());\n\n//# sourceURL=webpack://platypus/./src/Async.js?");

/***/ }),

/***/ "./src/CollisionData.js":
/*!******************************!*\
  !*** ./src/CollisionData.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Vector_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vector.js */ \"./src/Vector.js\");\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! config */ \"./src/config/development.js\");\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(config__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var recycle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! recycle */ \"./node_modules/recycle/recycle.js\");\n/**\n * CollisionData holds collision data passed to entities during collisions with other entities. This class is primarily used by the [\"HandlerCollision\"](\"HandlerCollision\"%20Component.html) Component to trigger messages on child entities as collision occur.\n *\n * @namespace platypus\n * @class CollisionData\n * @constructor\n * @param occurredOrData {Boolean|CollisionData} Whether this represents an actual collision between two shapes. If a CollisionData instance is provided, the instance's full set of values are copied.\n * @param direction {Number} 1 or -1 to define the direction of the collision.\n * @param position {Number} A positive number describing position along the line of collision direction.\n * @param deltaMovement {Number} A positive number describing the magnitude of overlap.\n * @param aABB {platypus.AABB} An AABB of the colliding shape.\n * @param thisShape {platypus.Shape} The moving shape.\n * @param thatShape {platypus.Shape} The stationary shape being collided with.\n * @param vector {platypus.Vector} The vector describing the contact point.\n * @param stuck {Number} The amount of unwarranted overlap if shapes start in a collided position before moving.\n * @return {platypus.CollisionData} Returns the new CollisionData object.\n */\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    var CollisionData = function (occurredOrData) {\n            if (!this.vector) {\n                this.vector = _Vector_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp();\n            }\n            if (occurredOrData instanceof CollisionData) {\n                this.copy(occurredOrData);\n            } else {\n                this.set.apply(this, arguments);\n            }\n        },\n        proto = CollisionData.prototype;\n    \n    /**\n     * Sets all of the properties of the CollisionData.\n     *\n     * @method set\n     * @param occurred {Boolean} Whether this represents an actual collision between two shapes.\n     * @param direction {Number} 1 or -1 to define the direction of the collision.\n     * @param position {Number} A positive number describing position along the line of collision direction.\n     * @param deltaMovement {Number} A positive number describing the magnitude of overlap.\n     * @param aABB {platypus.AABB} An AABB of the colliding shape.\n     * @param thisShape {platypus.Shape} The moving shape.\n     * @param thatShape {platypus.Shape} The stationary shape being collided with.\n     * @param vector {platypus.Vector} The vector describing the contact point.\n     * @param stuck {Number} The amount of unwarranted overlap if shapes start in a collided position before moving.\n     */\n    proto.set = function (occurred, direction, position, deltaMovement, aABB, thisShape, thatShape, vector, stuck) {\n        this.occurred = occurred || false;\n        this.direction = direction || null;\n        this.position = position || null;\n        this.deltaMovement = deltaMovement || null;\n        this.aABB = aABB || null;\n        this.thisShape = thisShape || null;\n        this.thatShape = thatShape || null;\n        this.vector.set(vector);\n        this.stuck  = stuck || 0;\n    };\n\n    /**\n     * Sets all of the properties of the CollisionData to match those of the provided CollisionData object.\n     *\n     * @method copy\n     * @param dataToCopy {CollisionData} The object values to copy.\n     */\n    proto.copy = function (dataToCopy) {\n        this.occurred         = dataToCopy.occurred;\n        this.direction         = dataToCopy.direction;\n        this.position         = dataToCopy.position;\n        this.deltaMovement     = dataToCopy.deltaMovement;\n        this.aABB             = dataToCopy.aABB;\n        this.thisShape      = dataToCopy.thisShape;\n        this.thatShape      = dataToCopy.thatShape;\n        this.vector.setVector(dataToCopy.vector);\n        this.stuck          = dataToCopy.stuck;\n    };\n\n    /**\n     * Returns an collisionData from cache or creates a new one if none are available.\n     *\n     * @method CollisionData.setUp\n     * @return {platypus.CollisionData} The instantiated CollisionData.\n     */\n    /**\n     * Returns a collisionData back to the cache.\n     *\n     * @method CollisionData.recycle\n     * @param collisionData {platypus.CollisionData} The collisionData to be recycled.\n     */\n    /**\n     * Relinquishes properties of the collisionData and recycles it.\n     *\n     * @method recycle\n     */\n    recycle__WEBPACK_IMPORTED_MODULE_2__[\"default\"].add(CollisionData, 'CollisionData', CollisionData, null, true, config__WEBPACK_IMPORTED_MODULE_1___default.a.dev);\n    \n    return CollisionData;\n}());\n\n//# sourceURL=webpack://platypus/./src/CollisionData.js?");

/***/ }),

/***/ "./src/CollisionDataContainer.js":
/*!***************************************!*\
  !*** ./src/CollisionDataContainer.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! config */ \"./src/config/development.js\");\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(config__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var recycle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! recycle */ \"./node_modules/recycle/recycle.js\");\n/**\n * CollisionDataContainer holds lists of CollisionData passed to entities during collisions with other entities. This class is primarily used by the [\"HandlerCollision\"](\"HandlerCollision\"%20Component.html) Component to trigger messages on child entities as collisions occur.\n *\n * @namespace platypus\n * @class CollisionDataContainer\n * @constructor\n * @return {platypus.CollisionDataContainer} Returns the new aabb object.\n */\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    var CollisionDataContainer = function () {\n            if (!this.xData && !this.yData) {\n                this.xData = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n                this.yData = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n                this.xDeltaMovement = Infinity;\n                this.yDeltaMovement = Infinity;\n            } else {\n                this.reset();\n            }\n        },\n        proto = CollisionDataContainer.prototype;\n    \n    /**\n     * Adds a CollisionData object to the container's X-axis if the movement distance is less than or equal to collision data collected so far.\n     *\n     * @method tryToAddX\n     * @param collisionData {platypus.CollisionData} The collision data to add.\n     * @return {Boolean} Whether the collision data was added.\n     */\n    proto.tryToAddX = function (collisionData) {\n        if (collisionData.deltaMovement > this.xDeltaMovement) {\n            return false;\n        } else if (collisionData.deltaMovement < this.xDeltaMovement) {\n            this.resetX(collisionData.deltaMovement);\n        }\n\n        this.xData.push(collisionData);\n\n        return true;\n    };\n    \n    /**\n     * Adds a CollisionData object to the container's Y-axis if the movement distance is less than or equal to collision data collected so far.\n     *\n     * @method tryToAddY\n     * @param collisionData {platypus.CollisionData} The collision data to add.\n     * @return {Boolean} Whether the collision data was added.\n     */\n    proto.tryToAddY = function (collisionData) {\n        if (collisionData.deltaMovement > this.yDeltaMovement) {\n            return false;\n        } else if (collisionData.deltaMovement < this.yDeltaMovement) {\n            this.resetY(collisionData.deltaMovement);\n        }\n        \n        this.yData.push(collisionData);\n        \n        return true;\n    };\n    \n    /**\n     * Resets the X and Y axes.\n     *\n     * @method reset\n     */\n    proto.reset = function () {\n        this.resetX(Infinity);\n        this.resetY(Infinity);\n    };\n    \n    /**\n     * Resets the X axis.\n     *\n     * @param delta {Number} The delta value of the X-axis.\n     * @method resetX\n     */\n    proto.resetX = function (delta) {\n        var xData = this.xData,\n            i = xData.length;\n        \n        while (i--) {\n            xData[i].recycle();\n        }\n        xData.length = 0;\n        this.xDeltaMovement = delta;\n    };\n    \n    /**\n     * Resets the Y axis.\n     *\n     * @param delta {Number} The delta value of the Y-axis.\n     * @method resetY\n     */\n    proto.resetY = function (delta) {\n        var yData = this.yData,\n            i = yData.length;\n        \n        while (i--) {\n            yData[i].recycle();\n        }\n        yData.length = 0;\n        this.yDeltaMovement = delta;\n    };\n    \n    /**\n     * Returns an CollisionDataContainer from cache or creates a new one if none are available.\n     *\n     * @method CollisionDataContainer.setUp\n     * @return {platypus.CollisionDataContainer} The instantiated CollisionDataContainer.\n     */\n    /**\n     * Returns a CollisionDataContainer back to the cache.\n     *\n     * @method CollisionDataContainer.recycle\n     * @param CollisionDataContainer {platypus.CollisionDataContainer} The CollisionDataContainer to be recycled.\n     */\n    /**\n     * Relinquishes properties of the CollisionDataContainer and recycles it.\n     *\n     * @method recycle\n     */\n    recycle__WEBPACK_IMPORTED_MODULE_2__[\"default\"].add(CollisionDataContainer, 'CollisionDataContainer', CollisionDataContainer, null, true, config__WEBPACK_IMPORTED_MODULE_1___default.a.dev);\n\n    return CollisionDataContainer;\n}());\n\n//# sourceURL=webpack://platypus/./src/CollisionDataContainer.js?");

/***/ }),

/***/ "./src/CollisionShape.js":
/*!*******************************!*\
  !*** ./src/CollisionShape.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _AABB_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AABB.js */ \"./src/AABB.js\");\n/* harmony import */ var _Vector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Vector.js */ \"./src/Vector.js\");\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! config */ \"./src/config/development.js\");\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(config__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var recycle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! recycle */ \"./node_modules/recycle/recycle.js\");\n/**\n * This class defines a collision shape, which defines the 'space' an entity occupies in the collision system. Currently only rectangle and circle shapes can be created. Collision shapes include an axis-aligned bounding box (AABB) that tightly wraps the shape. The AABB is used for initial collision checks.\n *\n * @namespace platypus\n * @class CollisionShape\n * @constructor\n * @param owner {platypus.Entity} The entity that uses this shape.\n * @param definition {Object} This is an object of key/value pairs describing the shape.\n * @param definition.x {number} The x position of the shape. The x is always located in the center of the object.\n * @param definition.y {number} The y position of the shape. The y is always located in the center of the object.\n * @param [definition.type=\"rectangle\"] {String} The type of shape this is. Currently this can be either \"rectangle\" or \"circle\".\n * @param [definition.width] {number} The width of the shape if it's a rectangle.\n * @param [definition.height] {number} The height of the shape if it's a rectangle.\n * @param [definition.radius] {number} The radius of the shape if it's a circle.\n * @param [definition.offsetX] {number} The x offset of the collision shape from the owner entity's location.\n * @param [definition.offsetY] {number} The y offset of the collision shape from the owner entity's location.\n * @param [definition.regX] {number} The registration x of the collision shape with the owner entity's location if offsetX is not provided.\n * @param [definition.regY] {number} The registration y of the collision shape with the owner entity's location if offsetX is not provided.\n * @param collisionType {String} A string describing the collision type of this shape.\n */\n\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    var circleRectCollision = function (circle, rect) {\n            var rectAabb         = rect.aABB,\n                hh = rectAabb.halfHeight,\n                hw = rectAabb.halfWidth,\n                abs = Math.abs,\n                pow = Math.pow,\n                shapeDistanceX = abs(circle.x - rect.x),\n                shapeDistanceY = abs(circle.y - rect.y),\n                radius = circle.radius;\n            \n            /* This checks the following in order:\n                - Is the x or y distance between shapes less than half the width or height respectively of the rectangle? If so, we know they're colliding.\n                - Is the x or y distance between the shapes greater than the half width/height plus the radius of the circle? Then we know they're not colliding.\n                - Otherwise, we check the distance between a corner of the rectangle and the center of the circle. If that distance is less than the radius of the circle, we know that there is a collision; otherwise there is not.\n            */\n            return (shapeDistanceX < hw) || (shapeDistanceY < hh) || ((shapeDistanceX < (hw + radius)) && (shapeDistanceY < (hh + radius)) && ((pow((shapeDistanceX - hw), 2) + pow((shapeDistanceY - hh), 2)) < pow(radius, 2)));\n        },\n        collidesCircle = function (shape) {\n            var pow = Math.pow;\n            \n            return this.aABB.collides(shape.aABB) && (\n                ((shape.type === 'rectangle') && circleRectCollision(this, shape)) ||\n                ((shape.type === 'circle')    && ((pow((this.x - shape.x), 2) + pow((this.y - shape.y), 2)) <= pow((this.radius + shape.radius), 2)))\n            );\n        },\n        collidesDefault = function () {\n            return false;\n        },\n        collidesRectangle = function (shape) {\n            return this.aABB.collides(shape.aABB) && (\n                (shape.type === 'rectangle') ||\n                ((shape.type === 'circle') && circleRectCollision(shape, this))\n            );\n        },\n        CollisionShape = function (owner, definition, collisionType) {\n            var regX = definition.regX,\n                regY = definition.regY,\n                width = definition.width || definition.radius * 2 || 0,\n                height = definition.height || definition.radius * 2 || 0,\n                radius = definition.radius || 0,\n                type = definition.type || 'rectangle';\n\n            // If this shape is recycled, the vectors will already be in place.\n            if (!this.initialized) {\n                this.initialized = true;\n                _Vector_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].assign(this, 'offset', 'offsetX', 'offsetY');\n                _Vector_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].assign(this, 'position', 'x', 'y');\n                _Vector_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].assign(this, 'size', 'width', 'height');\n                this.aABB = _AABB_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp();\n            }\n\n            this.owner = owner;\n            this.collisionType = collisionType;\n            this.type = type;\n            this.subType = '';\n            \n            /**\n             * Determines whether shapes collide.\n             *\n             * @method collides\n             * @param shape {platypus.CollisionShape} The shape to check against for collision.\n             * @return {Boolean} Whether the shapes collide.\n             */\n            if (type === 'circle') {\n                width = height = radius * 2;\n                this.collides = collidesCircle;\n            } else if (type === 'rectangle') {\n                this.collides = collidesRectangle;\n            } else {\n                this.collides = collidesDefault;\n            }\n            this.size.setXYZ(width, height);\n            this.radius = radius;\n\n            if (typeof regX !== 'number') {\n                regX = width / 2;\n            }\n            if (typeof regY !== 'number') {\n                regY = height / 2;\n            }\n            this.offset.setXYZ(definition.offsetX || ((width  / 2) - regX), definition.offsetY || ((height / 2) - regY));\n\n            if (owner) {\n                this.position.setXYZ(owner.x, owner.y).add(this.offset);\n            } else {\n                this.position.setXYZ(definition.x, definition.y).add(this.offset);\n            }\n\n            this.aABB.setAll(this.x, this.y, width, height);\n        },\n        proto = CollisionShape.prototype;\n\n    /**\n     * Updates the shape to match another shape.\n     *\n     * @method updateAll\n     * @param updateAll {platypus.CollisionShape} The shape to copy into this one.\n     */\n    proto.updateAll = function (shape) {\n        this.owner = shape.owner;\n        this.collisionType = shape.collisionType;\n        this.type = shape.type;\n        this.subType = shape.subType;\n        this.offset.x = shape.offset.x;\n        this.offset.y = shape.offset.y;\n        this.position.x = shape.position.x;\n        this.position.y = shape.position.y;\n        this.size.x = shape.size.x;\n        this.size.y = shape.size.y;\n        this.radius = shape.radius;\n        this.aABB.setAll(this.x, this.y, this.width, this.height);\n        if (this.type === 'circle') {\n            this.collides = collidesCircle;\n        } else if (this.type === 'rectangle') {\n            this.collides = collidesRectangle;\n        } else {\n            this.collides = collidesDefault;\n        }\n    };\n\n    /**\n     * Updates the location of the shape and AABB. The position you send should be that of the owner, the offset of the shape is added inside the function.\n     *\n     * @method update\n     * @param ownerX {number} The x position of the owner.\n     * @param ownerY {number} The y position of the owner.\n     */\n    proto.update = function (ownerX, ownerY) {\n        var x = ownerX + this.offsetX,\n            y = ownerY + this.offsetY;\n\n        this.position.setXYZ(x, y);\n        this.aABB.move(x, y);\n    };\n    \n    /**\n     * Move the shape's x position.\n     *\n     * @method moveX\n     * @param x {number} The x position to which the shape should be moved.\n     */\n    proto.moveX = function (x) {\n        this.x = x;\n        this.aABB.moveX(x);\n    };\n    \n    /**\n     * Move the shape's y position.\n     *\n     * @method moveY\n     * @param y {number} The y position to which the shape should be moved.\n     */\n    proto.moveY = function (y) {\n        this.y = y;\n        this.aABB.moveY(y);\n    };\n\n    /**\n     * Move the shape's x and y position.\n     *\n     * @method moveXY\n     * @param x {number} The x position to which the shape should be moved.\n     * @param y {number} The y position to which the shape should be moved.\n     */\n    proto.moveXY = function (x, y) {\n        this.x = x;\n        this.y = y;\n        this.aABB.move(x, y);\n    };\n    \n    /**\n     * Returns the axis-aligned bounding box of the shape.\n     *\n     * @method getAABB\n     * @return {platypus.AABB} The AABB of the shape.\n     */\n    proto.getAABB = function () {\n        return this.aABB;\n    };\n    \n    /**\n     * Set the shape's position as if the entity's x position is in a certain location.\n     *\n     * @method setXWithEntityX\n     * @param entityX {number} The x position of the entity.\n     */\n    proto.setXWithEntityX = function (entityX) {\n        this.x = entityX + this.offsetX;\n        this.aABB.moveX(this.x);\n    };\n    \n    /**\n     * Set the shape's position as if the entity's y position is in a certain location.\n     *\n     * @method setYWithEntityY\n     * @param entityY {number} The y position of the entity.\n     */\n    proto.setYWithEntityY = function (entityY) {\n        this.y = entityY + this.offsetY;\n        this.aABB.moveY(this.y);\n    };\n    \n    /**\n     * Transform the shape using a matrix transformation.\n     *\n     * @method multiply\n     * @param matrix {Array} A matrix used to transform the shape.\n     */\n    proto.multiply = function (m) {\n        var pos = this.position,\n            own = this.owner.position;\n        \n        pos.subtractVector(own);\n        \n        pos.multiply(m);\n        this.offset.multiply(m);\n        this.size.multiply(m);\n        \n        pos.addVector(own);\n        this.width  = Math.abs(this.width);\n        this.height = Math.abs(this.height);\n        \n        this.aABB.setAll(this.x, this.y, this.width, this.height);\n    };\n\n    /**\n     * Expresses whether this shape contains the given point.\n     *\n     * @method containsPoint\n     * @param x {number} The x-axis value.\n     * @param y {number} The y-axis value.\n     * @return {boolean} Returns `true` if this shape contains the point.\n     */\n    proto.containsPoint = function (x, y) {\n        var pow = Math.pow;\n\n        return this.aABB.containsPoint(x, y) && (\n            (this.type === 'rectangle') ||\n            ((this.type === 'circle') && ((pow((this.x - x), 2) + pow((this.y - y), 2)) <= pow(this.radius, 2)))\n        );\n    };\n    \n    /**\n    * Returns a JSON object describing the collision shape.\n    *\n    * @method toJSON\n    * @return {Object} Returns a JSON definition that can be used to recreate the collision shape.\n    **/\n    proto.toJSON = function () {\n        var json = {},\n            width = this.size.width,\n            height = this.size.height;\n\n        if (width / 2 !== this.regX) {\n            json.regX = this.regX;\n        }\n        if (height / 2 !== this.regY) {\n            json.regY = this.regY;\n        }\n        if (this.offset.x !== ((width / 2) - this.regX)) {\n            json.offsetX = this.offset.x;\n        }\n        if (this.offset.y !== ((height / 2) - this.regY)) {\n            json.offsetY = this.offset.y;\n        }\n        if (this.type === 'circle') {\n            json.radius = this.radius;\n        } else {\n            json.width = width;\n            json.height = height;\n        }\n        json.type = this.type;\n\n        return json;\n    };\n\n    /**\n     * Returns an CollisionShape from cache or creates a new one if none are available.\n     *\n     * @method CollisionShape.setUp\n     * @return {platypus.CollisionShape} The instantiated CollisionShape.\n     */\n    /**\n     * Returns a CollisionShape back to the cache.\n     *\n     * @method CollisionShape.recycle\n     * @param {platypus.CollisionShape} The CollisionShape to be recycled.\n     */\n    /**\n     * Relinquishes properties of the CollisionShape and recycles it.\n     *\n     * @method recycle\n     */\n    recycle__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(CollisionShape, 'CollisionShape', CollisionShape, null, true, config__WEBPACK_IMPORTED_MODULE_2___default.a.dev);\n    \n    return CollisionShape;\n}());\n\n\n//# sourceURL=webpack://platypus/./src/CollisionShape.js?");

/***/ }),

/***/ "./src/Component.js":
/*!**************************!*\
  !*** ./src/Component.js ***!
  \**************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var _Data_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Data.js */ \"./src/Data.js\");\n/**\n * This is the extendable Component class. Typically specific component classes should be created using `createComponentClass()`. This method accepts component definitions and creates component classes that can be used to create components by entities.  It adds properties and methods that are common to all components so that component definitions can focus on unique properties and methods.\n *\n * To create an extended component class, use the following syntax:\n *\n *      createComponentClass(componentDefinition, prototype);\n *\n *  * `componentDefinition` is list of key/value pairs that describe the component's behavior.\n *  * `prototype` is an optional prototype that this component extends.\n * See [component-template.js](\"component-template\"%20Component.html) for an example componentDefinition that can be sent into this component class factory.\n *\n * @namespace platypus\n * @class Component\n * @static\n */\n/*global platypus */\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    var getAssetList = function () {\n            return _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n        },\n        Component = function (type, owner) {\n            this.type = type;\n            this.owner = owner;\n            this.publicMethods = _Data_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp();\n            this.listener = _Data_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp(\n                \"events\", _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(),\n                \"messages\", _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp()\n            );\n        },\n        proto = Component.prototype;\n    \n    /**\n     * Returns a string describing the component.\n     *\n     * @method toString\n     * @return {String} Returns the component type as a string of the form \"[Component ComponentType]\".\n     **/\n    proto.toString = function () {\n        return \"[Component \" + this.type + \"]\";\n    };\n\n    /**\n     * Returns a JSON object describing the component.\n     *\n     * @method toJSON\n     * @return {Object} Returns a JSON definition that can be used to recreate the component.\n     **/\n    proto.toJSON = null; // defined in factory.js\n\n    /**\n     * This method cleans up listeners and methods that this component added to the entity. It should never be called by the component itself. Call this.owner.removeComponent(this) instead.\n     *\n     * @method destroy\n     * @private\n     */\n    proto.destroy = function () {\n        var func = '';\n        \n        if (this.listener) {\n            // Handle component's destroy method before removing messaging and methods.\n            if (this._destroy) {\n                this._destroy();\n            }\n            \n            // Now remove event listeners and methods.\n            for (func in this.publicMethods) {\n                if (this.publicMethods.hasOwnProperty(func)) {\n                    this.removeMethod(func);\n                }\n            }\n            this.publicMethods.recycle();\n            \n            this.removeEventListeners();\n            _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.listener.events);\n            _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.listener.messages);\n            this.listener.recycle();\n            this.listener = null;\n        }\n    };\n    \n    /**\n     * This method removes multiple event listeners from the entity.\n     *\n     * @method removeEventListeners\n     * @param [listeners] {Array} The list of listeners to remove. If not supplied, all event listeners are removed.\n     * @private\n     */\n    proto.removeEventListeners = function (listeners) {\n        var i = 0,\n            events   = null,\n            messages = null;\n        \n        if (!listeners) {\n            events   = this.listener.events;\n            messages = this.listener.messages;\n            for (i = 0; i < events.length; i++) {\n                this.owner.off(events[i], messages[i]);\n            }\n            events.length = 0;\n            messages.length = 0;\n        } else {\n            for (i = 0; i < listeners.length; i++) {\n                this.removeEventListener(listeners[i]);\n            }\n        }\n    };\n    \n    /**\n     * This method adds an event listener to the entity.\n     *\n     * @method addEventListener\n     * @param event {String} The event that this component should listen for.\n     * @param callback {Function} The handler for the event.\n     * @return handler {Function} A reference to the bound handler.\n     * @private\n     */\n    proto.addEventListener = function (event, callback, priority) {\n        var handler = callback.bind(this);\n        \n        this.listener.events.push(event);\n        this.listener.messages.push(handler);\n        this.owner.on(event, handler, priority);\n\n        return handler;\n    };\n    \n    /**\n     * This method adds a method to the entity.\n     *\n     * @method addMethod\n     * @param name {String} The name of the method. For example, if name is \"turnYellow\", the method is accessible on the entity as `entity.turnYellow()`.\n     * @param func {Function} The function describing the method.\n     * @private\n     */\n    proto.addMethod = function (name, func) {\n        if (this.owner[name]) {\n            platypus.debug.warn(this.owner.type + ': Entity already has a method called \"' + name + '\". Method not added.');\n        } else {\n            this.owner[name] = function () {\n                return func.apply(this, arguments);\n            }.bind(this);\n            this.publicMethods[name] = func;\n        }\n    };\n\n    /**\n     * This method removes an event listener from the entity.\n     *\n     * @method removeEventListener\n     * @param event {String} The event for which to remove a listener.\n     * @param callback {Function} The listener to remove. If not supplied, all event listeners for the provided event are removed.\n     * @private\n     */\n    proto.removeEventListener = function (event, callback) {\n        var i = 0,\n            events   = this.listener.events,\n            messages = this.listener.messages;\n        \n        for (i = events.length - 1; i >= 0; i--) {\n            if ((events[i] === event) && (!callback || (messages[i] === callback))) {\n                this.owner.off(event, messages[i]);\n                Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSplice\"])(this.listener.events, i);\n                Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSplice\"])(this.listener.messages, i);\n            }\n        }\n    };\n    \n    /**\n     * This method removes a method from the entity.\n     *\n     * @method removeMethod\n     * @param name {String} The name of the method to be removed.\n     * @private\n     */\n    proto.removeMethod = function (name) {\n        if (!this.owner[name]) {\n            platypus.debug.warn(this.owner.type + ': Entity does not have a method called \"' + name + '\".');\n        } else {\n            delete this.owner[name];\n        }\n        delete this.publicMethods[name];\n    };\n\n    /**\n     * This method can be overwritten to provide the list of assets this component requires. This method is invoked when the list of game scenes is created to determine assets for each scene.\n     *\n     * @method getAssetList\n     * @param definition {Object} The definition for the component.\n     * @param properties {Object} The properties of the Entity.\n     * @param defaultProperties {Object} The default properties of the Entity.\n     * @return {Array} A list of the necessary assets to load.\n     */\n    Component.getAssetList = getAssetList;\n    \n    return Component;\n}());\n\n\n//# sourceURL=webpack://platypus/./src/Component.js?");

/***/ }),

/***/ "./src/Data.js":
/*!*********************!*\
  !*** ./src/Data.js ***!
  \*********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! config */ \"./src/config/development.js\");\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(config__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var recycle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! recycle */ \"./node_modules/recycle/recycle.js\");\n/**\n * This class defines a generic data object to use for messaging. It includes recycle methods to encourage reuse.\n *\n * @namespace platypus\n * @class Data\n * @constructor\n * @return {Data} Returns the new Data object.\n */\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    var\n        Data = function (first) {\n            var i = arguments.length,\n                key = '';\n            \n            if (first) {\n                if (typeof first === 'string') {\n                    if (i % 2) {\n                        this[i] = null;\n                        i -= 1;\n                    }\n                    while (i) {\n                        this[arguments[i - 2]] = arguments[i - 1];\n                        i -= 2;\n                    }\n                } else {\n                    for (key in first) {\n                        if (first.hasOwnProperty(key)) {\n                            this[key] = first[key];\n                        }\n                    }\n                }\n            }\n        };\n    \n    /**\n     * Returns Data from cache or creates a new one if none are available.\n     *\n     * @method Data.setUp\n     * @return {platypus.Data} The instantiated Data.\n     */\n    /**\n     * Returns Data back to the cache. Prefer the Data's recycle method since it recycles property objects as well.\n     *\n     * @method Data.recycle\n     * @param {platypus.Data} The Data to be recycled.\n     */\n    /**\n     * Relinquishes Data properties and recycles it.\n     *\n     * @method recycle\n     */\n    recycle__WEBPACK_IMPORTED_MODULE_1__[\"default\"].add(Data, 'Data', Data, function () {\n        var key = '';\n        \n        for (key in this) {\n            if (this.hasOwnProperty(key)) {\n                delete this[key];\n            }\n        }\n    }, true, config__WEBPACK_IMPORTED_MODULE_0___default.a.dev);\n    \n    return Data;\n}());\n\n//# sourceURL=webpack://platypus/./src/Data.js?");

/***/ }),

/***/ "./src/DataMap.js":
/*!************************!*\
  !*** ./src/DataMap.js ***!
  \************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _polyfills_Map_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./polyfills/Map.js */ \"./src/polyfills/Map.js\");\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! config */ \"./src/config/development.js\");\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(config__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var recycle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! recycle */ \"./node_modules/recycle/recycle.js\");\n/**\n * This class defines a generic iterable data object. It behaves similarly to Map but maintains a list of keys as an Array. It includes recycle methods to encourage reuse.\n *\n * @namespace platypus\n * @class DataMap\n * @constructor\n * @return dataMap {platypus.DataMap} Returns the new DataMap object.\n * @uses Map\n */\n/* global window */\n\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    var Map = window.Map,\n        mapSet = function (keys, key, value) {\n            if (this.get(key) !== value) {\n                if (!this.has(key)) {\n                    keys.push(key);\n                }\n                this.set(key, value);\n            }\n            return value;\n        },\n        mapDelete = function (keys, key) {\n            var i = keys.indexOf(key),\n                value = this.get(key);\n            \n            if (i >= 0) {\n                Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"greenSplice\"])(keys, i);\n                this.delete(key);\n            }\n            \n            return value;\n        },\n        mapClear = function (keys) {\n            var i = keys.length;\n            \n            while (i--) {\n                this.delete(keys[i]);\n            }\n            keys.length = 0;\n        },\n        mapToJSON = function (keys) {\n            var i = keys.length,\n                json = {};\n            \n            while (i--) {\n                json[keys[i]] = this.get(keys[i]);\n            }\n\n            return json;\n        },\n        mapMethods = {\n            get: {\n                value: null\n            },\n            has: {\n                value: null\n            },\n            keys: {\n                value: null\n            },\n            set: {\n                value: null\n            },\n            delete: {\n                value: null\n            },\n            clear: {\n                value: null\n            },\n            toJSON: {\n                value: null\n            }\n        },\n        DataMap = function (first) {\n            var i = arguments.length,\n                key = '',\n                keys = null,\n                map = null,\n                mm = null;\n            \n            if (!this.map) {\n                mm = mapMethods;\n                map = this.map = new Map();\n                \n                /**\n                 * Tracks keys on this object to make iteration faster.\n                 *\n                 * @property keys\n                 * @type Array\n                 * @default []\n                 */\n                keys = mm.keys.value = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp();\n                \n                /**\n                 * Returns the value of the provided key.\n                 *\n                 * @method get\n                 * @param key {String} The key to lookup.\n                 * @return value {any} The value of the provded key.\n                 */\n                mm.get.value = map.get.bind(map);\n                \n                /**\n                 * Determines whether the provided key is available on this DataMap.\n                 *\n                 * @method has\n                 * @param key {String} The key to lookup.\n                 * @return value {Boolean} Whether the key is listed in this DataMap.\n                 */\n                mm.has.value = map.has.bind(map);\n                \n                /**\n                 * Sets a value to a key in the DataMap.\n                 *\n                 * @method set\n                 * @param key {String} The key to associate with the provided value.\n                 * @param value {any} The value to be stored by the DataMap.\n                 * @return value {any} The value passed in is returned for chaining.\n                 */\n                mm.set.value = mapSet.bind(map, keys);\n                \n                /**\n                 * Deletes a key (and value) from the DataMap.\n                 *\n                 * @method delete\n                 * @param key {String} The key to delete from the DataMap.\n                 * @return value {any} The value of the key is returned.\n                 */\n                mm.delete.value = mapDelete.bind(map, keys);\n                \n                /**\n                 * Clears out of keys (and values) from the DataMap.\n                 *\n                 * @method clear\n                 */\n                mm.clear.value = mapClear.bind(map, keys);\n                            \n                /**\n                 * Returns a JSON object describing the component.\n                 *\n                 * @method toJSON\n                 * @return {Object} Returns a JSON definition that can be used to recreate the component.\n                 **/\n                mm.toJSON.value = mapToJSON.bind(map, keys);\n                \n                Object.defineProperties(this, mm);\n            }\n            \n            if (first) {\n                keys = first.keys;\n\n                if (typeof first === 'string') {\n                    if (i % 2) {\n                        i -= 1;\n                        this.set(arguments[i], null);\n                    }\n                    while (i) {\n                        i -= 2;\n                        this.set(arguments[i], arguments[i + 1]);\n                    }\n                } else if (keys) {\n                    i = keys.length;\n                    while (i--) {\n                        this.set(keys[i], first.get(keys[i]));\n                    }\n                } else {\n                    for (key in first) {\n                        if (first.hasOwnProperty(key)) {\n                            this.set(key, first[key]);\n                        }\n                    }\n                }\n            }\n        };\n\n    /**\n     * Returns DataMap from cache or creates a new one if none are available.\n     *\n     * @method DataMap.setUp\n     * @return dataMap {platypus.DataMap} The instantiated DataMap.\n     */\n    /**\n     * Returns DataMap back to the cache. Prefer the DataMap's recycle method since it recycles property objects as well.\n     *\n     * @method DataMap.recycle\n     * @param dataMap {platypus.DataMap} The DataMap to be recycled.\n     */\n    /**\n     * Relinquishes DataMap properties and recycles it.\n     *\n     * @method recycle\n     */\n    recycle__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(DataMap, 'DataMap', DataMap, function () {\n        this.clear();\n    }, true, config__WEBPACK_IMPORTED_MODULE_2___default.a.dev);\n    \n    return DataMap;\n}());\n\n//# sourceURL=webpack://platypus/./src/DataMap.js?");

/***/ }),

/***/ "./src/Entity.js":
/*!***********************!*\
  !*** ./src/Entity.js ***!
  \***********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var _Async_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Async.js */ \"./src/Async.js\");\n/* harmony import */ var _Data_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Data.js */ \"./src/Data.js\");\n/* harmony import */ var _Messenger_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Messenger.js */ \"./src/Messenger.js\");\n/* harmony import */ var _StateMap_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./StateMap.js */ \"./src/StateMap.js\");\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./factory.js */ \"./src/factory.js\");\n/**\n * The Entity object acts as a container for components, facilitates communication between components and other game objects, and includes properties set by components to maintain a current state. The entity object serves as the foundation for most of the game objects in the platypus engine.\n *\n * ## JSON Definition Example\n     {\n         \"id\": \"entity-id\",\n         // \"entity-id\" becomes `entity.type` once the entity is created.\n      \n         \"components\": [\n         // This array lists one or more component definition objects\n      \n             {\"type\": \"example-component\"}\n            // The component objects must include a \"type\" property corresponding to a component to load, but may also include additional properties to customize the component in a particular way for this entity.\n         ],\n      \n         \"properties\": {\n         // This object lists properties that will be attached directly to this entity.\n      \n             \"x\": 240\n             // For example, `x` becomes `entity.x` on the new entity.\n         },\n\n         \"preload\": ['image.png', 'sound.{ogg,mp3}']\n         // assets that need to be loaded before this entity loads\n     }\n *\n * @namespace platypus\n * @class Entity\n * @constructor\n * @extends Messenger\n * @param [definition] {Object} Base definition for the entity.\n * @param [definition.id] {Object} This declares the type of entity and will be stored on the Entity as `entity.type` after instantiation.\n * @param [definition.components] {Object} This lists the components that should be attached to this entity.\n * @param [definition.properties] {Object} [definition.properties] This is a list of key/value pairs that are added directly to the Entity as `entity.key = value`.\n * @param [instanceDefinition] {Object} Specific instance definition including properties that override the base definition properties.\n * @param [instanceDefinition.properties] {Object} This is a list of key/value pairs that are added directly to the Entity as `entity.key = value`.\n * @param [callback] {Function} A function to run once all of the components on the Entity have been loaded. The first parameter is the entity itself.\n * @param [parent] {Entity} Presets the parent of the entity so that the parent entity is available during component instantiation. Overrides `parent` in properties definitions.\n * @return {Entity} Returns the new entity made up of the provided components.\n**/\n/* global platypus */\n\n\n\n\n\n\n        \n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    var componentInit = function (Component, componentDefinition, callback) {\n            this.addComponent(new Component(this, componentDefinition, callback));\n        },\n        entityIds = {};\n\n    class Entity extends _Messenger_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"] {\n        constructor (definition, instanceDefinition, callback, parent) {\n            var i                    = 0,\n                componentDefinition  = null,\n                componentInits       = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(),\n                def                  = _Data_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(definition),\n                componentDefinitions = def.components,\n                defaultProperties    = _Data_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(def.properties),\n                instance             = _Data_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(instanceDefinition),\n                instanceProperties   = _Data_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(instance.properties),\n                savedEvents          = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n\n            // Set properties of messenger on this entity.\n            super();\n\n            this.components  = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n            this.type = def.id || 'none';\n\n            this.id = instance.id || instanceProperties.id;\n            if (this.id) { // check to make sure auto-ids don't overlap.\n                if (this.id.search(this.type + '-') === 0) {\n                    i = parseInt(this.id.substring(this.id.search('-') + 1), 10);\n                    if (!isNaN(i) && (!entityIds[this.type] || (entityIds[this.type] <= i))) {\n                        entityIds[this.type] = i + 1;\n                    }\n                }\n            } else {\n                if (!entityIds[this.type]) {\n                    entityIds[this.type] = 0;\n                }\n                this.id = this.type + '-' + entityIds[this.type];\n                entityIds[this.type] += 1;\n            }\n\n            this.setProperty(defaultProperties); // This takes the list of properties in the JSON definition and appends them directly to the object.\n            this.setProperty(instanceProperties); // This takes the list of options for this particular instance and appends them directly to the object.\n            this.on('set-property', function (keyValuePairs) {\n                this.setProperty(keyValuePairs);\n            }.bind(this));\n\n            this.state = _StateMap_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].setUp(this.state); //starts with no state information. This expands with boolean value properties entered by various logic components.\n            this.lastState = _StateMap_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].setUp(); //This is used to determine if the state of the entity has changed.\n            \n            if (parent) {\n                this.parent = parent;\n            }\n\n            this.trigger = this.triggerEvent = function (trigger, ...args) {\n                savedEvents.push(trigger.bind(this, ...args));\n\n                return -1; // Message has not been delivered yet.\n            }.bind(this, this.trigger);\n            \n            if (componentDefinitions) {\n                for (i = 0; i < componentDefinitions.length; i++) {\n                    componentDefinition = componentDefinitions[i];\n                    if (componentDefinition) {\n                        if (componentDefinition.type) {\n                            if (platypus.components[componentDefinition.type]) {\n                                componentInits.push(componentInit.bind(this, platypus.components[componentDefinition.type], componentDefinition));\n                            } else {\n                                platypus.debug.warn('Entity \"' + this.type + '\": Component \"' + componentDefinition.type + '\" is not defined.', componentDefinition);\n                            }\n                        } else if (componentDefinition.id) { // \"type\" not specified, so we create the component directly.\n                            componentInits.push(componentInit.bind(this, Object(_factory_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(componentDefinition), null));\n                        } else if (typeof componentDefinition === 'function') {\n                            componentInits.push(componentInit.bind(this, componentDefinition, null));\n                        } else {\n                            platypus.debug.warn('Entity \"' + this.type + '\": Component must have an `id` or `type` value.', componentDefinition);\n                        }\n                    }\n                }\n            }\n            this.loadingComponents = _Async_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp(componentInits, function () {\n                this.loadingComponents = null;\n\n                // Trigger saved events that were being fired during component addition.\n                delete this.trigger;\n                delete this.triggerEvent;\n                for (let i = 0; i < savedEvents.length; i++) {\n                    savedEvents[i]();\n                }\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(savedEvents);\n\n                /**\n                 * The entity triggers `load` on itself once all the properties and components have been attached, notifying the components that all their peer components are ready for messages.\n                 *\n                 * @event load\n                 */\n                this.triggerEvent('load');\n\n                if (callback) {\n                    callback(this);\n                }\n            }.bind(this));\n            \n            _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(componentInits);\n            def.recycle();\n            defaultProperties.recycle();\n            instance.recycle();\n            instanceProperties.recycle();\n        }\n\n        /**\n        * Returns a string describing the entity.\n        *\n        * @method toString\n        * @return {String} Returns the entity type as a string of the form \"[Entity entity-type]\".\n        **/\n        toString () {\n            return \"[Entity \" + this.type + \"]\";\n        }\n        \n        /**\n        * Returns a JSON object describing the entity.\n        *\n        * @method toJSON\n        * @param includeComponents {Boolean} Whether the returned JSON should list components. Defaults to `false` to condense output since components are generally defined in `platypus.game.settings.entities`, but may be needed for custom-constructed entities not so defined.\n        * @return {Object} Returns a JSON definition that can be used to recreate the entity.\n        **/\n        toJSON (includeComponents) {\n            var components = this.components,\n                definition = {\n                    properties: {\n                        id: this.id,\n                        state: this.state.toJSON()\n                    }\n                },\n                i = 0,\n                json = null,\n                properties = definition.properties;\n            \n            if (includeComponents) {\n                definition.id = this.type;\n                definition.components = [];\n            } else {\n                definition.type = this.type;\n            }\n\n            for (i = 0; i < components.length; i++) {\n                json = components[i].toJSON(properties);\n                if (includeComponents && json) {\n                    definition.components.push(json);\n                }\n            }\n\n            return definition;\n        }\n        \n        /**\n        * Attaches the provided component to the entity.\n        *\n        * @method addComponent\n        * @param {platypus.Component} component Must be an object that functions as a Component.\n        * @return {platypus.Component} Returns the same object that was submitted.\n        **/\n        addComponent (component) {\n            this.components.push(component);\n\n            /**\n             * The entity triggers `component-added` on itself once a component has been attached, notifying other components of their peer component.\n             *\n             * @event component-added\n             * @param {platypus.Component} component The added component.\n             * @param {String} component.type The type of component.\n             **/\n            this.triggerEvent('component-added', component);\n            return component;\n        }\n        \n        /**\n        * Removes the mentioned component from the entity.\n        *\n        * @method removeComponent\n        * @param {Component} component Must be a [[Component]] attached to the entity.\n        * @return {Component} Returns the same object that was submitted if removal was successful; otherwise returns false (the component was not found attached to the entity).\n        **/\n        removeComponent (component) {\n            var i = 0;\n            \n            /**\n             * The entity triggers `component-removed` on itself once a component has been removed, notifying other components of their peer component's removal.\n             *\n             * @event component-removed\n             * @param {Component} component The removed component.\n             * @param {String} component.type The type of component.\n             **/\n            if (typeof component === 'string') {\n                for (i = 0; i < this.components.length; i++) {\n                    if (this.components[i].type === component) {\n                        component = this.components[i];\n                        Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSplice\"])(this.components, i);\n                        this.triggerEvent('component-removed', component);\n                        component.destroy();\n                        return component;\n                    }\n                }\n            } else {\n                for (i = 0; i < this.components.length; i++) {\n                    if (this.components[i] === component) {\n                        Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSplice\"])(this.components, i);\n                        this.triggerEvent('component-removed', component);\n                        component.destroy();\n                        return component;\n                    }\n                }\n            }\n            \n            return false;\n        }\n        \n        /**\n        * This method sets one or more properties on the entity.\n        *\n        * @param {Object} properties A list of key/value pairs to set as properties on the entity.\n        * @method setProperty\n        **/\n        setProperty (properties) {\n            var index = '';\n            \n            for (index in properties) { // This takes a list of properties and appends them directly to the object.\n                if (properties.hasOwnProperty(index)) {\n                    this[index] = properties[index];\n                }\n            }\n        }\n        \n        /**\n        * This method removes all components from the entity.\n        *\n        * @method destroy\n        **/\n        destroy () {\n            var components = this.components;\n            \n            if (!this._destroyed) {\n                while (components.length) {\n                    components[0].destroy();\n                    components.shift();\n                }\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(components);\n                this.components = null;\n                \n                this.state.recycle();\n                this.state = null;\n                \n                this.lastState.recycle();\n                this.lastState = null;\n                \n                super.destroy();\n            }\n        }\n        \n        /**\n         * Returns all of the assets required for this Entity. This method calls the corresponding method on all components to determine the list of assets.\n         *\n         * @method getAssetList\n         * @param definition {Object} The definition for the Entity.\n         * @param properties {Object} Properties for this instance of the Entity.\n         * @param data {Object} Layer data that affects asset list.\n         * @return {Array} A list of the necessary assets to load.\n         */\n        static getAssetList (def, props, data) {\n            var i = 0,\n                component = null,\n                arr = null,\n                assets = null,\n                definition = null;\n            \n            if (def.type) {\n                definition = platypus.game.settings.entities[def.type];\n                if (!definition) {\n                    platypus.debug.warn('Entity \"' + def.type + '\": This entity is not defined.', def);\n                    return _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n                }\n                return Entity.getAssetList(definition, def.properties, data);\n            }\n            \n            assets = Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"union\"])(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(), def.preload);\n\n            for (i = 0; i < def.components.length; i++) {\n                component = def.components[i] && def.components[i].type && platypus.components[def.components[i].type];\n                if (component) {\n                    arr = component.getAssetList(def.components[i], def.properties, props, data);\n                    Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"union\"])(assets, arr);\n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(arr);\n                }\n            }\n            \n            return assets;\n        }\n    }\n    \n    return Entity;\n}());\n\n\n//# sourceURL=webpack://platypus/./src/Entity.js?");

/***/ }),

/***/ "./src/Game.js":
/*!*********************!*\
  !*** ./src/Game.js ***!
  \*********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var springroll__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! springroll */ \"springroll\");\n/* harmony import */ var springroll__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(springroll__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pixi.js */ \"pixi.js\");\n/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(pixi_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var _Async_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Async.js */ \"./src/Async.js\");\n/* harmony import */ var _Data_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Data.js */ \"./src/Data.js\");\n/* harmony import */ var _Entity_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Entity.js */ \"./src/Entity.js\");\n/* harmony import */ var _Messenger_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Messenger.js */ \"./src/Messenger.js\");\n/* harmony import */ var _SFXPlayer_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./SFXPlayer.js */ \"./src/SFXPlayer.js\");\n/* harmony import */ var pixi_sound__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! pixi-sound */ \"pixi-sound\");\n/* harmony import */ var pixi_sound__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(pixi_sound__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var _Storage_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Storage.js */ \"./src/Storage.js\");\n/* harmony import */ var _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @tweenjs/tween.js */ \"@tweenjs/tween.js\");\n/* harmony import */ var _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_10__);\n/* harmony import */ var _VOPlayer_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./VOPlayer.js */ \"./src/VOPlayer.js\");\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! config */ \"./src/config/development.js\");\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(config__WEBPACK_IMPORTED_MODULE_12__);\n/* harmony import */ var _sayHello_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./sayHello.js */ \"./src/sayHello.js\");\n/**\n * This class is used to create the `platypus.game` object and loads the Platypus game as described by the game configuration files.\n *\n * Configuration definition typically takes something like the following structures, but is highly dependent on the particular components used in a given game:\n *\n *     {\n *         \"atlases\": {}, // Keyed list of Spine atlases.\n *         \"captions\": {}, // Keyed list of captions for closed captioning.\n *         \"entities\": {}, // Keyed list of entity definitions.\n *         \"levels\": {}, // Keyed list of Tiled levels.\n *         \"mouthCues\": {}, // Keyed list of Rhubarb mouth cues for lip synch.\n *         \"scenes\": {}, // Keyed list of scene definitions.\n *         \"skeletons\": {}, // Keyed list of Spine skeletons.\n *         \"spriteSheets\": {} // Keyed list of sprite sheet definitions.\n *     }\n *\n * Options may include any of these:\n *\n *     {\n *         audio: '', // Relative path to audio assets (like \"assets/audio/\").\n *         canvasId: '', // HTML element ID for the canvas to draw to. If specified but unfound, will create a canvas with this ID.\n *         display: {}, // Display options are passed directly to PixiJS for setting up the renderer.\n *         features: { // Features supported for the Springroll application. Defaults are listed below.\n *             sfx: true,\n *             vo: true,\n *             music: true,\n *             sound: true,\n *             captions: true\n *         },\n *         images: '', // Relative path to graphical assets (like \"assets/images/\").\n *         name: '', // Name of game. Used for local storage keys and displayed in the console on run.\n *         storageKeys: [] // Array of keys to create in local storage on first run so game code may assume they exist.\n *         version: '' // Version of the game. This is displayed in the console on run.\n *     }\n *\n * @namespace platypus\n * @class Game\n * @constructor\n * @param definition {Object} Collection of configuration settings, typically from config.json.\n * @param options {Object} Options describing the display options, Springroll features, etc.\n * @param [onFinishedLoading] {Function} An optional function to run once the game has begun.\n * @return {platypus.Game} Returns the instantiated game.\n */\n/* global document, platypus, window */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    const XMLHttpRequest = window.XMLHttpRequest,\n        getJSON = function (path, callback) {\n            var xhr = new XMLHttpRequest();\n            \n            xhr.open('GET', path, true);\n            xhr.responseType = 'text';\n            xhr.onload = function () {\n                var obj = null;\n                \n                if (xhr.status === 200) {\n                    try {\n                        obj = JSON.parse(xhr.responseText);\n                    } catch (e) {\n                        platypus.debug.warn('Error parsing \"' + path + '\": ' + e.message);\n                    }\n                } else {\n                    platypus.debug.warn('Error opening \"' + path + '\": ' + xhr.description);\n                }\n                \n                callback(obj);\n            };\n            xhr.send();\n        },\n        loadJSONLinks = function (obj, callback) {\n            var i = 0,\n                key = '',\n                callbacks = 0,\n                resolve = function () {\n                    callbacks -= 1;\n                    if (!callbacks) {\n                        callback(obj);\n                    }\n                },\n                assign = function (obj, i, callback) {\n                    loadJSONLinks(obj[i], function (result) {\n                        obj[i] = result;\n                        callback(result);\n                    });\n                };\n            \n            if (obj) {\n                if (Array.isArray(obj)) {\n                    callbacks = obj.length;\n                    if (callbacks) {\n                        for (i = 0; i < obj.length; i++) {\n                            assign(obj, i, resolve);\n                        }\n                    } else {\n                        callback(obj);\n                    }\n                    return;\n                } else if (typeof obj === 'object') {\n                    if (obj.src && (obj.src.length > 5) && (obj.src.substring(obj.src.length - 5).toLowerCase() === '.json')) {\n                        loadJSONLinks(obj.src, function (result) {\n                            if (obj.src !== result) {\n                                obj = result;\n                            }\n                            callback(obj);\n                        });\n                    } else {\n                        for (key in obj) {\n                            if (obj.hasOwnProperty(key)) {\n                                callbacks += 1;\n                            }\n                        }\n                        if (callbacks) {\n                            for (key in obj) {\n                                if (obj.hasOwnProperty(key)) {\n                                    assign(obj, key, resolve);\n                                }\n                            }\n                        } else {\n                            callback(obj);\n                        }\n                    }\n                    return;\n                } else if ((typeof obj === 'string') && (obj.length > 5) && (obj.substring(obj.length - 5).toLowerCase() === '.json')) {\n                    getJSON(obj, function (result) {\n                        if (typeof result === 'object') {\n                            loadJSONLinks(result, callback);\n                        } else {\n                            callback(result);\n                        }\n                    });\n                    return;\n                }\n            }\n            \n            callback(obj);\n        },\n        setUpFPS = function (ticker, canvas) {\n            var framerate = document.createElement(\"div\"),\n                framerateTimer = 0;\n\n            framerate.id = \"framerate\";\n            framerate.innerHTML = \"FPS: 00.000\";\n            canvas.parentNode.insertBefore(framerate, canvas);\n\n            ticker.add(function () {\n                framerateTimer += this.deltaMS;\n\n                // Only update the framerate every second\n                if (framerateTimer >= 1000) {\n                    framerate.innerHTML = \"FPS: \" + this.FPS.toFixed(3);\n                    framerateTimer = 0;\n                }\n            }.bind(ticker));\n        };\n\n    class Game extends _Messenger_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"] {\n        constructor (definition, options, onFinishedLoading) {\n            const\n                displayOptions = options.display || {},\n                load = function (displayOptions, settings) {\n                    const\n                        dpi = window.devicePixelRatio || 1,\n                        ticker = pixi_js__WEBPACK_IMPORTED_MODULE_1__[\"Ticker\"].shared;\n                        \n                    platypus.game = this; //Make this instance the only Game instance.\n                    \n                    if (config__WEBPACK_IMPORTED_MODULE_12___default.a.dev) {\n                        settings.debug = true;\n                    }\n                    \n                    this.settings = settings;\n\n                    if (settings.captions) {\n                        const captionsElement = document.getElementById(\"captions\") || (function (canvas) {\n                            const element = document.createElement('div');\n                            \n                            element.setAttribute('id', 'captions');\n                            canvas.parentNode.insertBefore(element, canvas);\n                            return element;\n                        }(this.canvas));\n                        this.voPlayer.captions = new springroll__WEBPACK_IMPORTED_MODULE_0__[\"CaptionPlayer\"](settings.captions, new springroll__WEBPACK_IMPORTED_MODULE_0__[\"TextRenderer\"](captionsElement));\n                    }\n\n                    this.stage = new pixi_js__WEBPACK_IMPORTED_MODULE_1__[\"Container\"]();\n                    this.renderer = new pixi_js__WEBPACK_IMPORTED_MODULE_1__[\"Renderer\"]({\n                        width: this.canvas.width,\n                        height: this.canvas.height,\n                        view: this.canvas,\n                        transparent: !!displayOptions.transparent,\n                        antialias: !!displayOptions.antiAlias,\n                        preserveDrawingBuffer: !!displayOptions.preserveDrawingBuffer,\n                        clearBeforeRender: !!displayOptions.clearView,\n                        backgroundColor: displayOptions.backgroundColor || 0,\n                        autoResize: false\n                    });\n\n                    if (displayOptions.aspectRatio) { // Aspect ratio may be a single value like \"4:3\" or \"4:3-2:1\" for a range\n                        const\n                            aspectRatioRange = displayOptions.aspectRatio.split('-'),\n                            ratioArray1 = aspectRatioRange[0].split(':'),\n                            ratioArray2 = aspectRatioRange[aspectRatioRange.length - 1].split(':'),\n                            ratio1 = ratioArray1[0] / ratioArray1[1],\n                            ratio2 = ratioArray2[0] / ratioArray2[1],\n                            smallRatio = Math.min(ratio1, ratio2),\n                            largeRatio = Math.max(ratio1, ratio2);\n\n                        this.scaleManager = new springroll__WEBPACK_IMPORTED_MODULE_0__[\"ScaleManager\"](({width, height/*, ratio*/}) => {\n                            const\n                                renderer = this.renderer,\n                                frame = document.getElementById('content'),\n                                newHeight = (width / smallRatio) >> 0,\n                                newWidth = (height * largeRatio) >> 0;\n                            let h = height * dpi,\n                                w = width * dpi;\n                \n                            if (height > newHeight) {\n                                frame.style.height = newHeight + 'px';\n                                frame.style.top = (((height - newHeight) / 2) >> 0) + 'px';\n                                frame.style.width = '';\n                                frame.style.left = '';\n                                h = newHeight * dpi;\n                            } else if (width > newWidth) {\n                                frame.style.width = newWidth + 'px';\n                                frame.style.left = (((width - newWidth) / 2) >> 0) + 'px';\n                                frame.style.height = '';\n                                frame.style.top = '';\n                                w = newWidth * dpi;\n                            } else {\n                                frame.style.height = '';\n                                frame.style.top = '';\n                                frame.style.width = '';\n                                frame.style.left = '';\n                            }\n\n                            renderer.resize(w, h);\n                            renderer.render(this.stage); // to prevent flickering from canvas adjustment.\n                        });\n                    } else {\n                        this.scaleManager = new springroll__WEBPACK_IMPORTED_MODULE_0__[\"ScaleManager\"](({width, height/*, ratio*/}) => {\n                            const\n                                renderer = this.renderer;\n\n                            renderer.resize(width * dpi, height * dpi);\n                            renderer.render(this.stage); // to prevent flickering from canvas adjustment.\n                        });\n                    }\n                    this.scaleManager.onResize({ // Run once to resize content div.\n                        target: window\n                    });\n\n                    if (onFinishedLoading) {\n                        onFinishedLoading(this);\n                    }\n\n                    if (!settings.hideHello) {\n                        Object(_sayHello_js__WEBPACK_IMPORTED_MODULE_13__[\"default\"])(this);\n                    }\n\n                    platypus.debug.general(\"Game config loaded.\", settings);\n\n                    //Add Debug tools\n                    window.getEntityById = function (id) {\n                        return this.getEntityById(id);\n                    }.bind(this);\n    \n                    window.getEntitiesByType = function (type) {\n                        return this.getEntitiesByType(type);\n                    }.bind(this);\n                    \n                    window.getVisibleSprites = function (c, a) {\n                        var i = 0;\n                        \n                        a = a || _utils_array_js__WEBPACK_IMPORTED_MODULE_2__[\"arrayCache\"].setUp();\n                        c = c || this.stage;\n                        \n                        if (!c.texture && c.visible) {\n                            for (i = 0; i < c.children.length; i++) {\n                                window.getVisibleSprites(c.children[i], a);\n                            }\n                            return a;\n                        } else if (c.visible) {\n                            a.push(c);\n                            return a;\n                        }\n                        return a;\n                    }.bind(this);\n\n                    this.ticker = ticker;\n                    this.tickInstance = this.tick.bind(this, ticker, {\n                        delta: 0, // standard, backwards-compatible parameter for `deltaMS`\n                        deltaMS: 0, // MS from last frame (matches above)\n                        deltaTime: 0, // PIXI ticker frame value\n                        elapsed: 0 // MS since game start (minus pauses)\n                    });\n\n                    // START GAME!\n                    ticker.add(this.tickInstance);\n                    this.paused = false;\n\n                    if (config__WEBPACK_IMPORTED_MODULE_12___default.a.dev) {\n                        setUpFPS(ticker, this.canvas);\n                    }\n                };\n            let canvas = null;\n            \n            super();\n\n            if (!definition) {\n                platypus.debug.warn('No game definition is supplied. Game not created.');\n                return;\n            }\n\n            this.options = options;\n\n            // Get or set canvas.\n            if (options.canvasId) {\n                canvas = window.document.getElementById(options.canvasId);\n            }\n            if (!canvas) {\n                canvas = window.document.createElement('canvas');\n                window.document.body.appendChild(canvas);\n                if (options.canvasId) {\n                    canvas.setAttribute('id', options.canvasId);\n                }\n            }\n            canvas.width = canvas.offsetWidth;\n            canvas.height = canvas.offsetHeight;\n\n            // Fix for MS Edge so that \"no-drag\" icon doesn't appear on drag.\n            canvas.ondragstart = function () {\n                return false;\n            };\n\n            this.canvas = canvas;\n\n            this.voPlayer = new _VOPlayer_js__WEBPACK_IMPORTED_MODULE_11__[\"default\"](this, platypus.assetCache);\n            this.voPlayer.trackSound = platypus.supports.iOS;\n\n            this.sfxPlayer = new _SFXPlayer_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"]();\n            \n            this.springroll = (function () {\n                const\n                    springroll = new springroll__WEBPACK_IMPORTED_MODULE_0__[\"Application\"]({\n                        features: options.features || {\n                            sfx: true,\n                            vo: true,\n                            music: true,\n                            sound: true,\n                            captions: true\n                        }\n                    }),\n                    state = springroll.state;\n\n                state.pause.subscribe(function (current) {\n                    if (current) {\n                        if (!this.paused) {\n                            this.ticker.remove(this.tickInstance);\n                            this.paused = true;\n                            pixi_sound__WEBPACK_IMPORTED_MODULE_8___default.a.pauseAll();\n                        }\n                    } else {\n                        if (this.paused) {\n                            this.ticker.add(this.tickInstance);\n                            this.paused = false;\n                            pixi_sound__WEBPACK_IMPORTED_MODULE_8___default.a.resumeAll();\n                        }\n                    }\n                }.bind(this));\n                \n                state.soundVolume.subscribe(function () {\n                    /* SR seems to trigger this too aggressively, in that it already calls mute/unmute on the comprising sfx/music/vo channels. We rely on the others instead. */\n                });\n                \n                state.musicVolume.subscribe((current) => {\n                    if (!current) {\n                        this.triggerOnChildren('mute-music');\n                    } else {\n                        this.triggerOnChildren('unmute-music');\n                    }\n                });\n                \n                state.voVolume.subscribe(function (current) {\n                    platypus.game.voPlayer.setVolume(current);\n                });\n\n                state.captionsMuted.subscribe(function (current) {\n                    platypus.game.voPlayer.setCaptionMute(current);\n                });\n                \n                state.sfxVolume.subscribe(function (current) {\n                    platypus.game.sfxPlayer.setVolume(current);\n                });\n\n                this.storage = new _Storage_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"](springroll, options);\n\n                return springroll;\n            }.bind(this))();\n\n            this.layers = _utils_array_js__WEBPACK_IMPORTED_MODULE_2__[\"arrayCache\"].setUp();\n            this.sceneLayers = _utils_array_js__WEBPACK_IMPORTED_MODULE_2__[\"arrayCache\"].setUp();\n            this.loading = _utils_array_js__WEBPACK_IMPORTED_MODULE_2__[\"arrayCache\"].setUp();\n            this.loadingQueue = _utils_array_js__WEBPACK_IMPORTED_MODULE_2__[\"arrayCache\"].setUp();\n\n            if (typeof definition === 'string') {\n                loadJSONLinks(definition, load.bind(this, displayOptions));\n            } else {\n                load.bind(this)(displayOptions, definition);\n            }\n        }\n        \n        /**\n         * This method causes the game to tick once.\n         *\n         * @method tick\n         * @param ticker {PIXI.Ticker} The ticker being used to set the game tick.\n         * @param tickMessage {Object} Event tracking tick data.\n         * @param deltaTime {number} The time elapsed since the last tick.\n         **/\n        tick (ticker, tickMessage, deltaTime) {\n            const loading = this.loading;\n\n            tickMessage.delta = tickMessage.deltaMS = ticker.deltaMS;\n            tickMessage.deltaTime = deltaTime;\n            tickMessage.elapsed += ticker.deltaMS;\n\n            // If layers need to be loaded, load them!\n            if (loading.length) {\n                for (let i = 0; i < loading.length; i++) {\n                    loading[i]();\n                }\n                loading.length = 0;\n            }\n\n            _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_10___default.a.update();\n\n            /**\n             * This event is triggered on the game as well as each layer currently loaded.\n             *\n             * @method tick\n             * @param tickMessage {Object} Event tracking tick data. This object is re-used for subsequent ticks.\n             * @param tickMessage.delta {Number} Time in MS passed since last tick.\n             * @param tickMessage.elapsed {Number} Time in MS passed since game load.\n             **/\n            this.triggerEvent('tick', tickMessage);\n            this.triggerOnChildren('tick', tickMessage);\n            this.renderer.render(this.stage);\n        }\n\n        /**\n         * This method is used by external objects to trigger messages on the layers as well as internal entities broadcasting messages across the scope of the scene.\n         *\n         * @method triggerOnChildren\n         * @param {String} eventId This is the message to process.\n         * @param {*} event This is a message object or other value to pass along to component functions.\n         **/\n        triggerOnChildren (...args) {\n            const layers = this.layers;\n\n            for (let i = 0; i < layers.length; i++) {\n                layers[i].trigger(...args);\n            }\n        }\n        \n        /**\n         * Loads one or more layers.\n         *\n         * If one layer is specified, it will complete loading if no other layers are already loading. If other layers are presently loading, it will complete as soon as other layers are complete.\n         *\n         * If an array of layers is specified, all layers must finish loading before any receive a completion event.\n         *\n         * @method load\n         * @param layerId {Array|String} The layer(s) to load.\n         * @param data {Object} A list of key/value pairs describing options or settings for the loading scene.\n         * @param isScene {Boolean} Whether the layers from a previous scene should be replaced by these layers.\n         * @param progressIdOrFunction {String|Function} Whether to report progress. A string sets the id of progress events whereas a function is called directly with progress.\n        **/\n        load (layerId, data, isScene, progressIdOrFunction) {\n            this.loadingQueue.push(layerId);\n            // Delay load so it doesn't begin a scene mid-tick.\n            this.loading.push(() => {\n                const\n                    layers = Array.isArray(layerId) ? Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_2__[\"greenSlice\"])(layerId) : _utils_array_js__WEBPACK_IMPORTED_MODULE_2__[\"arrayCache\"].setUp(layerId),\n                    assets = _utils_array_js__WEBPACK_IMPORTED_MODULE_2__[\"arrayCache\"].setUp(),\n                    properties = _utils_array_js__WEBPACK_IMPORTED_MODULE_2__[\"arrayCache\"].setUp(),\n                    loader = _utils_array_js__WEBPACK_IMPORTED_MODULE_2__[\"arrayCache\"].setUp((callback) => {\n                        const\n                            queue = this.loadingQueue,\n                            index = queue.indexOf(layerId);\n\n                        // Make sure previous layers have already gone live.\n                        if (index === 0) {\n                            queue.shift();\n                            callback();\n                            while (typeof queue[0] === 'function') {\n                                const prevCallback = queue[0];\n                                queue.shift();\n                                prevCallback();\n                            }\n                        } else { // Not the next in line, so we'll handle this later. (ie bracket above on another group of layers completion)\n                            queue[index] = callback;\n                        }\n                    }),\n                    getDefinition = (layer) => {\n                        const id = layer ? layer.type || layer : null;\n\n                        let layerDefinition = null;\n                        \n                        if (!id) {\n                            platypus.debug.warn('Game: A layer id or layer definition must be provided to load a layer.');\n                            return null;\n                        } else if (typeof id === 'string') {\n                            if (!this.settings.entities[id]) {\n                                platypus.debug.warn('Game: A layer with the id \"' + id + '\" has not been defined in the game settings.');\n                                return null;\n                            }\n                            layerDefinition = this.settings.entities[id];\n                        } else {\n                            layerDefinition = layer;\n                        }\n\n                        return layerDefinition;\n                    },\n                    loadAssets = function (layerDefinitions, properties, data, assetLists, progressCallback, completeCallback) {\n                        const assets = _utils_array_js__WEBPACK_IMPORTED_MODULE_2__[\"arrayCache\"].setUp();\n        \n                        for (let i = 0; i < layerDefinitions.length; i++) {\n                            const\n                                props = _Data_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].setUp(properties[i]),\n                                arr = assetLists[i] = _Entity_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].getAssetList(layerDefinitions[i], props, data);\n\n                            for (let j = 0; j < arr.length; j++) {\n                                assets.push(arr[j]); // We don't union so that we can remove individual layers as needed and their asset dependencies.\n                            }\n                            props.recycle();\n                        }\n\n                        platypus.assetCache.load(assets, progressCallback, completeCallback);\n                    },\n                    loadLayer = function (layers, assetLists, index, layerDefinition, properties, data, completeCallback) {\n                        const props = _Data_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].setUp(properties);\n        \n                        props.stage = this.stage;\n                        props.parent = this;\n\n                        if (layerDefinition) { // Load layer\n                            const\n                                holds = _Data_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].setUp('count', 1, 'release', () => {\n                                    holds.count -= 1;\n                                    if (!holds.count) { // All holds have been released\n                                        holds.recycle();\n                                        \n                                        completeCallback();\n                                    }\n                                }),\n                                layer = new _Entity_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"](layerDefinition, {\n                                    properties: props\n                                }, (entity) => {\n                                    layers[index] = entity;\n                                    holds.release();\n                                });\n        \n                            layer.unloadLayer = () => {\n                                const\n                                    release = () => {\n                                        holds -= 1;\n                                        if (holds === 0) {\n                                            // Delay load so it doesn't end a layer mid-tick.\n                                            window.setTimeout(() => {\n                                                /**\n                                                 * This event is triggered on the layers once the Scene is over.\n                                                 *\n                                                 * @event 'layer-unloaded'\n                                                 */\n                                                layer.triggerEvent('layer-unloaded');\n    \n                                                platypus.debug.olive('Layer unloaded: ' + layer.id);\n                                    \n                                                Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_2__[\"greenSplice\"])(this.layers, this.layers.indexOf(layer));\n    \n                                                layer.destroy();\n                                                platypus.assetCache.unload(assetLists[index]);\n                                                _utils_array_js__WEBPACK_IMPORTED_MODULE_2__[\"arrayCache\"].recycle(assetLists[index]);\n                                            }, 1);\n                                        }\n                                    };\n                                let holds = 1;\n    \n                                /**\n                                 * This event is triggered on the layer to allow children of the layer to place a hold on the closing until they're ready.\n                                 *\n                                 * @event 'unload-layer'\n                                 * @param data {Object} A list of key-value pairs of data sent into this Scene from the previous Scene.\n                                 * @param hold {Function} Calling this function places a hold; `release` must be called to release this hold and unload the layer.\n                                 * @param release {Function} Calling this function releases a previous hold.\n                                 */\n                                layer.triggerEvent('unload-layer', () => {\n                                    holds += 1;\n                                }, release);\n    \n                                platypus.debug.olive('Layer unloading: ' + layer.id);\n                                release();\n                            };\n                            \n                            /**\n                             * This event is triggered on the layers once all assets have been readied and the layer is created.\n                             *\n                             * @event 'layer-loaded'\n                             * @param data {Object} A list of key-value pairs of data sent into this Scene from the previous Scene.\n                             */\n                            layer.triggerEvent('layer-loaded', data, holds);\n                        }\n                    },\n                    progressHandler = progressIdOrFunction ? ((typeof progressIdOrFunction === 'string') ? function (progress, ratio) {\n                        progress.progress = ratio;\n                        this.triggerOnChildren('load-progress', progress);\n                    }.bind(this, _Data_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].setUp(\n                        'id', progressIdOrFunction,\n                        'progress', 0\n                    )) : progressIdOrFunction) : null;\n\n                for (let i = 0; i < layers.length; i++) {\n                    const\n                        layer = layers[i],\n                        layerDefinition = getDefinition(layer),\n                        layerProps = (layer && layer.type && layer.properties) || null;\n\n                    loader.push(loadLayer.bind(this, layers, assets, i, layerDefinition, layerProps, data));\n                    layers[i] = layerDefinition;\n                    properties[i] = layerProps;\n                }\n\n                loadAssets(layers, properties, data, assets, progressHandler, () => {\n                    _Async_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].setUp(loader, () => {\n                        for (let i = 0; i < layers.length; i++) {\n                            const layer = layers[i];\n\n                            this.layers.push(layer);\n\n                            if (isScene) {\n                                this.sceneLayers.push(layer);\n                            }\n\n                            platypus.debug.olive('Layer live: ' + layer.id);\n    \n                            /**\n                             * This event is triggered on each newly-live layer once it is finished loading and ready to display.\n                             *\n                             * @event 'layer-live'\n                             * @param data {Object} A list of key-value pairs of data sent into this Scene from the previous Scene.\n                             */\n                            layer.triggerEvent('layer-live', data);\n                        }\n                    });\n                });\n            });\n        }\n\n        /**\n         * Loads a scene.\n         *\n         * @method loadScene\n         * @param layersOrId {Array|Object|String} The list of layers, an object with a `layers` Array property, or scene id to load.\n         * @param data {Object} A list of key/value pairs describing options or settings for the loading scene.\n         **/\n        loadScene (layersOrId, data) {\n            const sceneLayers = this.sceneLayers;\n            let layers = layersOrId;\n            \n            if (typeof layers === 'string') {\n                layers = this.settings.scenes && this.settings.scenes[layers];\n            }\n\n            if (!layers) {\n                platypus.debug.warn('Game: \"' + layersOrId + '\" is an invalid scene.');\n                return;\n            }\n\n            if (layers.layers) { // Object containing a list of layers.\n                layers = layers.layers;\n            }\n            \n            while (sceneLayers.length) {\n                this.unload(sceneLayers[0]);\n            }\n\n            this.load(layers, data, true, 'scene');\n        }\n        \n        /**\n         * Unloads a layer.\n         *\n         * @method unload\n         * @param layer {String|Object} The layer to unload.\n        **/\n        unload (layer) {\n            let layerToUnload = layer,\n                sceneIndex = 0;\n\n            if (typeof layerToUnload === 'string') {\n                for (let i = 0; i < this.layers.length; i++) {\n                    if (this.layers[i].type === layerToUnload) {\n                        layerToUnload = this.layers[i];\n                        break;\n                    }\n                }\n            }\n\n            sceneIndex = this.sceneLayers.indexOf(layerToUnload); // remove scene entry if it exists\n            if (sceneIndex >= 0) {\n                Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_2__[\"greenSplice\"])(this.sceneLayers, sceneIndex);\n            }\n\n            layerToUnload.unloadLayer();\n        }\n        \n        /**\n         * This method will return the first entity it finds with a matching id.\n         *\n         * @method getEntityById\n         * @param {string} id The entity id to find.\n         * @return {Entity} Returns the entity that matches the specified entity id.\n         **/\n        getEntityById (id) {\n            var i = 0,\n                selection = null;\n            \n            for (i = 0; i < this.layers.length; i++) {\n                if (this.layers[i].id === id) {\n                    return this.layers[i];\n                }\n                if (this.layers[i].getEntityById) {\n                    selection = this.layers[i].getEntityById(id);\n                    if (selection) {\n                        return selection;\n                    }\n                }\n            }\n            return null;\n        }\n\n        /**\n         * This method will return all game entities that match the provided type.\n         *\n         * @method getEntitiesByType\n         * @param {String} type The entity type to find.\n         * @return entities {Array} Returns the entities that match the specified entity type.\n         **/\n        getEntitiesByType (type) {\n            var i = 0,\n                selection = null,\n                entities  = _utils_array_js__WEBPACK_IMPORTED_MODULE_2__[\"arrayCache\"].setUp();\n            \n            for (i = 0; i < this.layers.length; i++) {\n                if (this.layers[i].type === type) {\n                    entities.push(this.layers[i]);\n                }\n                if (this.layers[i].getEntitiesByType) {\n                    selection = this.layers[i].getEntitiesByType(type);\n                    Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_2__[\"union\"])(entities, selection);\n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_2__[\"arrayCache\"].recycle(selection);\n                }\n            }\n            return entities;\n        }\n        \n        /**\n        * This method destroys the game.\n        *\n        * @method destroy\n        **/\n        destroy () {\n            const layers = this.layers;\n\n            for (let i = 0; i < layers.length; i++) {\n                layers[i].destroy();\n            }\n            layers.recycle();\n        }\n    }\n    \n    return Game;\n}());\n\n//# sourceURL=webpack://platypus/./src/Game.js?");

/***/ }),

/***/ "./src/Messenger.js":
/*!**************************!*\
  !*** ./src/Messenger.js ***!
  \**************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! config */ \"./src/config/development.js\");\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(config__WEBPACK_IMPORTED_MODULE_1__);\n/**\n * The Messenger object facilitates communication between components and other game objects. Messenger is currently used by [Entity](platypus.Entity.html) and [EntityContainer](platypus.components.EntityContainer).\n *\n * @namespace platypus\n * @class Messenger\n */\n/* global platypus, window */\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    var debug = config__WEBPACK_IMPORTED_MODULE_1___default.a.dev,\n        perfTools = debug && window.performance && window.performance.mark && window.performance.measure && window.performance, // End with this to set perfTools to window.performance\n        runBoth = function (f1, f2) {\n            return function () {\n                f1.apply(this, arguments);\n                f2.apply(this, arguments);\n            };\n        };\n\n    class Messenger {\n        constructor () {\n            this._listeners = {};\n            this._destroyed = false;\n            this.loopCheck = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n        }\n\n        /**\n         * Add an event listener. The parameters for the listener functions depend on the event.\n         *\n         * @method on\n         * @param name {String} The type of event.\n         * @param callback {Function} The callback function when event is triggered.\n         */\n        on (name, callback) {\n            var listener = this._listeners[name] = this._listeners[name] || [];\n\n            if (this._destroyed) return;\n\n            if (listener.indexOf(callback) === -1) {\n                listener.push(callback);\n            }\n        }\n\n        /**\n         * Remove the event listener\n         *\n         * @method off\n         * @param name {String} The type of event; if no name is specifed remove all listeners.\n         * @param callback {Function} The listener function.\n         */\n        off (name, callback) {\n            var listener = this._listeners[name],\n                index = 0;\n\n            if (this._destroyed || !listener) return;\n\n            // remove all\n            if (typeof name === 'undefined') {\n                this._listeners = {};\n            } else {\n                // remove all listeners for that event\n                if (typeof callback === 'undefined') {\n                    listener.length = 0;\n                } else {\n                    //remove single listener\n                    index = listener.indexOf(callback);\n                    if (index !== -1) {\n                        listener.splice(index, 1);\n                    }\n                }\n            }\n        }\n\n        /**\n         * Returns a string describing the Messenger as \"[Messenger object]\".\n         *\n         * @method toString\n         * @return String\n         */\n        toString () {\n            return \"[Messenger Object]\";\n        }\n\n        /**\n         * This method is used by both internal components and external entities to trigger messages. When triggered, Messenger checks through bound handlers to run as appropriate. This handles multiple event structures: \"\", [], and {}\n         *\n         * @method trigger\n         * @param event {String|Array|Object} This is the message(s) to process. This can be a string, an object containing an \"event\" property (and optionally a \"message\" property, overriding the value below), or an array of the same.\n         * @param value {*} This is a message object or other value to pass along to event handler.\n         * @param debug {boolean} This flags whether to output message contents and subscriber information to the console during game development. A \"value\" object parameter (above) will also set this flag if value.debug is set to true.\n         * @return {number} The number of handlers for the triggered message.\n         */\n        trigger (events, message, debug) {\n            var args = null,\n                i = 0,\n                count = 0,\n                msg = message,\n                indexOf = 0,\n                splitEvents = null;\n            \n            if (typeof events === 'string') {\n                indexOf = events.indexOf(\" \");\n                if (indexOf === -1) {\n                    return this.triggerEvent.apply(this, arguments);\n                } else {\n                    splitEvents = events.split(\" \");\n                    args = Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSlice\"])(arguments);\n                    for (i = 0; i < splitEvents.length; i++) {\n                        args[0] = splitEvents[i];\n                        count += this.triggerEvent.apply(this, args);\n                    }\n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(args);\n                    return count;\n                }\n            } else if (Array.isArray(events)) {\n                args = Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSlice\"])(arguments);\n                for (i = 0; i < events.length; i++) {\n                    args[0] = events[i];\n                    count += this.trigger.apply(this, args);\n                }\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(args);\n                return count;\n            } else if (events.event) {\n                if (typeof events.message !== 'undefined') {\n                    msg = events.message;\n                }\n                return this.triggerEvent(events.event, msg, events.debug || debug);\n            } else {\n                platypus.debug.warn('Event incorrectly formatted: must be string, array, or object containing an \"event\" property.', events);\n                return 0;\n            }\n        }\n        \n        /**\n         * This method is used by both internal components and external entities to trigger messages on this entity. When triggered, entity checks through bound handlers to run as appropriate. This method is identical to Spring Roll's [EventDispatcher.trigger](http://springroll.io/SpringRoll/docs/classes/springroll.EventDispatcher.html#method_trigger), but uses alternative Array methods to alleviate excessive GC.\n         *\n         * @method triggerEvent\n         * @param event {String} This is the message to process.\n         * @param [value] {*} This is a message object or other value to pass along to event handler.\n         * @param [value.debug] {boolean} This flags whether to output message contents and subscriber information to the console during game development.\n         * @return {number} The number of handlers for the triggered message.\n         */\n        triggerEvent (type) {\n            var count = 0,\n                i = 0,\n                listener = null,\n                listeners = this._listeners,\n                args = null;\n            \n            if (!this._destroyed && listeners.hasOwnProperty(type) && (listeners[type])) {\n                // copy the listeners array; reusing `listeners` variable\n                listeners = Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSlice\"])(listeners[type]);\n\n                if (arguments.length > 1) {\n                    args = Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSlice\"])(arguments);\n                    args.shift();\n                }\n\n                count = i = listeners.length;\n                while (i--) {\n                    listener = listeners[i];\n                    if (listener._eventDispatcherOnce) {\n                        delete listener._eventDispatcherOnce;\n                        this.off(type, listener);\n                    }\n                    listener.apply(this, args);\n                }\n                \n                if (args) {\n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(args);\n                }\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(listeners);\n            }\n            \n            return count;\n        }\n        \n        /**\n         * This method returns all the messages that this entity is concerned about.\n         *\n         * @method getMessageIds\n         * @return {Array} An array of strings listing all the messages for which this Messenger has handlers.\n         */\n        getMessageIds () {\n            return Object.keys(this._listeners);\n        }\n        \n        /**\n         * This method relinguishes Messenger properties\n         *\n         * @method destroy\n         */\n        destroy () {\n            _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.loopCheck);\n            this.loopCheck = null;\n            this._destroyed = true;\n            this._listeners = null;\n        }\n\n        /**\n         * Adds Messenger functionality to a Class.\n         *\n         * @method Messenger.mixin\n         * @param {Class|Function} ClassObject The class to add Messenger behavior to.\n         */\n        static mixin (ClassObject) {\n            var key = '',\n                fromProto = Messenger.prototype,\n                toProto = ClassObject.prototype,\n                methods = Object.getOwnPropertyNames(fromProto),\n                i = methods.length;\n\n            while (i--) {\n                key = methods[i];\n                if (key !== 'constructor') {\n                    if (toProto[key]) {\n                        toProto[key] = runBoth(toProto[key], fromProto[key]);\n                    } else {\n                        toProto[key] = fromProto[key];\n                    }\n                }\n            }\n        }\n\n        /**\n         * Call this method in an Object's instantiation if `Messenger.mixin` has been called on its Class.\n         *\n         * @method Messenger.mixin\n         * @param {Object} object The object for which Messenger should be instantiated.\n         */\n        static initialize (object) {\n            object._listeners = {};\n            object._destroyed = false;\n            object.loopCheck = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n        }\n    }\n\n    // Add logging checks for development mode.\n    if (debug) {\n        Messenger.prototype._triggerEvent = Messenger.prototype.triggerEvent;\n        Messenger.prototype.triggerEvent = function (event, value) {\n            var i = 0,\n                debugLimit = 5,\n                debugLogging = value && value.debug,\n                debugCount = 0,\n                count = 0;\n            \n            // Debug logging.\n            if (debugLogging || this.debug) {\n                for (i = 0; i < this.loopCheck.length; i++) {\n                    if (this.loopCheck[i] === event) {\n                        debugCount += 1;\n                        if (debugCount > debugLimit) {\n                            throw \"Endless loop detected for '\" + event + \"'.\";\n                        } else {\n                            platypus.debug.warn(\"Event '\" + event + \"' is nested inside another '\" + event + \"' event.\");\n                        }\n                    }\n                }\n\n                this.loopCheck.push(event);\n                if (perfTools) {\n                    perfTools.mark(\"a\");\n                }\n                count = this._triggerEvent.apply(this, arguments);\n                if (perfTools) {\n                    perfTools.mark(\"b\");\n                    perfTools.measure(this.type + \":\" + event, 'a', 'b');\n                }\n                this.loopCheck.length = this.loopCheck.length - 1;\n                if (debugLogging) {\n                    if (count) {\n                        platypus.debug.olive('Entity \"' + this.type + '\": Event \"' + event + '\" has ' + count + ' subscriber' + ((count > 1) ? 's' : '') + '.', value);\n                    } else {\n                        platypus.debug.warn('Entity \"' + this.type + '\": Event \"' + event + '\" has no subscribers.', value);\n                    }\n                }\n                return count;\n            } else {\n                return this._triggerEvent.apply(this, arguments);\n            }\n        };\n    }\n    \n    return Messenger;\n}());\n\n\n//# sourceURL=webpack://platypus/./src/Messenger.js?");

/***/ }),

/***/ "./src/PIXIAnimation.js":
/*!******************************!*\
  !*** ./src/PIXIAnimation.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pixi.js */ \"pixi.js\");\n/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(pixi_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var _Data_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Data.js */ \"./src/Data.js\");\n/**\n * This class plays animation sequences of frames and mimics the syntax required for creating CreateJS Sprites, allowing CreateJS Sprite Sheet definitions to be used with PixiJS.\n *\n * @class PIXIAnimation\n */\n/*global platypus */\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    var MAX_KEY_LENGTH_PER_IMAGE = 128,\n        animationCache = {},\n        baseTextureCache = {},\n        doNothing = function () {},\n        emptyFrame = pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Texture\"].EMPTY,\n        regex = /[\\[\\]{},-]/g,\n        getBaseTextures = function (images) {\n            var i = 0,\n                bts = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp(),\n                asset = null,\n                assetCache = platypus.assetCache,\n                btCache = baseTextureCache,\n                path = null;\n            \n            for (i = 0; i < images.length; i++) {\n                path = images[i];\n                if (typeof path === 'string') {\n                    if (!btCache[path]) {\n                        asset = assetCache.get(path);\n                        if (!asset) {\n                            platypus.debug.warn('\"' + path + '\" is not a loaded asset.');\n                            break;\n                        }\n                        btCache[path] = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"BaseTexture\"](asset);\n                    }\n                    bts.push(btCache[path]);\n                } else {\n                    bts.push(new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"BaseTexture\"](path));\n                }\n            }\n            \n            return bts;\n        },\n        getTexturesCacheId = function (spriteSheet) {\n            var i = 0;\n            \n            if (spriteSheet.id) {\n                return spriteSheet.id;\n            }\n            \n            for (i = 0; i < spriteSheet.images.length; i++) {\n                if (typeof spriteSheet.images[i] !== 'string') {\n                    return '';\n                }\n            }\n            \n            spriteSheet.id = JSON.stringify(spriteSheet).replace(regex, '');\n\n            return spriteSheet.id;\n        },\n        getDefaultAnimation = function (length, textures) {\n            var frames = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp(),\n                i = 0;\n            \n            for (i = 0; i < length; i++) {\n                frames.push(textures[i] || emptyFrame);\n            }\n            return _Data_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(\n                \"id\", \"default\",\n                \"frames\", frames,\n                \"next\", \"default\",\n                \"speed\", 1\n            );\n        },\n        standardizeAnimations = function (def, textures) {\n            var animation = '',\n                anims = _Data_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(),\n                i = 0,\n                frames = null,\n                key = '';\n            \n            for (key in def) {\n                if (def.hasOwnProperty(key)) {\n                    animation = def[key];\n                    frames = Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"greenSlice\"])(animation.frames);\n                    i = frames.length;\n                    while (i--) {\n                        frames[i] = textures[frames[i]] || emptyFrame;\n                    }\n                    anims[key] = _Data_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(\n                        \"id\", key,\n                        \"frames\", frames,\n                        \"next\", animation.next,\n                        \"speed\", animation.speed\n                    );\n                }\n            }\n\n            if (!anims.default) {\n                // Set up a default animation that plays through all frames\n                anims.default = getDefaultAnimation(textures.length, textures);\n            }\n            \n            return anims;\n        },\n        getAnimations = function (spriteSheet) {\n            var i = 0,\n                anims    = null,\n                frame    = null,\n                frames   = spriteSheet.frames,\n                images   = spriteSheet.images,\n                textures = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp(),\n                bases    = getBaseTextures(images);\n\n            // Set up texture for each frame\n            for (i = 0; i < frames.length; i++) {\n                frame = frames[i];\n                textures.push(new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Texture\"](bases[frame[4]], new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Rectangle\"](frame[0], frame[1], frame[2], frame[3]), null, null, 0, new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Point\"]((frame[5] || 0) / frame[2], (frame[6] || 0) / frame[3])));\n            }\n\n            // Set up animations\n            anims = standardizeAnimations(spriteSheet.animations, textures);\n\n            // Set up a default animation that plays through all frames\n            if (!anims.default) {\n                anims.default = getDefaultAnimation(textures.length, textures);\n            }\n            \n            _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].recycle(bases);\n            \n            return _Data_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(\n                \"textures\", textures,\n                \"animations\", anims\n            );\n        },\n        cacheAnimations = function (spriteSheet, cacheId) {\n            var i = 0,\n                anims    = null,\n                frame    = null,\n                frames   = spriteSheet.frames,\n                images   = spriteSheet.images,\n                textures = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp(),\n                bases    = getBaseTextures(images);\n\n            // Set up texture for each frame\n            for (i = 0; i < frames.length; i++) {\n                frame = frames[i];\n                textures.push(new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Texture\"](bases[frame[4]], new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Rectangle\"](frame[0], frame[1], frame[2], frame[3]), null, null, 0, new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Point\"]((frame[5] || 0) / frame[2], (frame[6] || 0) / frame[3])));\n            }\n\n            // Set up animations\n            anims = standardizeAnimations(spriteSheet.animations, textures);\n\n            _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].recycle(bases);\n            \n            return _Data_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(\n                \"textures\", textures,\n                \"animations\", anims,\n                \"viable\", 1,\n                \"cacheId\", cacheId\n            );\n        },\n        PIXIAnimation = function (spriteSheet, animation) {\n            var FR = 60,\n                cacheId = getTexturesCacheId(spriteSheet),\n                cache = (cacheId ? animationCache[cacheId] : null),\n                speed = (spriteSheet.framerate || FR) / FR;\n\n            if (!cacheId) {\n                cache = getAnimations(spriteSheet);\n            } else if (!cache) {\n                cache = animationCache[cacheId] = cacheAnimations(spriteSheet, cacheId);\n                this.cacheId = cacheId;\n            } else {\n                cache.viable += 1;\n                this.cacheId = cacheId;\n            }\n\n            pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Container\"].call(this); //, cache.textures[0].texture\n        \n            /**\n            * @private\n            */\n            this._animations = {};\n            for (const key in cache.animations) {\n                if (cache.animations[key].frames.length === 1) {\n                    this._animations[key] = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Sprite\"](cache.animations[key].frames[0]);\n                } else {\n                    const anim = this._animations[key] = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"AnimatedSprite\"](cache.animations[key].frames);\n\n                    anim.animationSpeed = speed * cache.animations[key].speed;\n                    anim.onComplete = anim.onLoop = function (animation, properties) {\n                        if (this.onComplete) {\n                            this.onComplete(animation);\n                        }\n                        if (properties.next) {\n                            this.gotoAndPlay(properties.next);\n                        }\n                    }.bind(this, key, cache.animations[key]);\n                    anim.updateAnchor = true;\n                }\n            }\n            \n            this._animation = null;\n        \n            /**\n            * The speed that the PIXIAnimation will play at. Higher is faster, lower is slower\n            *\n            * @member {number}\n            * @default 1\n            */\n            this.animationSpeed = speed;\n\n            /**\n             * The currently playing animation name.\n             *\n             * @property currentAnimation\n             * @default \"\"\n             * @type String\n             */\n            this.currentAnimation = null;\n        \n            /**\n            * Indicates if the PIXIAnimation is currently playing\n            *\n            * @member {boolean}\n            * @readonly\n            */\n            this.playing = false;\n            \n            this._visible = true;\n            \n            this._updating = false;\n\n            /*\n            * Updates the object transform for rendering\n            * @private\n            */\n            this.update = doNothing;\n\n            // Set up initial playthrough.\n            this.gotoAndPlay(animation);\n        },\n        prototype = PIXIAnimation.prototype = Object.create(pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Container\"].prototype);\n    \n    PIXIAnimation.prototype.constructor = PIXIAnimation;\n    \n    Object.defineProperties(prototype, {\n        /**\n        * The visibility of the sprite.\n        *\n        * @property visible\n        * @memberof PIXI.DisplayObject#\n        */\n        visible: {\n            get: function () {\n                return this._visible;\n            },\n            set: function (value) {\n                this._visible = value;\n            }\n        },\n        \n        /**\n        * The PIXIAnimations paused state. If paused, the animation doesn't update.\n        *\n        * @property paused\n        */\n        paused: {\n            get: function () {\n                return !this.playing;\n            },\n            set: function (value) {\n                if ((value && this.playing) || (!value && !this.playing)) {\n                    this.playing = !value;\n                }\n            }\n        }\n    \n    });\n    \n    /**\n    * Stops the PIXIAnimation\n    *\n    * @method stop\n    */\n    prototype.stop = function () {\n        this.paused = true;\n    };\n    \n    /**\n    * Plays the PIXIAnimation\n    *\n    * @method play\n    */\n    prototype.play = function () {\n        this.paused = false;\n    };\n    \n    /**\n    * Stops the PIXIAnimation and goes to a specific frame\n    *\n    * @method gotoAndStop\n    * @param animation {number} frame index to stop at\n    */\n    prototype.gotoAndStop = function (animation) {\n        this.stop();\n        if (this._animation && this._animation.stop) {\n            this._animation.stop();\n        }\n    \n        this._animation = this._animations[animation];\n        if (!this._animation) {\n            this._animation = this._animations.default;\n        }\n        this.removeChildren();\n        this.addChild(this._animation);\n    };\n    \n    /**\n    * Goes to a specific frame and begins playing the PIXIAnimation\n    *\n    * @method gotoAndPlay\n    * @param animation {string} The animation to begin playing.\n    * @param [loop = true] {Boolean} Whether this animation should loop.\n    * @param [restart = true] {Boolean} Whether to restart the animation if it's currently playing.\n    */\n    prototype.gotoAndPlay = function (animation, loop = true, restart = true) {\n        if ((this.currentAnimation !== animation) || restart) {\n            if (this._animation && this._animation.stop) {\n                this._animation.stop();\n            }\n            this._animation = this._animations[animation];\n            this.currentAnimation = animation;\n            if (!this._animation) {\n                this._animation = this._animations.default;\n                this.currentAnimation = 'default';\n            }\n            this.removeChildren();\n            this.addChild(this._animation);\n        }\n\n        this._animation.loop = loop;\n        \n        if (this._animation.play) {\n            this._animation.play();\n        }\n        this.play();\n    };\n    \n    /**\n    * Returns whether a particular animation is available.\n    *\n    * @method has\n    * @param animation {string} The animation to check.\n    */\n    prototype.has = function (animation) {\n        return !!this._animations[animation];\n    };\n    \n    /**\n     * Stops the PIXIAnimation and destroys it\n     *\n     * @method destroy\n     */\n    prototype.destroy = function () {\n        var key = '';\n        \n        this.stop();\n        if (this._animation && this._animation.stop) {\n            this._animation.stop();\n        }\n        pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Container\"].prototype.destroy.call(this);\n        if (this.cacheId) {\n            animationCache[this.cacheId].viable -= 1;\n            if (animationCache[this.cacheId].viable <= 0) {\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].recycle(animationCache[this.cacheId].textures);\n                for (key in animationCache[this.cacheId].animations) {\n                    if (animationCache[this.cacheId].animations.hasOwnProperty(key)) {\n                        _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].recycle(animationCache[this.cacheId].animations[key].frames);\n                    }\n                }\n                delete animationCache[this.cacheId];\n            }\n        }\n    };\n    \n    PIXIAnimation.EmptySpriteSheet = {\n        framerate: 60,\n        frames: [],\n        images: [],\n        animations: {},\n        recycleSpriteSheet: function () {\n            // We don't recycle this sprite sheet.\n        }\n    };\n    \n    /**\n     * This method formats a provided value into a valid PIXIAnimation Sprite Sheet. This includes accepting the EaselJS spec, strings mapping to Platypus sprite sheets, or arrays of either.\n     *\n     * @method PIXIAnimation.formatSpriteSheet\n     * @param spriteSheet {String|Array|Object} The value to cast to a valid Sprite Sheet.\n     * @return {Object}\n     */\n    PIXIAnimation.formatSpriteSheet = (function () {\n        var imageParts = /([\\w-]+)\\.(\\w+)$/,\n            addAnimations = function (source, destination, speedRatio, firstFrameIndex, id) {\n                var key = '';\n                \n                for (key in source) {\n                    if (source.hasOwnProperty(key)) {\n                        if (destination[key]) {\n                            _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].recycle(destination[key].frames);\n                            destination[key].recycle();\n                            platypus.debug.olive('PIXIAnimation \"' + id + '\": Overwriting duplicate animation for \"' + key + '\".');\n                        }\n                        destination[key] = formatAnimation(key, source[key], speedRatio, firstFrameIndex);\n                    }\n                }\n            },\n            addFrameObject = function (source, destination, firstImageIndex, bases) {\n                var i = 0,\n                    fw = source.width,\n                    fh = source.height,\n                    rx = source.regX || 0,\n                    ry = source.regY || 0,\n                    w = 0,\n                    h = 0,\n                    x = 0,\n                    y = 0;\n                \n                for (i = 0; i < bases.length; i++) {\n                    \n                    // Subtract the size of a frame so that margin slivers aren't returned as frames.\n                    w = bases[i].realWidth - fw;\n                    h = bases[i].realHeight - fh;\n                    \n                    for (y = 0; y <= h; y += fh) {\n                        for (x = 0; x <= w; x += fw) {\n                            destination.push([x, y, fw, fh, i + firstImageIndex, rx, ry]);\n                        }\n                    }\n                }\n            },\n            addFrameArray = function (source, destination, firstImageIndex) {\n                var frame = null,\n                    i = 0;\n                \n                for (i = 0; i < source.length; i++) {\n                    frame = source[i];\n                    destination.push(_utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp(\n                        frame[0],\n                        frame[1],\n                        frame[2],\n                        frame[3],\n                        frame[4] + firstImageIndex,\n                        frame[5],\n                        frame[6]\n                    ));\n                }\n            },\n            createId = function (images) {\n                var i = images.length,\n                    id = '',\n                    segment = '',\n                    separator = '';\n\n                while (i--) {\n                    segment = images[i].src || images[i];\n                    id += separator + segment.substring(0, MAX_KEY_LENGTH_PER_IMAGE);\n                    separator = ',';\n                }\n\n                return id;\n            },\n            format = function (source, destination) {\n                var bases = null,\n                    dAnims = destination.animations,\n                    dImages = destination.images,\n                    dFR = destination.framerate || 60,\n                    dFrames = destination.frames,\n                    i = 0,\n                    images = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp(),\n                    firstImageIndex = dImages.length,\n                    firstFrameIndex = dFrames.length,\n                    sAnims = source.animations,\n                    sImages = source.images,\n                    sFR = source.framerate || 60,\n                    sFrames = source.frames;\n                \n                // Set up id\n                if (destination.id) {\n                    destination.id += ';' + (source.id || createId(source.images));\n                } else {\n                    destination.id = source.id || createId(source.images);\n                }\n                \n                // Set up images array\n                for (i = 0; i < sImages.length; i++) {\n                    images.push(formatImages(sImages[i]));\n                    dImages.push(images[i]);\n                }\n\n                // Set up frames array\n                if (Array.isArray(sFrames)) {\n                    addFrameArray(sFrames, dFrames, firstImageIndex);\n                } else {\n                    bases = getBaseTextures(images);\n                    addFrameObject(sFrames, dFrames, firstImageIndex, bases);\n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].recycle(bases);\n                }\n                \n                // Set up animations object\n                addAnimations(sAnims, dAnims, sFR / dFR, firstFrameIndex, destination.id);\n                \n                _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].recycle(images);\n                \n                return destination;\n            },\n            formatAnimation = function (key, animation, speedRatio, firstFrameIndex) {\n                var i = 0,\n                    first = 0,\n                    frames = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp(),\n                    last = 0;\n                \n                if (typeof animation === 'number') {\n                    frames.push(animation + firstFrameIndex);\n                    return _Data_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(\n                        \"frames\", frames,\n                        \"next\", key,\n                        \"speed\", speedRatio\n                    );\n                } else if (Array.isArray(animation)) {\n                    first = animation[0] || 0;\n                    last = (animation[1] || first) + 1 + firstFrameIndex;\n                    first += firstFrameIndex;\n                    for (i = first; i < last; i++) {\n                        frames.push(i);\n                    }\n                    return _Data_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(\n                        \"frames\", frames,\n                        \"next\", animation[2] || key,\n                        \"speed\", (animation[3] || 1) * speedRatio\n                    );\n                } else {\n                    for (i = 0; i < animation.frames.length; i++) {\n                        frames.push(animation.frames[i] + firstFrameIndex);\n                    }\n                    return _Data_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(\n                        \"frames\", frames,\n                        \"next\", animation.next || key,\n                        \"speed\", (animation.speed || 1) * speedRatio\n                    );\n                }\n            },\n            formatImages = function (name) {\n                var match = false;\n                \n                if (typeof name === 'string') {\n                    match = name.match(imageParts);\n\n                    if (match) {\n                        return match[1];\n                    }\n                }\n\n                return name;\n            },\n            recycle = function () {\n                var animations = this.animations,\n                    key = '';\n                \n                for (key in animations) {\n                    if (animations.hasOwnProperty(key)) {\n                        _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].recycle(animations[key].frames);\n                    }\n                    animations[key].recycle();\n                }\n                \n                _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].recycle(this.frames, 2);\n                this.frames = null;\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].recycle(this.images);\n                this.images = null;\n                this.recycle();\n            },\n            merge = function (spriteSheets, destination) {\n                var i = spriteSheets.length,\n                    ss = null;\n                \n                while (i--) {\n                    ss = spriteSheets[i];\n                    if (typeof ss === 'string') {\n                        ss = platypus.game.settings.spriteSheets[ss];\n                    }\n                    if (ss) {\n                        format(ss, destination);\n                    }\n                }\n                \n                return destination;\n            };\n        \n        return function (spriteSheet) {\n            var response = PIXIAnimation.EmptySpriteSheet,\n                ss = spriteSheet;\n            \n            if (typeof ss === 'string') {\n                ss = platypus.game.settings.spriteSheets[spriteSheet];\n            }\n            \n            if (ss) {\n                response = _Data_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(\n                    \"animations\", _Data_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(),\n                    \"framerate\", 60,\n                    \"frames\", _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp(),\n                    \"id\", '',\n                    \"images\", _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp(),\n                    \"recycleSpriteSheet\", recycle\n                );\n                    \n                if (Array.isArray(ss)) {\n                    return merge(ss, response);\n                } else if (ss) {\n                    return format(ss, response);\n                }\n            }\n\n            return response;\n        };\n    }());\n\n    return PIXIAnimation;\n}());\n\n\n//# sourceURL=webpack://platypus/./src/PIXIAnimation.js?");

/***/ }),

/***/ "./src/SFXPlayer.js":
/*!**************************!*\
  !*** ./src/SFXPlayer.js ***!
  \**************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return SFXPlayer; });\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var pixi_sound__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pixi-sound */ \"pixi-sound\");\n/* harmony import */ var pixi_sound__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(pixi_sound__WEBPACK_IMPORTED_MODULE_1__);\n/**\n * This component plays sfx audio and manages Springroll volume changes.\n *\n * @namespace platypus\n * @class SFXPlayer\n */\n/* global platypus */\n\n\n\nclass SFXPlayer {\n    constructor () {\n        this.volume = 1;\n        this.player = pixi_sound__WEBPACK_IMPORTED_MODULE_1___default.a;\n        this.playingAudio = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n        this.sounds = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n    }\n\n    /**\n     * Plays a sound.\n     *\n     * @param {String} sound Sound Id to play.\n     * @param {Object} data PixiSound data to inform sound playback.\n     * @return {pixiSound.MediaInstance} The media instance of the playing sound.\n     * @public\n     */\n    play (sound, data) {\n        const\n            audio = this.player.play(sound, data);\n\n        audio.initialVolume = audio.volume;\n        audio.set('volume', audio.initialVolume * this.volume);\n        this.playingAudio.push(audio);\n        this.sounds.push(sound);\n        audio.on('end', () => {\n            const index = this.playingAudio.indexOf(audio);\n\n            Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSplice\"])(this.playingAudio, index);\n            Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSplice\"])(this.sounds, index);\n        });\n\n        return audio;\n    }\n\n    /**\n     * Plays a sound.\n     *\n     * @param {pixiSound.MediaInstance} audio Audio to stop.\n     * @public\n     */\n    stop (audio) {\n        const index = this.playingAudio.indexOf(audio);\n\n        audio.stop();\n        if (index >= 0) {\n            Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSplice\"])(this.playingAudio, index);\n            Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSplice\"])(this.sounds, index);\n        } else {\n            platypus.debug.warn('SFXPlayer: Did not find \"' + audio.soundId + '\"');\n        }\n    }\n\n    /**\n     * Sets volume on all playing sound effects.\n     *\n     * @param {Number} volume A value between 0-1 to set volume on all playing sound effects.\n     * @public\n     */\n    setVolume (volume) {\n        const\n            playingAudio = this.playingAudio;\n\n        this.volume = volume;\n        for (let i = 0; i < playingAudio.length; i++) {\n            const\n                audio = playingAudio[i];\n\n            audio.set('volume', audio.initialVolume * this.volume);\n        }\n    }\n\n    /**\n     * Cleans up this SFXPlayer.\n     * @method destroy\n     * @public\n     */\n    destroy () {\n        _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.playingAudio);\n        this.playingAudio = null;\n        _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.sounds);\n        this.sounds = null;\n    }\n};\n\n\n//# sourceURL=webpack://platypus/./src/SFXPlayer.js?");

/***/ }),

/***/ "./src/StateMap.js":
/*!*************************!*\
  !*** ./src/StateMap.js ***!
  \*************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _DataMap_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DataMap.js */ \"./src/DataMap.js\");\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! config */ \"./src/config/development.js\");\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(config__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _utils_string_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/string.js */ \"./src/utils/string.js\");\n/* harmony import */ var recycle__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! recycle */ \"./node_modules/recycle/recycle.js\");\n/**\n * This class defines a state object to use for entity states with helper methods. It includes recycle methods to encourage reuse.\n *\n * @namespace platypus\n * @class StateMap\n * @constructor\n * @return stateMap {platypus.StateMap} Returns the new StateMap object.\n * @extends platypus.DataMap\n */\n\n\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    var StateMap = function (first) {\n            var l = arguments.length;\n            \n            if (l) {\n                if ((l === 1) && (typeof first === 'string')) {\n                    _DataMap_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].call(this);\n                    this.updateFromString(first);\n                } else {\n                    _DataMap_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].apply(this, arguments);\n                }\n            } else {\n                _DataMap_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].call(this);\n            }\n        },\n        parent = _DataMap_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].prototype,\n        proto = StateMap.prototype = Object.create(parent);\n\n    Object.defineProperty(StateMap.prototype, 'constructor', {\n        configurable: true,\n        writable: true,\n        value: StateMap\n    });\n        \n    /**\n     * Sets the state using the provided string value which is a comma-delimited list such that `\"blue,red,!green\"` sets the following state values:\n     *\n     *      {\n     *          red: true,\n     *          blue: true,\n     *          green: false\n     *      }\n     *\n     * @method updateFromString\n     * @param states {String} A comma-delimited list of true/false state values.\n     * @chainable\n     */\n    Object.defineProperty(proto, 'updateFromString', {\n        value: function (states) {\n            var arr = Object(_utils_string_js__WEBPACK_IMPORTED_MODULE_3__[\"greenSplit\"])(states, ','),\n                i = arr.length,\n                str = '';\n            \n            while (i--) {\n                str = arr[i];\n                if (str) {\n                    if (str.substr(0, 1) === '!') {\n                        this.set(str.substr(1), false);\n                    } else {\n                        this.set(str, true);\n                    }\n                }\n            }\n            \n            _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].recycle(arr);\n            \n            return this;\n        }\n    });\n    \n    /**\n     * Checks whether the provided state matches this state and updates this state to match.\n     *\n     * @method update\n     * @param state {platypus.StateMap} The state that this state should match.\n     * @return {Boolean} Whether this state already matches the provided state.\n     */\n    Object.defineProperty(proto, 'update', {\n        value: function (newState) {\n            var keys = newState.keys,\n                i = keys.length,\n                state   = '',\n                changed = false,\n                value = false;\n            \n            while (i--) {\n                state = keys[i];\n                value = newState.get(state);\n                if (this.get(state) !== value) {\n                    this.set(state, value);\n                    changed = true;\n                }\n            }\n            \n            return changed;\n        }\n    });\n    \n    /**\n     * Checks whether the provided state matches all equivalent keys on this state.\n     *\n     * @method includes\n     * @param state {platypus.StateMap} The state that this state should match.\n     * @return {Boolean} Whether this state matches the provided state.\n     */\n    Object.defineProperty(proto, 'includes', {\n        value: function (otherState) {\n            var keys = otherState.keys,\n                i = keys.length,\n                state = '';\n            \n            while (i--) {\n                state = keys[i];\n                if (this.get(state) !== otherState.get(state)) {\n                    return false;\n                }\n            }\n            \n            return true;\n        }\n    });\n    \n    /**\n     * Checks whether the provided state matches any equivalent keys on this state.\n     *\n     * @method intersects\n     * @param state {platypus.StateMap} The state that this state should intersect.\n     * @return {Boolean} Whether this state intersects the provided state.\n     */\n    Object.defineProperty(proto, 'intersects', {\n        value: function (otherState) {\n            var keys = otherState.keys,\n                i = keys.length,\n                state = '';\n            \n            while (i--) {\n                state = keys[i];\n                if (this.get(state) === otherState.get(state)) {\n                    return true;\n                }\n            }\n            \n            return false;\n        }\n    });\n    \n    /**\n     * Returns StateMap from cache or creates a new one if none are available.\n     *\n     * @method StateMap.setUp\n     * @return stateMap {platypus.StateMap} The instantiated StateMap.\n     */\n    /**\n     * Returns StateMap back to the cache. Prefer the StateMap's recycle method since it recycles property objects as well.\n     *\n     * @method StateMap.recycle\n     * @param stateMap {platypus.StateMap} The StateMap to be recycled.\n     */\n    /**\n     * Relinquishes StateMap properties and recycles it.\n     *\n     * @method recycle\n     */\n    recycle__WEBPACK_IMPORTED_MODULE_4__[\"default\"].add(StateMap, 'StateMap', StateMap, function () {\n        this.clear();\n    }, true, config__WEBPACK_IMPORTED_MODULE_2___default.a.dev);\n    \n    return StateMap;\n}());\n\n//# sourceURL=webpack://platypus/./src/StateMap.js?");

/***/ }),

/***/ "./src/Storage.js":
/*!************************!*\
  !*** ./src/Storage.js ***!
  \************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Storage; });\n/* harmony import */ var _DataMap_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DataMap.js */ \"./src/DataMap.js\");\n/* harmony import */ var springroll__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! springroll */ \"springroll\");\n/* harmony import */ var springroll__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(springroll__WEBPACK_IMPORTED_MODULE_1__);\n/**\n * This class is used to create the Platypus storage system accessible at `platypus.storage`. It uses Springroll UserData if available, with a fallback to local storage if not.\n *\n * @namespace platypus\n * @class Storage\n * @constructor\n * @return {Data} Returns the new Storage object.\n */\n/* global platypus, window */\n\n\n\nclass Storage {\n    constructor (springroll, options) {\n        const\n            gameId = options.name,\n            storageKey = gameId + '-data',\n            unconnectedData = window.localStorage.getItem(storageKey),\n            keys = options.storageKeys || null,\n            handleData = (resp) => {\n                if (resp && resp.data) {\n                    const data = resp.data;\n\n                    for (const key in data) {\n                        if (data.hasOwnProperty(key)) {\n                            if (this.map.has(key)) {\n                                this.map.set(key, data[key]);\n                            } else {\n                                this.addKey(key, data[key]);\n                            }\n                        }\n                    }\n                }\n            };\n\n        this.map = _DataMap_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp();\n\n        /**\n         * The storage key being used to store data.\n         *\n         * @property storageKey\n         * @type String\n         * @default options.name+'-data'\n         */\n        this.storageKey = storageKey;\n\n        /**\n         * Whether Springroll is connected to a hosting page.\n         *\n         * @property connected\n         * @type Boolean\n         * @default false\n         */\n        this.connected = false;\n\n        if (keys) {\n            for (let i = 0; i < keys.length; i++) {\n                this.addKey(keys[i], null);\n            }\n        }\n\n        try { // May throw if data is not parseable. If so, we'll just ignore it.\n            handleData({\n                data: JSON.parse(unconnectedData)\n            });\n        } catch (e) {}\n\n        springroll.container.on('connected', () => {\n            this.connected = true;\n            springroll__WEBPACK_IMPORTED_MODULE_1__[\"UserData\"].read(this.storageKey).then(handleData).catch((e) => {\n                platypus.debug.warn('Storage: connected but received an error', e);\n            });\n        });\n    }\n\n    /**\n     * Adds a storage key to the game's storage.\n     *\n     * @method addKey\n     * @param {String} key The key to add.\n     * @param {*} value The data to store at this defined key.\n     */\n    addKey (key, value) {\n        this.map.set(key, value);\n        Object.defineProperty(this, key, {\n            get: function () {\n                return this.map.get(key);\n            },\n            set: function (value) {\n                this.map.set(key, value);\n\n                this.save();\n            },\n            enumerable: true\n        });\n    }\n\n    /**\n     * Gets a value from storage for the provided storage key.\n     *\n     * @method get\n     * @param {String} key The key for the data to return\n     * @return {*}\n     */\n    get (key) {\n        if (!this.map.has(key)) {\n            this.addKey(key, null);\n        }\n\n        return this[key];\n    }\n\n    /**\n     * Takes the current game storage and saves it to local storage or Springroll UserData\n     *\n     * @method save\n     */\n    save () {\n        const save = this.map.toJSON();\n        \n        if (this.connected) {\n            springroll__WEBPACK_IMPORTED_MODULE_1__[\"UserData\"].write(this.storageKey, save).catch((e) => {\n                platypus.debug.warn('Storage: tried to save but received an error', e);\n            });\n        } else {\n            window.localStorage.setItem(this.storageKey, JSON.stringify(save));\n        }\n    }\n\n    /**\n     * Updates a storage key's data. Creates the key if it does not exist.\n     *\n     * @method set\n     * @param {String} key The key to update.\n     * @param {*} value The data to store at this key.\n     */\n    set (key, value) {\n        if (!this.map.has(key)) {\n            this.addKey(key, value);\n            this.save();\n        } else {\n            this[key] = value;\n        }\n    }\n}\n\n//# sourceURL=webpack://platypus/./src/Storage.js?");

/***/ }),

/***/ "./src/VOPlayer.js":
/*!*************************!*\
  !*** ./src/VOPlayer.js ***!
  \*************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return VOPlayer; });\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var _Data_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Data.js */ \"./src/Data.js\");\n/* harmony import */ var _Messenger_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Messenger.js */ \"./src/Messenger.js\");\n/* harmony import */ var pixi_sound__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! pixi-sound */ \"pixi-sound\");\n/* harmony import */ var pixi_sound__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(pixi_sound__WEBPACK_IMPORTED_MODULE_3__);\n/**\n * This class is used to create `platypus.game.voPlayer` and manages playback by only playing one at a time, playing a list, and even handling captions at the same time.\n *\n * This class borrows heavily from SpringRoll v1 to match the original capabilities exposed for Platypus v1.\n *\n * @namespace platypus\n * @class VOPlayer\n * @constructor\n * @param {Game} game The game instance for which to play audio.\n * @param {assetManager} assetCache The Platypus assetManager used to load and unload VO clips.\n */\n/* global platypus */\n\n\n\n\n\nclass VOPlayer extends _Messenger_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"] {\n    constructor (game, assetCache) {\n        super();\n\n        this.game = game;\n        this.assetCache = assetCache;\n\n        //Bound method calls\n        this._onSoundFinished = this._onSoundFinished.bind(this);\n        this._updateSilence = this._updateSilence.bind(this);\n        this._syncCaptionToSound = this._syncCaptionToSound.bind(this);\n\n        /**\n         * Preloading next sound.\n         * @property {String} preloadingNextSound\n         * @private\n         */\n        this.preloadingNextSound = '';\n\n        /**\n         * If the sound is currently paused. Setting this has no effect - use pause()\n         * and resume().\n         * @property {Boolean} paused\n         * @public\n         * @readOnly\n         */\n        this.paused = false;\n\n        /**\n         * The current list of audio/silence times/functions.\n         * Generally you will not need to modify this.\n         * @property {Array} voList\n         * @public\n         */\n        this.voList = null;\n\n        /**\n         * The current position in voList.\n         * @property {int} _listCounter\n         * @private\n         */\n        this._listCounter = 0;\n\n        /**\n         * The current audio alias being played.\n         * @property {String} _currentVO\n         * @private\n         */\n        this._currentVO = null;\n\n        /**\n         * The current audio instance being played.\n         * @property {SoundInstance} _soundInstance\n         * @private\n         */\n        this._soundInstance = null;\n\n        /**\n         * The callback for when the list is finished.\n         * @property {Function} _callback\n         * @private\n         */\n        this._callback = null;\n\n        /**\n         * The callback for when the list is interrupted for any reason.\n         * @property {Function} _cancelledCallback\n         * @private\n         */\n        this._cancelledCallback = null;\n\n        /**\n         * A timer for silence entries in the list, in milliseconds.\n         * @property {int} _timer\n         * @private\n         */\n        this._timer = 0;\n\n        /**\n         * The captions object\n         * @property {springroll.Captions} _captions\n         * @private\n         */\n        this._captions = null;\n\n        this.volume = 1;\n        this.captionMute = true;\n        this.currentlyLoadingAudio = false;\n        this.playQueue = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n    }\n\n    /**\n     * Fired when a new VO, caption, or silence timer begins\n     * @event start\n     * @param {String} currentVO The alias of the VO or caption that has begun, or null if it is a silence timer.\n     */\n\n    /**\n     * Fired when a new VO, caption, or silence timer completes\n     * @event end\n     * @param {String} currentVO The alias of the VO or caption that has begun, or null if it is a silence timer.\n     */\n\n    /**\n     * If VOPlayer is currently playing (audio or silence).\n     * @property {Boolean} playing\n     * @public\n     * @readOnly\n     */\n    get playing () {\n        return this._currentVO !== null || this._timer > 0;\n    }\n\n    /**\n     * The current VO alias that is playing, even if it is just a caption. If a silence timer\n     * is running, currentVO will be null.\n     * @property {Boolean} currentVO\n     * @public\n     * @readOnly\n     */\n    get currentVO () {\n        return this._currentVO;\n    }\n\n    /**\n     * The springroll.Captions object used for captions. The developer is responsible for initializing this with a captions dictionary config file and a reference to a text field.\n     * @property {Captions} captions\n     * @public\n     */\n    set captions (captions) {\n        this._captions = captions;\n        if (captions) {\n            captions.selfUpdate = false;\n            this.setCaptionMute(this.captionMute);\n        }\n    }\n\n    get captions () {\n        return this._captions;\n    }\n\n    /**\n     * The amount of time elapsed in the currently playing item of audio/silence in milliseconds\n     * @property {int} currentPosition\n     */\n    get currentPosition () {\n        if (!this.playing) return 0;\n        //active audio\n        if (this._soundInstance)\n            return this._soundInstance.position;\n        //captions only\n        else if (this._currentVO)\n            return this._timer;\n        //silence timer\n        else\n            return this.voList[this._listCounter] - this._timer;\n    }\n\n    /**\n     * The duration of the currently playing item of audio/silence in milliseconds. If this is waiting on an audio file to load for the first time, it will be 0, as there is no duration data to give.\n     * @property {int} currentDuration\n     */\n    get currentDuration () {\n        if (!this.playing) {\n            return 0;\n        }\n\n        //active audio\n        if (this._soundInstance) {\n            return pixi_sound__WEBPACK_IMPORTED_MODULE_3___default.a.duration(this._soundInstance.alias);\n        } else if (this._currentVO && this._captions) { //captions only\n            return this._captions.currentDuration;\n        } else { //silence timer\n            return this.voList[this._listCounter];\n        }\n    }\n\n    /**\n     * Calculates the amount of time elapsed in the current playlist of audio/silence.\n     * @method getElapsed\n     * @return {int} The elapsed time in milliseconds.\n     */\n    getElapsed () {\n        let index = 0,\n            total = 0;\n\n        if (!this.voList)\n        {\n            return 0;\n        }\n\n        for (let i = 0; i < this._listCounter; ++i) {\n            const item = this.voList[i];\n            if (typeof item === \"string\") {\n                total += pixi_sound__WEBPACK_IMPORTED_MODULE_3___default.a.duration(item) * 1000;\n            }\n            else if (typeof item === \"number\")\n            {\n                total += item;\n            }\n        }\n\n        //get the current item\n        index = this._listCounter;\n        if (index < this.voList.length) {\n            const item = this.voList[index];\n            if (typeof item === \"string\") {\n                if (this._soundInstance) {\n                    total += this._soundInstance._elapsed * 1000;\n                } // Otherwise it's not yet loaded so progress is `0`\n            } else if (typeof item === \"number\") {\n                total += item - this._timer;\n            }\n        }\n        return total;\n    }\n\n    /**\n     * Pauses the current VO, caption, or silence timer if the VOPlayer is playing.\n     * @method pause\n     * @public\n     */\n    pause () {\n        if (this.paused || !this.playing) return;\n\n        this.paused = true;\n\n        if (this._soundInstance)\n            this._soundInstance.pause();\n        \n        //remove any update callback\n        this.game.off(\"tick\", this._syncCaptionToSound);\n        this.game.off(\"tick\", this._updateSilence);\n    }\n\n    /**\n     * Resumes the current VO, caption, or silence timer if the VOPlayer was paused.\n     * @method resume\n     * @public\n     */\n    resume () {\n        if (!this.paused) return;\n\n        this.paused = false;\n        if (this._soundInstance)\n            this._soundInstance.resume();\n        //captions for solo captions or VO\n        if (this._captions.activeCaption) {\n            if (this._soundInstance) {\n                this.game.on(\"tick\", this._syncCaptionToSound);\n            }\n\n            //timer\n        } else {\n            this.game.on(\"tick\", this._updateSilence);\n        }\n    }\n\n    /**\n     * Plays a single audio alias, interrupting any current playback.\n     * Alternatively, plays a list of audio files, timers, and/or functions.\n     * Audio in the list will be preloaded to minimize pauses for loading.\n     * @method play\n     * @public\n     * @param {String|Array} idOrList The alias of the audio file to play or the\n     * array of items to play/call in order.\n     * @param {Function} [callback] The function to call when playback is complete.\n     * @param {Function|Boolean} [cancelledCallback] The function to call when playback\n     * is interrupted with a stop() or play() call. If this value is a boolean\n     * <code>true</code> then callback will be used instead.\n     */\n    play (idOrList, callback, cancelledCallback) {\n        if (!this.startingNewTrack) {\n            if (this.currentlyLoadingAudio) {\n                this.playQueue.push(_Data_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp(\n                    'idOrList', idOrList,\n                    'callback', callback,\n                    'cancelledCallback', cancelledCallback\n                ));\n                return;\n            }\n            this.startingNewTrack = true;\n            this.stop();\n            this.startingNewTrack = false;\n\n            this._listCounter = -1;\n            if (typeof idOrList === \"string\") {\n                this.voList = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(0, idOrList);\n            } else {\n                this.voList = Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSlice\"])(idOrList);\n                this.voList.unshift(0);\n            }\n            this._callback = callback;\n            this._cancelledCallback = cancelledCallback === true ? callback : cancelledCallback;\n            this._onSoundFinished();\n\n        } else {\n            platypus.debug.warn('VOPlayer: Tried playing a new track while a new track was starting up.');\n        }\n    }\n\n    /**\n     * Callback for when audio/timer is finished to advance to the next item in the list.\n     * @method _onSoundFinished\n     * @private\n     */\n    _onSoundFinished () {\n        if (this._listCounter >= 0) {\n            const currentVO = this._currentVO;\n\n            this.trigger(\"end\", currentVO);\n            if (typeof currentVO === \"string\") {\n                this.voList[0] += pixi_sound__WEBPACK_IMPORTED_MODULE_3___default.a.duration(currentVO) * 1000;\n                this.unloadSound(currentVO);\n                Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSplice\"])(this.voList, 1);\n                this._listCounter -= 1;\n            } else if (typeof this._currentVO === \"function\") {\n                Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSplice\"])(this.voList, 1);\n                this._listCounter -= 1;\n            } else {\n                this.voList[0] += this.voList[1];\n                Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSplice\"])(this.voList, 1);\n                this._listCounter -= 1;\n            }\n        } else {\n            this._listCounter = 0; // bump past elapsed storage index.\n        }\n        //remove any update callback\n        this.game.off(\"tick\", this._syncCaptionToSound);\n        this.game.off(\"tick\", this._updateSilence);\n\n        //if we have captions and an audio instance, set the caption time to the length of the audio\n        if (this._captions && this._captions.activeCaption && this._soundInstance) {\n            const activeCaption = this._captions.activeCaption;\n            \n            activeCaption.lineIndex = activeCaption.lines.length;\n        }\n        this._soundInstance = null; //clear the audio instance\n        this._listCounter++; //advance list\n\n        //if the list is complete\n        if (this._listCounter >= this.voList.length) {\n            const c = this._callback;\n\n            if (this._captions) {\n                this._captions.stop();\n            }\n            this._currentVO = null;\n            this._cancelledCallback = null;\n            this._callback = null;\n            _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.voList);\n            this.voList = null;\n            if (c) {\n                c();\n            }\n        } else {\n            this._currentVO = this.voList[this._listCounter];\n            if (typeof this._currentVO === \"string\") {\n                //If the sound doesn't exist, then we play it and let it fail,\n                //an error should be shown and playback will continue\n                this._playSound();\n                this.trigger(\"start\", this._currentVO);\n            } else if (typeof this._currentVO === \"function\") {\n                this._currentVO(); //call function\n                this._onSoundFinished(); //immediately continue\n            } else {\n                this._timer = this._currentVO; //set up a timer to wait\n                this._currentVO = null;\n                this.game.on(\"tick\", this._updateSilence);\n                this.trigger(\"start\", null);\n            }\n        }\n    }\n\n    /**\n     * The update callback used for silence timers.\n     * This method is bound to the VOPlayer instance.\n     * @method _updateSilence\n     * @private\n     * @param {int} elapsed The time elapsed since the previous frame, in milliseconds.\n     */\n    _updateSilence (tick) {\n        this._timer -= tick.delta;\n\n        if (this._timer <= 0) {\n            this._onSoundFinished();\n        }\n    }\n\n    /**\n     * The update callback used for updating captions with active audio.\n     * This method is bound to the VOPlayer instance.\n     * @method _syncCaptionToSound\n     * @private\n     * @param {int} elapsed The time elapsed since the previous frame, in milliseconds.\n     */\n    _syncCaptionToSound (tick) {\n        if (!this._soundInstance) return;\n\n        this._captions.update(tick.delta / 1000);\n    }\n\n    /**\n     * Plays the current audio item and begins preloading the next item.\n     * @method _playSound\n     * @private\n     */\n    _playSound () {\n        const\n            play = () => {\n                this._soundInstance = pixi_sound__WEBPACK_IMPORTED_MODULE_3___default.a.play(this._currentVO, this._onSoundFinished);\n                this._soundInstance.volume = this.volume;\n                if (this._captions) {\n                    this._captions.start(this._currentVO);\n                    this.game.on(\"tick\", this._syncCaptionToSound);\n                }\n                if (this.playQueue.length) { // We need to skip on ahead, because new VO was played while this or a prior one was loading.\n                    const\n                        vo = Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSplice\"])(this.playQueue, 0);\n\n                    this.play(vo.idOrList, vo.callback, vo.cancelledCallback);\n\n                    vo.recycle();\n                } else {\n                    for (let i = this._listCounter + 1; i < this.voList.length; ++i) {\n                        const next = this.voList[i];\n                        if (typeof next === \"string\") {\n                            const\n                                arr = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp({\n                                    id: this._currentVO,\n                                    src: this._currentVO + '.{ogg,mp3}'\n                                });\n        \n                            this.assetCache.load(arr);\n                \n                            _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(arr);\n\n                            if (this.preloadingNextSound) {\n                                this.unloadSound(this.preloadingNextSound);\n                            }\n                            this.preloadingNextSound = next;\n                            break;\n                        }\n                    }\n                }\n            },\n            arr = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp({\n                id: this._currentVO,\n                src: this._currentVO + '.{ogg,mp3}'\n            }),\n            currentVO = this._currentVO;\n\n        this.currentlyLoadingAudio = true;\n\n        this.assetCache.load(arr, null, () => {\n            this.currentlyLoadingAudio = false;\n            if (this.stoppedWhileLoading) {\n                this.stoppedWhileLoading = false;\n                if (this.playQueue.length) { // Already more queued up, so we'll roll the stop into it here\n                    play();\n                } else {\n                    play();\n                    this.stop();\n                }\n            } else if (currentVO === this._currentVO) {\n                play();\n            } else {\n                platypus.debug.warn('VOPlayer: Asset loading out of order.');\n            }\n        });\n\n        _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(arr);\n    }\n\n    /**\n     * Stops playback of any audio/timer.\n     * @method stop\n     * @public\n     */\n    stop () {\n        if (this.currentlyLoadingAudio) {\n            this.stoppedWhileLoading = true;\n            return;\n        }\n        const c = this._cancelledCallback;\n\n        this.paused = false;\n        if (this._soundInstance) {\n            this._soundInstance.stop();\n            this.unloadSound(this._currentVO);\n            this._soundInstance = null;\n        }\n        this._currentVO = null;\n        if (this._captions && this._captions.activeCaption) {\n            this._captions.stop();\n        }\n        this.game.off(\"tick\", this._syncCaptionToSound);\n        this.game.off(\"tick\", this._updateSilence);\n        if (this.voList) {\n            for (let i = this._listCounter + 1; i < this.voList.length; i++) {\n                if (typeof this.voList[i] === 'function') {\n                    this.voList[i](); // Make sure all events are triggered.\n                }\n            }\n            this.voList = null;\n        }\n        this._timer = 0;\n        this._callback = null;\n\n        this._cancelledCallback = null;\n        if (c) {\n            c();\n        }\n    }\n\n    /**\n     * Sets the volume of VO playback.\n     *\n     * @method setVolume\n     * @param {Number} volume\n     */\n    setVolume (volume) {\n        this.volume = volume;\n        if (this._soundInstance) {\n            this._soundInstance.volume = this.volume;\n        }\n    }\n\n    /**\n     * Whether to mute captions.\n     *\n     * @method setCaptionMute\n     * @param {Boolean} muted\n     */\n    setCaptionMute (muted) {\n        this.captionMute = muted;\n        if (this._captions) {\n            this._captions.renderer.renderTarget.style.display = muted ? 'none' : 'block';\n        }\n    }\n\n    /**\n     * Unloads an audio track this VOPlayer has played.\n     * @method unloadSound\n     * @param sound {string} Sound to unload.\n     * @public\n     */\n    unloadSound (sound) {\n        const\n            assetCache = this.assetCache;\n\n        if (assetCache.delete(sound)) {\n            pixi_sound__WEBPACK_IMPORTED_MODULE_3___default.a.remove(sound);\n        }\n    }\n\n    /**\n     * Cleans up this VOPlayer.\n     * @method destroy\n     * @public\n     */\n    destroy () {\n        this.stop();\n        this.voList = null;\n        this._currentVO = null;\n        this._soundInstance = null;\n        this._callback = null;\n        this._cancelledCallback = null;\n        this._captions = null;\n    }\n};\n\n\n//# sourceURL=webpack://platypus/./src/VOPlayer.js?");

/***/ }),

/***/ "./src/Vector.js":
/*!***********************!*\
  !*** ./src/Vector.js ***!
  \***********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! config */ \"./src/config/development.js\");\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(config__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var recycle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! recycle */ \"./node_modules/recycle/recycle.js\");\n/**\n * This class defines a multi-dimensional vector object and a variety of methods for manipulating the vector.\n *\n * @namespace platypus\n * @class Vector\n * @constructor\n * @param x {number|Array|Vector} The x coordinate or an array or Vector describing the whole vector.\n * @param [y] {number} The y coordinate.\n * @param [z] {number} The z coordinate.\n */\n/*global platypus */\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    var Vector = function (x, y, z) {\n            if (this.matrix) { // Recycled vectors will already have a matrix array. Resetting x, y, z to 0's to properly handle a set-up array of less than 3 dimensions.\n                this.matrix[0] = 0;\n                this.matrix[1] = 0;\n                this.matrix[2] = 0;\n            } else {\n                this.matrix = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(0, 0, 0);\n            }\n            this.set(x, y, z);\n        },\n        proto = Vector.prototype;\n    \n    /**\n     * The x component of the vector.\n     *\n     * @property x\n     * @type number\n     * @default 0\n     */\n    Object.defineProperty(proto, 'x', {\n        get: function () {\n            return this.matrix[0];\n        },\n        set: function (value) {\n            this.matrix[0] = value;\n        }\n    });\n    \n    /**\n     * The y component of the vector.\n     *\n     * @property y\n     * @type number\n     * @default 0\n     */\n    Object.defineProperty(proto, 'y', {\n        get: function () {\n            return this.matrix[1];\n        },\n        set: function (value) {\n            this.matrix[1] = value;\n        }\n    });\n    \n    /**\n     * The z component of the vector.\n     *\n     * @property z\n     * @type number\n     * @default 0\n     */\n    Object.defineProperty(proto, 'z', {\n        get: function () {\n            return this.matrix[2];\n        },\n        set: function (value) {\n            this.matrix[2] = value;\n        }\n    });\n    \n    /**\n     * Returns a string describing the vector in the format of \"[x, y, z]\".\n     *\n     * @method toString\n     * @return {String}\n     */\n    proto.toString = function () {\n        return '[' + this.matrix.join(',') + ']';\n    };\n    \n    /**\n     * Sets the coordinates of the vector.\n     *\n     * @method set\n     * @param x {number|Array|Vector} The x coordinate or an array or Vector describing the whole vector.\n     * @param [y] {number} The y coordinate, or if x is an array/Vector this is the number of elements to copy from the array/Vector.\n     * @param [z] {number} The z coordinate.\n     * @chainable\n     */\n    proto.set = function (x, y, z) {\n        if (x && x.matrix) {                // Passing in a vector.\n            return this.setVector(x, y);\n        } else if (x && (typeof x.x === 'number') && (typeof x.y === 'number')) { // Passing in a vector-like object.\n            return this.setXYZ(x.x, x.y, x.z);\n        } else if (x && Array.isArray(x)) { // Passing in an array.\n            return this.setArray(x, y);\n        } else {                            // Passing in coordinates.\n            return this.setXYZ(x, y, z);\n        }\n    };\n\n    /**\n     * Sets the coordinates of the vector.\n     *\n     * @method setXYZ\n     * @param x {number} The x coordinate.\n     * @param [y] {number} The y coordinate.\n     * @param [z] {number} The z coordinate.\n     * @chainable\n     */\n    proto.setXYZ = function (x, y, z) {\n        var matrix = this.matrix;\n        \n        matrix[0] = x || 0;\n        matrix[1] = y || 0;\n        matrix[2] = z || 0;\n        \n        return this;\n    };\n\n    /**\n     * Sets the coordinates of the vector.\n     *\n     * @method setVector\n     * @param vector {Vector} The Vector to copy.\n     * @param [dimensions] {number} The number of elements to copy from the Vector.\n     * @chainable\n     */\n    proto.setVector = function (vector, dimensions) {\n        return this.setArray(vector.matrix, dimensions);\n    };\n\n    /**\n     * Sets the coordinates of the vector.\n     *\n     * @method setArray\n     * @param arr {Array} The array to copy.\n     * @param [dimensions] {number} The number of elements to copy from the Array.\n     * @chainable\n     */\n    proto.setArray = function (arr, dimensions) {\n        var q = dimensions || arr.length,\n            matrix = this.matrix;\n        \n        while (q--) {\n            matrix[q] = arr[q];\n        }\n\n        return this;\n    };\n\n    /**\n     * Determines whether two vectors are equal.\n     *\n     * @method equals\n     * @param x {number|Array|Vector} The x coordinate or an array or Vector to check against.\n     * @param [y] {number} The y coordinate, or if x is an array/Vector this is the number of dimensions to check from the array/Vector.\n     * @param [z] {number} The z coordinate.\n     * @return {Boolean} Whether the vectors are equal.\n     */\n    proto.equals = function (x, y, z) {\n        var m = null,\n            q = 0,\n            matrix = this.matrix;\n        \n        if (x && Array.isArray(x)) {   // Passing in an array.\n            q = y || x.length;\n            while (q--) {\n                if (matrix[q] !== x[q]) {\n                    return false;\n                }\n            }\n            return true;\n        } else if (x && x.matrix) {   // Passing in a vector.\n            m = x.matrix;\n            q = y || m.length;\n            while (q--) {\n                if (matrix[q] !== m[q]) {\n                    return false;\n                }\n            }\n            return true;\n        } else {                     // Passing in coordinates.\n            return ((typeof x === 'number') && (matrix[0] === x)) && ((typeof y !== 'number') || (matrix[1] === y)) && ((typeof z !== 'number') || (matrix[2] === z));\n        }\n    };\n    \n    /**\n     * Returns the magnitude of the vector.\n     *\n     * @method magnitude\n     * @param [dimensions] {number} The dimensions to include. Defaults to all dimensions.\n     * @return {number} The magnitude of the vector.\n     */\n    proto.magnitude = function (dimensions) {\n        return Math.sqrt(this.magnitudeSquared(dimensions));\n    };\n    \n    /**\n     * Returns the magnitude squared of the vector. This is slightly faster than finding the magnitude.\n     *\n     * @method magnitudeSquared\n     * @param [dimensions] {number} The dimensions to include. Defaults to all dimensions.\n     * @return {number} The magnitude squared of the vector.\n     */\n    proto.magnitudeSquared = function (dimensions) {\n        var squares = 0,\n            x = 0;\n\n        dimensions = dimensions || this.matrix.length;\n\n        for (x = 0; x < dimensions; x++) {\n            squares += Math.pow(this.matrix[x], 2);\n        }\n\n        return squares;\n    };\n    \n    /**\n     * Returns the direction of the vector from the z-axis\n     *\n     * @return {number} The direction of the vector in radians.\n     */\n    proto.getAngle = function () {\n        var mag   = this.magnitude(2),\n            angle = 0;\n\n        if (mag !== 0) {\n            angle = Math.acos(this.x / mag);\n            if (this.y < 0) {\n                angle = (Math.PI * 2) - angle;\n            }\n        }\n        return angle;\n    };\n    \n    /**\n     * Returns a normalized copy of the vector.\n     *\n     * @method getUnit\n     * @return {platypus.Vector} A normalized vector in the same direction as this vector.\n     */\n    proto.getUnit = function () {\n        return Vector.setUp(this).normalize();\n    };\n    \n    /**\n     * Returns a copy of the Vector inverted.\n     *\n     * @method getInverse\n     * @return {platypus.Vector}\n     */\n    proto.getInverse = function () {\n        return Vector.setUp(this).multiply(-1);\n    };\n    \n    /**\n     * Normalizes the vector.\n     *\n     * @method normalize\n     * @chainable\n     */\n    proto.normalize = function () {\n        var mag = this.magnitude();\n        \n        if (mag === 0) {\n            // Ignores attempt to normalize a vector of zero magnitude.\n            return this;\n        } else {\n            return this.multiply(1 / mag);\n        }\n    };\n    \n    /**\n     * Crosses this vector with the parameter vector.\n     *\n     * @method cross\n     * @param vector {platypus.Vector} The vector to cross this vector with.\n     * @chainable\n     */\n    proto.cross = (function () {\n        var det = function (a, b, c, d) {\n            return a * d - b * c;\n        };\n        \n        return function (v) {\n            var tempX = det(this.y, this.z, v.y, v.z),\n                tempY = -det(this.x, this.z, v.x, v.z),\n                tempZ = det(this.x, this.y, v.x, v.y);\n            \n            this.x = tempX;\n            this.y = tempY;\n            this.z = tempZ;\n            \n            return this;\n        };\n    }());\n    \n    /**\n     * Crosses this vector with the parameter vector and returns the cross product.\n     *\n     * @method getCrossProduct\n     * @param vector {platypus.Vector} The vector to cross this vector with.\n     * @return {platypus.Vector} The cross product.\n     */\n    proto.getCrossProduct = function (v) {\n        return Vector.setUp(this).cross(v);\n    };\n    \n    /**\n     * Rotates the vector by the given amount.\n     *\n     * @method rotate\n     * @param angle {number} The amount to rotate the vector in radians.\n     * @param [axis=\"z\"] {String|Vector} A vector describing the axis around which the rotation should occur or 'x', 'y', or 'z'.\n     * @chainable\n     */\n    proto.rotate = function (angle, axis) {\n        var a    = axis,\n            arr  = null,\n            cos  = Math.cos(angle),\n            sin  = Math.sin(angle),\n            icos = 1 - cos,\n            x    = 0,\n            y    = 0,\n            z    = 0,\n            temp = Vector.setUp();\n        \n        if (a) {\n            if (a === 'x') {\n                a = temp.setXYZ(1, 0, 0);\n            } else if (a === 'y') {\n                a = temp.setXYZ(0, 1, 0);\n            } else if (a === 'z') {\n                a = temp.setXYZ(0, 0, 1);\n            }\n        } else {\n            a = temp.setXYZ(0, 0, 1);\n        }\n        \n        x     = a.x;\n        y     = a.y;\n        z     = a.z;\n        \n        arr = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(\n            _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(    cos + x * x * icos, x * y * icos - z * sin, x * z * icos + y * sin),\n            _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(y * x * icos + z * sin,     cos + y * y * icos, y * z * icos - x * sin),\n            _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(z * x * icos - y * sin, z * y * icos + x * sin,     cos + z * z * icos)\n        );\n        \n        this.multiply(arr);\n\n        temp.recycle();\n        _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(arr, 2);\n        \n        return this;\n    };\n\n    /**\n     * Rotates the vector position around a given point on the cartesian plane.\n     *\n     * @method rotateAbout\n     * @param point {Vector} A vector describing the point around which the rotation should occur.\n     * @param angle {number} The amount to rotate the vector in radians.\n     * @chainable\n     */\n    proto.rotateAbout = function (point, angle) {\n        const cos = Math.cos(angle),\n            sin = Math.sin(angle),\n            dx = this.x - point.x,\n            dy = this.y - point.y;\n\n        this.x = point.x + (dx * cos - dy * sin);\n        this.y = point.y + (dx * sin + dy * cos);\n\n        return this;\n    };\n    \n    /**\n     * Scales the vector by the given factor or performs a transform if a matrix is provided.\n     *\n     * @method multiply\n     * @param multiplier {number|Array} The factor to scale by or a 2D array describing a multiplication matrix.\n     * @param limit {number} For scaling, determines which coordinates are affected.\n     * @chainable\n     */\n    proto.multiply = function (multiplier, limit) {\n        const\n            matrix = this.matrix;\n        \n        if (Array.isArray(multiplier)) {\n            const\n                arr = Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSlice\"])(matrix);\n\n            if (multiplier.length === 2) {\n                matrix[0] = arr[0] * multiplier[0][0] + arr[1] * multiplier[0][1];\n                matrix[1] = arr[0] * multiplier[1][0] + arr[1] * multiplier[1][1];\n            } else if (multiplier.length >= 3) {\n                matrix[0] = arr[0] * multiplier[0][0] + arr[1] * multiplier[0][1] + arr[2] * multiplier[0][2];\n                matrix[1] = arr[0] * multiplier[1][0] + arr[1] * multiplier[1][1] + arr[2] * multiplier[1][2];\n                matrix[2] = arr[0] * multiplier[2][0] + arr[1] * multiplier[2][1] + arr[2] * multiplier[2][2];\n            }\n\n            _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(arr);\n        } else {\n            const\n                l = limit || matrix.length;\n\n            for (let i = 0; i < l; i++) {\n                matrix[i] *= multiplier;\n            }\n        }\n        \n        return this;\n    };\n    \n    /**\n     * Adds the given components to this vector.\n     *\n     * @method add\n     * @param x {number|Array|Vector} The x component to add, or an array or vector describing the whole addition.\n     * @param [y] {number} The y component to add or the limit if the first parameter is a vector or array.\n     * @param [z] {number} The z component to add.\n     * @chainable\n     */\n    proto.add = function (x, y, z) {\n        var addMatrix = x,\n            limit = 0,\n            q = 0;\n\n        if (!Array.isArray(addMatrix)) {\n            if (addMatrix instanceof Vector) {\n                addMatrix = addMatrix.matrix;\n                limit = y || this.matrix.length;\n            } else {\n                addMatrix = [x || 0, y || 0, z || 0];\n                limit = this.matrix.length;\n            }\n        } else {\n            limit = y || this.matrix.length;\n        }\n        \n        for (q = 0; q < limit; q++) {\n            this.matrix[q] += addMatrix[q];\n        }\n        \n        return this;\n    };\n    \n    /**\n     * Adds the given vector to this vector.\n     *\n     * @method addVector\n     * @param otherVector {platypus.Vector} The vector to add.\n     * @chainable\n     */\n    proto.addVector = function (otherVector, dimensions) {\n        return this.add(otherVector, dimensions);\n    };\n    \n    /**\n     * Subtracts the given vector from this vector.\n     *\n     * @method subtractVector\n     * @param otherVector {platypus.Vector} The vector to subtract.\n     * @chainable\n     */\n    proto.subtractVector = function (otherVector, dimensions) {\n        var inv = otherVector.getInverse();\n\n        this.add(inv, dimensions);\n        inv.recycle();\n\n        return this;\n    };\n\n    /**\n     * Returns the perpendicular vector.\n     *\n     * @method perpendicular\n     * @param opposite {Boolean} Whether to negate the perpendicular vector.\n     * @chainable\n     */\n    proto.perpendicular = function (negate) {\n        const matrix = this.matrix,\n            mult = (negate === true) ? -1 : 1,\n            x = -this.matrix[1];\n\n        matrix[1] = matrix[0];\n        matrix[0] = x;\n\n        if (negate) {\n            matrix[1] *= mult;\n            matrix[0] *= mult;\n        }\n\n        return this;\n    };\n    \n    /**\n     * Scales the vector by the given factor.\n     *\n     * @method multiply\n     * @param factor {number} The factor to scale by.\n     * @param limit {number} Determines which coordinates are affected. Defaults to all coordinates.\n     * @chainable\n     */\n    proto.scale = function (factor, limit) {\n        return this.multiply(factor, limit);\n    };\n    \n    /**\n     * Finds the dot product of the two vectors.\n     *\n     * @method dot\n     * @param otherVector {platypus.Vector} The other vector.\n     * @param limit {number} The number of vector indexes to include in the dot product.\n     * @return {number} The dot product.\n     */\n    proto.dot = function (otherVector, limit) {\n        var sum = 0,\n            q = 0,\n            m = this.matrix,\n            oM = otherVector.matrix;\n            \n        q = limit || m.length;\n        \n        while (q--) {\n            sum += m[q] * (oM[q] || 0);\n        }\n        \n        return sum;\n    };\n    \n    /**\n     * Finds the shortest angle between the two vectors.\n     *\n     * @method angleTo\n     * @param otherVector {platypus.Vector} The other vector.\n     * @return {number} The angle between this vector and the received vector.\n     */\n    proto.angleTo = function (otherVector) {\n        var v1 = this.getUnit(),\n            v2 = otherVector.getUnit(),\n            ang = 0;\n            \n        if (v1.magnitude() && v2.magnitude()) { // Probably want a less expensive check here for zero-length vectors.\n            ang = Math.acos(v1.dot(v2));\n        } else {\n            platypus.debug.warn('Vector: Attempted to find the angle of a zero-length vector.');\n            ang = NaN;\n        }\n            \n        v1.recycle();\n        v2.recycle();\n        \n        return ang;\n    };\n    \n    /**\n     * Finds the shortest signed angle between the two vectors.\n     *\n     * @method signedAngleTo\n     * @param otherVector {platypus.Vector} The other vector.\n     * @param normal {platypus.Vector} A normal vector determining the resultant sign of the angle between two vectors.\n     * @return {number} The angle between this vector and the received vector.\n     */\n    proto.signedAngleTo = function (otherVector, normal) {\n        var v1 = this.getUnit(),\n            v2 = otherVector.getUnit(),\n            v3 = v1.getCrossProduct(v2),\n            ang = 0;\n        \n        if (v3.magnitude() === 0) {\n            ang = 0;\n        } else if (v3.dot(normal) < 0) {\n            ang = -Math.acos(v1.dot(v2));\n        } else {\n            ang =  Math.acos(v1.dot(v2));\n        }\n        \n        v1.recycle();\n        v2.recycle();\n        v3.recycle();\n        \n        return ang;\n    };\n    \n    /**\n     * Find the scalar value of projecting this vector onto the parameter vector or onto a vector at the specified angle away.\n     *\n     * @method scalerProjection\n     * @param vectorOrAngle {Vector|number} The other vector or the angle between the vectors.\n     * @return {number} The magnitude of the projection.\n     */\n    proto.scalarProjection = function (vectorOrAngle) {\n        var v = null,\n            d = 0;\n        \n        if (typeof vectorOrAngle === \"number\") {\n            return this.magnitude(2) * Math.cos(vectorOrAngle);\n        } else {\n            v = Vector.setUp(vectorOrAngle).normalize();\n            d = this.dot(v);\n            v.recycle();\n            return d;\n        }\n    };\n    \n    /**\n     * Returns a copy of this vector.\n     *\n     * @method copy\n     * @return {platypus.Vector} A copy of this vector.\n     */\n    proto.copy = function () {\n        return Vector.setUp(this);\n    };\n    \n    /**\n     * Adds properties to an object that describe the coordinates of a vector.\n     *\n     * @method Vector.assign\n     * @param object {Object} Object on which the coordinates and vector will be added.\n     * @param propertyName {String} A string describing the property name where the vector is accessable.\n     * @param [coordinateName*] {String} One or more parameters describing coordinate values on the object.\n     */\n    Vector.assign = (function () {\n        var createProperty = function (property, obj, vector, index) {\n            var temp = null,\n                propertyInUse = false;\n            \n            if (typeof property === 'string') {\n                if (typeof obj[property] !== 'undefined') {\n                    temp = obj[property];\n                    delete obj[property];\n                    propertyInUse = true;\n                }\n            }\n            \n            Object.defineProperty(obj, property, {\n                get: function () {\n                    return vector.matrix[index];\n                },\n                set: function (value) {\n                    vector.matrix[index] = value;\n                },\n                enumerable: true\n            });\n            \n            if (propertyInUse) {\n                obj[property] = temp;\n            }\n        };\n        \n        return function (obj, prop) {\n            var i = 0;\n\n            if (obj && prop) {\n                if (!obj[prop]) {\n                    obj[prop] = Vector.setUp();\n                    \n                    for (i = 2; i < arguments.length; i++) {\n                        if (arguments[i] !== prop) {\n                            createProperty(arguments[i], obj, obj[prop], i - 2);\n                        }\n                    }\n                    \n                    return null;\n                }\n                return obj[prop];\n            } else {\n                return null;\n            }\n        };\n    }());\n\n    /**\n     * Returns a Vector from cache or creates a new one if none are available.\n     *\n     * @method Vector.setUp\n     * @return {platypus.Vector} The instantiated Vector.\n     */\n    /**\n     * Returns a Vector back to the cache. Prefer the Vector's recycle method since it recycles property objects as well.\n     *\n     * @method Vector.recycle\n     * @param {platypus.Vector} The Vector to be recycled.\n     */\n    /**\n     * Relinquishes properties of the vector and recycles it.\n     *\n     * @method recycle\n     */\n    recycle__WEBPACK_IMPORTED_MODULE_2__[\"default\"].add(Vector, 'Vector', Vector, function () {\n        this.matrix.length = 0;\n    }, true, config__WEBPACK_IMPORTED_MODULE_1___default.a.dev);\n    \n    return Vector;\n}());\n\n\n//# sourceURL=webpack://platypus/./src/Vector.js?");

/***/ }),

/***/ "./src/components/AIChaser.js":
/*!************************************!*\
  !*** ./src/components/AIChaser.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Vector_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Vector.js */ \"./src/Vector.js\");\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../factory.js */ \"./src/factory.js\");\n/**\n * This component acts as a simple AI that will chase another entity.\n *\n * @namespace platypus.components\n * @class AIChaser\n * @uses platypus.Component\n */\n/* global platypus */\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    return Object(_factory_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])({\n        \n        id: 'AIChaser',\n        \n        properties: {\n            /**\n             * Sets whether the speed property should enact acceleration upon the entity rather than velocity.\n             *\n             * @property accelerate\n             * @type boolean\n             * @default false\n             */\n            accelerate: false,\n            \n            /**\n             * Whether the entity is in a chasing state.\n             *\n             * @property chasing\n             * @type boolean\n             * @default true\n             */\n            chasing: true\n        },\n        \n        publicProperties: {\n            /**\n             * Sets the velocity of the entity. This property is accessible on the entity as `entity.speed`.\n             *\n             * @property speed\n             * @type number\n             * @default 0.3\n             */\n            speed: 0.3\n        },\n        \n        initialize: function () {\n            this.target = this.owner.target || null;\n            this.offset = _Vector_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp(0, 0);\n            this.state = this.owner.state;\n            this.state.set('chasing', false);\n        },\n\n        events: {\n            /**\n             * This component listens for this event to initialize movement.\n             *\n             * @method 'load'\n             */\n            \"load\": function () {\n                if (!this.owner.addMover) {\n                    platypus.debug.warn('The \"AIChaser\" component requires a \"Mover\" component to function correctly.');\n                    return;\n                }\n                \n                this.direction = this.owner.addMover({\n                    vector: [this.speed, 0, 0],\n                    event: \"chase\",\n                    accelerator: this.accelerate\n                }).vector;\n            },\n        \n            /**\n             * This AI listens for a step message triggered by its entity parent in order to perform its logic on each tick.\n             *\n             * @method 'handle-ai'\n             */\n            \"handle-ai\": function () {\n                var v = null,\n                    m = 0,\n                    c = false;\n\n                if (this.target && this.chasing) {\n                    v = _Vector_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp(this.offset).add(this.target.position).subtractVector(this.owner.position);\n                    m = v.magnitude(2);\n\n                    if (m) {\n                        c = true;\n                        this.direction.setVector(v).normalize().multiply(this.speed);\n                    }\n\n                    v.recycle();\n                }\n                \n                if (c !== this.state.get('chasing')) {\n                    this.state.set('chasing', c);\n                    \n                    /**\n                     * This event is triggered whenever the entity begins chasing another entity or stops chasing another entity.\n                     *\n                     * @event 'chase'\n                     * @param chasing {boolean} Whether the entity is chasing another entity.\n                     */\n                    this.owner.triggerEvent('chase', c);\n                }\n            },\n            \n            /**\n             * On receiving this message, the component will change its target and begin chasing the new entity.\n             *\n             * @method 'set-target'\n             * @param entity {platypus.Entity} Sets this entity's target to the provided entity.\n             */\n            \"set-target\": function (entity) {\n                this.target = entity;\n                this.offset.x = 0;\n                this.offset.y = 0;\n            },\n            \n            /**\n             * On receiving this message, the component will change its target offset.\n             *\n             * @method 'set-target-offset'\n             * @param offset {Object|Vector} Sets the chased entity's offset to the provided offset.\n             * @param offset.x {number} The offset along the x-axis.\n             * @param offset.y {number} The offset along the y-axis.\n             */\n            \"set-target-offset\": function (offset) {\n                this.offset.x = offset.x;\n                this.offset.y = offset.y;\n            },\n            \n            /**\n             * On receiving this message, the component will begin chasing the entity.\n             *\n             * @method 'start-chasing'\n             * @param [entity] {platypus.Entity} Sets the entity if it's provided.\n             */\n            \"start-chasing\": function (entity) {\n                if (entity) {\n                    this.target = entity;\n                }\n                this.chasing = true;\n            },\n            \n            /**\n             * On receiving this message, the component will cease chasing the entity.\n             *\n             * @method 'stop-chasing'\n             */\n            \"stop-chasing\": function () {\n                this.chasing = false;\n            }\n        },\n        \n        methods: {// These are methods that are called on the component\n            destroy: function () {\n                this.target = null;\n                this.offset.recycle();\n                this.state = null;\n            }\n        }\n    });\n}());\n\n//# sourceURL=webpack://platypus/./src/components/AIChaser.js?");

/***/ }),

/***/ "./src/components/AIPacer.js":
/*!***********************************!*\
  !*** ./src/components/AIPacer.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../factory.js */ \"./src/factory.js\");\n/**\n * This component acts as a simple AI that will reverse the movement direction of an object when it collides with something.\n *\n * @namespace platypus.components\n * @class AIPacer\n * @uses platypus.Component\n */\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    return Object(_factory_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        id: \"AIPacer\",\n        \n        properties: {\n            /**\n             * This determines the direction of movement. Can be \"horizontal\", \"vertical\", or \"both\".\n             *\n             * @property movement\n             * @type String\n             * @default \"both\"\n             */\n            movement: 'both',\n            \n            /**\n             * This sets the initial direction of movement. Defaults to \"up\", or \"left\" if movement is horizontal.\n             *\n             * @property direction\n             * @type String\n             * @default \"up\"\n             */\n            direction: null\n        },\n        \n        initialize: function () {\n            this.lastDirection    = '';\n            this.currentDirection = this.direction || ((this.movement === 'horizontal') ? 'left' : 'up');\n        },\n        \n        events: {\n            /**\n             * This AI listens for a step message triggered by its entity parent in order to perform its logic on each tick.\n             *\n             * @method 'handle-ai'\n             */\n            \"handle-ai\": function () {\n                if (this.currentDirection !== this.lastDirection) {\n                    this.lastDirection = this.currentDirection;\n                    \n                    /**\n                     * Triggers this event prior to changing direction.\n                     *\n                     * @event 'stop'\n                     */\n                    this.owner.triggerEvent('stop');\n                    \n                    /**\n                     * Triggers this event when the entity is moving right and collides with something.\n                     *\n                     * @event 'go-left'\n                     */\n                    /**\n                     * Triggers this event when the entity is moving left and collides with something.\n                     *\n                     * @event 'go-right'\n                     */\n                    /**\n                     * Triggers this event when the entity is moving up and collides with something.\n                     *\n                     * @event 'go-down'\n                     */\n                    /**\n                     * Triggers this event when the entity is moving down and collides with something.\n                     *\n                     * @event 'go-up'\n                     */\n                    this.owner.triggerEvent('go-' + this.currentDirection);\n                }\n            },\n            \n            /**\n             * On receiving this message, the component will check the collision side and re-orient itself accordingly.\n             *\n             * @method 'turn-around'\n             * @param collisionInfo {platypus.CollisionData} Uses direction of collision to determine whether to turn around.\n             */\n            \"turn-around\": function (collisionInfo) {\n                if ((this.movement === 'both') || (this.movement === 'horizontal')) {\n                    if (collisionInfo.x > 0) {\n                        this.currentDirection = 'left';\n                    } else if (collisionInfo.x < 0) {\n                        this.currentDirection = 'right';\n                    }\n                }\n                if ((this.movement === 'both') || (this.movement === 'vertical')) {\n                    if (collisionInfo.y > 0) {\n                        this.currentDirection = 'up';\n                    } else if (collisionInfo.y < 0) {\n                        this.currentDirection = 'down';\n                    }\n                }\n            }\n        }\n    });\n}());\n\n\n//# sourceURL=webpack://platypus/./src/components/AIPacer.js?");

/***/ }),

/***/ "./src/components/AudioMusic.js":
/*!**************************************!*\
  !*** ./src/components/AudioMusic.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var pixi_sound__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pixi-sound */ \"pixi-sound\");\n/* harmony import */ var pixi_sound__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(pixi_sound__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tweenjs/tween.js */ \"@tweenjs/tween.js\");\n/* harmony import */ var _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../factory.js */ \"./src/factory.js\");\n/**\n * This component plays music or background ambiance.\n *\n * @namespace platypus.components\n * @class AudioMusic\n * @uses platypus.Component\n */\n\n\n\n\n\nconst\n    Tween = _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_2___default.a.Tween,\n    tracks = {}; // List of actively-playing tracks.\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Object(_factory_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])({\n    id: 'AudioMusic',\n    \n    properties: {\n        /**\n         * Use the tracks property object to handle playing tracks or new tracks to load. Here is an example audioMap object:\n         *       {\n         *           \"audio-1\": \"audio-id\",\n         *\n         *           \"audio-2\": {\n         *               \"sound\": \"another-audio-id\",\n         *               // Required. This is the audio clip to loop.\n         *\n         *               \"volume\": 0.75,\n         *               // Optional. Used to specify how loud to play audio on a range from 0 (mute) to 1 (full volume). Default is 1.\n         *\n         *               \"fade\": 1000\n         *               // Optional. How long to fade to selected volume.\n         *           }\n         *       }\n         *\n         * Any tracks already playing and not defined here will fade out.\n         *\n         * @property tracks\n         * @type Object\n         * @default null\n         */\n        tracks: null\n    },\n        \n    initialize: function () {\n        const fadeOuts = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n        let fade = 1000;\n        \n        for (const key in tracks) {\n            if (tracks.hasOwnProperty(key)) {\n                fadeOuts.push(key);\n            }\n        }\n    \n        if (this.tracks) {\n            for (const key in this.tracks) {\n                if (this.tracks.hasOwnProperty(key)) {\n                    const fadeOut = fadeOuts.indexOf(key),\n                        trackProperties = this.tracks[key];\n                    \n                    let sound = tracks[key],\n                        tween = null;\n\n                    if (fadeOut >= 0) {\n                        Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSplice\"])(fadeOuts, fadeOut);\n                    } else { // gotta load it because it's not there!\n                        sound = tracks[key] = pixi_sound__WEBPACK_IMPORTED_MODULE_1___default.a.play(trackProperties.sound || trackProperties, {\n                            loop: Infinity,\n                            volume: trackProperties.fade ? 0 : (typeof trackProperties.volume === 'number' ? trackProperties.volume : 1)\n                        });\n                    }\n\n                    if (trackProperties.fade) {\n                        tween = new Tween(sound);\n                        tween.to({\n                            volume: typeof trackProperties.volume === 'number' ? trackProperties.volume : 1\n                        }, trackProperties.fade);\n                        tween.start();\n\n                        // default to what is being used for defined sounds to handle undefined sounds.\n                        fade = trackProperties.fade;\n                    }\n                }\n            }\n        }\n\n        fadeOuts.forEach((value) => {\n            const sound = tracks[value],\n                tween = new Tween(sound);\n\n            tween.to({\n                volume: 0\n            }, fade);\n            tween.onComplete(() => {\n                sound.stop();\n                //sound.unload();\n            });\n            delete tracks[value];\n            tween.start();\n        });\n    },\n\n    events: {\n        /**\n         * On receiving this message all music will mute.\n         *\n         * @method 'mute-music'\n         */\n        \"mute-music\": function () {\n            for (const key in tracks) {\n                if (tracks.hasOwnProperty(key)) {\n                    tracks[key].muted = true;\n                }\n            }\n        },\n\n        /**\n         * On receiving this message all music will unmute.\n         *\n         * @method 'unmute-music'\n         */\n        \"unmute-music\": function () {\n            for (const key in tracks) {\n                if (tracks.hasOwnProperty(key)) {\n                    tracks[key].muted = false;\n                }\n            }\n        }\n    },\n    \n    methods: {\n        destroy: function () {\n        }\n    },\n        \n    getAssetList: function (component, props, defaultProps) {\n        var key = '',\n            preload = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(),\n            tracks = component.tracks || props.tracks || defaultProps.tracks;\n        \n        if (tracks) {\n            for (key in tracks) {\n                if (tracks.hasOwnProperty(key)) {\n                    const item = (tracks[key].sound || tracks[key]) + '.{ogg,mp3}';\n                    if (preload.indexOf(item) === -1) {\n                        preload.push(item);\n                    }\n                }\n            }\n        }\n\n        return preload;\n    }\n}));\n\n\n//# sourceURL=webpack://platypus/./src/components/AudioMusic.js?");

/***/ }),

/***/ "./src/components/AudioSFX.js":
/*!************************************!*\
  !*** ./src/components/AudioSFX.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var _Data_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Data.js */ \"./src/Data.js\");\n/* harmony import */ var pixi_sound__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! pixi-sound */ \"pixi-sound\");\n/* harmony import */ var pixi_sound__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(pixi_sound__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _StateMap_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../StateMap.js */ \"./src/StateMap.js\");\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../factory.js */ \"./src/factory.js\");\n/**\n * This component plays audio using the SpringRoll Sound instance. Audio is played in one of two ways, by triggering specific messages defined in the audio component definition or using an audio map which plays sounds when the entity enters specified states.\n *\n * @namespace platypus.components\n * @class AudioSFX\n * @uses platypus.Component\n */\n/* global platypus */\n\n\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    var defaultSettings = {\n            interrupt: 0,\n            delay: 0,\n            offset: 0,\n            loop: 0,\n            volume: 1,\n            pan: 0,\n            muted: false,\n            speed: 1,\n            playthrough: false\n        },\n        playSound = function (soundDefinition) {\n            var sound      = '',\n                attributes = null,\n                completed  = function (data/*, cancelled*/) {\n                    if (data.audio && !this.owner.destroyed && this.activeAudioClips) {\n                        //clean up active clips\n                        this.removeClip(data.audio);\n                        \n                        /**\n                         * When a sound effect is finished playing, this event is triggered.\n                         *\n                         * @event clip-complete\n                         */\n                        this.owner.triggerEvent('clip-complete');\n                    }\n                    data.recycle();\n                };\n            \n            if (typeof soundDefinition === 'string') {\n                sound      = soundDefinition;\n                attributes = {};\n            } else {\n                sound      = soundDefinition.sound;\n                attributes = {\n                    interrupt: soundDefinition.interrupt,\n                    delay: soundDefinition.delay,\n                    offset: soundDefinition.offset,\n                    loop: soundDefinition.loop,\n                    volume: soundDefinition.volume,\n                    pan: soundDefinition.pan,\n                    startTime: soundDefinition.startTime,\n                    duration: soundDefinition.duration,\n                    muted: soundDefinition.muted,\n                    speed: soundDefinition.speed,\n                    playthrough: soundDefinition.playthrough\n                };\n            }\n\n            return function (value) {\n                let data = null;\n\n                value = value || attributes;\n                \n                data = _Data_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp(\n                    \"interrupt\", value.interrupt || attributes.interrupt || defaultSettings.interrupt,\n                    \"delay\",     value.delay     || attributes.delay  || defaultSettings.delay,\n                    \"loop\",      value.loop      || attributes.loop   || defaultSettings.loop,\n                    \"offset\",    value.offset    || attributes.offset || defaultSettings.offset,\n                    \"volume\",    (typeof value.volume !== 'undefined') ? value.volume : ((typeof attributes.volume !== 'undefined') ? attributes.volume : defaultSettings.volume),\n                    \"pan\",       value.pan       || attributes.pan    || defaultSettings.pan,\n                    \"muted\",      value.muted      || attributes.muted   || defaultSettings.muted,\n                    \"speed\",    (typeof value.speed !== 'undefined') ? value.speed : ((typeof attributes.speed !== 'undefined') ? attributes.speed : defaultSettings.speed),\n                    \"playthrough\", value.playthrough || attributes.playthrough || defaultSettings.playthrough\n                );\n                data.audio = this.player.play(sound, data);\n                if (data.pan) {\n                    data.audio.filters = [\n                        new pixi_sound__WEBPACK_IMPORTED_MODULE_2___default.a.filters.StereoFilter(data.audio.pan)\n                    ];\n                }\n                if (data.volume) {\n                    data.audio.volume = data.volume;\n                }\n                if (data.speed) {\n                    data.audio.speed = data.speed;\n                }\n                if (data.playthrough && (data.loop !== -1)) {\n                    data.audio.playthrough = true;\n                } else {\n                    data.audio.playthrough = false;\n                }\n                data.audio.on('end', completed.bind(this, data));\n                \n                data.audio.soundId = sound;\n                this.activeAudioClips.push(data.audio);\n\n                if (data.audio.playState === 'playFailed') {\n                    // Let's try again - maybe it was a loading issue.\n                    const\n                        wait = function (event) {\n                            if (event.id === sound) {\n                                data.audio.play(data);\n                                pixi_sound__WEBPACK_IMPORTED_MODULE_2___default.a.off('fileload', wait);\n                            }\n                        };\n\n                    pixi_sound__WEBPACK_IMPORTED_MODULE_2___default.a.on('fileload', wait);\n                }\n            };\n        },\n        stateAudioPlay = function (checkData, audioId, play, state) {\n            var active = state.includes(checkData.states);\n\n            if (active !== checkData.playing) {\n                if (active) {\n                    play();\n                } else {\n                    this.stopAudio(audioId, this.forcePlaythrough);\n                }\n                checkData.playing = active;\n            }\n        };\n    \n    return Object(_factory_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])({\n        id: 'AudioSFX',\n        \n        properties: {\n            /**\n             * Use the audioMap property object to map messages triggered with audio clips to play. At least one audio mapping should be included for audio to play. Here is an example audioMap object:\n             *\n             *       {\n             *           \"message-triggered\": \"audio-id\",\n             *           // This simple form is useful to listen for \"message-triggered\" and play \"audio-id\" using default audio properties.\n             *\n             *           \"another-message\": {\n             *           // To specify audio properties, instead of mapping the message to an audio id string, map it to an object with one or more of the properties shown below. Many of these properties directly correspond to SoundJS play parameters.\n             *\n             *               \"sound\": \"another-audio-id\",\n             *               // Required. This is the audio clip to play when \"another-message\" is triggered.\n             *\n             *               \"interrupt\": \"none\",\n             *               // Optional. Can be \"any\", \"early\", \"late\", or \"none\". Determines how to handle the audio when it's already playing but a new play request is received. Default is \"any\".\n             *\n             *               \"delay\": 500,\n             *               // Optional. Time in milliseconds to wait before playing audio once the message is received. Default is 0.\n             *\n             *               \"offset\": 1500,\n             *               // Optional. Time in milliseconds determining where in the audio clip to begin playback. Default is 0.\n             *\n             *               \"length\": 2500,\n             *               // Optional. Time in milliseconds to play audio before stopping it. If 0 or not specified, play continues to the end of the audio clip.\n             *\n             *               \"loop\": 4,\n             *               // Optional. Determines how many more times to play the audio clip once it finishes. Set to -1 for an infinite loop. Default is 0.\n             *\n             *               \"muted\": false,\n             *               // Whether clip should start muted.\n             *\n             *               \"volume\": 0.75,\n             *               // Optional. Used to specify how loud to play audio on a range from 0 (mute) to 1 (full volume). Default is 1.\n             *\n             *               \"speed\": 0.75,\n             *               // Optional. Used to specify how fast to play audio. Default is 1 (100% speed).\n             *\n             *               \"pan\": -0.25,\n             *               // Optional. Used to specify the pan of audio on a range of -1 (left) to 1 (right). Default is 0.\n             *\n             *               \"playthrough\": false\n             *               // Whether SFX should force completion of sound even when stopped prematurely.\n             *           }\n             *       }\n             *\n             * @property audioMap\n             * @type Object\n             * @default null\n             */\n            audioMap: null,\n\n            /**\n             * Determines whether a sound that's started should play through completely regardless of entity state changes.\n             *\n             * @property forcePlayThrough\n             * @type boolean\n             * @default true\n             */\n            forcePlayThrough: true,\n\n            /**\n             * Optional. Specifies whether this component should listen to events matching the animationMap to animate. Set this to true if the component should animate for on events.\n             *\n             * @property eventBased\n             * @type Boolean\n             * @default true\n             */\n            eventBased: true,\n\n            /**\n             * Optional. Specifies whether this component should listen to changes in the entity's state that match the animationMap to animate. Set this to true if the component should animate based on this.owner.state.\n             *\n             * @property stateBased\n             * @type Boolean\n             * @default false\n             */\n            stateBased: false\n        },\n            \n        initialize: function () {\n            var key      = '',\n                playClip = null,\n                sound    = null;\n            \n            this.activeAudioClips = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n    \n            this.state = this.owner.state;\n            this.stateChange = false;\n            \n            this.player = platypus.game.sfxPlayer;\n    \n            if (this.audioMap) {\n                if (this.stateBased) {\n                    this.checkStates = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n                }\n                for (key in this.audioMap) {\n                    if (this.audioMap.hasOwnProperty(key)) {\n                        sound = this.audioMap[key];\n                        playClip = playSound(sound);\n                        if (sound.sound) {\n                            sound = sound.sound;\n                        }\n                        \n                        /**\n                         * Listens for messages specified by the `audioMap` and on receiving them, begins playing corresponding audio clips. Audio play message can optionally include several parameters, many of which correspond with SoundJS play parameters.\n                         *\n                         * @method '*'\n                         * @param message.interrupt (string) - Optional. Can be \"any\", \"early\", \"late\", or \"none\". Determines how to handle the audio when it's already playing but a new play request is received. Default is \"any\".\n                         * @param message.delay (integer) - Optional. Time in milliseconds to wait before playing audio once the message is received. Default is 0.\n                         * @param message.length (integer) - Optional. Time in milliseconds to play audio before stopping it. If 0 or not specified, play continues to the end of the audio clip.\n                         * @param message.loop (integer) - Optional. Determines how many more times to play the audio clip once it finishes. Set to -1 for an infinite loop. Default is 0.\n                         * @param message.muted {Boolean} Whether clip should start muted.\n                         * @param message.offset (integer) - Optional. Time in milliseconds determining where in the audio clip to begin playback. Default is 0.\n                         * @param message.pan (float) - Optional. Used to specify the pan of audio on a range of -1 (left) to 1 (right). Default is 0.\n                         * @param message.playthrough {Boolean} Whether SFX should force completion of sound even when stopped prematurely.\n                         * @param message.speed (float) - Optional. Used to specify how fast to play audio. Default is 1.\n                         * @param message.volume (float) - Optional. Used to specify how loud to play audio on a range from 0 (mute) to 1 (full volume). Default is 1.\n                         */\n                        if (this.eventBased) {\n                            this.addEventListener(key, playClip);\n                        }\n                        if (this.stateBased) {\n                            this.addStateCheck(key, sound, playClip);\n                        }\n                    }\n                }\n            }\n            \n            this.paused          = false;\n        },\n\n        events: {\n            /**\n             * On each `handle-render` message, this component checks its list of playing audio clips and stops any clips whose play length has been reached.\n             *\n             * @method 'handle-render'\n             */\n            \"handle-render\": function () {\n                var i = 0,\n                    cs = null,\n                    state = this.state;\n                \n                if (this.paused) {\n                    return;\n                }\n                \n                if (this.stateBased && this.stateChange) {\n                    cs = this.checkStates;\n                    i = cs.length;\n                    while (i--) {\n                        cs[i].check(state);\n                    }\n                    this.stateChange = false;\n                }\n            },\n             \n            /**\n             * This component listens for changes to the entity state and tests the current state of the entity against the audio map. If a match is found, the matching audio clip is played.\n             *\n             * @method 'state-changed'\n             */\n            \"state-changed\": function () {\n                this.stateChange = true;\n            },\n\n            /**\n             * On receiving this message, the audio will mute if unmuted, and unmute if muted.\n             *\n             * @method 'toggle-mute'\n             * @param audioId {String} If an audioId is provided, that particular sound instance is toggled. Otherwise all audio is toggled from mute to unmute or vice versa.\n             */\n            \"toggle-mute\": function (audioId) {\n                this.handleClip(audioId, function (clip) {\n                    if (clip) {\n                        if (clip.unmuted) {\n                            clip.volume = clip.unmuted;\n                            delete clip.unmuted;\n                        } else {\n                            clip.unmuted = clip.volume;\n                            clip.volume = 0;\n                        }\n                    }\n                });\n            },\n\n            /**\n             * On receiving this message, audio will stop playing.\n             *\n             * @method 'stop-audio'\n             * @param audioId {String} If an audioId is provided, that particular sound instance is stopped. Otherwise all audio is stopped.\n             */\n            \"stop-audio\": function (audioId) {\n                if (!audioId) {\n                    this.stopAudio();\n                } else if (typeof audioId === 'string') {\n                    this.stopAudio(audioId);\n                } else {\n                    this.stopAudio(audioId.audioId || false, audioId.playthrough || false);\n                }\n            },\n\n            /**\n             * On receiving this message all audio will mute, or a particular sound instance will mute if an id is specified.\n             *\n             * @method 'mute-audio'\n             * @param audioId {String} If an audioId is provided, that particular sound instance will mute. Otherwise all audio is muted.\n             */\n            \"mute-audio\": function (audioId) {\n                this.handleClip(audioId, function (clip) {\n                    if (clip) {\n                        clip.unmuted = clip.volume;\n                        clip.volume = 0;\n                    }\n                });\n            },\n\n            /**\n             * On receiving this message all audio will unmute, or a particular sound instance will unmute if an id is specified.\n             *\n             * @method 'unmute-audio'\n             * @param audioId {String} If an audioId is provided, that particular sound instance will unmute. Otherwise all audio is unmuted.\n             */\n            \"unmute-audio\": function (audioId) {\n                this.handleClip(audioId, function (clip) {\n                    if (clip) {\n                        clip.volume = clip.unmuted;\n                        delete clip.unmuted;\n                    }\n                });\n            },\n\n            /**\n             * On receiving this message all audio will pause, or a particular sound instance will pause if an id is specified.\n             *\n             * @method 'pause-audio'\n             * @param audioId {String} If an audioId is provided, that particular sound instance will pause. Otherwise all audio is paused.\n             */\n            \"pause-audio\": function (audioId) {\n                this.handleClip(audioId, function (clip) {\n                    if (clip) {\n                        clip.pause();\n                    }\n                });\n            },\n\n            /**\n             * On receiving this message all audio will unpause, or a particular sound instance will unpause if an id is specified.\n             *\n             * @method 'unpause-audio'\n             * @param audioId {String} If an audioId is provided, that particular sound instance will unpause. Otherwise all audio is unpaused.\n             */\n            \"unpause-audio\": function (audioId) {\n                this.handleClip(audioId, function (clip) {\n                    if (clip) {\n                        clip.unpause();\n                    }\n                });\n            },\n             \n            /**\n             * This message sets the volume of playing audio.\n             *\n             * @method 'set-pan'\n             * @param pan {Number} A number from -1 to 1 that sets the pan.\n             * @param [soundId] {String} If an soundId is provided, that particular sound instance's pan is set.\n             */\n            \"set-pan\": function (pan, soundId) {\n                var id = soundId || '',\n                    handler = function (pan, clip) {\n                        if (clip) {\n                            clip.pan = pan;\n                        }\n                    };\n\n                if (soundId) {\n                    this.handleClip(id, handler.bind(null, pan));\n                } else {\n                    this.getAllClips(handler.bind(null, pan));\n                }\n            },\n             \n            /**\n             * This message sets the volume of playing audio.\n             *\n             * @method 'set-volume'\n             * @param volume {Number} A number from 0 to 1 that sets the volume.\n             * @param [soundId] {String} If an soundId is provided, that particular sound instance's volume is set. Otherwise all audio volume is changed.\n             */\n            \"set-volume\": function (volume, soundId) {\n                var id = soundId || '',\n                    handler = function (vol, clip) {\n                        if (clip) {\n                            clip.volume = vol;\n                        }\n                    };\n\n                if (soundId) {\n                    this.handleClip(id, handler.bind(null, volume));\n                } else {\n                    this.getAllClips(handler.bind(null, volume));\n                }\n            },\n\n            /**\n             * This message sets the speed of playing audio.\n             *\n             * @method 'set-speed'\n             * @param speed {Number} A number that sets the speed.\n             * @param [soundId] {String} If an soundId is provided, that particular sound instance's speed is set. Otherwise all audio speed is changed.\n             */\n            \"set-speed\": function (speed, soundId) {\n                var id = soundId || '',\n                    handler = function (spd, clip) {\n                        if (clip) {\n                            clip.speed = spd;\n                        }\n                    };\n\n                if (soundId) {\n                    this.handleClip(id, handler.bind(null, speed));\n                } else {\n                    this.getAllClips(handler.bind(null, speed));\n                }\n            }\n        },\n        \n        methods: {\n            handleClip: function (audioId, handler) {\n                if (typeof audioId === 'string') {\n                    this.getClipById(audioId, handler);\n                } else {\n                    this.getAllClips(handler);\n                }\n            },\n            \n            getClipById: function (id, onGet) {\n                var i     = 0,\n                    clips = this.activeAudioClips;\n                \n                for (i = 0; i < clips.length; i++) {\n                    if (clips[i].soundId === id) {\n                        if (onGet) {\n                            onGet(clips[i]);\n                        }\n                        return clips[i];\n                    }\n                }\n                \n                if (onGet) {\n                    onGet(null);\n                }\n\n                return null;\n            },\n            \n            getAllClips: function (onGet) {\n                var i     = 0,\n                    clips = this.activeAudioClips;\n                \n                if (onGet) {\n                    for (i = 0; i < clips.length; i++) {\n                        onGet(clips[i]);\n                    }\n                }\n\n                return clips;\n            },\n            \n            stopAudio: function (audioId, playthrough) {\n                var clips = this.activeAudioClips,\n                    i = clips.length;\n                \n                if (audioId) {\n                    while (i--) {\n                        if (clips[i].soundId === audioId) {\n                            if (clips[i].playthrough || playthrough) {\n                            } else {\n                                this.player.stop(clips[i]);\n                                Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSplice\"])(clips, i);\n                            }\n                        }\n                    }\n                } else {\n                    while (i--) {\n                        if (playthrough || clips[i].playthrough) {\n                        } else {\n                            this.player.stop(clips[i]);\n                        }\n                    }\n                    clips.length = 0;\n                }\n            },\n            \n            removeClip: function (audioClip) {\n                var i = this.activeAudioClips.indexOf(audioClip);\n\n                if (i >= 0) {\n                    Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSplice\"])(this.activeAudioClips, i);\n                }\n            },\n            \n            addStateCheck: function (key, value, play) {\n                var states = _StateMap_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].setUp(key),\n                    checkData = _Data_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp(\n                        \"states\", states,\n                        \"playing\", false\n                    );\n                \n                checkData.check = stateAudioPlay.bind(this, checkData, value, play.bind(this));\n                this.checkStates.push(checkData);\n            },\n            \n            destroy: function () {\n                var c = this.checkStates,\n                    ci = null,\n                    i = 0;\n                \n                this.stopAudio();\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.activeAudioClips);\n                this.activeAudioClips = null;\n                \n                this.state = null;\n\n                if (c) {\n                    i = c.length;\n                    while (i--) {\n                        ci = c[i];\n                        ci.states.recycle();\n                        ci.recycle();\n                    }\n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(c);\n                    this.checkStates = null;\n                }\n            }\n        },\n        \n        getAssetList: function (component, props, defaultProps) {\n            var key = '',\n                preload = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(),\n                audioMap = component.audioMap || props.audioMap || defaultProps.audioMap;\n            \n            for (key in audioMap) {\n                if (audioMap.hasOwnProperty(key)) {\n                    const item = (audioMap[key].sound || audioMap[key]) + '.{ogg,mp3}';\n                    if (preload.indexOf(item) === -1) {\n                        preload.push(item);\n                    }\n                }\n            }\n\n            return preload;\n        }\n    });\n}());\n\n\n//# sourceURL=webpack://platypus/./src/components/AudioSFX.js?");

/***/ }),

/***/ "./src/components/AudioVO.js":
/*!***********************************!*\
  !*** ./src/components/AudioVO.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Data_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Data.js */ \"./src/Data.js\");\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../factory.js */ \"./src/factory.js\");\n/**\n * This component plays audio using the SpringRoll VOPlayer instance. Audio is played by triggering specific messages defined in the audio component definition.\n *\n * @namespace platypus.components\n * @class AudioVO\n * @uses platypus.Component\n */\n/*global platypus */\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    var sortByTime = function (a, b) {\n            return a.time - b.time;\n        },\n        addEvents = function (fromList, toList) {\n            let i = 0;\n            \n            for (i = 0; i < fromList.length; i++) {\n                toList.push(_Data_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp(\n                    'event', fromList[i].event,\n                    'time', fromList[i].time || 0,\n                    'message', fromList[i].message || null,\n                    'interruptable', !!fromList[i].interruptable\n                ));\n            }\n            \n            if (i) {\n                toList.sort(sortByTime);\n            }\n            \n            return toList;\n        },\n        offsetEvents = function (fromList, toList, player) {\n            const offset = player.getElapsed();\n            let i = 0;\n            \n            for (i = 0; i < fromList.length; i++) {\n                toList.push(_Data_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp(\n                    'event', fromList[i].event,\n                    'time', (fromList[i].time || 0) + offset,\n                    'message', fromList[i].message || null,\n                    'interruptable', !!fromList[i].interruptable\n                ));\n            }\n            \n            if (i) {\n                toList.sort(sortByTime);\n            }\n        },\n        setupEventList = function (sounds, eventList, player) { // This function merges events from individual sounds into a full list queued to sync with the SpringRoll voPlayer.\n            var i = 0,\n                soundList = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp();\n            \n            // Create alias-only sound list.\n            for (i = 0; i < sounds.length; i++) {\n                if (sounds[i].sound) {\n                    if (sounds[i].events) {\n                        soundList.push(offsetEvents.bind(this, sounds[i].events, eventList, player));\n                    }\n                    soundList.push(sounds[i].sound);\n                } else {\n                    soundList.push(sounds[i]);\n                }\n            }\n            return soundList;\n        },\n        onComplete = function (completed, soundList) {\n            this.playingAudio = false;\n            if (!this.owner.destroyed) {\n                this.checkTimeEvents(true, completed);\n\n                /**\n                 * When an audio sequence is finished playing, this event is triggered.\n                 *\n                 * @event sequence-complete\n                 */\n                this.owner.triggerEvent('sequence-complete');\n            }\n            _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].recycle(soundList);\n        };\n    \n    return Object(_factory_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({\n        id: 'AudioVO',\n        \n        properties: {\n            /**\n             * Use the audioMap property object to map messages triggered with audio clips to play. At least one audio mapping should be included for audio to play. Here is an example audioMap object:\n             *\n             *       {\n             *           \"message-triggered\": \"audio-id\",\n             *           // This simple form is useful to listen for \"message-triggered\" and play \"audio-id\" using default audio properties.\n             *\n             *           \"another-message\": {\n             *           // To specify audio properties, instead of mapping the message to an audio id string, map it to an object with one or more of the properties shown below. Many of these properties directly correspond to SoundJS play parameters.\n             *\n             *               \"sound\": \"another-audio-id\",\n             *               // Required. This is the audio clip to play when \"another-message\" is triggered.\n             *\n             *               \"events\": [{\n             *                   \"event\": \"walk-to-the-left\",\n             *                   \"time\": 1500,\n             *                   \"interruptable\": true // If `false`, event will trigger immediately when VO is interrupted or otherwise ended before event's time is reached. If `true`, event is not triggered if VO stops before time is reached. Defaults to `false`.\n             *               }]\n             *               // Optional. Used to specify a list of events to play once the VO begins.\n             *           }\n             *       }\n             *\n             * @property audioMap\n             * @type Object\n             * @default null\n             */\n            audioMap: null\n        },\n            \n        initialize: function () {\n            var key = '';\n            \n            this.eventList = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp();\n    \n            this.playingAudio = false;\n            this.player = platypus.game.voPlayer;\n    \n            if (this.audioMap) {\n                for (key in this.audioMap) {\n                    if (this.audioMap.hasOwnProperty(key)) {\n\n                        /**\n                         * Listens for messages specified by the `audioMap` and on receiving them, begins playing corresponding audio clips.\n                         *\n                         * @method '*'\n                         * @param [message.events] {Array} Used to specify the list of events to trigger while playing this audio sequence.\n                         */\n                        this.addEventListener(key, this.playSound.bind(this, this.audioMap[key]));\n                    }\n                }\n            }\n            \n            this.paused = false;\n        },\n\n        events: {\n            /**\n             * On each `handle-render` message, this component checks its list of playing audio clips and stops any clips whose play length has been reached.\n             *\n             * @method 'handle-render'\n             */\n            \"handle-render\": function () {\n                if (!this.paused) {\n                    this.checkTimeEvents(false);\n                }\n            },\n\n            /**\n             * Plays voice-over directly without using a predefined mapping from `audioMap`. This event accepts the same syntax as individual items in the `audioMap`.\n             *\n             * @param {String|Array|Object} vo Voice-over track or tracks to play.\n             */\n            \"play-voice-over\": function (vo) {\n                this.playSound(vo);\n            },\n\n            /**\n             * On receiving this message, audio will stop playing.\n             *\n             * @method 'stop-audio'\n             */\n            \"stop-audio\": function () {\n                this.player.stop();\n                this.player.voList = []; // Workaround to prevent a Springroll bug wherein stopping throws an error due to `voList` being `null`.\n            }\n        },\n        \n        methods: {\n            checkTimeEvents: function (finished, completed) {\n                var event = null,\n                    events = this.eventList,\n                    currentTime = 0,\n                    owner = this.owner;\n                \n                if (events && events.length) {\n                    currentTime = finished ? Infinity : this.player.getElapsed();\n\n                    while (events.length && (events[0].time <= currentTime)) {\n                        event = events.shift();\n                        if (!finished || completed || !event.interruptable) {\n                            owner.trigger(event.event, event.message);\n                        }\n                        event.recycle();\n                    }\n                }\n            },\n\n            destroy: function () {\n                if (this.playingAudio) {\n                    this.player.stop();\n                    this.player.voList = []; // Workaround to prevent a Springroll bug wherein stopping throws an error due to `voList` being `null`.\n                }\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].recycle(this.eventList);\n                this.eventList = null;\n            },\n\n            playSound: function (soundDefinition, value) {\n                var soundList = null,\n                    eventList = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp(),\n                    player = this.player;\n    \n                if (typeof soundDefinition === 'string') {\n                    soundList = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp(soundDefinition);\n                } else if (Array.isArray(soundDefinition)) {\n                    soundList = setupEventList(soundDefinition, eventList, player);\n                } else {\n                    if (soundDefinition.events) {\n                        addEvents(soundDefinition.events, eventList);\n                    }\n                    if (Array.isArray(soundDefinition.sound)) {\n                        soundList = setupEventList(soundDefinition.sound, eventList, player);\n                    } else {\n                        soundList = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp(soundDefinition.sound);\n                    }\n                }\n                \n                if (value && value.events) {\n                    addEvents(value.events, eventList);\n                }\n    \n                player.play(soundList, onComplete.bind(this, true, soundList), onComplete.bind(this, false, soundList));\n    \n                // Removing `this.eventList` after play call since playing a VO clip could be stopping a currently playing clip with events in progress.\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].recycle(this.eventList);\n                this.eventList = eventList;\n                this.playingAudio = true;\n            }\n        }\n    });\n}());\n\n\n//# sourceURL=webpack://platypus/./src/components/AudioVO.js?");

/***/ }),

/***/ "./src/components/Camera.js":
/*!**********************************!*\
  !*** ./src/components/Camera.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _AABB_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../AABB.js */ \"./src/AABB.js\");\n/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pixi.js */ \"pixi.js\");\n/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(pixi_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _Data_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Data.js */ \"./src/Data.js\");\n/* harmony import */ var _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tweenjs/tween.js */ \"@tweenjs/tween.js\");\n/* harmony import */ var _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _Vector_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Vector.js */ \"./src/Vector.js\");\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../factory.js */ \"./src/factory.js\");\n/**\n * This component controls the game camera deciding where and how it should move. The camera also broadcasts messages when the window resizes or its orientation changes.\n *\n * @namespace platypus.components\n * @class Camera\n * @uses platypus.Component\n*/\n/*global platypus, window */\n\n\n\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    var DPR = window.devicePixelRatio || 1,\n        anchorBound = function (anchorAABB, entityOffsetX, entityOffsetY, entity) {\n            var aabb = _AABB_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp(entity.x + entityOffsetX, entity.y + entityOffsetY, entity.width, entity.height),\n                x = anchorAABB.x,\n                y = anchorAABB.y;\n\n            if (aabb.top < anchorAABB.top) {\n                y -= (anchorAABB.top - aabb.top);\n            } else if (aabb.bottom > anchorAABB.bottom) {\n                y += (anchorAABB.bottom - aabb.bottom);\n            }\n            \n            if (aabb.left < anchorAABB.left) {\n                x -= (anchorAABB.left - aabb.left);\n            } else if (aabb.right > anchorAABB.right) {\n                x += (anchorAABB.right - aabb.right);\n            }\n            \n            aabb.recycle();\n            \n            return this.move(x, y, 0);\n        },\n        doNothing = function () {\n            return false;\n        },\n\n        // These fix coords for touch events filling in for pointer events from the PIXI InteractiveManager\n        getClientX = function (event) {\n            if (!event.clientX) {\n                if (event.touches && event.touches[0] && event.touches[0].clientX) {\n                    return event.touches[0].clientX;\n                }\n                return 0;\n            }\n            return event.clientX;\n        },\n        getClientY = function (event) {\n            if (!event.clientY) {\n                if (event.touches && event.touches[0] && event.touches[0].clientY) {\n                    return event.touches[0].clientY;\n                }\n                return 0;\n            }\n            return event.clientY;\n        };\n    \n    return Object(_factory_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])({\n        id: 'Camera',\n        properties: {\n            /**\n             * Number specifying width of viewport in world coordinates.\n             *\n             * @property width\n             * @type number\n             * @default 0\n             **/\n            \"width\": 0,\n             \n            /**\n             * Number specifying height of viewport in world coordinates.\n             *\n             * @property height\n             * @type number\n             * @default 0\n             **/\n            \"height\": 0,\n            \n            /**\n             * Specifies whether the camera should be draggable via the mouse by setting to 'pan'.\n             *\n             * @property mode\n             * @type String\n             * @default 'static'\n             **/\n            \"mode\": \"static\",\n            \n            /**\n             * Whether camera overflows to cover the whole canvas or remains contained within its aspect ratio's boundary.\n             *\n             * @property overflow\n             * @type boolean\n             * @default false\n             */\n            \"overflow\": false,\n            \n            /**\n             * Boolean value that determines whether the camera should stretch the world viewport when window is resized. Defaults to false which maintains the proper aspect ratio.\n             *\n             * @property stretch\n             * @type boolean\n             * @default: false\n             */\n            \"stretch\": false,\n            \n            /**\n             * Sets how many units the followed entity can move before the camera will re-center. This should be lowered for small-value coordinate systems such as Box2D.\n             *\n             * @property threshold\n             * @type number\n             * @default 1\n             **/\n            \"threshold\": 1,\n            \n            /**\n             * Whether, when following an entity, the camera should rotate to match the entity's orientation.\n             *\n             * @property rotate\n             * @type boolean\n             * @default false\n             **/\n            \"rotate\": false,\n\n            /**\n             * Number specifying the horizontal center of viewport in world coordinates.\n             *\n             * @property x\n             * @type number\n             * @default 0\n             **/\n            \"x\": 0,\n             \n            /**\n             * Number specifying the vertical center of viewport in world coordinates.\n             *\n             * @property y\n             * @type number\n             * @default 0\n             **/\n            \"y\": 0\n        },\n        publicProperties: {\n            /**\n             * The entity's canvas element is used to determine the window size of the camera.\n             *\n             * @property canvas\n             * @type DOMElement Canvas\n             * @default null\n             */\n            \"canvas\": null,\n            \n            /**\n             * Sets how quickly the camera should pan to a new position in the horizontal direction.\n             *\n             * @property transitionX\n             * @type number\n             * @default 400\n             **/\n            \"transitionX\": 400,\n            \n            /**\n             * Sets how quickly the camera should pan to a new position in the vertical direction.\n             *\n             * @property transitionY\n             * @type number\n             * @default 600\n             **/\n            \"transitionY\": 600,\n             \n            /**\n             * Sets how quickly the camera should rotate to a new orientation.\n             *\n             * @property transitionAngle\n             * @type number\n             * @default: 600\n             **/\n            \"transitionAngle\": 600\n        },\n        initialize: function (definition) {\n            var worldVP = _AABB_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp(this.x, this.y, this.width, this.height),\n                worldCamera = _Data_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(\n                    \"viewport\", worldVP,\n                    \"orientation\", definition.orientation || 0\n                );\n\n            //The dimensions of the camera in the window\n            this.viewport = _AABB_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp(0, 0, 0, 0);\n            \n            //The dimensions of the camera in the game world\n            this.worldCamera = worldCamera;\n\n            //Message object defined here so it's reusable\n            this.worldDimensions = _AABB_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp();\n            this.message = _Data_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(\n                \"viewport\", _AABB_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp(),\n                \"scaleX\", 0,\n                \"scaleY\", 0,\n                \"orientation\", 0,\n                \"stationary\", false,\n                \"world\", this.worldDimensions\n            );\n            this.cameraLoadedMessage = _Data_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(\n                \"viewport\", this.message.viewport,\n                \"world\", this.worldDimensions\n            );\n    \n            //Whether the map has finished loading.\n            this.worldIsLoaded = false;\n            \n            this.following = null;\n            this.state = 'static';//'roaming';\n            if (this.mode === 'pan') {\n                this.state = 'mouse-pan';\n            }\n            \n            //FOLLOW MODE VARIABLES\n            \n            //--Bounding\n            this.boundingBox = _AABB_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp(worldVP.x, worldVP.y, worldVP.width / 2, worldVP.height / 2);\n            \n            //Forward Follow\n            this.lastX = worldVP.x;\n            this.lastY = worldVP.y;\n            this.lastOrientation = worldCamera.orientation;\n            this.forwardX = 0;\n            this.forwardY = 0;\n            this.forwardAngle = 0;\n            this.averageOffsetX = 0;\n            this.averageOffsetY = 0;\n            this.averageOffsetAngle = 0;\n            this.offsetX = 0;\n            this.offsetY = 0;\n            this.offsetAngle = 0;\n            this.forwardFollower = _Data_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(\n                \"x\", this.lastX,\n                \"y\", this.lastY,\n                \"orientation\", this.lastOrientation\n            );\n            \n            this.lastFollow = _Data_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(\n                \"entity\", null,\n                \"mode\", null,\n                \"offsetX\", 0,\n                \"offsetY\", 0,\n                \"begin\", 0\n            );\n            \n            this.xMagnitude = 0;\n            this.yMagnitude = 0;\n            this.xWaveLength = 0;\n            this.yWaveLength = 0;\n            this.xShakeTime = 0;\n            this.yShakeTime = 0;\n            this.shakeTime = 0;\n            this.shakeIncrementor = 0;\n            \n            this.direction = true;\n            this.stationary = false;\n            \n            this.viewportUpdate = false;\n            \n            if (this.owner.container) {\n                this.parentContainer = this.owner.container;\n            } else if (this.owner.stage) {\n                this.canvas = this.canvas || platypus.game.canvas; //TODO: Probably need to find a better way to handle resizing - DDD 10/4/2015\n                this.parentContainer = this.owner.stage;\n                this.owner.width  = this.canvas.width;\n                this.owner.height = this.canvas.height;\n            } else {\n                platypus.debug.warn('Camera: There appears to be no Container on this entity for the camera to display.');\n            }\n            this.container = new pixi_js__WEBPACK_IMPORTED_MODULE_1__[\"Container\"]();\n            this.container.visible = false;\n            this.parentContainer.addChild(this.container);\n            this.movedCamera = false;\n        },\n        events: {\n            /**\n             * Sets up the camera window size on load.\n             *\n             * @method 'load'\n             */\n            \"load\": function () {\n                this.resize();\n            },\n            \n            /**\n             * On receiving this message, the camera begins viewing the world.\n             *\n             * @method 'render-world'\n             * @param data {Object} Information about the world.\n             * @param data.world {PIXI.Container} The container containing world entities.\n             */\n            \"render-world\": function (data) {\n                this.world = data.world;\n                this.container.addChild(this.world);\n            },\n            \n            /**\n             * The viewport is flagged to update when children are added.\n             *\n             * @method 'child-entity-added'\n             * @param entity {platypus.Entity} Expects an entity as the message object.\n              **/\n            \"child-entity-added\": function (entity) {\n                this.viewportUpdate = true;\n                \n                if (this.worldIsLoaded) {\n                    /**\n                     * On receiving a \"world-loaded\" message, the camera broadcasts the world size to all children in the world.\n                     *\n                     * @event 'camera-loaded'\n                     * @param message\n                     * @param message.world {platypus.AABB} The dimensions of the world map.\n                     **/\n                    entity.triggerEvent('camera-loaded', this.cameraLoadedMessage);\n                }\n            },\n\n            /**\n             * Triggers \"camera-update\" on newly changed entities.\n             *\n             * @method 'child-entity-updated'\n             * @param entity {platypus.Entity} Expects an entity as the message object to determine whether to trigger `camera-update` on it.\n             **/\n            \"child-entity-updated\": function (entity) {\n                this.viewportUpdate = true;\n                \n                if (this.worldIsLoaded) {\n                    entity.triggerEvent('camera-update', this.message);\n                }\n            },\n\n            /**\n             * On receiving this message, the camera updates its world location and size as necessary. An example of this message is triggered by the [TiledLoader](platypus.components.TiledLoader.html) component.\n             *\n             * @method 'world-loaded'\n             * @param message {Object}\n             * @param [message.width] {number} The width of the loaded world.\n             * @param [message.height] {number} The height of the loaded world.\n             * @param [message.camera] {platypus.Entity} An entity that the camera should follow in the loaded world.\n             **/\n            \"world-loaded\": function (values) {\n                var msg = this.message;\n                \n                msg.viewport.set(this.worldCamera.viewport);\n                this.worldDimensions.set(values.world);\n                \n                this.worldIsLoaded = true;\n                if (values.camera) {\n                    this.follow(values.camera);\n                }\n                if (this.owner.triggerEventOnChildren) {\n                    this.owner.triggerEventOnChildren('camera-loaded', this.cameraLoadedMessage);\n                }\n                this.updateMovementMethods();\n            },\n            \n            /**\n             * If mouse dragging should cause the camera to move, this listens for the beginning of the drag motion.\n             *\n             * @method 'pointerdown'\n             * @param event {Object} The pointer event.\n             **/\n            \"pointerdown\": function (event) {\n                var worldVP = this.worldCamera.viewport;\n\n                if (this.state === 'mouse-pan') {\n                    if (!this.mouseVector) {\n                        this.mouseVector = _Vector_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].setUp();\n                        this.mouseWorldOrigin = _Vector_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].setUp();\n                    }\n                    this.mouse = this.mouseVector;\n                    this.mouse.x = getClientX(event.event);\n                    this.mouse.y = getClientY(event.event);\n                    this.mouseWorldOrigin.x = worldVP.x;\n                    this.mouseWorldOrigin.y = worldVP.y;\n                    event.pixiEvent.stopPropagation();\n                }\n            },\n            \n            /**\n             * If mouse dragging should cause the camera to move, this listens the drag motion.\n             *\n             * @method 'pressmove'\n             * @param event {Object} The pointer event.\n             **/\n            \"pressmove\": function (event) {\n                if (this.mouse) {\n                    if (this.move(this.mouseWorldOrigin.x + ((this.mouse.x - getClientX(event.event)) * DPR) / this.world.transform.worldTransform.a, this.mouseWorldOrigin.y + ((this.mouse.y - getClientY(event.event)) * DPR) / this.world.transform.worldTransform.d)) {\n                        this.viewportUpdate = true;\n                        this.movedCamera = true;\n                        event.pixiEvent.stopPropagation();\n                    }\n                }\n            },\n\n            /**\n             * If mouse dragging should cause the camera to move, this listens for the end of the drag motion.\n             *\n             * @method 'pressup'\n             * @param event {Object} The pointer event.\n             **/\n            \"pressup\": function (event) {\n                if (this.mouse) {\n                    this.mouse = null;\n                    if (this.movedCamera) {\n                        this.movedCamera = false;\n                        event.pixiEvent.stopPropagation();\n                    }\n                }\n            },\n            \n            /**\n             * On a \"tick\" step event, the camera updates its location according to its current state.\n             *\n             * @method 'tick'\n             * @param message {Object}\n             * @param message.delta {Number} If necessary, the current camera update function may require the length of the tick to adjust movement rate.\n             **/\n            \"tick\": function (resp) {\n                var msg       = this.message,\n                    viewport  = msg.viewport,\n                    worldCamera = this.worldCamera;\n                \n                if ((this.state === 'following') && this.followingFunction(this.following, resp.delta)) {\n                    this.viewportUpdate = true;\n                }\n                \n                // Need to update owner's size information for changes to canvas size\n                if (this.canvas) {\n                    this.owner.width  = this.canvas.width;\n                    this.owner.height = this.canvas.height;\n                }\n                \n                // Check for owner resizing\n                if ((this.owner.width !== this.lastWidth) || (this.owner.height !== this.lastHeight)) {\n                    this.resize();\n                    this.lastWidth = this.owner.width;\n                    this.lastHeight = this.owner.height;\n                }\n                \n                if (this.viewportUpdate) {\n                    this.viewportUpdate = false;\n                    this.stationary = false;\n                    msg.stationary = false;\n                    \n                    viewport.set(worldCamera.viewport);\n\n                    if (this.shakeIncrementor < this.shakeTime) {\n                        this.viewportUpdate = true;\n                        this.shakeIncrementor += resp.delta;\n                        this.shakeIncrementor = Math.min(this.shakeIncrementor, this.shakeTime);\n                        \n                        if (this.shakeIncrementor < this.xShakeTime) {\n                            viewport.moveX(viewport.x + Math.sin((this.shakeIncrementor / this.xWaveLength) * (Math.PI * 2)) * this.xMagnitude);\n                        }\n                        \n                        if (this.shakeIncrementor < this.yShakeTime) {\n                            viewport.moveY(viewport.y + Math.sin((this.shakeIncrementor / this.yWaveLength) * (Math.PI * 2)) * this.yMagnitude);\n                        }\n                    }\n\n                    // Set up the rest of the camera message:\n                    msg.scaleX         = this.windowPerWorldUnitWidth;\n                    msg.scaleY         = this.windowPerWorldUnitHeight;\n                    msg.orientation    = worldCamera.orientation;\n                    \n                    // Transform the world to appear within camera\n                    this.world.setTransform(-viewport.x, -viewport.y, 1, 1, 0);\n                    this.container.setTransform(viewport.halfWidth * msg.scaleX, viewport.halfHeight * msg.scaleY, msg.scaleX, msg.scaleY, msg.orientation);\n                    this.container.visible = true;\n\n                    /**\n                     * This component fires \"camera-update\" when the position of the camera in the world has changed. This event is triggered on both the entity (typically a layer) as well as children of the entity.\n                     *\n                     * @event 'camera-update'\n                     * @param message {Object}\n                     * @param message.world {platypus.AABB} The dimensions of the world map.\n                     * @param message.orientation {Number} Number describing the orientation of the camera.\n                     * @param message.scaleX {Number} Number of window pixels that comprise a single world coordinate on the x-axis.\n                     * @param message.scaleY {Number} Number of window pixels that comprise a single world coordinate on the y-axis.\n                     * @param message.viewport {platypus.AABB} An AABB describing the world viewport area.\n                     * @param message.stationary {Boolean} Whether the camera is moving.\n                     **/\n                    this.owner.triggerEvent('camera-update', msg);\n                    if (this.owner.triggerEventOnChildren) {\n                        this.owner.triggerEventOnChildren('camera-update', msg);\n                    }\n                } else if (!this.stationary) {\n                    this.stationary = true;\n                    msg.stationary = true;\n\n                    this.owner.triggerEvent('camera-update', msg);\n                    if (this.owner.triggerEventOnChildren) {\n                        this.owner.triggerEventOnChildren('camera-update', msg);\n                    }\n                }\n                \n                if (this.lastFollow.begin) {\n                    if (this.lastFollow.begin < Date.now()) {\n                        this.follow(this.lastFollow);\n                    }\n                }\n            },\n            \n            /**\n            * The camera listens for this event to change its world viewport size.\n            *\n            * @method 'resize-camera'\n            * @param dimensions {Object} List of key/value pairs describing new viewport size\n            * @param dimensions.width {number} Width of the camera viewport\n            * @param dimensions.height {number} Height of the camera viewport\n            **/\n            \"resize-camera\": function (dimensions) {\n                this.width = dimensions.width;\n                this.height = dimensions.height;\n                this.resize();\n            },\n            \n            /**\n             * The camera listens for this event to change its position in the world.\n             *\n             * @method 'relocate'\n             * @param location {Vector|Object} List of key/value pairs describing new location\n             * @param location.x {Number} New position along the x-axis.\n             * @param location.y {Number} New position along the y-axis.\n             * @param [location.time] {Number} The time to transition to the new location.\n             * @param [location.ease] {Function} The ease function to use. Defaults to a linear transition.\n             */\n            \"relocate\": (function () {\n                var move = function (v) {\n                        if (this.move(v.x, v.y)) {\n                            this.viewportUpdate = true;\n                        }\n                    },\n                    stop = function () {\n                        this.recycle();\n                    };\n\n                return function (location) {\n                    var v = null,\n                        worldVP = this.worldCamera.viewport;\n\n                    if (location.time) {\n                        v = _Vector_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].setUp(worldVP.x, worldVP.y);\n                        new _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_3___default.a.Tween(v).to({x: location.x, y: location.y}, location.time).easing(location.ease).onUpdate(move.bind(this, v)).onStop(stop.bind(v)).start();\n                    } else if (this.move(location.x, location.y)) {\n                        this.viewportUpdate = true;\n                    }\n                };\n            }()),\n            \n            /**\n            * On receiving this message, the camera begins following the requested object.\n            *\n            * @method 'follow'\n            * @param message {Object}\n            * @param message.mode {String} Can be \"locked\", \"forward\", \"bounding\", \"anchor-bound\", or \"static\". \"static\" suspends following, but the other three settings require that the entity parameter be defined. Also set the bounding area parameters if sending \"bounding\" as the following method and the movement parameters if sending \"forward\" as the following method.\n            * @param [message.entity] {platypus.Entity} The entity that the camera should commence following.\n            * @param [message.top] {number} The top of a bounding box following an entity.\n            * @param [message.left] {number} The left of a bounding box following an entity.\n            * @param [message.width] {number} The width of a bounding box following an entity.\n            * @param [message.height] {number} The height of a bounding box following an entity.\n            * @param [message.movementX] {number} Movement multiplier for focusing the camera ahead of a moving entity in the horizontal direction.\n            * @param [message.movementY] {number} Movement multiplier for focusing the camera ahead of a moving entity in the vertical direction.\n            * @param [message.offsetX] {number} How far to offset the camera from the entity horizontally.\n            * @param [message.offsetY] {number} How far to offset the camera from the entity vertically.\n            * @param [message.time] {number} How many milliseconds to follow the entity.\n            **/\n            \"follow\": function (def) {\n                this.follow(def);\n            },\n            \n            /**\n            * On receiving this message, the camera will shake around its target location.\n            *\n            * @method 'shake'\n            * @param shake {Object}\n            * @param [shake.xMagnitude] {number} How much to move along the x axis.\n            * @param [shake.yMagnitude] {number} How much to move along the y axis.\n            * @param [shake.xFrequency] {number} How quickly to shake along the x axis.\n            * @param [shake.yFrequency] {number} How quickly to shake along the y axis.\n            * @param [shake.time] {number} How long the camera should shake.\n            **/\n            \"shake\": function (shakeDef) {\n                var def = shakeDef || {},\n                    xMag    = def.xMagnitude || 0,\n                    yMag    = def.yMagnitude || 0,\n                    xFreq   = def.xFrequency || 0, //Cycles per second\n                    yFreq   = def.yFrequency || 0, //Cycles per second\n                    second  = 1000,\n                    time    = def.time || 0;\n                \n                this.viewportUpdate = true;\n                \n                this.shakeIncrementor = 0;\n                \n                this.xMagnitude = xMag;\n                this.yMagnitude = yMag;\n                \n                if (xFreq === 0) {\n                    this.xWaveLength = 1;\n                    this.xShakeTime = 0;\n                } else {\n                    this.xWaveLength = (second / xFreq);\n                    this.xShakeTime = Math.ceil(time / this.xWaveLength) * this.xWaveLength;\n                }\n                \n                if (yFreq === 0) {\n                    this.yWaveLength = 1;\n                    this.yShakeTime = 0;\n                } else {\n                    this.yWaveLength = (second / yFreq);\n                    this.yShakeTime = Math.ceil(time / this.yWaveLength) * this.yWaveLength;\n                }\n                \n                this.shakeTime = Math.max(this.xShakeTime, this.yShakeTime);\n            }\n        },\n        \n        methods: {\n            follow: function (def) {\n                var portion = 0.1;\n                \n                if (def.time) { //save current follow\n                    if (!this.lastFollow.begin) {\n                        this.lastFollow.entity = this.following;\n                        this.lastFollow.mode   = this.mode;\n                        this.lastFollow.offsetX = this.offsetX;\n                        this.lastFollow.offsetY = this.offsetY;\n                    }\n                    this.lastFollow.begin  = Date.now() + def.time;\n                } else if (this.lastFollow.begin) {\n                    this.lastFollow.begin = 0;\n                }\n                \n                this.mode = def.mode;\n                \n                switch (def.mode) {\n                case 'locked':\n                    this.state = 'following';\n                    this.following = def.entity;\n                    this.followingFunction = this.lockedFollow;\n                    this.offsetX = def.offsetX || 0;\n                    this.offsetY = def.offsetY || 0;\n                    this.offsetAngle = def.offsetAngle || 0;\n                    break;\n                case 'forward':\n                    this.state = 'following';\n                    this.followFocused   = false;\n                    this.following       = def.entity;\n                    this.lastX           = def.entity.x - def.offsetX || 0;\n                    this.lastY           = def.entity.y - def.offsetY || 0;\n                    this.lastOrientation = def.entity.orientation || 0;\n                    this.forwardX  = def.movementX || (this.transitionX * portion);\n                    this.forwardY  = def.movementY || (this.transitionY * portion);\n                    this.averageOffsetX = 0;\n                    this.averageOffsetY = 0;\n                    this.averageOffsetAngle = 0;\n                    this.offsetX = def.offsetX || 0;\n                    this.offsetY = def.offsetY || 0;\n                    this.offsetAngle = def.offsetAngle || 0;\n                    this.followingFunction = this.forwardFollow;\n                    break;\n                case 'bounding':\n                    this.state = 'following';\n                    this.following = def.entity;\n                    this.offsetX = def.offsetX || 0;\n                    this.offsetY = def.offsetY || 0;\n                    this.offsetAngle = def.offsetAngle || 0;\n                    this.boundingBox.setAll(def.x, def.y, def.width, def.height);\n                    this.followingFunction = this.boundingFollow;\n                    break;\n                case 'anchor-bound':\n                    this.state = 'following';\n                    this.following = def.entity;\n                    this.followingFunction = anchorBound.bind(this, def.anchorAABB, def.offsetX || 0, def.offsetY || 0);\n                    break;\n                case 'pan':\n                    this.state = 'mouse-pan';\n                    this.following = null;\n                    this.followingFunction = null;\n                    if (def && (typeof def.x === 'number') && (typeof def.y === 'number')) {\n                        this.move(def.x, def.y, def.orientation || 0);\n                        this.viewportUpdate = true;\n                    }\n                    break;\n                default:\n                    this.state = 'static';\n                    this.following = null;\n                    this.followingFunction = null;\n                    if (def && (typeof def.x === 'number') && (typeof def.y === 'number')) {\n                        this.move(def.x, def.y, def.orientation || 0);\n                        this.viewportUpdate = true;\n                    }\n                    break;\n                }\n                \n                if (def.begin) { // get rid of last follow\n                    def.begin = 0;\n                }\n\n            },\n            \n            move: function (x, y, newOrientation) {\n                var moved = this.moveX(x);\n                moved = this.moveY(y) || moved;\n                if (this.rotate) {\n                    moved = this.reorient(newOrientation || 0) || moved;\n                }\n                return moved;\n            },\n            \n            moveX: doNothing,\n            \n            moveY: doNothing,\n            \n            reorient: function (newOrientation) {\n                var errMargin = 0.0001,\n                    worldCamera = this.worldCamera;\n                \n                if (Math.abs(worldCamera.orientation - newOrientation) > errMargin) {\n                    worldCamera.orientation = newOrientation;\n                    return true;\n                }\n                return false;\n            },\n            \n            lockedFollow: (function () {\n                var min = Math.min,\n                    getTransitionalPoint = function (a, b, ratio) {\n                        // Find point between two points according to ratio.\n                        return ratio * b + (1 - ratio) * a;\n                    },\n                    getRatio = function (transition, time) {\n                        // Look at the target transition time (in milliseconds) and set up ratio accordingly.\n                        if (transition) {\n                            return min(time / transition, 1);\n                        } else {\n                            return 1;\n                        }\n                    };\n                \n                return function (entity, time) {\n                    var worldCamera = this.worldCamera,\n                        worldVP = worldCamera.viewport,\n                        x = getTransitionalPoint(worldVP.x, entity.x + this.offsetX, getRatio(this.transitionX, time)),\n                        y = getTransitionalPoint(worldVP.y, entity.y + this.offsetY, getRatio(this.transitionY, time));\n\n                    if (this.rotate) { // Only run the orientation calculations if we need them.\n                        return this.move(x, y, getTransitionalPoint(worldCamera.orientation, -(entity.orientation || 0), getRatio(this.transitionAngle, time)));\n                    } else {\n                        return this.move(x, y, 0);\n                    }\n                };\n            }()),\n            \n            forwardFollow: function (entity, time) {\n                var avgFraction = 0.9,\n                    avgFractionFlip = 1 - avgFraction,\n                    ff = this.forwardFollower,\n                    moved  = false,\n                    ms = 15,\n                    standardizeTimeDistance = ms / time, //This allows the camera to pan appropriately on slower devices or longer ticks\n                    worldCamera = this.worldCamera,\n                    worldVP = worldCamera.viewport,\n                    x = entity.x + this.offsetX,\n                    y = entity.y + this.offsetY,\n                    a = (entity.orientation || 0) + this.offsetAngle;\n                \n                if (this.followFocused && (this.lastX === x) && (this.lastY === y)) {\n                    return this.lockedFollow(ff, time);\n                } else {\n                    // span over last 10 ticks to prevent jerkiness\n                    this.averageOffsetX *= avgFraction;\n                    this.averageOffsetY *= avgFraction;\n                    this.averageOffsetX += avgFractionFlip * (x - this.lastX) * standardizeTimeDistance;\n                    this.averageOffsetY += avgFractionFlip * (y - this.lastY) * standardizeTimeDistance;\n\n                    if (Math.abs(this.averageOffsetX) > (worldVP.width / (this.forwardX * 2))) {\n                        this.averageOffsetX = 0;\n                    }\n                    if (Math.abs(this.averageOffsetY) > (worldVP.height / (this.forwardY * 2))) {\n                        this.averageOffsetY = 0;\n                    }\n                    \n                    if (this.rotate) {\n                        this.averageOffsetAngle *= avgFraction;\n                        this.averageOffsetAngle += avgFractionFlip * (a - this.lastOrientation) * standardizeTimeDistance;\n                        if (Math.abs(this.averageOffsetAngle) > (worldCamera.orientation / (this.forwardAngle * 2))) {\n                            this.averageOffsetAngle = 0;\n                        }\n                    }\n\n                    ff.x = this.averageOffsetX * this.forwardX + x;\n                    ff.y = this.averageOffsetY * this.forwardY + y;\n                    ff.orientation = this.averageOffsetAngle * this.forwardAngle + a;\n                    \n                    this.lastX = x;\n                    this.lastY = y;\n                    this.lastOrientation = a;\n                    \n                    moved = this.lockedFollow(ff, time);\n\n                    if (!this.followFocused && !moved) {\n                        this.followFocused = true;\n                    }\n                    \n                    return moved;\n                }\n                \n                \n            },\n            \n            boundingFollow: function (entity, time) {\n                var x = 0,\n                    y = 0,\n                    ratioX  = (this.transitionX ? Math.min(time / this.transitionX, 1) : 1),\n                    iratioX = 1 - ratioX,\n                    ratioY  = (this.transitionY ? Math.min(time / this.transitionY, 1) : 1),\n                    iratioY = 1 - ratioY,\n                    worldVP = this.worldCamera.viewport;\n                \n                this.boundingBox.move(worldVP.x, worldVP.y);\n                \n                if (entity.x > this.boundingBox.right) {\n                    x = entity.x - this.boundingBox.halfWidth;\n                } else if (entity.x < this.boundingBox.left) {\n                    x = entity.x + this.boundingBox.halfWidth;\n                }\n                \n                if (entity.y > this.boundingBox.bottom) {\n                    y = entity.y - this.boundingBox.halfHeight;\n                } else if (entity.y < this.boundingBox.top) {\n                    y = entity.y + this.boundingBox.halfHeight;\n                }\n                \n                if (x !== 0) {\n                    x = this.moveX(ratioX * x + iratioX * worldVP.x);\n                }\n                \n                if (y !== 0) {\n                    y = this.moveY(ratioY * y + iratioY * worldVP.y);\n                }\n                \n                return x || y;\n            },\n            \n            resize: function () {\n                var worldAspectRatio = this.width / this.height,\n                    windowAspectRatio = this.owner.width / this.owner.height,\n                    worldVP = this.worldCamera.viewport;\n                \n                //The dimensions of the camera in the window\n                this.viewport.setAll(this.owner.width / 2, this.owner.height / 2, this.owner.width, this.owner.height);\n                \n                if (!this.stretch) {\n                    if (windowAspectRatio > worldAspectRatio) {\n                        if (this.overflow) {\n                            worldVP.resize(this.height * windowAspectRatio, this.height);\n                        } else {\n                            this.viewport.resize(this.viewport.height * worldAspectRatio, this.viewport.height);\n                        }\n                    } else if (this.overflow) {\n                        worldVP.resize(this.width, this.width / windowAspectRatio);\n                    } else {\n                        this.viewport.resize(this.viewport.width, this.viewport.width / worldAspectRatio);\n                    }\n                }\n                \n                this.worldPerWindowUnitWidth  = worldVP.width  / this.viewport.width;\n                this.worldPerWindowUnitHeight = worldVP.height / this.viewport.height;\n                this.windowPerWorldUnitWidth  = this.viewport.width  / worldVP.width;\n                this.windowPerWorldUnitHeight = this.viewport.height / worldVP.height;\n                \n                this.container.setTransform(this.viewport.x - this.viewport.halfWidth, this.viewport.y - this.viewport.halfHeight);\n                \n                this.viewportUpdate = true;\n                \n                this.updateMovementMethods();\n            },\n            \n            updateMovementMethods: (function () {\n                // This is used to change movement modes as needed rather than doing a check every tick to determine movement type. - DDD 2/29/2016\n                var doNot = doNothing,\n                    centerX = function () {\n                        var world = this.worldDimensions;\n                        \n                        this.worldCamera.viewport.moveX(world.width / 2 + world.left);\n                        this.moveX = doNot;\n                        return true;\n                    },\n                    centerY = function () {\n                        var world = this.worldDimensions;\n                        \n                        this.worldCamera.viewport.moveY(world.height / 2 + world.top);\n                        this.moveY = doNot;\n                        return true;\n                    },\n                    containX = function (x) {\n                        var aabb = this.worldCamera.viewport,\n                            d = this.worldDimensions,\n                            w = d.width,\n                            l = d.left;\n                        \n                        if (Math.abs(aabb.x - x) > this.threshold) {\n                            if (x + aabb.halfWidth > w + l) {\n                                aabb.moveX(w - aabb.halfWidth + l);\n                            } else if (x < aabb.halfWidth + l) {\n                                aabb.moveX(aabb.halfWidth + l);\n                            } else {\n                                aabb.moveX(x);\n                            }\n                            return true;\n                        }\n                        return false;\n                    },\n                    containY = function (y) {\n                        var aabb = this.worldCamera.viewport,\n                            d = this.worldDimensions,\n                            h = d.height,\n                            t = d.top;\n                        \n                        if (Math.abs(aabb.y - y) > this.threshold) {\n                            if (y + aabb.halfHeight > h + t) {\n                                aabb.moveY(h - aabb.halfHeight + t);\n                            } else if (y < aabb.halfHeight + t) {\n                                aabb.moveY(aabb.halfHeight + t);\n                            } else {\n                                aabb.moveY(y);\n                            }\n                            return true;\n                        }\n                        return false;\n                    },\n                    allX = function (x) {\n                        var aabb = this.worldCamera.viewport;\n                        \n                        if (Math.abs(aabb.x - x) > this.threshold) {\n                            aabb.moveX(x);\n                            return true;\n                        }\n                        return false;\n                    },\n                    allY = function (y) {\n                        var aabb = this.worldCamera.viewport;\n                        \n                        if (Math.abs(aabb.y - y) > this.threshold) {\n                            aabb.moveY(y);\n                            return true;\n                        }\n                        return false;\n                    };\n                \n                return function () {\n                    var threshold = this.threshold,\n                        worldVP = this.worldCamera.viewport,\n                        world = this.worldDimensions,\n                        w = world.width,\n                        h = world.height;\n                    \n                    if (!w) {\n                        this.moveX = allX;\n                    } else if (w < worldVP.width) {\n                        this.moveX = centerX;\n                    } else {\n                        this.moveX = containX;\n                    }\n\n                    if (!h) {\n                        this.moveY = allY;\n                    } else if (h < worldVP.height) {\n                        this.moveY = centerY;\n                    } else {\n                        this.moveY = containY;\n                    }\n\n                    // Make sure camera is correctly contained:\n                    this.threshold = -1; // forces update\n                    this.moveX(worldVP.x);\n                    this.moveY(worldVP.y);\n                    this.threshold = threshold;\n                };\n            }()),\n            \n            destroy: function () {\n                this.parentContainer.removeChild(this.container);\n                this.parentContainer = null;\n                this.container = null;\n                if (this.mouseVector) {\n                    this.mouseVector.recycle();\n                    this.mouseWorldOrigin.recycle();\n                }\n                \n                this.boundingBox.recycle();\n                this.viewport.recycle();\n                this.worldCamera.viewport.recycle();\n                this.worldCamera.recycle();\n                this.message.viewport.recycle();\n                this.message.recycle();\n                this.cameraLoadedMessage.recycle();\n                this.worldDimensions.recycle();\n    \n                this.forwardFollower.recycle();\n                this.lastFollow.recycle();\n            }\n        },\n\n        publicMethods: {\n            /**\n             * Returns whether a particular display object intersects the camera's viewport on the canvas.\n             *\n             * @method isOnCanvas\n             * @param bounds {PIXI.Rectangle|Object} The bounds of the display object.\n             * @param bounds.height {Number} The height of the display object.\n             * @param bounds.width {Number} The width of the display object.\n             * @param bounds.x {Number} The left edge of the display object.\n             * @param bounds.y {Number} The top edge of the display object.\n             * @return {Boolean} Whether the display object intersects the camera's bounds.\n             */\n            isOnCanvas: function (bounds) {\n                var canvas = this.canvas;\n\n                return !bounds || !((bounds.x + bounds.width < 0) || (bounds.x > canvas.width) || (bounds.y + bounds.height < 0) || (bounds.y > canvas.height));\n            },\n\n            /**\n             * Returns a world coordinate corresponding to a provided window coordinate.\n             *\n             * @method windowToWorld\n             * @param windowVector {platypus.Vector} A vector describing a window position.\n             * @param withOffset {Boolean} Whether to provide a world position relative to the camera's location.\n             * @param vector {platypus.Vector} If provided, this is used as the return vector.\n             * @return {platypus.Vector} A vector describing a world position.\n             */\n            windowToWorld: function (windowVector, withOffset, vector) {\n                var worldVector = vector || _Vector_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].setUp();\n                \n                worldVector.x = windowVector.x * this.worldPerWindowUnitWidth;\n                worldVector.y = windowVector.y * this.worldPerWindowUnitHeight;\n                \n                if (withOffset !== false) {\n                    worldVector.x += this.worldCamera.viewport.left;\n                    worldVector.y += this.worldCamera.viewport.top;\n                }\n\n                return worldVector;\n            },\n            \n            /**\n             * Returns a window coordinate corresponding to a provided world coordinate.\n             *\n             * @method worldToWindow\n             * @param worldVector {platypus.Vector} A vector describing a world position.\n             * @param withOffset {Boolean} Whether to provide a window position relative to the camera's location.\n             * @param vector {platypus.Vector} If provided, this is used as the return vector.\n             * @return {platypus.Vector} A vector describing a window position.\n             */\n            worldToWindow: function (worldVector, withOffset, vector) {\n                var windowVector = vector || _Vector_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].setUp();\n\n                windowVector.x = worldVector.x * this.windowPerWorldUnitWidth;\n                windowVector.y = worldVector.y * this.windowPerWorldUnitHeight;\n                \n                if (withOffset !== false) {\n                    windowVector.x += this.viewport.x;\n                    windowVector.y += this.viewport.y;\n                }\n\n                return windowVector;\n            }\n        }\n    });\n}());\n\n\n//# sourceURL=webpack://platypus/./src/components/Camera.js?");

/***/ }),

/***/ "./src/components/CameraFollowMe.js":
/*!******************************************!*\
  !*** ./src/components/CameraFollowMe.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Data_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Data.js */ \"./src/Data.js\");\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../factory.js */ \"./src/factory.js\");\n/**\n * This component can request that the camera focus on this entity.\n *\n * @namespace platypus.components\n * @class CameraFollowMe\n * @uses platypus.Component\n */\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    return Object(_factory_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])({\n        id: 'CameraFollowMe',\n        \n        properties: {\n            /**\n             * Sets initial camera settings when the entity is being followed. This can be over-written by the \"follow-me\" call itself. If any of these attributes are not provided, the following are used by default:\n             *\n                  {\n                      \"time\": 500,\n                      // Optional. Time in milliseconds that the camera should focus before returning to the original focus.\n                      \n                      \"mode\": \"forward\",\n                      // Optional. Camera mode that the camera should use.\n                      \n                      \"top\": 100,\n                      // Optional number specifying top of viewport in world coordinates\n                      \n                      \"left\": 100,\n                      // Optional number specifying left of viewport in world coordinates\n                      \n                      \"width\": 100,\n                      // Optional number specifying width of viewport in world coordinates\n                      \n                      \"height\": 100,\n                      // Optional number specifying height of viewport in world coordinates\n                      \n                      \"offsetX\": 20,\n                      // Optional number setting how far to offset the camera from the entity horizontally.\n                      \n                      \"offsetY\": 40\n                      // Optional number setting how far to offset the camera from the entity vertically.\n                  }\n             *\n             * @property camera\n             * @type Object\n             * @default {}\n             */\n            camera: {},\n            \n            /**\n             * Camera mode that the camera should use.\n             *\n             * @property mode\n             * @type String\n             * @default \"forward\"\n             */\n            mode: \"forward\",\n\n            /**\n             * Whether to pause the game while the camera is focused.\n             *\n             * @property pause\n             * @type boolean\n             * @default false\n             */\n            pause: false\n        },\n        \n        initialize: function () {\n            this.pauseGame = (this.pause && this.camera.time) ? {\n                time: this.camera.time\n            } : null;\n            \n            this.camera = _Data_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp(\n                \"entity\", this.owner,\n                \"mode\", this.camera.mode || this.mode,\n                \"top\", this.camera.top,\n                \"left\", this.camera.left,\n                \"offsetX\", this.camera.offsetX,\n                \"offsetY\", this.camera.offsetY,\n                \"width\", this.camera.width,\n                \"height\", this.camera.height,\n                \"time\", this.camera.time\n            );\n        },\n        \n        events: {\n            /**\n             * On receiving this message, the component will trigger a message requesting that the parent camera begin following this entity.\n             *\n             * @method 'follow-me'\n             * @param [options] {Object} A list of key/value paris describing camera options to set.\n             * @param [options.mode] {String} Camera following mode.\n             * @param [options.top] {number} The top of a bounding box.\n             * @param [options.left] {number} The left of a bounding box.\n             * @param [options.width] {number} The width of a bounding box.\n             * @param [options.height] {number} The height of a bounding box.\n             * @param [options.offsetX] {number} How far to offset the camera from the entity horizontally.\n             * @param [options.offsetY] {number} How far to offset the camera from the entity vertically.\n             * @param [options.time] {number} How many milliseconds to follow the entity.\n             */\n            \"follow-me\": function (options) {\n                var msg = null;\n                \n                if (options) {\n                    msg = _Data_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp(\n                        \"entity\",  this.owner,\n                        \"mode\",    options.mode    || this.camera.mode,\n                        \"top\",     options.top     || this.camera.top,\n                        \"left\",    options.left    || this.camera.left,\n                        \"offsetX\", options.offsetX || this.camera.offsetX,\n                        \"offsetY\", options.offsetY || this.camera.offsetY,\n                        \"width\",   options.width   || this.camera.width,\n                        \"height\",  options.height  || this.camera.height,\n                        \"time\",    options.time    || this.camera.time\n                    );\n                } else {\n                    msg = _Data_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp(this.camera);\n                }\n\n                if (this.pauseGame) {\n\n                    /**\n                     * This component fires this message on the parent entity to pause logic if required.\n                     *\n                     * @event 'pause-logic'\n                     * @param options {Object}\n                     * @param options.time {number} The amount of time to pause before re-enabling logic.\n                     */\n                    this.owner.parent.triggerEvent('pause-logic',  this.pauseGame);\n                    \n                    /**\n                     * This component fires this message on the parent entity to pause rendering if required.\n                     *\n                     * @event 'pause-render'\n                     * @param options {Object}\n                     * @param options.time {number} The amount of time to pause before re-enabling render updates.\n                     */\n                    this.owner.parent.triggerEvent('pause-render', this.pauseGame);\n                }\n                \n                /**\n                 * This component fires this message on this entity's parent so the camera will begin following this entity.\n                 *\n                 * @event 'follow'\n                 * @param options {Object} A list of key/value pairs describing camera options to set.\n                 * @param options.entity {platypus.Entity} Sends this entity for the camera to follow.\n                 * @param options.mode {String} Camera following mode.\n                 * @param options.top {number} The top of a bounding box.\n                 * @param options.left {number} The left of a bounding box.\n                 * @param options.width {number} The width of a bounding box.\n                 * @param options.height {number} The height of a bounding box.\n                 * @param options.offsetX {number} How far to offset the camera from the entity horizontally.\n                 * @param options.offsetY {number} How far to offset the camera from the entity vertically.\n                 * @param options.time {number} How many milliseconds to follow the entity.\n                 */\n                this.owner.parent.triggerEvent('follow', msg);\n                \n                msg.recycle();\n            }\n        },\n        \n        methods: {\n            destroy: function () {\n                this.camera.recycle();\n            }\n        }\n    });\n}());\n\n\n//# sourceURL=webpack://platypus/./src/components/CameraFollowMe.js?");

/***/ }),

/***/ "./src/components/CollisionBasic.js":
/*!******************************************!*\
  !*** ./src/components/CollisionBasic.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var _AABB_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../AABB.js */ \"./src/AABB.js\");\n/* harmony import */ var _CollisionShape_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../CollisionShape.js */ \"./src/CollisionShape.js\");\n/* harmony import */ var _Data_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Data.js */ \"./src/Data.js\");\n/* harmony import */ var _DataMap_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../DataMap.js */ \"./src/DataMap.js\");\n/* harmony import */ var _Vector_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../Vector.js */ \"./src/Vector.js\");\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../factory.js */ \"./src/factory.js\");\n/**\n * This component causes this entity to collide with other entities. It must be part of a collision group and will receive messages when colliding with other entities in the collision group.\n *\n * Multiple collision components may be added to a single entity if distinct messages should be triggered for certain collision areas on the entity or if the soft collision area is a different shape from the solid collision area. Be aware that too many additional collision areas may adversely affect performance.\n *\n * @namespace platypus.components\n * @class CollisionBasic\n * @uses platypus.Component\n */\n\n\n\n\n\n\n\n\nconst\n    /**\n     * On receiving a 'hit-by' message, custom messages are triggered on the entity corresponding with the component's `solidCollisions` and `softCollisions` key/value mappings.\n     *\n     * @event *\n     * @param collision {Object} A list of key/value pairs describing the collision.\n     */\n    entityBroadcast = (function () {\n        var stringBroadcast = function (event, collisionType, solidOrSoft, value) {\n                if (value.myType === collisionType) {\n                    if (value.hitType === solidOrSoft) {\n                        this.owner.triggerEvent(event, value);\n                    }\n                }\n            },\n            arrayBroadcast = function (event, collisionType, solidOrSoft, value) {\n                var i = 0;\n                \n                if (value.myType === collisionType) {\n                    if (value.hitType === solidOrSoft) {\n                        for (i = 0; i < event.length; i++) {\n                            this.owner.triggerEvent(event[i], value);\n                        }\n                    }\n                }\n            },\n            directionalBroadcast = function (event, collisionType, solidOrSoft, collisionInfo) {\n                var dx = collisionInfo.x,\n                    dy = collisionInfo.y;\n\n                if (collisionInfo.entity && !(dx || dy)) {\n                    dx = collisionInfo.entity.x - this.owner.x;\n                    dy = collisionInfo.entity.y - this.owner.y;\n                }\n\n                if (collisionInfo.myType === collisionType) {\n                    if (collisionInfo.hitType === solidOrSoft) {\n                        if ((dy > 0) && event.bottom) {\n                            this.owner.trigger(event.bottom, collisionInfo);\n                        } else if ((dy < 0) && event.top) {\n                            this.owner.trigger(event.top, collisionInfo);\n                        }\n                        if ((dx > 0) && event.right) {\n                            this.owner.trigger(event.right, collisionInfo);\n                        } else if ((dx < 0) && event.left) {\n                            this.owner.trigger(event.left, collisionInfo);\n                        }\n                        if (event.all) {\n                            this.owner.trigger(event.all, collisionInfo);\n                        }\n                    }\n                }\n            };\n        \n        return function (self, event, solidOrSoft) {\n            if (typeof event === 'string') {\n                return stringBroadcast.bind(self, event, self.collisionType, solidOrSoft);\n            } else if (Array.isArray(event)) {\n                return arrayBroadcast.bind(self, event, self.collisionType, solidOrSoft);\n            } else {\n                return directionalBroadcast.bind(self, event, self.collisionType, solidOrSoft);\n            }\n        };\n    }()),\n    setupCollisionFunctions = (function () {\n        var entityGetAABB = function (aabb, colFuncs, collisionType) {\n                var keys = colFuncs.keys,\n                    i = keys.length,\n                    funcs = null;\n\n                if (!collisionType) {\n                    aabb.reset();\n                    while (i--) {\n                        aabb.include(colFuncs.get(keys[i]).getAABB());\n                    }\n                    return aabb;\n                } else {\n                    funcs = colFuncs.get(collisionType);\n                    if (funcs) {\n                        return funcs.getAABB();\n                    } else {\n                        return null;\n                    }\n                }\n            },\n            entityGetPreviousAABB = function (colFuncs, collisionType) {\n                var colFunc = colFuncs.get(collisionType);\n                \n                if (colFunc) {\n                    return colFunc.getPreviousAABB();\n                } else {\n                    return null;\n                }\n            },\n            entityGetShapes = function (colFuncs, collisionType) {\n                var colFunc = colFuncs.get(collisionType);\n                \n                if (colFunc) {\n                    return colFunc.getShapes();\n                } else {\n                    return null;\n                }\n            },\n            entityGetPrevShapes = function (colFuncs, collisionType) {\n                var colFunc = colFuncs.get(collisionType);\n                \n                if (colFunc) {\n                    return colFunc.getPrevShapes();\n                } else {\n                    return null;\n                }\n            },\n            entityPrepareCollision = function (colFuncs, x, y) {\n                var keys = colFuncs.keys,\n                    i = keys.length;\n                \n                while (i--) {\n                    colFuncs.get(keys[i]).prepareCollision(x, y);\n                }\n            },\n            entityRelocateEntity = (function () {\n                var handleStuck = function (position, data, owner) {\n                        var m = 0,\n                            s = data.stuck;\n\n                        if (s) {\n                            m = position.magnitude();\n                            if (data.thatShape.owner && (Math.abs(s) > 1)) {\n                                s *= 0.05;\n                            }\n                            if (!m || (m > Math.abs(s))) {\n                                if (data.vector.x) {\n                                    position.x = s;\n                                    position.y = 0;\n                                }\n                                if (data.vector.y) {\n                                    position.x = 0;\n                                    position.y = s;\n                                }\n                                if (owner.stuckWith) {\n                                    owner.stuckWith.recycle();\n                                }\n                                owner.stuckWith = _Vector_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].setUp(data.thatShape.x, data.thatShape.y);\n                            }\n                        }\n                    },\n                    message = {\n                        position: null,\n                        unstick: null\n                    };\n                \n                return function (vector, collisionData) {\n                    var colX = collisionData.xData[0],\n                        colY = collisionData.yData[0],\n                        msg = message,\n                        v = null;\n\n                    if (colX) {\n                        v = _Vector_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].setUp(0, 0, 0);\n                        handleStuck(v, colX, this);\n                    }\n\n                    if (colY) {\n                        v = v || _Vector_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].setUp(0, 0, 0);\n                        handleStuck(v, colY, this);\n                    }\n\n                    msg.position = vector;\n                    msg.unstick = v;\n                    this.triggerEvent('relocate-entity', msg);\n                    \n                    if (v) {\n                        v.recycle();\n                    }\n                };\n            }()),\n            entityMovePreviousX = function (colFuncs, x) {\n                var keys = colFuncs.keys,\n                    i = keys.length;\n                \n                while (i--) {\n                    colFuncs.get(keys[i]).movePreviousX(x);\n                }\n            },\n            entityGetCollisionTypes = function () {\n                return this.collisionTypes;\n            },\n            entityGetSolidCollisions = function () {\n                return this.solidCollisionMap;\n            },\n            getAABB = function () {\n                return this.getAABB();\n            },\n            getPreviousAABB = function () {\n                return this.getPreviousAABB();\n            },\n            getShapes = function () {\n                return this.getShapes();\n            },\n            getPrevShapes = function () {\n                return this.getPrevShapes();\n            },\n            prepareCollision = function (x, y) {\n                this.prepareCollision(x, y);\n            },\n            movePreviousX = function (x) {\n                this.movePreviousX(x);\n            };\n        \n        return function (self, entity) {\n            var colFuncs = entity.collisionFunctions;\n            \n            // This allows the same component type to be added multiple times.\n            if (!colFuncs) {\n                colFuncs = entity.collisionFunctions = _DataMap_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].setUp();\n                entity.aabb = _AABB_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp();\n                entity.getAABB = entityGetAABB.bind(entity, entity.aabb, colFuncs);\n                entity.getPreviousAABB = entityGetPreviousAABB.bind(entity, colFuncs);\n                entity.getShapes = entityGetShapes.bind(entity, colFuncs);\n                entity.getPrevShapes = entityGetPrevShapes.bind(entity, colFuncs);\n                entity.prepareCollision = entityPrepareCollision.bind(entity, colFuncs);\n                entity.relocateEntity = entityRelocateEntity.bind(entity);\n                entity.movePreviousX = entityMovePreviousX.bind(entity, colFuncs);\n                entity.getCollisionTypes = entityGetCollisionTypes.bind(entity);\n                entity.getSolidCollisions = entityGetSolidCollisions.bind(entity);\n            }\n\n            colFuncs.set(self.collisionType, _Data_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].setUp(\n                \"getAABB\", getAABB.bind(self),\n                \"getPreviousAABB\", getPreviousAABB.bind(self),\n                \"getShapes\", getShapes.bind(self),\n                \"getPrevShapes\", getPrevShapes.bind(self),\n                \"prepareCollision\", prepareCollision.bind(self),\n                \"movePreviousX\", movePreviousX.bind(self)\n            ));\n        };\n    }()),\n    updateShapesFull = function (shapes, prevs, aabb, x, y) {\n        let i = shapes.length;\n\n        while (i--) {\n            const shape = shapes[i];\n            shape.updateAll(prevs[i]);\n            shape.update(x, y);\n            aabb.include(shape.aABB);\n        }\n\n        // Done with the full update; back to fast!\n        this.updateShapes = updateShapesFast;\n    },\n    updateShapesFast = function (shapes, prevs, aabb, x, y) {\n        let i = shapes.length;\n\n        while (i--) {\n            const shape = shapes[i];\n            shape.update(x, y);\n            aabb.include(shape.aABB);\n        }\n    };\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Object(_factory_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"])({\n        \n    id: 'CollisionBasic',\n\n    properties: {\n        /**\n         * Defines how this entity should be recognized by other colliding entities.\n         *\n         * @property collisionType\n         * @type String\n         * @default \"none\"\n         */\n        collisionType: \"none\",\n\n        /**\n         * Defines the type of colliding shape.\n         *\n         * @property shapeType\n         * @type String\n         * @default \"rectangle\"\n         */\n        shapeType: \"rectangle\",\n        \n        /**\n         * Determines whether the collision area should transform on orientation changes.\n         *\n         * @property ignoreOrientation\n         * @type boolean\n         * @default false\n         */\n        ignoreOrientation: false,\n        \n        /**\n         * Determines the x-axis center of the collision shape.\n         *\n         * @property regX\n         * @type number\n         * @default width / 2\n         */\n        regX: null,\n        \n        /**\n         * Determines the y-axis center of the collision shape.\n         *\n         * @property regY\n         * @type number\n         * @default height / 2\n         */\n        regY: null,\n        \n        /**\n         * Sets the width of the collision area in world coordinates.\n         *\n         * @property width\n         * @type number\n         * @default 0\n         */\n        width: 0,\n        \n        /**\n         * Sets the height of the collision area in world coordinates.\n         *\n         * @property height\n         * @type number\n         * @default 0\n         */\n        height: 0,\n        \n        /**\n         * Sets the radius of a circle collision area in world coordinates.\n         *\n         * @property radius\n         * @type number\n         * @default 0\n         */\n        radius: 0,\n        \n        /**\n         * Determines which collision types this entity should consider soft, meaning this entity may pass through them, but triggers collision messages on doing so. Example:\n         *\n         *     {\n         *         \"water\": \"soaked\",       // This triggers a \"soaked\" message on the entity when it passes over a \"water\" collision-type entity.\n         *         \"lava\": [\"burn\", \"ouch\"] // This triggers both messages on the entity when it passes over a \"lava\" collision-type entity.\n         *     }\n         *\n         * @property softCollisions\n         * @type Object\n         * @default null\n         */\n        softCollisions: null,\n        \n        /**\n         * Determines which collision types this entity should consider solid, meaning this entity should not pass through them. Example:\n         *\n         *     {\n         *         \"boulder\": \"\",                       // This specifies that this entity should not pass through other \"boulder\" collision-type entities.\n         *         \"diamond\": \"crack-up\",               // This specifies that this entity should not pass through \"diamond\" collision-type entities, but if it touches one, it triggers a \"crack-up\" message on the entity.\n         *         \"marble\": [\"flip\", \"dance\", \"crawl\"] // This specifies that this entity should not pass through \"marble\" collision-type entities, but if it touches one, it triggers all three specified messages on the entity.\n         *     }\n         *\n         * @property solidCollisions\n         * @type Object\n         * @default null\n         */\n        solidCollisions: null,\n        \n        /**\n         * This is the margin around the entity's width and height. This is an alternative method for specifying the collision shape in terms of the size of the entity. Can also pass in an object specifying the following parameters if the margins vary per side: top, bottom, left, and right.\n         *\n         * @property margin\n         * @type number|Object\n         * @default 0\n         */\n        margin: 0,\n        \n        /**\n         * Defines one or more shapes to create the collision area. Defaults to a single shape with the width, height, regX, and regY properties of the entity if not specified. See [CollisionShape](CollisionShape.html) for the full list of properties.\n         *\n         * @property shapes\n         * @type Array\n         * @default null\n         */\n        shapes: null\n    },\n    \n    publicProperties: {\n        collisionDirty: false,\n\n        /**\n         * This property should be set to true if entity doesn't move for better optimization. This causes other entities to check against this entity, but this entity performs no checks of its own. Available on the entity as `entity.immobile`.\n         *\n         * @property immobile\n         * @type boolean\n         * @default false\n         */\n        immobile: false,\n\n        /**\n         * Whether this entity should be tested across its entire movement path. This is necessary for fast-moving entities, but shouldn't be used for others due to the processing overhead. Available on the entity as `entity.bullet`.\n         *\n         * @property bullet\n         * @type boolean\n         * @default false\n         */\n        bullet: false,\n        \n        /**\n         * Whether the entity is only solid when being collided with from the top.\n         *\n         * @property jumpThrough\n         * @type boolean\n         * @default: false\n         */\n        jumpThrough: false\n    },\n    \n    initialize: function (definition) {\n        var arr = null,\n            x            = 0,\n            key          = '',\n            shapes       = null,\n            regX         = this.regX,\n            regY         = this.regY,\n            width        = this.width,\n            height       = this.height,\n            radius       = this.radius,\n            marginLeft   = 0,\n            marginRight  = 0,\n            marginTop    = 0,\n            marginBottom = 0;\n\n        if (typeof this.margin === \"number\") {\n            marginLeft   = this.margin;\n            marginRight  = this.margin;\n            marginTop    = this.margin;\n            marginBottom = this.margin;\n        } else {\n            marginLeft   = this.margin.left || 0;\n            marginRight  = this.margin.right || 0;\n            marginTop    = this.margin.top || 0;\n            marginBottom = this.margin.bottom || 0;\n        }\n        \n        if (regX === null) {\n            regX = this.regX = width / 2;\n        }\n        \n        if (regY === null) {\n            regY = this.regY = height / 2;\n        }\n        \n        _Vector_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].assign(this.owner, 'position', 'x', 'y', 'z');\n        _Vector_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].assign(this.owner, 'previousPosition', 'previousX', 'previousY', 'previousZ');\n        this.owner.previousX = this.owner.previousX || this.owner.x;\n        this.owner.previousY = this.owner.previousY || this.owner.y;\n        \n        this.aabb     = _AABB_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp();\n        this.prevAABB = _AABB_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp();\n        \n        if (this.shapes) {\n            shapes = this.shapes;\n        } else if (this.shapeType === 'circle') {\n            radius = radius || (((width || 0) + (height || 0)) / 4);\n            shapes = [{\n                regX: (isNaN(regX) ? radius : regX) - (marginRight - marginLeft) / 2,\n                regY: (isNaN(regY) ? radius : regY) - (marginBottom - marginTop) / 2,\n                radius: radius,\n                type: this.shapeType\n            }];\n        } else {\n            shapes = [{\n                //regX: (isNaN(regX) ? (width  || 0) / 2 : regX) - (marginRight  - marginLeft) / 2,\n                //regY: (isNaN(regY) ? (height || 0) / 2 : regY) - (marginBottom - marginTop)  / 2,\n                regX: (isNaN(regX) ? (width  || 0) / 2 : regX) + marginLeft,\n                regY: (isNaN(regY) ? (height || 0) / 2 : regY) + marginTop,\n                points: definition.points,\n                width: (width  || 0) + marginLeft + marginRight,\n                height: (height || 0) + marginTop  + marginBottom,\n                type: this.shapeType\n            }];\n        }\n        \n        this.owner.collisionTypes = this.owner.collisionTypes || _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n        this.owner.collisionTypes.push(this.collisionType);\n        \n        this.shapes = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n        this.prevShapes = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n        this.entities = null;\n        for (x = 0; x < shapes.length; x++) {\n            this.shapes.push(_CollisionShape_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(this.owner, shapes[x], this.collisionType));\n            this.prevShapes.push(_CollisionShape_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(this.owner, shapes[x], this.collisionType));\n            this.prevAABB.include(this.prevShapes[x].aABB);\n            this.aabb.include(this.shapes[x].aABB);\n        }\n        \n        this.updateShapes = updateShapesFast;\n\n        setupCollisionFunctions(this, this.owner);\n        \n        this.owner.solidCollisionMap = this.owner.solidCollisionMap || _DataMap_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].setUp();\n        arr = this.owner.solidCollisionMap.set(this.collisionType, _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp());\n        if (this.solidCollisions) {\n            for (key in this.solidCollisions) {\n                if (this.solidCollisions.hasOwnProperty(key)) {\n                    arr.push(key);\n                    if (this.solidCollisions[key]) { // To make sure it's not an empty string.\n                        this.addEventListener('hit-by-' + key, entityBroadcast(this, this.solidCollisions[key], 'solid'));\n                    }\n                }\n            }\n        }\n\n        this.owner.softCollisionMap = this.owner.softCollisionMap || _DataMap_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].setUp();\n        arr = this.owner.softCollisionMap.set(this.collisionType, _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp());\n        if (this.softCollisions) {\n            for (key in this.softCollisions) {\n                if (this.softCollisions.hasOwnProperty(key)) {\n                    arr.push(key);\n                    if (this.softCollisions[key]) { // To make sure it's not an empty string.\n                        this.addEventListener('hit-by-' + key, entityBroadcast(this, this.softCollisions[key], 'soft'));\n                    }\n                }\n            }\n        }\n        \n        this.active = true;\n        this.stuck = false;\n    },\n    \n    events: {\n        /**\n         * On receiving this message, the component triggers `add-collision-entity` on the parent.\n         *\n         * @method 'collide-on'\n         * @param type {String} If specified, only collision components of this type are added to the collision list.\n         */\n        \"collide-on\": function (type) {\n            var owner = this.owner,\n                colType = this.collisionType,\n                colTypes = owner.collisionTypes;\n            \n            /**\n             * On receiving 'collide-on', this message is triggered on the parent to turn on collision.\n             *\n             * @event 'add-collision-entity'\n             * @param entity {platypus.Entity} The entity this component is attached to.\n             */\n            if (!this.active && ((typeof type !== 'string') || (type === colType))) {\n                owner.parent.triggerEvent('remove-collision-entity', owner);\n                if (colTypes.indexOf(colType) === -1) {\n                    colTypes.push(colType);\n                }\n                owner.parent.triggerEvent('add-collision-entity', owner);\n                this.active = true;\n                this.collisionDirty = true;\n            }\n        },\n        \n        /**\n         * On receiving this message, the component triggers `remove-collision-entity` on the parent.\n         *\n         * @method 'collide-off'\n         * @param type {String} If specified, only collision components of this type are removed from the collision list.\n         */\n        \"collide-off\": function (type) {\n            var index = 0,\n                owner = this.owner,\n                parent = owner.parent,\n                colType = this.collisionType,\n                colTypes = owner.collisionTypes;\n            \n            /**\n             * On receiving 'collide-off', this message is triggered on the parent to turn off collision.\n             *\n             * @event 'remove-collision-entity'\n             * @param entity {platypus.Entity} The entity this component is attached to.\n             */\n            if (this.active && ((typeof type !== 'string') || (type === colType))) {\n                parent.triggerEvent('remove-collision-entity', owner);\n                index = colTypes.indexOf(colType);\n                if (index >= 0) {\n                    Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSplice\"])(colTypes, index);\n                }\n                this.active = false;\n\n                if (colTypes.length) {\n                    parent.triggerEvent('add-collision-entity', owner);\n                }\n            }\n        },\n        \n        /**\n         * This message causes the entity's x,y coordinates to update. (Usually after collision checks, but can be used to avoid collision checks during logic handling.)\n         *\n         * @method 'relocate-entity'\n         * @param location {Object|platypus.Vector} The new coordinates.\n         * @param [location.position] {platypus.Vector} If specified, this vector is used instead of the passed-in object as the location.\n         * @param [location.relative=false] {boolean} Determines whether the provided x,y coordinates are relative to the entity's current position.\n         * @param [location.unstick=null] {platypus.Vector} Where the entity should be moved to unstick from collision contact.\n         * @param [relative] If `location.relative` is not specified, this parameter is also checked.\n         */\n        \"relocate-entity\": function (location, relative) {\n            var unstick = location.unstick,\n                um      = 0,\n                i       = 0,\n                x       = 0,\n                y       = 0,\n                aabb    = this.aabb,\n                owner   = this.owner,\n                shape   = null,\n                shapes  = this.shapes,\n                v = location.position || location;\n            \n            if (unstick) {\n                um = unstick.magnitude();\n            }\n            \n            if (this.move) {\n                this.move.recycle();\n                this.move = null;\n            }\n            \n            if (location.relative || relative) {\n                owner.position.setVector(owner.previousPosition).add(v);\n            } else {\n                owner.position.setVector(v);\n            }\n\n            if (this.stuck) {\n                if (um > 0) {\n                    owner.position.add(unstick);\n                } else {\n                    this.stuck = false;\n                }\n            }\n            \n            x = owner.x;\n            y = owner.y;\n            \n            aabb.reset();\n            i = shapes.length;\n            while (i--) {\n                shape = shapes[i];\n                shape.update(x, y);\n                aabb.include(shape.aABB);\n            }\n\n            owner.previousPosition.setVector(owner.position);\n            \n            if (um > 0) { // to force check in all directions for ultimate stuck resolution (esp. for stationary entities)\n                if (!this.stuck) {\n                    this.stuck = true;\n                }\n                this.move = owner.stuckWith.copy().add(-x, -y).normalize();\n            }\n        },\n        \n        /**\n         * If the entity is stuck to another entity, this component tries to unstick the entity on each logic step.\n         *\n         * @method 'handle-logic'\n         */\n        \"handle-logic\": function () {\n            if (this.move) {\n                this.owner.position.add(this.move); // By trying to move into it, we should get pushed back out.\n            }\n        },\n        \n        /**\n         * Collision shapes are updated to reflect the new orientation when this message occurs.\n         *\n         * @method 'orientation-updated'\n         * @param matrix {Array} A 2D matrix describing the new orientation.\n         */\n        \"orientation-updated\": function (matrix) {\n            var i = 0;\n            \n            if (!this.ignoreOrientation) {\n                for (i = 0; i < this.shapes.length; i++) {\n                    this.shapes[i].multiply(matrix);\n                }\n                this.updateShapes = updateShapesFull;\n                this.collisionDirty = true;\n            }\n        }\n    },\n    \n    methods: {\n        getAABB: function () {\n            return this.aabb;\n        },\n        \n        getPreviousAABB: function () {\n            return this.prevAABB;\n        },\n        \n        getShapes: function () {\n            return this.shapes;\n        },\n        \n        getPrevShapes: function () {\n            return this.prevShapes;\n        },\n        \n        prepareCollision: function (x, y) {\n            const\n                prevShapes = this.shapes,\n                shapes     = this.prevShapes,\n                aabb       = this.aabb;\n            \n            this.owner.x = x;\n            this.owner.y = y;\n            \n            this.prevShapes = prevShapes;\n            this.shapes = shapes;\n            \n            this.prevAABB.set(aabb);\n            aabb.reset();\n            \n            this.updateShapes(shapes, prevShapes, aabb, x, y);\n            \n            if (this.collisionDirty) {\n                this.collisionDirty = false;\n            }\n        },\n        \n        movePreviousX: function (x) {\n            var i = 0;\n            \n            this.prevAABB.moveX(x);\n            for (i = 0; i < this.prevShapes.length; i++) {\n                this.prevShapes[i].setXWithEntityX(x);\n            }\n        },\n        \n        destroy: function () {\n            var colFuncs = this.owner.collisionFunctions,\n                collisionType = this.collisionType,\n                i = this.owner.collisionTypes ? this.owner.collisionTypes.indexOf(collisionType) : -1,\n                owner = this.owner;\n            \n            owner.parent.triggerEvent('remove-collision-entity', owner);\n\n            this.aabb.recycle();\n            delete this.aabb;\n            this.prevAABB.recycle();\n            delete this.prevAABB;\n            \n            if (i >= 0) {\n                Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSplice\"])(owner.collisionTypes, i);\n            }\n            \n            if (owner.collisionTypes) {\n                if (owner.solidCollisionMap.has(collisionType)) {\n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(owner.solidCollisionMap.delete(collisionType));\n                }\n                if (owner.softCollisionMap.has(collisionType)) {\n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(owner.softCollisionMap.delete(collisionType));\n                }\n\n                colFuncs.delete(collisionType).recycle();\n            }\n            \n            i = this.shapes.length;\n            while (i--) {\n                this.shapes[i].recycle();\n                this.prevShapes[i].recycle();\n            }\n            _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.shapes);\n            _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.prevShapes);\n            this.shapes = null;\n            this.prevShapes = null;\n\n            this.entities = null;\n\n            if (owner.collisionTypes) {\n                if (owner.collisionTypes.length) {\n                    owner.parent.triggerEvent('add-collision-entity', owner);\n                } else { //remove collision functions\n                    colFuncs.recycle();\n                    owner.collisionFunctions = null;\n                    owner.solidCollisionMap.recycle();\n                    owner.solidCollisionMap = null;\n                    owner.softCollisionMap.recycle();\n                    owner.softCollisionMap = null;\n                    owner.aabb.recycle();\n                    owner.aabb = null;\n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(owner.collisionTypes);\n                    owner.collisionTypes = null;\n                }\n            }\n        }\n    }\n}));\n    \n\n\n//# sourceURL=webpack://platypus/./src/components/CollisionBasic.js?");

/***/ }),

/***/ "./src/components/CollisionFilter.js":
/*!*******************************************!*\
  !*** ./src/components/CollisionFilter.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../factory.js */ \"./src/factory.js\");\n/**\n * This component will listen for a particular collision message and, depending on a given entity.state attribute, retrigger the collision as another collision message.\n *\n * @namespace platypus.components\n * @class CollisionFilter\n * @uses platypus.Component\n */\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    \n\n    var collidePos = function (state, event, collInfo) {\n            if (this.state.get(state)) {\n                this.trigger(event, collInfo);\n            }\n        },\n        collideNeg = function (state, event, collInfo) {\n            if (!this.state.get(state)) {\n                this.trigger(event, collInfo);\n            }\n        };\n    \n    return Object(_factory_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        id: 'CollisionFilter',\n        \n        properties: {\n            /**\n             * One or more collision events for which to listen. For example, if the state property is set to \"allergic\":\n             *\n                   {\n                       \"hitting-flowers\": \"sneeze\",\n                       // Listen for \"hitting-flowers\", and if the entity is \"allergic\", trigger a \"sneeze\" event.\n                    \n                       \"in-the-weeds\": \"cough\"\n                       // Another collision event that triggers \"cough\" if the entity is \"allergic\".\n                   }\n             *\n             * @property collisions\n             * @type Object\n             * @default {}\n             */\n            collisions: {},\n            \n            /**\n             * The entity state that should cause the following list of collisions to trigger events. If this state is not true, no events are triggered. To trigger events on the inverse of a state, place \"!\" before the state such as \"!allergic\".\n             *\n             * @property state\n             * @type String\n             * @default \"\"\n             */\n            state: \"\"\n        },\n        \n        initialize: function () {\n            var event      = \"\",\n                collisions = this.collisions,\n                state      = this.state;\n            \n            if (collisions) {\n                /**\n                 * Events defined by the `collisions` property trigger whenever collisions happen while in the defined state.\n                 *\n                 * @event *\n                 * @param collisionData {CollisionData} Information regarding the collision that occurred.\n                 */\n                if (state[0] === '!') {\n                    state = state.substring(1);\n                    for (event in collisions) {\n                        if (collisions.hasOwnProperty(event)) {\n                            this.addEventListener(event, collideNeg.bind(this.owner, state, collisions[event]));\n                        }\n                    }\n                } else {\n                    for (event in collisions) {\n                        if (collisions.hasOwnProperty(event)) {\n                            this.addEventListener(event, collidePos.bind(this.owner, state, collisions[event]));\n                        }\n                    }\n                }\n            }\n        }\n    });\n}());\n\n\n//# sourceURL=webpack://platypus/./src/components/CollisionFilter.js?");

/***/ }),

/***/ "./src/components/CollisionGroup.js":
/*!******************************************!*\
  !*** ./src/components/CollisionGroup.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var _AABB_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../AABB.js */ \"./src/AABB.js\");\n/* harmony import */ var _DataMap_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../DataMap.js */ \"./src/DataMap.js\");\n/* harmony import */ var _Vector_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Vector.js */ \"./src/Vector.js\");\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../factory.js */ \"./src/factory.js\");\n/**\n * This component groups other entities with this entity for collision checking. This is useful for carrying and moving platforms. It uses `EntityContainer` component messages if triggered to add to its collision list and also listens for explicit add/remove messages (useful in the absence of an `EntityContainer` component).\n *\n * @namespace platypus.components\n * @class CollisionGroup\n * @uses platypus.Component\n */\n\n\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    return Object(_factory_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])({\n        id: 'CollisionGroup',\n        \n        initialize: function () {\n            this.solidEntities = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n            \n            // These are used as return values for methods, but are instantiated here for recycling later.\n            this.collisionTypes = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n            this.shapes = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n            this.prevShapes = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n            \n            this.terrain  = null;\n            this.aabb     = _AABB_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp(this.owner.x, this.owner.y);\n            this.prevAABB = _AABB_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp(this.owner.x, this.owner.y);\n            this.filteredAABB = _AABB_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp();\n\n            _Vector_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].assign(this.owner, 'position', 'x', 'y', 'z');\n            _Vector_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].assign(this.owner, 'previousPosition', 'previousX', 'previousY', 'previousZ');\n            this.owner.previousX = this.owner.previousX || this.owner.x;\n            this.owner.previousY = this.owner.previousY || this.owner.y;\n            \n            this.collisionGroup = this.owner.collisionGroup = {\n                getAllEntities: function () {\n                    var x           = 0,\n                        count       = 0,\n                        childEntity = null;\n                    \n                    for (x = 0; x < this.solidEntities.length; x++) {\n                        childEntity = this.solidEntities[x];\n                        if ((childEntity !== this.owner) && childEntity.collisionGroup) {\n                            count += childEntity.collisionGroup.getAllEntities();\n                        } else {\n                            count += 1;\n                        }\n                    }\n\n                    return count;\n                }.bind(this),\n                getSize: function () {\n                    return this.solidEntities.length;\n                }.bind(this),\n                getCollisionTypes: function () {\n                    return this.getCollisionTypes();\n                }.bind(this),\n                getSolidCollisions: function () {\n                    return this.getSolidCollisions();\n                }.bind(this),\n                getAABB: function (collisionType) {\n                    return this.getAABB(collisionType);\n                }.bind(this),\n                getPreviousAABB: function (collisionType) {\n                    return this.getPreviousAABB(collisionType);\n                }.bind(this),\n                getShapes: function (collisionType) {\n                    return this.getShapes(collisionType);\n                }.bind(this),\n                getPrevShapes: function (collisionType) {\n                    return this.getPrevShapes(collisionType);\n                }.bind(this),\n                prepareCollision: function (x, y) {\n                    return this.prepareCollision(x, y);\n                }.bind(this),\n                relocateEntity: function (vector, collisionData) {\n                    return this.relocateEntity(vector, collisionData);\n                }.bind(this),\n                movePreviousX: function (x) {\n                    return this.movePreviousX(x);\n                }.bind(this),\n                getSolidEntities: function () {\n                    return this.solidEntities;\n                }.bind(this),\n                jumpThrough: false //TODO: this introduces odd behavior - not sure how to resolve yet. - DDD\n            };\n        },\n        \n        events: {\n            /**\n             * On receiving this message, the component checks the entity to determine whether it listens for collision messages. If so, the entity is added to the collision group.\n             *\n             * @method 'child-entity-added'\n             * @param entity {platypus.Entity} The entity to be added.\n             */\n            \"child-entity-added\": function (entity) {\n                this.addCollisionEntity(entity);\n            },\n            \n            /**\n             * On receiving this message, the component checks the entity to determine whether it listens for collision messages. If so, the entity is added to the collision group.\n             *\n             * @method 'add-collision-entity'\n             * @param entity {platypus.Entity} The entity to be added.\n             */\n            \"add-collision-entity\": function (entity) {\n                this.addCollisionEntity(entity);\n            },\n            \n            /**\n             * On receiving this message, the component looks for the entity in its collision group and removes it.\n             *\n             * @method 'child-entity-removed'\n             * @param entity {platypus.Entity} The entity to be removed.\n             */\n            \"child-entity-removed\": function (entity) {\n                this.removeCollisionEntity(entity);\n            },\n            \n            /**\n             * On receiving this message, the component looks for the entity in its collision group and removes it.\n             *\n             * @method 'remove-collision-entity'\n             * @param entity {platypus.Entity} The entity to be removed.\n             */\n            \"remove-collision-entity\": function (entity) {\n                this.removeCollisionEntity(entity);\n            },\n            \n            /**\n             * When this message is triggered, the collision group updates its record of the owner's last (x, y) coordinate.\n             *\n             * @method 'relocate-entity'\n             */\n            \"relocate-entity\": function () {\n                this.owner.previousPosition.setVector(this.owner.position);\n                this.updateAABB();\n            }\n        },\n        \n        methods: {\n            addCollisionEntity: function (entity) {\n                var i     = 0,\n                    types = entity.collisionTypes;\n                \n                if (types) {\n                    i = types.length;\n                    while (i--) {\n                        if (entity.solidCollisionMap.get(types[i]).length && !entity.immobile) {\n                            this.solidEntities[this.solidEntities.length] = entity;\n                        }\n                    }\n                    this.updateAABB();\n                }\n            },\n            \n            removeCollisionEntity: function (entity) {\n                var x     = 0,\n                    i     = 0,\n                    types = entity.collisionTypes;\n\n                if (types) {\n                    i = types.length;\n                    while (i--) {\n                        if (entity.solidCollisionMap.get(types[i]).length) {\n                            x = this.solidEntities.indexOf(entity);\n                            if (x >= 0) {\n                                Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSplice\"])(this.solidEntities, x);\n                            }\n                        }\n                    }\n                    this.updateAABB();\n                }\n            },\n            \n            getCollisionTypes: function () {\n                var childEntity  = null,\n                    compiledList = this.collisionTypes,\n                    se = this.solidEntities,\n                    i = se.length;\n                \n                compiledList.length = 0;\n                \n                while (i--) {\n                    childEntity = se[i];\n                    if ((childEntity !== this.owner) && childEntity.collisionGroup) {\n                        childEntity = childEntity.collisionGroup;\n                    }\n                    Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"union\"])(compiledList, childEntity.getCollisionTypes());\n                }\n                \n                return compiledList;\n            },\n\n            getSolidCollisions: function () {\n                var x            = 0,\n                    key          = '',\n                    keys = null,\n                    childEntity  = null,\n                    compiledList = _DataMap_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(),\n                    entityList   = null,\n                    i = 0,\n                    toList = null,\n                    fromList = null,\n                    recycle = false;\n                \n                for (x = 0; x < this.solidEntities.length; x++) {\n                    recycle = false;\n                    childEntity = this.solidEntities[x];\n                    if ((childEntity !== this.owner) && childEntity.collisionGroup) {\n                        childEntity = childEntity.collisionGroup;\n                        recycle = true;\n                    }\n                    entityList = childEntity.getSolidCollisions();\n                    keys = entityList.keys;\n                    i = keys.length;\n                    while (i--) {\n                        key = keys[i];\n                        toList = compiledList.get(key);\n                        fromList = entityList.get(key);\n                        if (!toList) {\n                            toList = compiledList.set(key, _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp());\n                        }\n                        Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"union\"])(toList, fromList);\n                        if (recycle) {\n                            fromList.recycle();\n                        }\n                    }\n                    if (recycle) {\n                        entityList.recycle();\n                    }\n                }\n                \n                return compiledList; // TODO: Track down where this is used and make sure the arrays are recycled. - DDD 2/1/2016\n            },\n            \n            getAABB: function (collisionType) {\n                var i = 0,\n                    aabb        = this.filteredAABB,\n                    childEntity = null,\n                    incAABB = null,\n                    sE = this.solidEntities;\n                \n                if (!collisionType) {\n                    return this.aabb;\n                } else {\n                    aabb.reset();\n                    i = sE.length;\n                    while (i--) {\n                        childEntity = sE[i];\n                        if ((childEntity !== this.owner) && childEntity.collisionGroup) {\n                            childEntity = childEntity.collisionGroup;\n                        }\n                        incAABB = childEntity.getAABB(collisionType);\n                        if (incAABB) {\n                            aabb.include(incAABB);\n                        }\n                    }\n                    return aabb;\n                }\n            },\n\n            getPreviousAABB: function (collisionType) {\n                var i = 0,\n                    aabb        = this.filteredAABB,\n                    childEntity = null,\n                    incAABB = null,\n                    sE = this.solidEntities;\n                \n                if (!collisionType) {\n                    return this.prevAABB;\n                } else {\n                    aabb.reset();\n                    i = sE.length;\n                    while (i--) {\n                        childEntity = sE[i];\n                        if ((childEntity !== this.owner) && childEntity.collisionGroup) {\n                            childEntity = childEntity.collisionGroup;\n                        }\n\n                        incAABB = childEntity.getPreviousAABB(collisionType);\n                        if (incAABB) {\n                            aabb.include(incAABB);\n                        }\n                    }\n                    return aabb;\n                }\n            },\n            \n            updateAABB: function () {\n                var aabb = this.aabb,\n                    sE = this.solidEntities,\n                    entity = null,\n                    x = sE.length,\n                    owner = this.owner;\n                \n                aabb.reset();\n                while (x--) {\n                    entity = sE[x];\n                    aabb.include(((entity !== owner) && entity.getCollisionGroupAABB) ? entity.getCollisionGroupAABB() : entity.getAABB());\n                }\n            },\n            \n            getShapes: function (collisionType) {\n                var x           = 0,\n                    childEntity = null,\n                    shapes      = this.shapes,\n                    newShapes   = null;\n                    \n                shapes.length = 0;\n                \n                for (x = 0; x < this.solidEntities.length; x++) {\n                    childEntity = this.solidEntities[x];\n                    if ((childEntity !== this.owner) && childEntity.collisionGroup) {\n                        childEntity = childEntity.collisionGroup;\n                    }\n                    newShapes = childEntity.getShapes(collisionType);\n                    if (newShapes) {\n                        Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"union\"])(shapes, newShapes);\n                    }\n                }\n                return shapes;\n            },\n\n            getPrevShapes: function (collisionType) {\n                var x           = 0,\n                    childEntity = null,\n                    newShapes   = null,\n                    shapes      = this.prevShapes;\n                    \n                shapes.length = 0;\n                \n                for (x = 0; x < this.solidEntities.length; x++) {\n                    childEntity = this.solidEntities[x];\n                    if ((childEntity !== this.owner) && childEntity.collisionGroup) {\n                        childEntity = childEntity.collisionGroup;\n                    }\n                    newShapes = childEntity.getPrevShapes(collisionType);\n                    if (newShapes) {\n                        Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"union\"])(shapes, newShapes);\n                    }\n                }\n                return shapes;\n            },\n            \n            prepareCollision: function (x, y) {\n                var i           = 0,\n                    childEntity = null,\n                    oX          = 0,\n                    oY          = 0;\n                \n                for (i = 0; i < this.solidEntities.length; i++) {\n                    childEntity = this.solidEntities[i];\n                    childEntity.saveDX = childEntity.x - childEntity.previousX;\n                    childEntity.saveDY = childEntity.y - childEntity.previousY;\n                    oX = childEntity.saveOX = this.owner.previousX - childEntity.previousX;\n                    oY = childEntity.saveOY = this.owner.previousY - childEntity.previousY;\n                    if ((childEntity !== this.owner) && childEntity.collisionGroup) {\n                        childEntity = childEntity.collisionGroup;\n                    }\n                    childEntity.prepareCollision(x - oX, y - oY);\n                }\n            },\n            \n            movePreviousX: function (x) {\n                var childEntity = null,\n                    offset      = 0,\n                    i           = 0;\n                \n                for (i = 0; i < this.solidEntities.length; i++) {\n                    childEntity = this.solidEntities[i];\n                    offset = childEntity.saveOX;\n                    if ((childEntity !== this.owner) && childEntity.collisionGroup) {\n                        childEntity = childEntity.collisionGroup;\n                    }\n                    childEntity.movePreviousX(x - offset);\n                }\n            },\n            \n            relocateEntity: function (vector, collisionData) {\n                var childEntity = null,\n                    entity      = null,\n                    i           = 0,\n                    list        = null,\n                    owner       = this.owner,\n                    solids      = this.solidEntities,\n                    v           = null;\n                \n                owner.saveDX -= vector.x - owner.previousX;\n                owner.saveDY -= vector.y - owner.previousY;\n\n                list = collisionData.xData;\n                i = list.length;\n                while (i--) {\n                    if (list[i].thisShape.owner === owner) {\n                        owner.saveDX = 0;\n                        break;\n                    }\n                }\n                \n                list = collisionData.yData;\n                i = list.length;\n                while (i--) {\n                    if (list[i].thisShape.owner === owner) {\n                        owner.saveDY = 0;\n                        break;\n                    }\n                }\n                \n                for (i = 0; i < solids.length; i++) {\n                    childEntity = entity = solids[i];\n                    if ((childEntity !== owner) && childEntity.collisionGroup) {\n                        childEntity = childEntity.collisionGroup;\n                    }\n                    v = _Vector_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].setUp(vector.x - entity.saveOX, vector.y - entity.saveOY, childEntity.z);\n                    childEntity.relocateEntity(v, collisionData);\n                    v.recycle();\n                    entity.x += entity.saveDX;\n                    entity.y += entity.saveDY;\n                    if (entity !== owner) {\n                        entity.x += owner.saveDX;\n                        entity.y += owner.saveDY;\n                    }\n                }\n            },\n\n            destroy: function () {\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.solidEntities);\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.collisionTypes);\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.shapes);\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.prevShapes);\n                this.aabb.recycle();\n                this.prevAABB.recycle();\n                this.filteredAABB.recycle();\n            }\n        },\n        \n        publicMethods: {\n            /**\n             * Gets the bounding box of the group of entities.\n             *\n             * @method getCollisionGroupAABB\n             * @return platypus.AABB\n             */\n            getCollisionGroupAABB: function () {\n                return this.getAABB();\n            },\n            \n            /**\n             * Gets a list of all the entities in the world.\n             *\n             * @method getWorldEntities\n             * @return Array\n             */\n            getWorldEntities: function () {\n                return this.owner.parent.getWorldEntities();\n            },\n            \n            /**\n             * Gets the collision entity representing the world's terrain.\n             *\n             * @method getWorldTerrain\n             * @return platypus.Entity\n             */\n            getWorldTerrain: function () {\n                return this.owner.parent.getWorldTerrain();\n            }\n        }\n    });\n}());\n\n\n//# sourceURL=webpack://platypus/./src/components/CollisionGroup.js?");

/***/ }),

/***/ "./src/components/CollisionTiles.js":
/*!******************************************!*\
  !*** ./src/components/CollisionTiles.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _AABB_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../AABB.js */ \"./src/AABB.js\");\n/* harmony import */ var _CollisionShape_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../CollisionShape.js */ \"./src/CollisionShape.js\");\n/* harmony import */ var _Data_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Data.js */ \"./src/Data.js\");\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../factory.js */ \"./src/factory.js\");\n/**\n * This component causes the tile-map to collide with other entities. It must be part of a collision group and will cause \"hit-by-tile\" messages to fire on colliding entities.\n *\n * @namespace platypus.components\n * @class CollisionTiles\n * @uses platypus.Component\n */\n\n\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    var maskJumpThrough = 0x10000000,\n        maskRotation = 0x20000000,\n        maskXFlip = 0x80000000,\n        maskYFlip = 0x40000000,\n        maskIndex = 0x0fffffff,\n        getDefaultType = function () {\n            return this.collisionType;\n        },\n        getCollisionType = function (index) {\n            return this.collisionTypeMap[index & maskIndex] || this.collisionType;\n        },\n        flipDiagonal = function (num) {\n            if (num === 0) {\n                return num;\n            } else {\n                return num ^ maskYFlip ^ maskRotation;\n            }\n        },\n        flipDiagonalInverse = function (num) {\n            if (num === 0) {\n                return num;\n            } else {\n                return num ^ maskXFlip ^ maskRotation;\n            }\n        },\n        flipX = function (num) {\n            if (num === 0) {\n                return num;\n            } else {\n                return num ^ maskXFlip;\n            }\n        },\n        flipY = function (num) {\n            if (num === 0) {\n                return num;\n            } else {\n                return num ^ maskYFlip;\n            }\n        },\n        rotate90 = function (num) {\n            if (num === 0) {\n                return num;\n            } else if (maskRotation & num) {\n                return num ^ maskYFlip ^ maskRotation;\n            } else {\n                return num ^ maskXFlip ^ maskRotation;\n            }\n        },\n        rotate180 = function (num) {\n            if (num === 0) {\n                return num;\n            } else {\n                return num ^ maskXFlip ^ maskYFlip;\n            }\n        },\n        rotate270 = function (num) {\n            if (num === 0) {\n                return num;\n            } else if (maskRotation & num) {\n                return num ^ maskXFlip ^ maskRotation;\n            } else {\n                return num ^ maskYFlip ^ maskRotation;\n            }\n        },\n        copySection = function (array, originX, originY, width, height) {\n            var x   = 0,\n                y   = 0,\n                arr = _utils_array_js__WEBPACK_IMPORTED_MODULE_3__[\"arrayCache\"].setUp();\n\n            for (y = 0; y < height; y++) {\n                arr[y] = _utils_array_js__WEBPACK_IMPORTED_MODULE_3__[\"arrayCache\"].setUp();\n                for (x = 0; x < width; x++) {\n                    arr[y][x] = array[originX + x][originY + y];\n                }\n            }\n            return arr;\n        },\n        cutSection = function (array, originX, originY, width, height) {\n            var x   = 0,\n                y   = 0,\n                arr = _utils_array_js__WEBPACK_IMPORTED_MODULE_3__[\"arrayCache\"].setUp();\n\n            for (y = 0; y < height; y++) {\n                arr[y] = _utils_array_js__WEBPACK_IMPORTED_MODULE_3__[\"arrayCache\"].setUp();\n                for (x = 0; x < width; x++) {\n                    arr[y][x] = array[originX + x][originY + y];\n                    array[originX + x][originY + y] = -1;\n                }\n            }\n            return arr;\n        },\n        pasteSection = function (destinationArray, sourceArray, originX, originY, width, height) {\n            var x = 0,\n                y = 0;\n\n            for (y = 0; y < height; y++) {\n                for (x = 0; x < width; x++) {\n                    destinationArray[originX + x][originY + y] = sourceArray[y][x];\n                }\n            }\n            return destinationArray;\n        },\n        transforms = {\n            \"diagonal\": function (array, originX, originY, width, height) {\n                var arr   = copySection(array, originX, originY, width, height),\n                    fD    = flipDiagonal,\n                    x     = 0,\n                    y     = 0;\n\n                for (x = 0; x < width; x++) {\n                    for (y = 0; y < height; y++) {\n                        array[originX + x][originY + y] = fD(arr[x][y]);\n                    }\n                }\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_3__[\"arrayCache\"].recycle(arr, 2);\n                return array;\n            },\n            \"diagonal-inverse\": function (array, originX, originY, width, height) {\n                var arr   = copySection(array, originX, originY, width, height),\n                    fDI   = flipDiagonalInverse,\n                    x     = 0,\n                    y     = 0;\n\n                for (x = 0; x < width; x++) {\n                    for (y = 0; y < height; y++) {\n                        array[originX + width - x - 1][originY + height - y - 1] = fDI(arr[x][y]);\n                    }\n                }\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_3__[\"arrayCache\"].recycle(arr, 2);\n                return array;\n            },\n            \"horizontal\": function (array, originX, originY, width, height) {\n                var arr   = copySection(array, originX, originY, width, height),\n                    fX    = flipX,\n                    x     = 0,\n                    y     = 0;\n\n                for (y = 0; y < height; y++) {\n                    for (x = 0; x < width; x++) {\n                        array[originX + width - x - 1][originY + y] = fX(arr[y][x]);\n                    }\n                }\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_3__[\"arrayCache\"].recycle(arr, 2);\n                return array;\n            },\n            \"vertical\": function (array, originX, originY, width, height) {\n                var arr   = copySection(array, originX, originY, width, height),\n                    fY    = flipY,\n                    x     = 0,\n                    y     = 0;\n\n                for (y = 0; y < height; y++) {\n                    for (x = 0; x < width; x++) {\n                        array[originX + x][originY + height - y - 1] = fY(arr[y][x]);\n                    }\n                }\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_3__[\"arrayCache\"].recycle(arr, 2);\n                return array;\n            },\n            \"rotate-90\": function (array, originX, originY, width, height) {\n                var arr   = copySection(array, originX, originY, width, height),\n                    r90   = rotate90,\n                    x     = 0,\n                    y     = 0;\n\n                for (y = 0; y < height; y++) {\n                    for (x = 0; x < width; x++) {\n                        array[originX + height - y - 1][originY + x] = r90(arr[y][x]);\n                    }\n                }\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_3__[\"arrayCache\"].recycle(arr, 2);\n                return array;\n            },\n            \"rotate-180\": function (array, originX, originY, width, height) {\n                var arr   = copySection(array, originX, originY, width, height),\n                    r180  = rotate180,\n                    x     = 0,\n                    y     = 0;\n\n                for (y = 0; y < height; y++) {\n                    for (x = 0; x < width; x++) {\n                        array[originX + width - x - 1][originY + height - y - 1] = r180(arr[y][x]);\n                    }\n                }\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_3__[\"arrayCache\"].recycle(arr, 2);\n                return array;\n            },\n            \"rotate-270\": function (array, originX, originY, width, height) {\n                var arr   = copySection(array, originX, originY, width, height),\n                    r270  = rotate270,\n                    x     = 0,\n                    y     = 0;\n\n                for (y = 0; y < height; y++) {\n                    for (x = 0; x < width; x++) {\n                        array[originX + y][originY + width - x - 1] = r270(arr[y][x]);\n                    }\n                }\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_3__[\"arrayCache\"].recycle(arr, 2);\n                return array;\n            },\n            \"translate\": function (array, originX, originY, width, height, dx, dy) {\n                var arr = cutSection(array, originX, originY, width, height),\n                    x   = 0,\n                    y   = 0;\n\n                for (y = 0; y < height; y++) {\n                    for (x = 0; x < width; x++) {\n                        array[originX + x + dx][originY + y + dy] = arr[y][x];\n                    }\n                }\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_3__[\"arrayCache\"].recycle(arr, 2);\n                return array;\n            }\n        };\n\n    return Object(_factory_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])({\n        id: 'CollisionTiles',\n        \n        properties: {\n            /**\n             * Maps tile indexes to particular collision types. This defaults to a \"tiles\" collision type for all non-zero values if a particular collision map is not provided.\n             *\n             * @property collisionTypeMap\n             * @type Object\n             * @default null\n             */\n            collisionTypeMap: null,\n            \n            /**\n             * Sets the default collision type for non-zero map tiles.\n             *\n             * @property collisionType\n             * @type String\n             * @default \"tiles\"\n             */\n            collisionType: 'tiles',\n            \n            /**\n             * The map's top offset.\n             *\n             * @property top\n             * @type Number\n             * @default 0\n             */\n            top: 0,\n            \n            /**\n             * The map's left offset.\n             *\n             * @property left\n             * @type Number\n             * @default 0\n             */\n            left: 0\n        },\n        \n        publicProperties: {\n            /**\n             * A 2D array describing the tile-map with off (0) and on (!0) states. The indexes match Tiled map data indexes with an additional bit setting (0x2000000) for jumpthrough tiles. Example: `[[0, 0, 0], [1, 0, 0], [1, 1, 1]]`. Available on the entity as `entity.collisionMap`.\n             *\n             * @property collisionMap\n             * @type Array\n             * @default []\n             */\n            collisionMap: [],\n            \n            /**\n             * The width of tiles in world coordinates. Available on the entity as `entity.tileWidth`.\n             *\n             * @property tileWidth\n             * @type number\n             * @default 10\n             */\n            tileWidth: 10,\n\n            /**\n             * The height of tiles in world coordinates. Available on the entity as `entity.tileHeight`.\n             *\n             * @property tileWidth\n             * @type number\n             * @default 10\n             */\n            tileHeight: 10\n        },\n        initialize: function () {\n            this.tileOffsetLeft  = this.tileWidth / 2 + this.left;\n            this.tileOffsetTop = this.tileHeight / 2 + this.top;\n            \n            this.columns = this.collisionMap.length;\n            this.rows = this.collisionMap[0].length;\n            \n            this.shapeDefinition = _Data_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(\n                \"x\", 0,\n                \"y\", 0,\n                \"type\", 'rectangle',\n                \"width\", this.tileWidth,\n                \"height\", this.tileHeight\n            );\n            \n            this.storedTiles = _utils_array_js__WEBPACK_IMPORTED_MODULE_3__[\"arrayCache\"].setUp();\n            this.serveTiles = _utils_array_js__WEBPACK_IMPORTED_MODULE_3__[\"arrayCache\"].setUp();\n            this.storedTileIndex = 0;\n            \n            this.aabb = _AABB_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp();\n            this.aabb.setBounds(this.left, this.top, this.tileWidth * this.columns + this.left, this.tileHeight * this.rows + this.top);\n            \n            if (this.collisionTypeMap) {\n                this.getType = getCollisionType;\n            } else {\n                this.getType = getDefaultType;\n            }\n        },\n        \n        events: {\n            /**\n             * Performs a transform of a subset of the collision tile grid.\n             *\n             * @method 'transform'\n             * @param [transform] {Object} A list of key/value pairs describing the transform.\n             * @param [transform.type=\"horizontal\"] {String} The type of transform; one of the following: \"horizontal\", \"vertical\", \"diagonal\", \"diagonal-inverse\", \"rotate-90\", \"rotate-180\", \"rotate-270\". Height and width should match for diagonal flips and 90 degree rotations.\n             * @param [transform.left=0] {number} Grid coordinate for the left side of the bounding box.\n             * @param [transform.top=0] {number} Grid coordinate for the top of the bounding box.\n             * @param [transform.width=grid.width] {number} Cell width of the bounding box.\n             * @param [transform.height=grid.height] {number} Cell height of the bounding box.\n             */\n            \"transform\": function (transform) {\n                this.transform(transform);\n            },\n\n            /**\n             * Performs a translation of a subset of the collision tile grid.\n             *\n             * @method 'translate'\n             * @param [translate] {Object} A list of key/value pairs describing the translation.\n             * @param [translate.dx=0] {number} Movement in columns.\n             * @param [translate.dy=0] {number} Movement in rows.\n             * @param [translate.left=0] {number} Grid coordinate for the left side of the bounding box.\n             * @param [translate.top=0] {number} Grid coordinate for the top of the bounding box.\n             * @param [translate.width=grid.width] {number} Cell width of the bounding box.\n             * @param [translate.height=grid.height] {number} Cell height of the bounding box.\n             */\n            \"translate\": function (translate) {\n                this.translate(translate);\n            }\n        },\n        \n        methods: {\n            getShape: function (x, y, type) {\n                var i = this.storedTileIndex,\n                    shape = null,\n                    storedTiles = this.storedTiles;\n                \n                if (i === storedTiles.length) {\n                    shape = _CollisionShape_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp(null, this.shapeDefinition, type);\n                    storedTiles.push(shape);\n                } else {\n                    shape = storedTiles[i];\n                    shape.collisionType = type;\n                }\n                \n                shape.update(x * this.tileWidth + this.tileOffsetLeft, y * this.tileHeight + this.tileOffsetTop);\n\n                this.storedTileIndex += 1;\n                \n                return shape;\n            },\n            \n            addShape: function (shapes, prevAABB, x, y, collisionType) {\n                var xy = this.collisionMap[x][y],\n                    index = xy & maskIndex,\n                    jumpThrough = maskJumpThrough,\n                    rotation = maskRotation,\n                    xFlip = maskXFlip,\n                    yFlip = maskYFlip;\n                \n                if (xy && (this.getType(index) === collisionType)) {\n                    jumpThrough &= xy;\n                    if (jumpThrough) {\n                        rotation &= xy;\n                        xFlip &= xy;\n                        yFlip &= xy;\n                        if (rotation && xFlip) { // Right\n                            if (prevAABB.left >= (x + 1) * this.tileWidth + this.left) {\n                                shapes.push(this.getShape(x, y, collisionType));\n                            }\n                        } else if (rotation) { // Left\n                            if (prevAABB.right <= x * this.tileWidth + this.left) {\n                                shapes.push(this.getShape(x, y, collisionType));\n                            }\n                        } else if (yFlip) { // Bottom\n                            if (prevAABB.top >= (y + 1) * this.tileHeight + this.top) {\n                                shapes.push(this.getShape(x, y, collisionType));\n                            }\n                        } else if (prevAABB.bottom <= y * this.tileHeight + this.top) { // Top\n                            shapes.push(this.getShape(x, y, collisionType));\n                        }\n                    } else {\n                        shapes.push(this.getShape(x, y, collisionType));\n                    }\n                }\n\n                return shapes;\n            },\n            \n            destroy: function () {\n                var store = this.storedTiles,\n                    i = store.length;\n                \n                this.shapeDefinition.recycle();\n                this.shapeDefinition = null;\n                \n                while (i--) {\n                    store[i].recycle();\n                }\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_3__[\"arrayCache\"].recycle(store);\n                this.storedTiles = null;\n\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_3__[\"arrayCache\"].recycle(this.serveTiles);\n                this.serveTiles = null;\n                \n                this.aabb.recycle();\n                this.aabb = null;\n            }\n        },\n        \n        publicMethods: {\n            /**\n             * Returns the axis-aligned bounding box of the entire map.\n             *\n             * @method getAABB\n             * @return aabb {platypus.AABB} The returned object provides the top, left, width, and height of the collision map.\n             */\n            getAABB: function () {\n                return this.aabb;\n            },\n            \n            /**\n             * Confirms whether a particular map grid coordinate contains a tile.\n             *\n             * @method isTile\n             * @param x {number} Integer specifying the column of tiles in the collision map to check.\n             * @param y {number} Integer specifying the row of tiles in the collision map to check.\n             * @return {boolean} Returns `true` if the coordinate contains a collision tile, `false` if it does not.\n             */\n            isTile: function (x, y) {\n                return !((x < 0) || (y < 0) || (x >= this.columns) || (y >= this.rows) || (this.collisionMap[x][y] === -1));\n            },\n            \n            /**\n             * Returns all the collision tiles within the provided axis-aligned bounding box as an array of shapes.\n             *\n             * @method getTileShapes\n             * @param aabb {platypus.AABB} The axis-aligned bounding box for which tiles should be returned.\n             * @param prevAABB {platypus.AABB} The axis-aligned bounding box for a previous location to test for jump-through tiles.\n             * @param [collisionType] {String} The type of collision to check for. If not specified, \"tiles\" is used. (Since 0.8.3)\n             * @return {Array} Each returned object provides the [CollisionShape](CollisionShape.html) of a tile.\n             */\n            getTileShapes: function (aabb, prevAABB, collisionType) {\n                var colType = collisionType || 'tiles',\n                    l = this.left,\n                    t = this.top,\n                    th = this.tileHeight,\n                    tw = this.tileWidth,\n                    left   = Math.max(Math.floor((aabb.left - l) / tw),  0),\n                    top    = Math.max(Math.floor((aabb.top - t) / th), 0),\n                    right  = Math.min(Math.ceil((aabb.right - l) / tw),  this.columns),\n                    bottom = Math.min(Math.ceil((aabb.bottom - t) / th), this.rows),\n                    x      = 0,\n                    y      = 0,\n                    shapes = this.serveTiles;\n                \n                shapes.length = 0;\n                this.storedTileIndex = 0;\n                \n                for (x = left; x < right; x++) {\n                    for (y = top; y < bottom; y++) {\n                        this.addShape(shapes, prevAABB, x, y, colType);\n                    }\n                }\n                \n                return shapes;\n            },\n            \n            /**\n             * Performs a transform of a subset of the collision tile grid.\n             *\n             * @method transform\n             * @param [transform] {Object} A list of key/value pairs describing the transform.\n             * @param [transform.type=\"horizontal\"] {String} The type of transform; one of the following: \"horizontal\", \"vertical\", \"diagonal\", \"diagonal-inverse\", \"rotate-90\", \"rotate-180\", \"rotate-270\". Height and width should match for diagonal flips and 90 degree rotations.\n             * @param [transform.left=0] {number} Grid coordinate for the left side of the bounding box.\n             * @param [transform.top=0] {number} Grid coordinate for the top of the bounding box.\n             * @param [transform.width=grid.width] {number} Cell width of the bounding box.\n             * @param [transform.height=grid.height] {number} Cell height of the bounding box.\n             */\n            transform: function (transform) {\n                var t      = transform || {},\n                    x      = t.left    || 0,\n                    y      = t.top     || 0,\n                    width  = t.width   || this.rows,\n                    height = t.height  || this.columns,\n                    type   = t.type    || \"horizontal\";\n                \n                if (transforms[type]) {\n                    return transforms[type](this.collisionMap, x, y, width, height);\n                } else {\n                    return null;\n                }\n            },\n            \n            /**\n             * Performs a translation of a subset of the collision tile grid.\n             *\n             * @method translate\n             * @param [translate] {Object} A list of key/value pairs describing the translation.\n             * @param [translate.dx=0] {number} Movement in columns.\n             * @param [translate.dy=0] {number} Movement in rows.\n             * @param [translate.left=0] {number} Grid coordinate for the left side of the bounding box.\n             * @param [translate.top=0] {number} Grid coordinate for the top of the bounding box.\n             * @param [translate.width=grid.width] {number} Cell width of the bounding box.\n             * @param [translate.height=grid.height] {number} Cell height of the bounding box.\n             */\n            translate: function (translate) {\n                var t      = translate || {},\n                    x      = t.left    || 0,\n                    y      = t.top     || 0,\n                    width  = t.width   || this.rows,\n                    height = t.height  || this.columns,\n                    dx     = t.dx      || 0,\n                    dy     = t.dy      || 0;\n                \n                return transforms.translate(this.collisionMap, x, y, width, height, dx, dy);\n            },\n            \n            /**\n             * Gets a subset of the collision tile grid as a 2D array.\n             *\n             * @method getCollisionMatrix\n             * @param originX {number} Grid coordinate for the left side of the bounding box.\n             * @param originY {number} Grid coordinate for the top of the bounding box.\n             * @param width {number} Cell width of the bounding box.\n             * @param height {number} Cell height of the bounding box.\n             * @return {Array}\n             */\n            getCollisionMatrix: function (originX, originY, width, height) {\n                return copySection(this.collisionMap, originX, originY, width, height);\n            },\n            \n            /**\n             * Sets a subset of the collision tile grid.\n             *\n             * @method setCollisionMatrix\n             * @param sourceArray {Array} A 2D array describing the collision tiles to insert into the collision tile grid.\n             * @param originX {number} Grid coordinate for the left side of the bounding box.\n             * @param originY {number} Grid coordinate for the top of the bounding box.\n             * @param width {number} Cell width of the bounding box.\n             * @param height {number} Cell height of the bounding box.\n             */\n            setCollisionMatrix: function (sourceArray, originX, originY, width, height) {\n                return pasteSection(this.collisionMap, sourceArray, originX, originY, width, height);\n            }\n        }\n    });\n}());\n\n\n//# sourceURL=webpack://platypus/./src/components/CollisionTiles.js?");

/***/ }),

/***/ "./src/components/ComponentSwitcher.js":
/*!*********************************************!*\
  !*** ./src/components/ComponentSwitcher.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../factory.js */ \"./src/factory.js\");\n/**\n * This component listens for messages and, according to its preset settings, will remove and add components to the entity. This is useful if certain events should modify the behavior of the entity in some way: for example, acquiring a pogo-stick might add a jumping component so the hero can jump.\n *\n * @namespace platypus.components\n * @class ComponentSwitcher\n * @uses platypus.Component\n */\n/* global platypus */\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    var\n        addSwitch = function (event) {\n            this.switches.push(event);\n        };\n    \n    return Object(_factory_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])({\n        id: 'ComponentSwitcher',\n        \n        properties: {\n            /**\n             * This is the list of messages to listen for (as the keys) with the settings as two arrays of components to add and components to remove.\n             *\n                {\n                    \"found-pogostick\":{\n                      \"add\":[\n                      // This is a list of components to add when \"found-pogostick\" is triggered on the entity. If it's adding a single component, \"add\" can be a reference to the component definition itself rather than an array of one object.\n                        {\"type\": \"Mover\"},\n                        {\"type\": \"HeadGear\"}\n                      ]\n                      \n                      \"remove\": [\"CarSeat\"]\n                      // This is a string list of component ids to remove when \"found-pogostick\" is triggered on the entity. It will ignore listed components that are not connected to the entity.\n                    },\n                    \n                    // Multiple events can cause unique components to be added or removed\n                    \"walking-indoors\":{\n                      \"remove\": [\"HeadGear\"]\n                    },\n                    \n                    \"contemplate\":{\n                      \"add\": {\"type\": \"AIPacer\"}\n                    }\n                  }\n                }\n             *\n             * @property componentMap\n             * @type Object\n             * @default null\n             */\n            componentMap: null\n        },\n        \n        initialize: function () {\n            var event = '';\n            \n            this.switches = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(); // The list of switches to make.\n            \n            if (this.componentMap) {\n                for (event in this.componentMap) {\n                    if (this.componentMap.hasOwnProperty(event)) {\n                        /**\n                         * Message(s) listed by `componentMap` will add or remove components.\n                         *\n                         * @method '*'\n                         */\n                        this.addEventListener(event, addSwitch.bind(this, event));\n                    }\n                }\n            }\n        },\n        \n        events: {\n            /**\n             * This component handles component-switching on this call so that it doesn't interfere with the \"handle-logic\" loop.\n             *\n             * @method 'prepare-logic'\n             */\n            \"prepare-logic\": function () {\n                var i = 0;\n                \n                if (this.switches.length) {\n                    for (i = 0; i < this.switches.length; i++) {\n                        this.switchComponents(this.componentMap[this.switches[i]]);\n                    }\n                    this.switches.length = 0;\n                }\n            }\n        },\n        \n        methods: {\n            switchComponents: function (definition) {\n                var i = 0,\n                    j = 0,\n                    owner = this.owner,\n                    components = owner.components,\n                    remove = definition.remove,\n                    add = definition.add;\n                    \n                if (remove) {\n                    if (!Array.isArray(remove)) {\n                        for (i = components.length - 1; i > -1; i--) {\n                            if (components[i].type === remove) {\n                                owner.removeComponent(components[i]);\n                            }\n                        }\n                    } else {\n                        for (i = 0; i < remove.length; i++) {\n                            for (j = components.length - 1; j > -1; j--) {\n                                if (components[j].type === remove[i]) {\n                                    owner.removeComponent(components[j]);\n                                }\n                            }\n                        }\n                    }\n                }\n\n                if (add) {\n                    if (!Array.isArray(add)) {\n                        owner.addComponent(new platypus.components[add.type](owner, add));\n                    } else {\n                        for (i = 0; i < add.length; i++) {\n                            owner.addComponent(new platypus.components[add[i].type](owner, add[i]));\n                        }\n                    }\n                }\n                \n                /**\n                * This message is triggered on the parent when the entity's components change.\n                *\n                * @event 'child-entity-updated'\n                * @param entity {platypus.Entity} This is the entity itself.\n                */\n                owner.parent.triggerEvent('child-entity-updated', owner);\n\n                /**\n                * This message is triggered on the entity itself when its components change.\n                *\n                * @event 'add-remove-component-complete'\n                */\n                owner.triggerEvent('add-remove-component-complete');\n            },\n            \n            destroy: function () {\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.switches);\n            }\n        },\n        \n        getAssetList: function (def, props, defaultProps) {\n            var map = def.componentMap || props.componentMap || defaultProps.componentMap,\n                event = '',\n                i = 0,\n                component = null,\n                assets = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(),\n                arr = null;\n            \n            for (event in map) {\n                if (map.hasOwnProperty(event)) {\n                    for (i = 0; i < map[event].add.length; i++) {\n                        component = platypus.components[map[event].add[i].type];\n                        if (component) {\n                            arr = component.getAssetList(map[event].add[i], props, defaultProps);\n                            Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"union\"])(assets, arr);\n                            _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(arr);\n                        }\n                    }\n                }\n            }\n            \n            return assets;\n        }\n    });\n}());\n\n\n//# sourceURL=webpack://platypus/./src/components/ComponentSwitcher.js?");

/***/ }),

/***/ "./src/components/Counter.js":
/*!***********************************!*\
  !*** ./src/components/Counter.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Data_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Data.js */ \"./src/Data.js\");\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../factory.js */ \"./src/factory.js\");\n/**\n * A simple component that keeps count of something and sends messages each time the count changes. Can also have a total. When it does it will display 'count / total'.\n *\n * @namespace platypus.components\n * @class Counter\n * @uses platypus.Component\n */\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    return Object(_factory_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])({\n\n        id: 'Counter',\n\n        publicProperties: {\n            /**\n             * A total the counter is incrementing toward.\n             *\n             * @property total\n             * @type number\n             * @default 0\n             */\n            total: 0\n        },\n\n        initialize: function () {\n            this.count = 0;\n            this.lastTotal = 0;\n            this.lastCount = 0;\n            this.message = _Data_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp(\n                \"text\", \"\"\n            );\n        },\n\n        events: {\n            /**\n             * Each step, this component detects whether the count has changed and triggers an 'update-content' event if so.\n             *\n             * @method 'handle-logic'\n             */\n            \"handle-logic\": function () {\n                var update  = false,\n                    msg = this.message;\n                \n                if (this.total !== this.lastTotal) {\n                    this.lastTotal = this.total;\n                    update = true;\n                }\n                \n                if (this.count !== this.lastCount) {\n                    this.lastCount = this.count;\n                    update = true;\n                }\n                \n                if (update) {\n                    if (this.total) {\n                        msg.text = String(this.count) + \"/\" + String(this.total);\n                    } else {\n                        msg.text = String(this.count);\n                    }\n                    \n                    /**\n                     * A call used to notify other components that the count or total has changed.\n                     *\n                     * @event 'update-content'\n                     * @param update.text {string} String describing the current count.\n                     */\n                    this.owner.triggerEvent('update-content', msg);\n                }\n            },\n\n            /**\n             * Changes the total to the given value.\n             *\n             * @method 'change-total'\n             * @param data.total {number} The new total value.\n             */\n            \"change-total\": function (total) {\n                this.total = total;\n            },\n\n            /**\n             * Changes the count to the given value.\n             *\n             * @method 'change-count'\n             * @param data.count {number} The new count value.\n             */\n            \"change-count\": function (count) {\n                this.count = count;\n            },\n\n            /**\n             * Increments the count by 1.\n             *\n             * @method 'increment-count'\n             */\n            \"increment-count\": function () {\n                this.count += 1;\n            }\n        },\n        \n        methods: {\n            destroy: function () {\n                this.message.recycle();\n            }\n        }\n    });\n}());\n\n\n//# sourceURL=webpack://platypus/./src/components/Counter.js?");

/***/ }),

/***/ "./src/components/EntityContainer.js":
/*!*******************************************!*\
  !*** ./src/components/EntityContainer.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var _Async_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Async.js */ \"./src/Async.js\");\n/* harmony import */ var _Data_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Data.js */ \"./src/Data.js\");\n/* harmony import */ var _Entity_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Entity.js */ \"./src/Entity.js\");\n/* harmony import */ var _Messenger_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Messenger.js */ \"./src/Messenger.js\");\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../factory.js */ \"./src/factory.js\");\n/**\n * This component allows the entity to contain child entities. It will add several methods to the entity to manage adding and removing entities.\n *\n * @namespace platypus.components\n * @class EntityContainer\n * @extends platypus.Messenger\n * @uses platypus.Component\n */\n/**\n### Local Broadcasts:\n- **child-entity-added** - This message is triggered when a new entity has been added to the list of children entities.\n  - @param message ([[Entity]] object) - The entity that was just added.\n- **child-entity-removed** - This message is triggered when an entity has been removed from the list of children entities.\n  - @param message ([[Entity]] object) - The entity that was just removed.\n\n### Child Broadcasts:\n- **peer-entity-added** - This message is triggered when a new entity has been added to the parent's list of children entities.\n  - @param message ([[Entity]] object) - The entity that was just added.\n- **peer-entity-removed** - This message is triggered when an entity has been removed from the parent's list of children entities.\n  - @param message ([[Entity]] object) - The entity that was just removed.\n- **[Messages specified in definition]** - Listens for specified messages and on receiving them, re-triggers them on child entities.\n  - @param message (object) - sends the message object received by the original message.\n\n## Entity Methods:\n- **addEntity** -  This method will add the provided entity to this component's list of entities.\n  - @param entity ([[Entity]] object) - Required. This is the entity to be added as a child.\n  - @return entity ([[Entity]] object) - Returns the entity that was just added.\n- **removeEntity** - This method will remove the provided entity from the list of child entities.\n  - @param message ([[Entity]] object) - Required. The entity to remove.\n  - @return entity ([[Entity]] object | false) - Returns the entity that was just removed. If the entity was not foudn as a child, `false` is returned, indicated that the provided entity was not a child of this entity.\n- **getEntitiesByType** - This method will return all child entities (including grandchildren) that match the provided type.\n  - @param type (string) - Required. The entity type to find.\n  - @return entities (Array of [[Entity]] objects) - Returns the entities that match the specified entity type.\n- **getEntityById** - This method will return the first child entity it finds with a matching id (including grandchildren).\n  - @param id (string) - Required. The entity id to find.\n  - @return entity ([[Entity]] object) - Returns the entity that matches the specified entity id.\n- **triggerOnChildren** - This method is used by both internal components and external entities to trigger messages on the child entities.\n  - @param event (variant) - This is the message(s) to process. This can be a string, an object containing an \"event\" property (and optionally a \"message\" property, overriding the value below), or an array of the same.\n  - @param value (variant) - This is a message object or other value to pass along to component functions.\n  - @param debug (boolean) - This flags whether to output message contents and subscriber information to the console during game development. A \"value\" object parameter (above) will also set this flag if value.debug is set to true.\n  - @return integer - The number of handlers for the triggered message: this is useful for determining how many child entities care about a given message.\n- **triggerEvent** - This method is used by both internal components and external entities to trigger messages on the child entities.\n  - @param event (string) - This is the message to process.\n  - @param value (variant) - This is a message object or other value to pass along to component functions.\n  - @param debug (boolean) - This flags whether to output message contents and subscriber information to the console during game development. A \"value\" object parameter (above) will also set this flag if value.debug is set to true.\n  - @return integer - The number of handlers for the triggered message: this is useful for determining how many child entities care about a given message.\n*/\n/* global platypus */\n\n\n\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    var childBroadcast = function (event) {\n            return function (value, debug) {\n                this.triggerOnChildren(event, value, debug);\n            };\n        },\n        EntityContainer = Object(_factory_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])({\n            id: 'EntityContainer',\n            \n            properties: {\n                /**\n                 * An Array listing messages that are triggered on the entity and should be triggered on the children as well.\n                 *\n                 * @property childEvents\n                 * @type Array\n                 * @default []\n                 */\n                childEvents: []\n            },\n            \n            initialize: (function () {\n                var\n                    entityInit = function (entityDefinition, callback) {\n                        this.addEntity(entityDefinition, callback);\n                    };\n\n                return function (definition, callback) {\n                    var i = 0,\n                        entities = null,\n                        events = this.childEvents,\n                        entityInits = null;\n            \n                    _Messenger_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].initialize(this);\n\n                    this.newAdds = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n\n                    //saving list of entities for load message\n                    if (definition.entities && this.owner.entities) { //combine component list and entity list into one if they both exist.\n                        entities = definition.entities.concat(this.owner.entities);\n                    } else {\n                        entities = definition.entities || this.owner.entities || null;\n                    }\n\n                    this.owner.entities = this.entities = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n                    \n                    this.childEvents = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n                    for (i = 0; i < events.length; i++) {\n                        this.addNewPublicEvent(events[i]);\n                    }\n                    this.addNewPrivateEvent('peer-entity-added');\n                    this.addNewPrivateEvent('peer-entity-removed');\n\n                    if (entities) {\n                        entityInits = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n                        for (i = 0; i < entities.length; i++) {\n                            entityInits.push(entityInit.bind(this, entities[i]));\n                        }\n                        _Async_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp(entityInits, callback);\n                        _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(entityInits);\n                        return true; // notifies owner that this component is asynchronous.\n                    } else {\n                        return false;\n                    }\n                };\n            } ()),\n            \n            events: {\n                /**\n                 * This message will added the given entity to this component's list of entities.\n                 *\n                 * @method 'add-entity'\n                 * @param entity {platypus.Entity} This is the entity to be added as a child.\n                 * @param [callback] {Function} A function to run once all of the components on the Entity have been loaded.\n                 */\n                \"add-entity\": function (entity, callback) {\n                    this.addEntity(entity, callback);\n                },\n                \n                /**\n                 * On receiving this message, the provided entity will be removed from the list of child entities.\n                 *\n                 * @method 'remove-entity'\n                 * @param entity {platypus.Entity} The entity to remove.\n                 */\n                \"remove-entity\": function (entity) {\n                    this.removeEntity(entity);\n                },\n                \n                /**\n                 * On receiving this message, the provided entity will be updated in the list of child entities to reflect changes in its listeners.\n                 *\n                 * @method 'child-entity-updated'\n                 * @param entity {platypus.Entity} The entity to remove.\n                 */\n                \"child-entity-updated\": function (entity) {\n                    this.updateChildEventListeners(entity);\n                },\n\n                /**\n                 * On receiving this message, this component checks to see if any entities being added are ready. If so, they are added to the world. This is so ready entities don't have to wait until the end of a complete tick, but can be inserted between logic ticks.\n                 *\n                 * @method 'handle-logic'\n                 */\n                \"handle-logic\": function () {\n                    var adding = null,\n                        adds = this.newAdds,\n                        l = adds.length,\n                        i = 0,\n                        removals = null;\n\n                    if (l) {\n                        removals = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n\n                        //must go in order so entities are added in the expected order.\n                        for (i = 0; i < l; i++) {\n                            adding = adds[i];\n                            if (adding.destroyed || !adding.loadingComponents || adding.loadingComponents.attemptResolution()) {\n                                removals.push(i);\n                            }\n                        }\n\n                        i = removals.length;\n                        while (i--) {\n                            Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSplice\"])(adds, removals[i]);\n                        }\n\n                        _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(removals);\n                    }\n                }\n            },\n            \n            methods: {\n                addNewPublicEvent: function (event) {\n                    var i = 0;\n                    \n                    this.addNewPrivateEvent(event);\n                    \n                    for (i = 0; i < this.childEvents.length; i++) {\n                        if (this.childEvents[i] === event) {\n                            return false;\n                        }\n                    }\n                    this.childEvents.push(event);\n                    /**\n                     * Listens for specified messages and on receiving them, re-triggers them on child entities.\n                     *\n                     * @method '*'\n                     * @param message {Object} Accepts a message object that it will include in the new message to be triggered.\n                     */\n                    this.addEventListener(event, childBroadcast(event));\n                    \n                    return true;\n                },\n                \n                addNewPrivateEvent: function (event) {\n                    var x = 0,\n                        y = 0;\n                    \n                    if (this._listeners[event]) {\n                        return false; // event is already added.\n                    }\n\n                    this._listeners[event] = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(); //to signify it's been added even if not used\n                    \n                    //Listen for message on children\n                    for (x = 0; x < this.entities.length; x++) {\n                        if (this.entities[x]._listeners[event]) {\n                            for (y = 0; y < this.entities[x]._listeners[event].length; y++) {\n                                this.addChildEventListener(this.entities[x], event, this.entities[x]._listeners[event][y]);\n                            }\n                        }\n                    }\n                    \n                    return true;\n                },\n                \n                updateChildEventListeners: function (entity) {\n                    this.removeChildEventListeners(entity);\n                    this.addChildEventListeners(entity);\n                },\n                \n                addChildEventListeners: function (entity) {\n                    var y     = 0,\n                        event = '';\n                    \n                    for (event in this._listeners) {\n                        if (this._listeners.hasOwnProperty(event) && entity._listeners[event]) {\n                            for (y = 0; y < entity._listeners[event].length; y++) {\n                                this.addChildEventListener(entity, event, entity._listeners[event][y]);\n                            }\n                        }\n                    }\n                },\n                \n                removeChildEventListeners: function (entity) {\n                    var i        = 0,\n                        events   = null,\n                        messages = null;\n                    \n                    if (entity.containerListener) {\n                        events   = entity.containerListener.events;\n                        messages = entity.containerListener.messages;\n\n                        for (i = 0; i < events.length; i++) {\n                            this.removeChildEventListener(entity, events[i], messages[i]);\n                        }\n                        _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(events);\n                        _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(messages);\n                        entity.containerListener.recycle();\n                        entity.containerListener = null;\n                    }\n                },\n                \n                addChildEventListener: function (entity, event, callback) {\n                    if (!entity.containerListener) {\n                        entity.containerListener = _Data_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(\n                            \"events\", _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(),\n                            \"messages\", _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp()\n                        );\n                    }\n                    entity.containerListener.events.push(event);\n                    entity.containerListener.messages.push(callback);\n                    this.on(event, callback, callback._priority || 0);\n                },\n                \n                removeChildEventListener: function (entity, event, callback) {\n                    var i        = 0,\n                        events   = entity.containerListener.events,\n                        messages = entity.containerListener.messages;\n                    \n                    for (i = 0; i < events.length; i++) {\n                        if ((events[i] === event) && (!callback || (messages[i] === callback))) {\n                            this.off(event, messages[i]);\n                        }\n                    }\n                },\n\n                destroy: function () {\n                    var entities = Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSlice\"])(this.entities), // Make a copy to handle entities being destroyed while processing list.\n                        i = entities.length,\n                        entity = null;\n                    \n                    while (i--) {\n                        entity = entities[i];\n                        this.removeChildEventListeners(entity);\n                        entity.destroy();\n                    }\n                    \n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(entities);\n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.entities);\n                    this.owner.entities = null;\n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.childEvents);\n                    this.childEvents = null;\n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.newAdds);\n                    this.newAdds = null;\n                }\n            },\n            \n            publicMethods: {\n                /**\n                 * Gets an entity in this layer by its Id. Returns `null` if not found.\n                 *\n                 * @method getEntityById\n                 * @param {String} id\n                 * @return {Entity}\n                 */\n                getEntityById: function (id) {\n                    var i         = 0,\n                        selection = null;\n                    \n                    for (i = 0; i < this.entities.length; i++) {\n                        if (this.entities[i].id === id) {\n                            return this.entities[i];\n                        }\n                        if (this.entities[i].getEntityById) {\n                            selection = this.entities[i].getEntityById(id);\n                            if (selection) {\n                                return selection;\n                            }\n                        }\n                    }\n                    return null;\n                },\n\n                /**\n                 * Returns a list of entities of the requested type.\n                 *\n                 * @method getEntitiesByType\n                 * @param {String} type\n                 * @return {Array}\n                 */\n                getEntitiesByType: function (type) {\n                    var i         = 0,\n                        selection = null,\n                        entities  = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n                    \n                    for (i = 0; i < this.entities.length; i++) {\n                        if (this.entities[i].type === type) {\n                            entities.push(this.entities[i]);\n                        }\n                        if (this.entities[i].getEntitiesByType) {\n                            selection = this.entities[i].getEntitiesByType(type);\n                            Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"union\"])(entities, selection);\n                            _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(selection);\n                        }\n                    }\n                    return entities;\n                },\n\n                /**\n                 * This method adds an entity to the owner's group. If an entity definition or a reference to an entity definition is provided, the entity is created and then added to the owner's group.\n                 *\n                 * @method addEntity\n                 * @param newEntity {platypus.Entity|Object|String} Specifies the entity to add. If an object with a \"type\" property is provided or a String is provided, this component looks up the entity definition to create the entity.\n                 * @param [newEntity.type] {String} If an object with a \"type\" property is provided, this component looks up the entity definition to create the entity.\n                 * @param [newEntity.properties] {Object} A list of key/value pairs that sets the initial properties on the new entity.\n                 * @param [callback] {Function} A function to run once all of the components on the Entity have been loaded.\n                 * @return {platypus.Entity} The entity that was just added.\n                 */\n                addEntity: (function () {\n                    var\n                        whenReady = function (callback, entity) {\n                            var owner = this.owner,\n                                entities = this.entities,\n                                i = entities.length;\n\n                            entity.triggerEvent('adopted', entity);\n                            \n                            while (i--) {\n                                if (!entity.triggerEvent('peer-entity-added', entities[i])) {\n                                    break;\n                                }\n                            }\n                            this.triggerEventOnChildren('peer-entity-added', entity);\n\n                            this.addChildEventListeners(entity);\n                            entities.push(entity);\n                            owner.triggerEvent('child-entity-added', entity);\n\n                            if (callback) {\n                                callback(entity);\n                            }\n                        };\n\n                    return function (newEntity, callback) {\n                        var entity = null,\n                            owner = this.owner;\n                        \n                        if (newEntity instanceof _Entity_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]) {\n                            entity = newEntity;\n                            entity.parent = owner;\n                            whenReady.call(this, callback, entity);\n                        } else {\n                            if (typeof newEntity === 'string') {\n                                entity = new _Entity_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](platypus.game.settings.entities[newEntity], null, whenReady.bind(this, callback), owner);\n                            } else if (newEntity.id) {\n                                entity = new _Entity_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](newEntity, null, whenReady.bind(this, callback), owner);\n                            } else {\n                                entity = new _Entity_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](platypus.game.settings.entities[newEntity.type], newEntity, whenReady.bind(this, callback), owner);\n                            }\n                            this.owner.triggerEvent('entity-created', entity);\n                        }\n\n                        this.newAdds.push(entity);\n\n                        return entity;\n                    };\n                }()),\n                \n                /**\n                 * Removes the provided entity from the layer and destroys it. Returns `false` if the entity is not found in the layer.\n                 *\n                 * @method removeEntity\n                 * @param {Entity} entity\n                 * @return {Entity}\n                 */\n                removeEntity: function (entity) {\n                    var i = this.entities.indexOf(entity);\n\n                    if (i >= 0) {\n                        this.removeChildEventListeners(entity);\n                        Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSplice\"])(this.entities, i);\n                        this.triggerEventOnChildren('peer-entity-removed', entity);\n                        this.owner.triggerEvent('child-entity-removed', entity);\n                        entity.destroy();\n                        entity.parent = null;\n                        return entity;\n                    }\n                    return false;\n                },\n                \n                /**\n                 * Triggers a single event on the child entities in the layer.\n                 *\n                 * @method triggerEventOnChildren\n                 * @param {*} event\n                 * @param {*} message\n                 * @param {*} debug\n                 */\n                triggerEventOnChildren: function (event, message, debug) {\n                    if (this.destroyed) {\n                        return 0;\n                    }\n                    \n                    if (!this._listeners[event]) {\n                        this.addNewPrivateEvent(event);\n                    }\n                    return this.triggerEvent(event, message, debug);\n                },\n\n                /**\n                 * Triggers one or more events on the child entities in the layer. This is unique from `triggerEventOnChildren` in that it also accepts an `Array` to send multiple events.\n                 *\n                 * @method triggerOnChildren\n                 * @param {*} event\n                 * @param {*} message\n                 * @param {*} debug\n                 */\n                triggerOnChildren: function (event) {\n                    if (this.destroyed) {\n                        return 0;\n                    }\n                    \n                    if (!this._listeners[event]) {\n                        this.addNewPrivateEvent(event);\n                    }\n                    return this.trigger.apply(this, arguments);\n                }\n            },\n            \n            getAssetList: function (def, props, defaultProps) {\n                var i = 0,\n                    assets = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(),\n                    entities = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(),\n                    arr = null;\n                \n                if (def.entities) {\n                    Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"union\"])(entities, def.entities);\n                }\n                \n                if (props && props.entities) {\n                    Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"union\"])(entities, props.entities);\n                } else if (defaultProps && defaultProps.entities) {\n                    Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"union\"])(entities, defaultProps.entities);\n                }\n\n                for (i = 0; i < entities.length; i++) {\n                    arr = _Entity_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].getAssetList(entities[i]);\n                    Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"union\"])(assets, arr);\n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(arr);\n                }\n                \n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(entities);\n                \n                return assets;\n            }\n        });\n    \n    _Messenger_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].mixin(EntityContainer);\n\n    return EntityContainer;\n}());\n\n\n//# sourceURL=webpack://platypus/./src/components/EntityContainer.js?");

/***/ }),

/***/ "./src/components/EntityController.js":
/*!********************************************!*\
  !*** ./src/components/EntityController.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _ActionState_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ActionState.js */ \"./src/ActionState.js\");\n/* harmony import */ var _Data_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Data.js */ \"./src/Data.js\");\n/* harmony import */ var _DataMap_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../DataMap.js */ \"./src/DataMap.js\");\n/* harmony import */ var _StateMap_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../StateMap.js */ \"./src/StateMap.js\");\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../factory.js */ \"./src/factory.js\");\n/**\n * This component listens for input messages triggered on the entity and updates the state of any controller inputs it is listening for. It then broadcasts messages on the entity corresponding to the input it received.\n *\n * @namespace platypus.components\n * @class EntityController\n * @uses platypus.Component\n */\n\n\n\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    var distance = function (origin, destination) {\n            var x = destination.x - origin.x,\n                y = destination.y - origin.y;\n\n            return Math.sqrt((x * x) + (y * y));\n        },\n        angle = function (origin, destination, distance) {\n            var x      = destination.x - origin.x,\n                y      = destination.y - origin.y,\n                a      = 0,\n                circle = Math.PI * 2;\n\n            if (!distance) {\n                return a;\n            }\n\n            a = Math.acos(x / distance);\n            if (y < 0) {\n                a = circle - a;\n            }\n            return a;\n        },\n        directions = [null, null, null, null, //joystick directions\n            ['east', 'south', 'west', 'north'], null, null, null,\n            ['east', 'southeast', 'south', 'southwest', 'west', 'northwest', 'north', 'northeast'], null, null, null, null, null, null, null,\n            ['east', 'east-southeast', 'southeast', 'south-southeast', 'south', 'south-southwest', 'southwest', 'west-southwest', 'west', 'west-northwest', 'northwest', 'north-northwest', 'north', 'north-northeast', 'northeast', 'east-northeast']\n        ],\n        mouseMap = ['left-button', 'middle-button', 'right-button'],\n        trigger = function (event, message) {\n            if (!this.paused) {\n                this.owner.trigger(event, message);\n            }\n        },\n        filteredTrigger = function (state, event, message) {\n            if (!this.paused && message[state]) {\n                this.owner.trigger(event, message);\n            }\n        };\n\n    return Object(_factory_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])({\n        id: 'EntityController',\n        \n        properties: {\n            /**\n             * Use the controlMap property object to map inputs to messages that should be triggered. At least one control mapping should be included. The following are a few examples:\n             *\n             *       {\n             *           \"key:x\": \"run-left\",\n             *           // This causes an \"x\" keypress to fire \"run-left\" on the entity. For a full listing of key names, check out the `HandlerController` component.\n             *\n             *           \"button-pressed\": \"throw-block\",\n             *           // custom input messages can be fired on this entity from other entities, allowing for on-screen input buttons to run through the same controller channel as other inputs.\n             *\n             *           \"mouse:left-button\"\n             *           // The controller can also handle mouse events on the entity if the entity's render component triggers mouse events on the entity (for example, the `RenderSprite` component).\n             *       }\n             *\n             * @property controlMap\n             * @type Object\n             * @default {}\n             */\n            controlMap: {},\n\n            /**\n             * Determines whether this entity should listen for mouse events to trigger directional events. Can be set simply to \"true\" to accept all joystick defaults.\n             *\n             *       \"joystick\": {\n             *           \"directions\": 8, // Optional: 4, 8, or 16. Determines how many directions to broadcast. Default is 4 (\"north\", \"east\", \"south\", and \"west\").\n             *           \"innerRadius\": 30, // Optional. Number determining how far the mouse must be from the entity's position before joystick events should be triggered. Default is 0.\n             *           \"outerRadius\": 60 // Optional. Number determining how far the mouse can move away from the entity's position before the joystick stops triggering events. Default is Infinity.\n             *       }\n             *\n             * @property joystick\n             * @type Object\n             * @default null\n             */\n            joystick: null,\n            \n            /**\n             * The stateMaps property can hold multiple control maps. Use this if certain controls should only be available for certain states. The controller finds the first valid state and falls back to the base `controlMap` as default if no matches are found.\n             *\n             * @property stateMaps\n             * @type Object\n             * @default {}\n             */\n            stateMaps: {}\n        },\n        \n        publicProperties: {\n            /**\n             * Whether input controls should be deactivated.\n             *\n             * @property paused\n             * @type Boolean\n             * @default false\n             */\n            paused: false\n        },\n        \n        initialize: function (definition) {\n            var key = '',\n                filter = null;\n            \n            this.actions = _DataMap_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp();\n            \n            if (this.stateMaps) {\n                for (key in this.stateMaps) {\n                    if (this.stateMaps.hasOwnProperty(key)) {\n                        filter = _StateMap_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].setUp(key);\n                        this.addMap(this.stateMaps[key], key, filter);\n                        filter.recycle();\n                    }\n                }\n            }\n            \n            this.addMap(this.controlMap, 'default');\n\n            if (definition.joystick) {\n                this.joystick = _Data_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp(\n                    \"directions\",  definition.joystick.directions  || 4, // 4 = n,e,s,w; 8 = n,ne,e,se,s,sw,w,nw; 16 = n,nne,ene,e...\n                    \"handleEdge\",  definition.joystick.handleEdge  || false,\n                    \"innerRadius\", definition.joystick.innerRadius || 0,\n                    \"outerRadius\", definition.joystick.outerRadius || Infinity\n                );\n            }\n        },\n        \n        events: {\n            /**\n             * On each `handle-controller` message, this component checks its list of actions and if any of their states are currently true or were true on the last call, that action message is triggered.\n             *\n             * @method 'handle-controller'\n             */\n            \"handle-controller\": function () {\n                var actions = this.actions,\n                    keys = actions.keys,\n                    i = keys.length,\n                    action = '',\n                    resolution = _utils_array_js__WEBPACK_IMPORTED_MODULE_4__[\"arrayCache\"].setUp(),\n                    state = this.owner.state;\n                \n                while (i--) {\n                    action = actions.get(keys[i]);\n                    if (action.update(state)) {\n                        resolution.push(action);\n                    }\n                }\n                \n                i = resolution.length;\n                while (i--) {\n                    resolution[i].resolve();\n                }\n                \n                _utils_array_js__WEBPACK_IMPORTED_MODULE_4__[\"arrayCache\"].recycle(resolution);\n            },\n            \n            /**\n             * This message triggers a new message on the entity that includes what button on the mouse was pressed: \"mouse:left-button:down\", \"mouse:middle-button:down\", or \"mouse:right-button:down\".\n             *\n             * @method 'pointerdown'\n             * @param value.event {DOM Event object} This event object is passed along with the new message.\n             */\n            \"pointerdown\": function (value) {\n                if (value.pixiEvent.data.pointerType === 'mouse') {\n                    /**\n                     * This component triggers the state of mouse inputs on the entity if a render component of the entity accepts mouse input.\n                     *\n                     * @event 'mouse:mouse-left:down'\n                     * @param message {DOM Event object} The original mouse event object is passed along with the control message.\n                     */\n                    /**\n                     * This component triggers the state of mouse inputs on the entity if a render component of the entity accepts mouse input (for example [[Render-Animation]]).\n                     *\n                     * @event 'mouse:mouse-middle:down'\n                     * @param message {DOM Event object} The original mouse event object is passed along with the control message.\n                     */\n                    /**\n                     * This component triggers the state of mouse inputs on the entity if a render component of the entity accepts mouse input (for example [[Render-Animation]]).\n                     *\n                     * @event 'mouse:mouse-right:down'\n                     * @param message {DOM Event object} The original mouse event object is passed along with the control message.\n                     */\n                    this.owner.triggerEvent('mouse:' + mouseMap[value.event.button || 0] + ':down', value.event);\n                }\n\n                if (this.joystick) {\n                    /**\n                     * This event is triggered when there is an active touch in the joystick area.\n                     *\n                     * @event 'joystick:down'\n                     * @param message {DOM Event object} The original pointer event object is passed along with the control message.\n                     */\n                    this.owner.triggerEvent('joystick:down', value.event);\n                    this.handleJoy(value);\n                }\n            },\n            \n            /**\n             * This message triggers a new message on the entity that includes what button on the mouse was released: \"mouse:left-button:up\", \"mouse:middle-button:up\", or \"mouse:right-button:up\".\n             *\n             * @method 'pressup'\n             * @param value.event {DOM Event object} This event object is passed along with the new message.\n             */\n            \"pressup\": function (value) {\n                var owner = this.owner;\n\n                if (value.pixiEvent.data.pointerType === 'mouse') {\n                    /**\n                     * This component triggers the state of mouse inputs on the entity if a render component of the entity accepts mouse input (for example [[Render-Animation]]).\n                     *\n                     * @event 'mouse:mouse-left:up'\n                     * @param message {DOM Event object} The original mouse event object is passed along with the control message.\n                     */\n                    /**\n                     * This component triggers the state of mouse inputs on the entity if a render component of the entity accepts mouse input (for example [[Render-Animation]]).\n                     *\n                     * @event 'mouse:mouse-middle:up'\n                     * @param message {DOM Event object} The original mouse event object is passed along with the control message.\n                     */\n                    /**\n                     * This component triggers the state of mouse inputs on the entity if a render component of the entity accepts mouse input (for example [[Render-Animation]]).\n                     *\n                     * @event 'mouse:mouse-right:up'\n                     * @param message {DOM Event object} The original mouse event object is passed along with the control message.\n                     */\n                    owner.triggerEvent('mouse:' + mouseMap[value.event.button || 0] + ':up', value.event);\n                }\n\n                if (this.joystick) {\n                    /**\n                     * This event is triggered when there is an active touch is released from the joystick area.\n                     *\n                     * @event 'joystick:up'\n                     * @param message {DOM Event object} The original pointer event object is passed along with the control message.\n                     */\n                    owner.triggerEvent('joystick:up', value.event);\n                    /**\n                     * This event is triggered to stop movement once the joystick is released.\n                     *\n                     * @event 'stop'\n                     */\n                    owner.triggerEvent('stop');\n                }\n            },\n            \n            /**\n             * Updates joystick input if joystick is enabled.\n             *\n             * @method 'pressmove'\n             * @param value {platypus.Data} This event object is passed along with the joystick messages.\n             */\n            \"pressmove\": function (value) {\n                if (this.joystick) {\n                    this.handleJoy(value);\n                }\n            },\n            \n            /**\n             * This message will stop the controller from triggering messages until \"unpause-controls\" is triggered on the entity.\n             *\n             * @method 'pause-controls'\n             */\n            \"pause-controls\": function () {\n                this.paused = true;\n            },\n            \n            /**\n             * This message will allow the controller to trigger messages until \"pause-controls\" is triggered on the entity.\n             *\n             * @method 'unpause-controls'\n             */\n            \"unpause-controls\": function () {\n                this.paused = false;\n            }\n        },\n\n        methods: {\n            handleJoy: function (event) {\n                // The following translate mouse and touch events into messages that this controller can handle in a systematic way\n                var joystick = this.joystick,\n                    owner = this.owner,\n                    segment     = Math.PI / (joystick.directions / 2),\n                    dist        = distance(owner, event),\n                    orientation = 0,\n                    direction   = '',\n                    accuracy    = '';\n                \n                if ((dist > joystick.outerRadius) || (dist < joystick.innerRadius)) {\n                    return;\n                } else if (!this.paused) {\n                    orientation = angle(owner, event, dist);\n                    direction   = directions[joystick.directions][Math.floor(((orientation + segment / 2) % (Math.PI * 2)) / segment)];\n                    \n                    if (joystick.handleEdge) {\n                        segment  = Math.PI / joystick.directions;\n                        accuracy = directions[joystick.directions * 2][Math.floor(((orientation + segment / 2) % (Math.PI * 2)) / segment)];\n                        if (accuracy !== direction) {\n                            owner.triggerEvent(accuracy.replace(direction, '').replace('-', ''), event);  //There's probably a better way to perform this, but the current method is functional. - DDD\n                        }\n                    }\n\n                    owner.triggerEvent('stop');\n\n                    /**\n                     * If the soft joystick is enabled on this component, it will broadcast this directional message if the joystick is dragged due north.\n                     *\n                     * @event 'north'\n                     * @param message {DOM Event object} The original pointer event object is passed along with the control message.\n                     */\n                    /**\n                     * If the soft joystick is enabled on this component, it will broadcast this directional message if the joystick is dragged due north-northeast.\n                     *\n                     * @event 'north-northeast'\n                     * @param message {DOM Event object} The original pointer event object is passed along with the control message.\n                     */\n                    /**\n                     * If the soft joystick is enabled on this component, it will broadcast this directional message if the joystick is dragged due northeast.\n                     *\n                     * @event 'northeast'\n                     * @param message {DOM Event object} The original pointer event object is passed along with the control message.\n                     */\n                    /**\n                     * If the soft joystick is enabled on this component, it will broadcast this directional message if the joystick is dragged due east-northeast.\n                     *\n                     * @event 'east-northeast'\n                     * @param message {DOM Event object} The original pointer event object is passed along with the control message.\n                     */\n                    /**\n                     * If the soft joystick is enabled on this component, it will broadcast this directional message if the joystick is dragged due east.\n                     *\n                     * @event 'east'\n                     * @param message {DOM Event object} The original pointer event object is passed along with the control message.\n                     */\n                    /**\n                     * If the soft joystick is enabled on this component, it will broadcast this directional message if the joystick is dragged due east-southeast.\n                     *\n                     * @event 'east-southeast'\n                     * @param message {DOM Event object} The original pointer event object is passed along with the control message.\n                     */\n                    /**\n                     * If the soft joystick is enabled on this component, it will broadcast this directional message if the joystick is dragged due southeast.\n                     *\n                     * @event 'southeast'\n                     * @param message {DOM Event object} The original pointer event object is passed along with the control message.\n                     */\n                    /**\n                     * If the soft joystick is enabled on this component, it will broadcast this directional message if the joystick is dragged due south-southeast.\n                     *\n                     * @event 'south-southeast'\n                     * @param message {DOM Event object} The original pointer event object is passed along with the control message.\n                     */\n                    /**\n                     * If the soft joystick is enabled on this component, it will broadcast this directional message if the joystick is dragged due south.\n                     *\n                     * @event 'south'\n                     * @param message {DOM Event object} The original pointer event object is passed along with the control message.\n                     */\n                    /**\n                     * If the soft joystick is enabled on this component, it will broadcast this directional message if the joystick is dragged due south-southwest.\n                     *\n                     * @event 'south-southwest'\n                     * @param message {DOM Event object} The original pointer event object is passed along with the control message.\n                     */\n                    /**\n                     * If the soft joystick is enabled on this component, it will broadcast this directional message if the joystick is dragged due southwest.\n                     *\n                     * @event 'southwest'\n                     * @param message {DOM Event object} The original pointer event object is passed along with the control message.\n                     */\n                    /**\n                     * If the soft joystick is enabled on this component, it will broadcast this directional message if the joystick is dragged due west-southwest.\n                     *\n                     * @event 'west-southwest'\n                     * @param message {DOM Event object} The original pointer event object is passed along with the control message.\n                     */\n                    /**\n                     * If the soft joystick is enabled on this component, it will broadcast this directional message if the joystick is dragged due west.\n                     *\n                     * @event 'west'\n                     * @param message {DOM Event object} The original pointer event object is passed along with the control message.\n                     */\n                    /**\n                     * If the soft joystick is enabled on this component, it will broadcast this directional message if the joystick is dragged due west-northwest.\n                     *\n                     * @event 'west-northwest'\n                     * @param message {DOM Event object} The original pointer event object is passed along with the control message.\n                     */\n                    /**\n                     * If the soft joystick is enabled on this component, it will broadcast this directional message if the joystick is dragged due northwest.\n                     *\n                     * @event 'northwest'\n                     * @param message {DOM Event object} The original pointer event object is passed along with the control message.\n                     */\n                    /**\n                     * If the soft joystick is enabled on this component, it will broadcast this directional message if the joystick is dragged due north-northwest.\n                     *\n                     * @event 'north-northwest'\n                     * @param message {DOM Event object} The original pointer event object is passed along with the control message.\n                     */\n                    owner.triggerEvent(direction, event);\n\n                    /**\n                     * If the soft joystick is enabled on this component, this message will trigger to provide the current orientation of the joystick.\n                     *\n                     * @event 'joystick-orientation'\n                     * @param orientation (number) - A number in radians representing the orientation of the joystick.\n                     */\n                    owner.triggerEvent(\"joystick-orientation\", orientation);\n                }\n            },\n            \n            addController: (function () {\n                var up = function (index) {\n                        this.inputs[index] = false;\n                    },\n                    down = function (index) {\n                        this.inputs[index] = true;\n                    };\n                \n                return function (key, stateId, controller, states, controllerState) {\n                    var actions = this.actions,\n                        id = stateId + '-' + controller + '-' + (controllerState || 'all'),\n                        actionState = actions.get(id); // If there's already a state storage object for this action, reuse it: there are multiple keys mapped to the same action.\n                        \n                    // Otherwise create a new state storage object\n                    if (!actionState) {\n\n                        /**\n                         * Broadcasts active states using the JSON-defined message on each `handle-controller` message. Active states include `pressed` being true or `released` being true. If both of these states are false, the message is not broadcasted.\n                         *\n                         * @event '*'\n                         * @param message.pressed {Boolean} Whether the current input is active.\n                         * @param message.released {Boolean} Whether the current input was active last tick but is no longer active.\n                         * @param message.triggered {Boolean} Whether the current input is active but was not active last tick.\n                         * @param message.over {Boolean} Whether the mouse was over the entity when pressed, released, or triggered. This value is always false for non-mouse input messages.\n                         */\n                        if (controllerState) {\n                            actionState = actions.set(id, _ActionState_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp(controller, states, filteredTrigger.bind(this, controllerState)));\n                        } else {\n                            actionState = actions.set(id, _ActionState_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp(controller, states, trigger.bind(this)));\n                        }\n                    }\n                    \n                    // Set up listeners and input flag.\n                    this.addEventListener(key + ':up',   up.bind(actionState, actionState.inputs.length));\n                    this.addEventListener(key + ':down', down.bind(actionState, actionState.inputs.length));\n                    actionState.inputs.push(false);\n                };\n            }()),\n\n            addMap: function (map, id, states) {\n                var controller = null,\n                    i = 0,\n                    j = '',\n                    key = '';\n                \n                for (key in map) {\n                    if (map.hasOwnProperty(key)) {\n                        controller = map[key];\n                        if (typeof controller === 'string') {\n                            this.addController(key, id, controller, states);\n                        } else if (Array.isArray(controller)) {\n                            for (i = 0; i < controller.length; i++) {\n                                this.addController(key, id, controller[i], states);\n                            }\n                        } else {\n                            for (j in controller) {\n                                if (controller.hasOwnProperty(j)) {\n                                    if (typeof controller[j] === 'string') {\n                                        this.addController(key, id, controller[j], states, j);\n                                    } else {\n                                        for (i = 0; i < controller[j].length; i++) {\n                                            this.addController(key, id, controller[j][i], states, j);\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            },\n            \n            destroy: function () {\n                var actions = this.actions,\n                    keys = actions.keys,\n                    i = keys.length;\n                \n                while (i--) {\n                    actions.get(keys[i]).recycle();\n                }\n                actions.recycle();\n                if (this.joystick) {\n                    this.joystick.recycle();\n                }\n            }\n        }\n    });\n}());\n\n\n//# sourceURL=webpack://platypus/./src/components/EntityController.js?");

/***/ }),

/***/ "./src/components/HandlerCollision.js":
/*!********************************************!*\
  !*** ./src/components/HandlerCollision.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var _AABB_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../AABB.js */ \"./src/AABB.js\");\n/* harmony import */ var _CollisionData_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../CollisionData.js */ \"./src/CollisionData.js\");\n/* harmony import */ var _CollisionDataContainer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../CollisionDataContainer.js */ \"./src/CollisionDataContainer.js\");\n/* harmony import */ var _Data_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Data.js */ \"./src/Data.js\");\n/* harmony import */ var _DataMap_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../DataMap.js */ \"./src/DataMap.js\");\n/* harmony import */ var _Vector_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../Vector.js */ \"./src/Vector.js\");\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../factory.js */ \"./src/factory.js\");\n/**\n * This component checks for collisions between entities which typically have either a [CollisionTiles](platypus.components.CollisionTiles.html) component for tile maps or a [CollisionBasic](platypus.components.CollisionBasic.html) component for other entities. It uses `EntityContainer` component messages if triggered to add to its collision list and also listens for explicit add/remove messages (useful in the absence of an `EntityContainer` component).\n *\n * @namespace platypus.components\n * @class HandlerCollision\n * @uses platypus.Component\n */\n\n\n\n\n\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    /**\n     * When an entity collides with an entity of a listed collision-type, this message is triggered on the entity. * is the other entity's collision-type.\n     *\n     * @event 'hit-by-*'\n     * @param collision {Object}\n     * @param collision.entity {Entity} The entity with which the collision occurred.\n     * @param collision.target {Entity} The entity that's receiving the collision event.\n     * @param collision.type {String} The collision type of the other entity.\n     * @param collision.shape {CollisionShape} This is the shape of the other entity that caused the collision.\n     * @param collision.x {number} Returns -1, 0, or 1 indicating on which side of this entity the collision occurred: left, neither, or right respectively.\n     * @param collision.y {number} Returns -1, 0, or 1 indicating on which side of this entity the collision occurred: top, neither, or bottom respectively.\n     */\n    var BIT_16 = 0xffff,\n        combine = function (x, y) {\n            return (x << 16) | (y & BIT_16);\n        },\n        getBucketId = function (x, y, bits) {\n            return combine(x >> bits, y >> bits);\n        },\n        triggerMessage = {\n            entity: null,\n            target: null,\n            type: null,\n            x: 0,\n            y: 0,\n            hitType: null,\n            myType: null\n        },\n        groupSortBySize = function (a, b) {\n            return a.collisionGroup.getAllEntities() - b.collisionGroup.getAllEntities();\n        };\n    \n    return Object(_factory_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"])({\n        id: 'HandlerCollision',\n        \n        properties: {\n            /**\n             *\n             */\n            gridBits: 8\n        },\n        \n        initialize: function () {\n            this.againstGrid = _Data_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].setUp();\n            \n            this.solidEntitiesLive = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n            this.softEntitiesLive = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n            this.allEntitiesLive = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n            this.groupsLive = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n            this.nonColliders = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n            \n            this.terrain = null;\n            this.owner.previousX = this.owner.previousX || this.owner.x;\n            this.owner.previousY = this.owner.previousY || this.owner.y;\n            \n            this.relocationMessage = _Data_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].setUp(\n                \"position\", _Vector_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].setUp(),\n                \"relative\", false\n            );\n        },\n        \n        events: {\n            /**\n             * On receiving this message, the component checks the entity to determine whether it listens for collision messages. If so, the entity is added to the collision group.\n             *\n             * @method 'child-entity-added'\n             * @param entity {Entity} The entity to be added.\n             */\n            \"child-entity-added\": function (entity) {\n                if (!entity.collideOff) {\n                    this.addCollisionEntity(entity);\n                }\n            },\n            \n            /**\n             * On receiving this message, the component checks the entity to determine whether it listens for collision messages. If so, the entity is added to the collision group.\n             *\n             * @method 'add-collision-entity'\n             * @param entity {Entity} The entity to be added.\n             */\n            \"add-collision-entity\": function (entity) {\n                this.addCollisionEntity(entity);\n            },\n            \n            /**\n             * On receiving this message, the component looks for the entity in its collision group and removes it.\n             *\n             * @method 'child-entity-removed'\n             * @param message {platypus.Entity} The entity to be removed.\n             */\n            \"child-entity-removed\": function (entity) {\n                this.removeCollisionEntity(entity);\n            },\n            \n            /**\n             * On receiving this message, the component looks for the entity in its collision group and removes it.\n             *\n             * @method 'remove-collision-entity'\n             * @param message {platypus.Entity} The entity to be removed.\n             */\n            \"remove-collision-entity\": function (entity) {\n                this.removeCollisionEntity(entity);\n            },\n            \n            /**\n             * On receiving this message, the component looks for the entity in its collision group and updates it.\n             *\n             * @method 'child-entity-updated'\n             * @param message {platypus.Entity} The entity to be updated.\n             */\n            \"child-entity-updated\": function (entity) {\n                this.removeCollisionEntity(entity);\n                this.addCollisionEntity(entity);\n            },\n            \n            /**\n             * This message causes the component to go through the entities and check for collisions.\n             *\n             * @method 'check-collision-group'\n             * @param options {Object}\n             * @param [options.camera] {Object} Specifies a region in which to check for collisions. Expects the camera object to contain the following properties: top, left, width, height, and buffer.\n             */\n            \"check-collision-group\": function (resp) {\n                this.checkCamera(resp.camera, resp.entities);\n                this.checkGroupCollisions();\n                this.checkSolidCollisions();\n                this.resolveNonCollisions();\n                this.checkSoftCollisions(resp);\n            }\n        },\n        \n        methods: {\n            mapDown: function (aabb2) {\n                var aabb1 = _AABB_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp(),\n                    gb = this.gridBits;\n                \n                return aabb1.setBounds(aabb2.left >> gb, aabb2.top >> gb, aabb2.right >> gb, aabb2.bottom >> gb);\n            },\n            \n            getAgainstGrid: function (entity, sweep, types) {\n                var aabb = this.mapDown(sweep),\n                    data = _Data_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].setUp(),\n                    list = null,\n                    thisAgainstGrid = this.againstGrid,\n                    x = 0,\n                    y = 0;\n                \n                if (entity && sweep.equals(entity.againstAABB)) {\n                    return this.getEntityAgainstGrid(entity, types);\n                }\n\n                for (x = aabb.left; x <= aabb.right; x++) {\n                    for (y = aabb.top; y <= aabb.bottom; y++) {\n                        list = thisAgainstGrid[combine(x, y)];\n                        if (list) {\n                            this.mergeAGCell(list, data, types);\n                        }\n                    }\n                }\n                \n                aabb.recycle();\n                return data;\n            },\n            \n            getEntityAgainstGrid: function (entity, types) {\n                const\n                    ag = entity.againstGrid,\n                    data = _Data_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].setUp();\n                let i = ag.length;\n\n                while (i--) {\n                    this.mergeAGCell(ag[i], data, types);\n                }\n                \n                return data;\n            },\n\n            mergeAGCell: function (list, data, types) {\n                let i = types.length;\n\n                while (i--) {\n                    const\n                        type = types[i],\n                        arr = list.get(type);\n\n                    if (arr && arr.length) {\n                        const tList = data[type];\n                        if (!tList) {\n                            data[type] = Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"union\"])(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(), arr);\n                        } else {\n                            Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"union\"])(tList, arr);\n                        }\n                    }\n                }\n            },\n            \n            removeAgainst: function (entity) {\n                var ag = entity.againstGrid,\n                    types = entity.collisionTypes,\n                    arr = null,\n                    i = ag.length,\n                    j = 0,\n                    id = 0,\n                    len = types.length,\n                    list = null;\n                    \n                while (i--) {\n                    list = ag[i];\n                    j = len;\n                    while (j--) {\n                        arr = list.get(types[j]);\n                        if (arr) {\n                            id = arr.indexOf(entity);\n                            if (id >= 0) {\n                                Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSplice\"])(arr, id);\n                            }\n                        }\n                    }\n                }\n                ag.length = 0;\n            },\n            \n            updateAgainst: function (entity) {\n                var arr = null,\n                    i = 0,\n                    type = '',\n                    types = entity.collisionTypes,\n                    aabb = this.mapDown(entity.getAABB()),\n                    ag = entity.againstGrid,\n                    id = 0,\n                    list = null,\n                    thisAgainstGrid = this.againstGrid,\n                    x = 0,\n                    y = 0;\n                \n                if (!aabb.equals(entity.againstAABB)) {\n                    entity.againstAABB.set(aabb);\n                    this.removeAgainst(entity);\n\n                    for (x = aabb.left; x <= aabb.right; x++) {\n                        for (y = aabb.top; y <= aabb.bottom; y++) {\n                            id = combine(x, y);\n                            list = thisAgainstGrid[id];\n                            if (!list) {\n                                list = thisAgainstGrid[id] = _DataMap_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].setUp();\n                            }\n                            i = types.length;\n                            while (i--) {\n                                type = types[i];\n                                arr = list.get(type);\n                                if (!arr) {\n                                    arr = list.set(type, _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp());\n                                }\n                                arr.push(entity);\n                            }\n                            ag.push(list);\n                        }\n                    }\n                }\n                \n                aabb.recycle();\n            },\n            \n            addCollisionEntity: function (entity) {\n                if (entity.getTileShapes) { // Has a CollisionTiles component\n                    this.terrain = entity;\n                } else if (entity.collisionTypes && !entity.againstGrid) {\n                    entity.againstGrid = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n                    entity.againstAABB = _AABB_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp();\n                    this.updateAgainst(entity);\n                }\n            },\n\n            removeCollisionEntity: function (entity) {\n                if (entity.againstGrid) {\n                    this.removeAgainst(entity);\n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(entity.againstGrid);\n                    entity.againstGrid = null;\n                    entity.againstAABB.recycle();\n                    entity.againstAABB = null;\n                }\n            },\n            \n            checkCamera: function (camera, all) {\n                var i        = all.length,\n                    j        = 0,\n                    allLive  = this.allEntitiesLive,\n                    softs    = this.softEntitiesLive,\n                    solids   = this.solidEntitiesLive,\n                    nons     = this.nonColliders,\n                    groups   = this.groupsLive,\n                    entity        = null,\n                    types = null,\n                    collides = false;\n                \n                allLive.length = 0;\n                solids.length = 0;\n                softs.length = 0;\n                nons.length = 0;\n                groups.length = 0;\n\n                while (i--) {\n                    collides = false;\n                    entity = all[i];\n                    types = entity.collisionTypes;\n                    if (!entity.immobile && types && types.length) {\n                        allLive.push(entity);\n\n                        if (entity !== this.owner) {\n                            j = types.length;\n                            while (j--) {\n                                if (entity.solidCollisionMap.get(types[j]).length) {\n                                    solids.push(entity);\n                                    collides = true;\n                                    break;\n                                }\n                            }\n                        }\n                        j = types.length;\n                        while (j--) {\n                            if (entity.softCollisionMap.get(types[j]).length) {\n                                softs.push(entity);\n                                break;\n                            }\n                        }\n\n                        if (!collides) {\n                            nons.push(entity);\n                        }\n\n                        if (entity.collisionGroup) {\n                            groups.push(entity);\n                        }\n                    }\n                }\n                \n                groups.sort(groupSortBySize);\n            },\n            \n            resolveNonCollisions: function () {\n                var entity = null,\n                    msg    = this.relocationMessage,\n                    nons   = this.nonColliders,\n                    i      = nons.length;\n                \n                msg.relative = false;\n                while (i--) {\n                    entity = nons[i];\n                    if ((entity.position.x !== entity.previousPosition.x) || (entity.position.y !== entity.previousPosition.y)) {\n                        msg.position.setVector(entity.position);\n\n                        /**\n                         * This message is triggered on an entity that has been repositioned due to a solid collision.\n                         *\n                         * @event 'relocate-entity'\n                         * @param object {Object}\n                         * @param object.position {Vector} The relocated position of the entity.\n                         */\n                        entity.triggerEvent('relocate-entity', msg);\n                        this.updateAgainst(entity);\n                    }\n                }\n            },\n            \n            checkGroupCollisions: (function () {\n                var triggerCollisionMessages = function (entity, otherEntity, thisType, thatType, x, y, hitType, vector) {\n                    var msg = triggerMessage;\n                    \n                    msg.entity    = otherEntity;\n                    msg.target    = entity;\n                    msg.myType    = thisType;\n                    msg.type      = thatType;\n                    msg.x         = x;\n                    msg.y         = y;\n                    msg.direction = vector;\n                    msg.hitType   = hitType;\n                    entity.triggerEvent('hit-by-' + thatType, msg);\n                    \n                    if (otherEntity) {\n                        msg.entity    = entity;\n                        msg.target    = otherEntity;\n                        msg.type      = thisType;\n                        msg.myType    = thatType;\n                        msg.x         = -x;\n                        msg.y         = -y;\n                        msg.direction = vector.getInverse();\n                        msg.hitType   = hitType;\n                        otherEntity.triggerEvent('hit-by-' + thisType, msg);\n                        \n                        msg.direction.recycle();\n                    }\n                };\n\n                return function () {\n                    var i           = 0,\n                        entities    = this.groupsLive,\n                        x           = entities.length,\n                        entity      = null,\n                        list        = null,\n                        messageData = null,\n                        entityCDC   = null;\n                    \n                    while (x--) {\n                        entity = entities[x];\n                        if (entity.collisionGroup.getSize() > 1) {\n                            entityCDC = this.checkSolidEntityCollision(entity, entity.collisionGroup);\n                            \n                            list = entityCDC.xData;\n                            i = list.length;\n                            while (i--) {\n                                messageData = list[i];\n                                triggerCollisionMessages(messageData.thisShape.owner, messageData.thatShape.owner, messageData.thisShape.collisionType, messageData.thatShape.collisionType, messageData.direction, 0, 'solid', messageData.vector);\n                            }\n                            \n                            list = entityCDC.yData;\n                            i = list.length;\n                            while (i--) {\n                                messageData = list[i];\n                                triggerCollisionMessages(messageData.thisShape.owner, messageData.thatShape.owner, messageData.thisShape.collisionType, messageData.thatShape.collisionType, 0, messageData.direction, 'solid', messageData.vector);\n                            }\n                            \n                            entityCDC.recycle();\n                        }\n                    }\n                };\n            }()),\n            \n            checkSolidCollisions: (function () {\n                var triggerCollisionMessages = function (entity, otherEntity, thisType, thatType, x, y, hitType, vector) {\n                    var msg = triggerMessage;\n                    \n                    msg.entity    = otherEntity;\n                    msg.target    = entity;\n                    msg.myType    = thisType;\n                    msg.type      = thatType;\n                    msg.x         = x;\n                    msg.y         = y;\n                    msg.direction = vector;\n                    msg.hitType   = hitType;\n                    entity.triggerEvent('hit-by-' + thatType, msg);\n                    \n                    if (otherEntity) {\n                        msg.entity    = entity;\n                        msg.target    = otherEntity;\n                        msg.type      = thisType;\n                        msg.myType    = thatType;\n                        msg.x         = -x;\n                        msg.y         = -y;\n                        msg.direction = vector.getInverse();\n                        msg.hitType   = hitType;\n                        otherEntity.triggerEvent('hit-by-' + thisType, msg);\n                        \n                        msg.direction.recycle();\n                    }\n                };\n\n                return function () {\n                    var i           = 0,\n                        entities    = this.solidEntitiesLive,\n                        x           = entities.length,\n                        entity      = null,\n                        list        = null,\n                        messageData = null,\n                        entityCDC   = null,\n                        trigger = triggerCollisionMessages;\n                    \n                    while (x--) {\n                        entity = entities[x];\n                        entityCDC = this.checkSolidEntityCollision(entity, entity);\n                        \n                        list = entityCDC.xData;\n                        i = list.length;\n                        while (i--) {\n                            messageData = list[i];\n                            trigger(messageData.thisShape.owner, messageData.thatShape.owner, messageData.thisShape.collisionType, messageData.thatShape.collisionType, messageData.direction, 0, 'solid', messageData.vector);\n                        }\n                        \n                        list = entityCDC.yData;\n                        i = list.length;\n                        while (i--) {\n                            messageData = list[i];\n                            trigger(messageData.thisShape.owner, messageData.thatShape.owner, messageData.thisShape.collisionType, messageData.thatShape.collisionType, 0, messageData.direction, 'solid', messageData.vector);\n                        }\n                        \n                        entityCDC.recycle();\n                    }\n                };\n            }()),\n            \n            checkSolidEntityCollision: function (ent, entityOrGroup) {\n                var collisionDataCollection = _CollisionDataContainer_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].setUp(),\n                    step              = 0,\n                    finalMovementInfo = null,\n                    aabb              = null,\n                    pX                = ent.previousX,\n                    pY                = ent.previousY,\n                    dX                = ent.x - pX,\n                    dY                = ent.y - pY,\n                    sW                = Infinity,\n                    sH                = Infinity,\n                    collisionTypes    = entityOrGroup.getCollisionTypes(),\n                    i                 = 0,\n                    ignoredEntities   = false,\n                    min               = null;\n                \n                if (entityOrGroup.getSolidEntities) {\n                    ignoredEntities = entityOrGroup.getSolidEntities();\n                }\n                \n                finalMovementInfo = _Vector_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].setUp(ent.position);\n\n                if (dX || dY || ent.collisionDirty) {\n                    \n                    if (ent.bullet) {\n                        min = Math.min;\n                        \n                        i = collisionTypes.length;\n                        while (i--) {\n                            aabb = entityOrGroup.getAABB(collisionTypes[i]);\n                            sW = min(sW, aabb.width);\n                            sH = min(sH, aabb.height);\n                        }\n\n                        //Stepping to catch really fast entities - this is not perfect, but should prevent the majority of fallthrough cases.\n                        step = Math.ceil(Math.max(Math.abs(dX) / sW, Math.abs(dY) / sH));\n                        step = min(step, 100); //Prevent memory overflow if things move exponentially far.\n                        dX   = dX / step;\n                        dY   = dY / step;\n\n                        while (step--) {\n                            entityOrGroup.prepareCollision(ent.previousX + dX, ent.previousY + dY);\n\n                            finalMovementInfo = this.processCollisionStep(ent, entityOrGroup, ignoredEntities, collisionDataCollection, finalMovementInfo.setVector(ent.position), dX, dY, collisionTypes);\n                            \n                            if ((finalMovementInfo.x === ent.previousX) && (finalMovementInfo.y === ent.previousY)) {\n                                entityOrGroup.relocateEntity(finalMovementInfo, collisionDataCollection);\n                                //No more movement so we bail!\n                                break;\n                            } else {\n                                entityOrGroup.relocateEntity(finalMovementInfo, collisionDataCollection);\n                            }\n                        }\n                    } else {\n                        entityOrGroup.prepareCollision(ent.previousX + dX, ent.previousY + dY);\n                        finalMovementInfo = this.processCollisionStep(ent, entityOrGroup, ignoredEntities, collisionDataCollection, finalMovementInfo, dX, dY, collisionTypes);\n                        entityOrGroup.relocateEntity(finalMovementInfo, collisionDataCollection);\n                    }\n\n                    if ((finalMovementInfo.x !== pX) || (finalMovementInfo.y !== pY)) {\n                        this.updateAgainst(ent);\n                    }\n                }\n                \n                finalMovementInfo.recycle();\n                \n                return collisionDataCollection;\n            },\n            \n            processCollisionStep: (function () {\n                var sweeper       = _AABB_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp(),\n                    includeEntity = function (thisEntity, aabb, otherEntity, otherAABB, ignoredEntities, sweepAABB) {\n                        var i = 0;\n                        \n                        //Chop out all the special case entities we don't want to check against.\n                        if (otherEntity === thisEntity) {\n                            return false;\n                        } else if (otherEntity.jumpThrough && (aabb.bottom > otherAABB.top)) {\n                            return false;\n                        } else if (thisEntity.jumpThrough  && (otherAABB.bottom > aabb.top)) { // This will allow platforms to hit something solid sideways if it runs into them from the side even though originally they were above the top. - DDD\n                            return false;\n                        } else if (ignoredEntities) {\n                            i = ignoredEntities.length;\n                            while (i--) {\n                                if (otherEntity === ignoredEntities[i]) {\n                                    return false;\n                                }\n                            }\n                        }\n                        \n                        return sweepAABB.collides(otherAABB);\n                    };\n\n                return function (ent, entityOrGroup, ignoredEntities, collisionDataCollection, finalMovementInfo, entityDeltaX, entityDeltaY, collisionTypes) {\n                    var i = collisionTypes.length,\n                        j = 0,\n                        k = 0,\n                        l = 0,\n                        isIncluded = includeEntity,\n                        potentialCollision       = false,\n                        potentialCollidingShapes = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(),\n                        pcsGroup                 = null,\n                        previousAABB             = null,\n                        currentAABB              = null,\n                        collisionType            = null,\n                        otherEntity              = null,\n                        otherCollisionType       = '',\n                        otherAABB                = null,\n                        otherShapes              = null,\n                        otherEntities            = null,\n                        terrain                  = this.terrain,\n                        againstGrid          = null,\n                        solidCollisionMap        = entityOrGroup.getSolidCollisions(),\n                        collisionSubTypes        = null,\n                        sweepAABB                = sweeper;\n                    \n//                    if (!entityOrGroup.jumpThrough || (entityDeltaY >= 0)) { //TODO: Need to extend jumpthrough to handle different directions and forward motion - DDD\n    \n                    while (i--) {\n                        //Sweep the full movement of each collision type\n                        potentialCollidingShapes[i] = pcsGroup = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n                        collisionType = collisionTypes[i];\n                        previousAABB = entityOrGroup.getPreviousAABB(collisionType);\n                        currentAABB = entityOrGroup.getAABB(collisionType);\n\n                        sweepAABB.set(currentAABB);\n                        sweepAABB.include(previousAABB);\n                        \n                        collisionSubTypes = solidCollisionMap.get(collisionType);\n                        againstGrid = this.getAgainstGrid(ent, sweepAABB, collisionSubTypes);\n                        j = collisionSubTypes.length;\n                        while (j--) {\n                            otherCollisionType = collisionSubTypes[j];\n                            otherEntities = againstGrid[otherCollisionType];\n\n                            if (otherEntities) {\n                                k = otherEntities.length;\n                                while (k--) {\n                                    otherEntity = otherEntities[k];\n                                    otherAABB = otherEntity.getAABB(otherCollisionType);\n\n                                    //Do our sweep check against the AABB of the other object and add potentially colliding shapes to our list.\n                                    if (isIncluded(ent, previousAABB, otherEntity, otherAABB, ignoredEntities, sweepAABB)) {\n                                        otherShapes = otherEntity.getShapes(otherCollisionType);\n                                        \n                                        l = otherShapes.length;\n                                        while (l--) {\n                                            //Push the shapes on the end!\n                                            pcsGroup.push(otherShapes[l]);\n                                        }\n                                        potentialCollision = true;\n                                    }\n                                }\n                                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(otherEntities);\n                            } else if (terrain) {\n                                //Do our sweep check against the tiles and add potentially colliding shapes to our list.\n                                otherShapes = terrain.getTileShapes(sweepAABB, previousAABB, otherCollisionType);\n                                k = otherShapes.length;\n                                while (k--) {\n                                    //Push the shapes on the end!\n                                    pcsGroup.push(otherShapes[k]);\n                                    potentialCollision = true;\n                                }\n                            }\n                        }\n                        againstGrid.recycle();\n                    }\n\n                    if (potentialCollision) {\n                        finalMovementInfo = this.resolveCollisionPosition(ent, entityOrGroup, finalMovementInfo, potentialCollidingShapes, collisionDataCollection, collisionTypes, entityDeltaX, entityDeltaY);\n                    }\n                    \n                    // Array recycling\n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(potentialCollidingShapes, 2);\n                    \n                    return finalMovementInfo;\n                };\n            }()),\n            \n            resolveCollisionPosition: function (ent, entityOrGroup, finalMovementInfo, potentialCollidingShapes, collisionDataCollection, collisionTypes, entityDeltaX, entityDeltaY) {\n                var j = 0,\n                    cd = null;\n                \n                if (entityDeltaX !== 0) {\n                    j = collisionTypes.length;\n                    while (j--) {\n                        //Move each collision type in X to find the min X movement\n                        cd = this.findMinAxisMovement(ent, entityOrGroup, collisionTypes[j], 'x', potentialCollidingShapes[j]);\n                        \n                        if (!cd.occurred || !collisionDataCollection.tryToAddX(cd)) {\n                            cd.recycle();\n                        }\n                    }\n                }\n                \n                cd = collisionDataCollection.xData[0];\n                if (cd) {\n                    finalMovementInfo.x = ent.previousX + cd.deltaMovement * cd.direction;\n                } else {\n                    finalMovementInfo.x = ent.x;\n                }\n                \n                // This moves the previous position of everything so that the check in Y can begin.\n                entityOrGroup.movePreviousX(finalMovementInfo.x);\n                \n                if (entityDeltaY !== 0) {\n                    j = collisionTypes.length;\n                    while (j--) {\n                        //Move each collision type in Y to find the min Y movement\n                        cd = this.findMinAxisMovement(ent, entityOrGroup, collisionTypes[j], 'y', potentialCollidingShapes[j]);\n                        \n                        if (!cd.occurred || !collisionDataCollection.tryToAddY(cd)) {\n                            cd.recycle();\n                        }\n                    }\n                }\n                \n                cd = collisionDataCollection.yData[0];\n                if (cd) {\n                    finalMovementInfo.y = ent.previousY + cd.deltaMovement * cd.direction;\n                } else {\n                    finalMovementInfo.y = ent.y;\n                }\n                \n                return finalMovementInfo;\n            },\n            \n            findMinAxisMovement: function (ent, entityOrGroup, collisionType, axis, potentialCollidingShapes) {\n                //Loop through my shapes of this type vs the colliding shapes and do precise collision returning the shortest movement in axis direction\n                var bestCD     = _CollisionData_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(),\n                    shapes     = entityOrGroup.getShapes(collisionType),\n                    prevShapes = entityOrGroup.getPrevShapes(collisionType),\n                    cd         = null,\n                    i          = shapes.length;\n                \n                while (i--) {\n                    cd = this.findMinShapeMovementCollision(prevShapes[i], shapes[i], axis, potentialCollidingShapes);\n                    \n                    if (cd.occurred && (!bestCD.occurred //if a collision occurred and we haven't already had a collision.\n                        || (cd.deltaMovement < bestCD.deltaMovement))) { //if a collision occurred and the diff is smaller than our best diff.\n                        bestCD.recycle();\n                        bestCD = cd;\n                    } else {\n                        cd.recycle();\n                    }\n                }\n                \n                return bestCD;\n            },\n            \n            /**\n             * Find the earliest point at which this shape collides with one of the potential colliding shapes along this axis.\n             * For example, cycles through shapes a, b, and c to find the earliest position:\n             *\n             *    O---->   [b]  [a]     [c]\n             *\n             *    Returns collision location for:\n             *\n             *            O[b]\n             *\n             */\n            findMinShapeMovementCollision: (function () {\n                var returnInfo = {\n                        position: 0,\n                        contactVector: _Vector_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].setUp()\n                    },\n                    getMovementDistance = function (currentDistance, minimumDistance) {\n                        var pow = Math.pow;\n                        \n                        return Math.sqrt(pow(minimumDistance, 2) - pow(currentDistance, 2));\n                    },\n                    getCorner = function (circlePos, rectanglePos, half) {\n                        var diff = circlePos - rectanglePos;\n                        \n                        return diff - (diff / Math.abs(diff)) * half;\n                    },\n                    getOffsetForCircleVsAABBX = function (circle, rect, moving, direction, v) {\n                        var newAxisPosition = 0,\n                            aabb = rect.aABB,\n                            hw = aabb.halfWidth,\n                            x = circle.x,\n                            y = circle.y;\n\n                        if (y >= aabb.top && y <= aabb.bottom) {\n                            return hw + circle.radius;\n                        } else {\n                            y = getCorner(y, rect.y, aabb.halfHeight); // reusing y.\n                            newAxisPosition = hw + getMovementDistance(y, circle.radius);\n                            if (moving === circle) {\n                                v.x = -getCorner(x - direction * newAxisPosition, rect.x, hw) / 2;\n                                y = -y;\n                            } else {\n                                v.x = getCorner(x, rect.x - direction * newAxisPosition, hw) / 2;\n                            }\n                            v.y = y;\n                            v.normalize();\n                            return newAxisPosition;\n                        }\n                    },\n                    getOffsetForCircleVsAABBY = function (circle, rect, moving, direction, v) {\n                        var newAxisPosition = 0,\n                            aabb = rect.aABB,\n                            hh = aabb.halfHeight,\n                            x = circle.x,\n                            y = circle.y;\n\n                        if (x >= aabb.left && x <= aabb.right) {\n                            return hh + circle.radius;\n                        } else {\n                            x = getCorner(x, rect.x, aabb.halfWidth); // reusing x.\n                            newAxisPosition = hh + getMovementDistance(x, circle.radius);\n                            if (moving === circle) {\n                                x = -x;\n                                v.y = -getCorner(y - direction * newAxisPosition, rect.y, hh) / 2;\n                            } else {\n                                v.y = getCorner(y, rect.y - direction * newAxisPosition, hh) / 2;\n                            }\n                            v.x = x;\n                            v.normalize();\n                            return newAxisPosition;\n                        }\n                    },\n                    findAxisCollisionPosition = { // Decision tree for quicker access, optimized for mobile devices.\n                        x: {\n                            rectangle: {\n                                rectangle: function (direction, thisShape, thatShape) {\n                                    var ri = returnInfo;\n\n                                    ri.position = thatShape.x - direction * (thatShape.aABB.halfWidth + thisShape.aABB.halfWidth);\n                                    ri.contactVector.setXYZ(direction, 0);\n\n                                    return ri;\n                                },\n                                circle: function (direction, thisShape, thatShape) {\n                                    var ri = returnInfo;\n\n                                    ri.position = thatShape.x - direction * getOffsetForCircleVsAABBX(thatShape, thisShape, thisShape, direction, ri.contactVector.setXYZ(direction, 0));\n\n                                    return ri;\n                                }\n                            },\n                            circle: {\n                                rectangle: function (direction, thisShape, thatShape) {\n                                    var ri = returnInfo;\n\n                                    ri.position = thatShape.x - direction * getOffsetForCircleVsAABBX(thisShape, thatShape, thisShape, direction, ri.contactVector.setXYZ(direction, 0));\n\n                                    return ri;\n                                },\n                                circle: function (direction, thisShape, thatShape) {\n                                    var y = thatShape.y - thisShape.y,\n                                        position = thatShape.x - direction * getMovementDistance(y, thisShape.radius + thatShape.radius),\n                                        ri = returnInfo;\n                                        \n                                    ri.contactVector.setXYZ(thatShape.x - position, y).normalize();\n                                    ri.position = position;\n\n                                    return ri;\n                                }\n                            }\n                        },\n                        y: {\n                            rectangle: {\n                                rectangle: function (direction, thisShape, thatShape) {\n                                    var ri = returnInfo;\n\n                                    ri.position = thatShape.y - direction * (thatShape.aABB.halfHeight + thisShape.aABB.halfHeight);\n                                    ri.contactVector.setXYZ(0, direction);\n                                    \n                                    return ri;\n                                },\n                                circle: function (direction, thisShape, thatShape) {\n                                    var ri = returnInfo;\n\n                                    ri.position = thatShape.y - direction * getOffsetForCircleVsAABBY(thatShape, thisShape, thisShape, direction, ri.contactVector.setXYZ(0, direction));\n\n                                    return ri;\n                                }\n                            },\n                            circle: {\n                                rectangle: function (direction, thisShape, thatShape) {\n                                    var ri = returnInfo;\n\n                                    ri.position = thatShape.y - direction * getOffsetForCircleVsAABBY(thisShape, thatShape, thisShape, direction, ri.contactVector.setXYZ(0, direction));\n\n                                    return ri;\n                                },\n                                circle: function (direction, thisShape, thatShape) {\n                                    var x = thatShape.x - thisShape.x,\n                                        position = thatShape.y - direction * getMovementDistance(x, thisShape.radius + thatShape.radius),\n                                        ri = returnInfo;\n                                        \n                                    ri.contactVector.setXYZ(x, thatShape.y - position).normalize();\n                                    ri.position = position;\n\n                                    return ri;\n                                }\n                            }\n                        }\n                    };\n                \n                return function (prevShape, currentShape, axis, potentialCollidingShapes) {\n                    var i = 0,\n                        initialPoint    = prevShape[axis],\n                        goalPoint       = currentShape[axis],\n                        translatedShape = prevShape,\n                        direction       = ((initialPoint < goalPoint) ? 1 : -1),\n                        position        = goalPoint,\n                        pcShape         = null,\n                        cd              = _CollisionData_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(),\n                        collisionInfo   = null,\n                        finalPosition   = goalPoint,\n                        findACP         = null;\n                    \n                    if (initialPoint !== goalPoint) {\n                        findACP = findAxisCollisionPosition[axis][translatedShape.type];\n                        \n                        if (axis === 'x') {\n                            translatedShape.moveX(goalPoint);\n                        } else if (axis === 'y') {\n                            translatedShape.moveY(goalPoint);\n                        }\n                        \n                        i = potentialCollidingShapes.length;\n                        while (i--) {\n                            pcShape = potentialCollidingShapes[i];\n                            position = goalPoint;\n                            if (translatedShape.collides(pcShape)) {\n                                collisionInfo = findACP[pcShape.type](direction, translatedShape, pcShape);\n                                position = collisionInfo.position;\n                                if (direction > 0) {\n                                    if (position < finalPosition) {\n                                        if (position < initialPoint) { // Reality check: I think this is necessary due to floating point inaccuracies. - DDD\n                                            position = initialPoint;\n                                        }\n                                        finalPosition = position;\n                                        cd.set(true, direction, finalPosition, Math.abs(finalPosition - initialPoint), pcShape.aABB, currentShape, pcShape, collisionInfo.contactVector, 0);\n                                    }\n                                } else if (position > finalPosition) {\n                                    if (position > initialPoint) { // Reality check: I think this is necessary due to floating point inaccuracies. - DDD\n                                        position = initialPoint;\n                                    }\n                                    finalPosition = position;\n                                    cd.set(true, direction, finalPosition, Math.abs(finalPosition - initialPoint), pcShape.aABB, currentShape, pcShape, collisionInfo.contactVector, 0);\n                                }\n                            }\n                        }\n                    }\n                    \n                    return cd;\n                };\n            }()),\n            \n            checkSoftCollisions: (function () {\n                var\n                    trigger = function (collision) {\n                        this.triggerEvent('hit-by-' + collision.type, collision);\n                    };\n                \n                return function () {\n                    var softs = this.softEntitiesLive,\n                        entity = null,\n                        i = softs.length,\n                        t = trigger;\n                        \n                    while (i--) {\n                        entity = softs[i];\n                        this.checkEntityForSoftCollisions(entity, t.bind(entity));\n                    }\n                };\n            }()),\n            \n            checkEntityForSoftCollisions: function (ent, callback) {\n                var againstGrid = null,\n                    otherEntity = null,\n                    message = triggerMessage,\n                    i   = ent.collisionTypes.length,\n                    j   = 0,\n                    k   = 0,\n                    l   = 0,\n                    m   = 0,\n                    collisionType = null,\n                    softCollisionMap = null,\n                    otherEntities  = null,\n                    otherCollisionType = null,\n                    shapes = null,\n                    otherShapes = null,\n                    collisionFound = false;\n\n                message.x = 0;\n                message.y = 0;\n\n                while (i--) {\n                    collisionType = ent.collisionTypes[i];\n                    softCollisionMap = ent.softCollisionMap.get(collisionType);\n                    againstGrid = this.getEntityAgainstGrid(ent, softCollisionMap);\n                    j = softCollisionMap.length;\n                    while (j--) {\n                        otherCollisionType = softCollisionMap[j];\n                        otherEntities = againstGrid[otherCollisionType];\n                        if (otherEntities) {\n                            k = otherEntities.length;\n                            while (k--) {\n                                otherEntity = otherEntities[k];\n                                if ((otherEntity !== ent) && (ent.getAABB(collisionType).collides(otherEntity.getAABB(otherCollisionType)))) {\n                                    collisionFound = false;\n                                    shapes = ent.getShapes(collisionType);\n                                    otherShapes = otherEntity.getShapes(otherCollisionType);\n                                    l = shapes.length;\n                                    while (l--) {\n                                        m = otherShapes.length;\n                                        while (m--) {\n                                            if (shapes[l].collides(otherShapes[m])) {\n                                                //TML - We're only reporting the first shape we hit even though there may be multiple that we could be hitting.\n                                                message.entity  = otherEntity;\n                                                message.target  = ent;\n                                                message.type    = otherCollisionType;\n                                                message.myType  = collisionType;\n                                                message.shape   = otherShapes[m];\n                                                message.hitType = 'soft';\n                                                \n                                                callback(message);\n                                                \n                                                collisionFound = true;\n                                                break;\n                                            }\n                                        }\n                                        if (collisionFound) {\n                                            break;\n                                        }\n                                    }\n                                }\n                            }\n                            _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(otherEntities);\n                        }\n                    }\n                    againstGrid.recycle();\n                }\n            },\n\n\n            checkShapeForCollisions: function (shape, softCollisionMap, callback) {\n                var againstGrid = null,\n                    otherEntity = null,\n                    message = triggerMessage,\n                    j   = 0,\n                    k   = 0,\n                    m   = 0,\n                    otherEntities  = null,\n                    otherCollisionType = null,\n                    otherShapes = null;\n\n                message.x = 0;\n                message.y = 0;\n\n                againstGrid = this.getAgainstGrid(null, shape.getAABB(), softCollisionMap);\n                j = softCollisionMap.length;\n                while (j--) {\n                    otherCollisionType = softCollisionMap[j];\n                    otherEntities = againstGrid[otherCollisionType];\n                    if (otherEntities) {\n                        k = otherEntities.length;\n                        while (k--) {\n                            otherEntity = otherEntities[k];\n                            if ((shape.getAABB().collides(otherEntity.getAABB(otherCollisionType)))) {\n                                otherShapes = otherEntity.getShapes(otherCollisionType);\n                                m = otherShapes.length;\n                                while (m--) {\n                                    if (shape.collides(otherShapes[m])) {\n                                        //TML - We're only reporting the first shape we hit even though there may be multiple that we could be hitting.\n                                        message.entity  = otherEntity;\n                                        message.target  = null;\n                                        message.type    = otherCollisionType;\n                                        message.myType  = '';\n                                        message.shape   = otherShapes[m];\n                                        message.hitType = 'soft';\n                                        \n                                        callback(message);\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n                        _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(otherEntities);\n                    }\n                }\n                againstGrid.recycle();\n            },\n\n            \n            checkPointForCollisions: function (x, y, collisions, callback) {\n                var gb = this.gridBits,\n                    againstGrid = this.againstGrid[getBucketId(x, y, gb)],\n                    otherEntity = null,\n                    message = triggerMessage,\n                    j   = 0,\n                    k   = 0,\n                    m   = 0,\n                    otherEntities  = null,\n                    otherCollisionType = null,\n                    otherShapes = null;\n\n                message.x = 0;\n                message.y = 0;\n\n                if (!againstGrid) {\n                    return;\n                }\n                \n                j = collisions.length;\n                while (j--) {\n                    otherCollisionType = collisions[j];\n                    otherEntities = againstGrid.get(otherCollisionType);\n                    if (otherEntities) {\n                        k = otherEntities.length;\n                        while (k--) {\n                            otherEntity = otherEntities[k];\n                            if (otherEntity.getAABB(otherCollisionType).containsPoint(x, y)) {\n                                otherShapes = otherEntity.getShapes(otherCollisionType);\n                                m = otherShapes.length;\n                                while (m--) {\n                                    if (otherShapes[m].containsPoint(x, y)) {\n                                        //TML - We're only reporting the first shape we hit even though there may be multiple that we could be hitting.\n                                        message.entity  = otherEntity;\n                                        message.target  = null;\n                                        message.type    = otherCollisionType;\n                                        message.myType  = '';\n                                        message.shape   = otherShapes[m];\n                                        message.hitType = 'soft';\n                                        \n                                        callback(message);\n                                        \n                                        break;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            },\n            \n            destroy: function () {\n                var ag = this.againstGrid,\n                    data = null,\n                    key = '',\n                    keys = null,\n                    i = 0;\n                \n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.groupsLive);\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.nonColliders);\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.allEntitiesLive);\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.softEntitiesLive);\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.solidEntitiesLive);\n                this.relocationMessage.position.recycle();\n                this.relocationMessage.recycle();\n                \n                for (key in ag) {\n                    if (ag.hasOwnProperty(key)) {\n                        data = ag[key];\n                        keys = data.keys;\n                        i = keys.length;\n                        while (i--) {\n                            _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(data.get(keys[i]));\n                        }\n                        data.recycle();\n                    }\n                }\n                ag.recycle();\n                this.againstGrid = null;\n            }\n        },\n        \n        publicMethods: {\n            /**\n             * This method returns an object containing world entities.\n             *\n             * @method getWorldEntities\n             * @return {Array} A list of all world collision entities.\n             */\n            getWorldEntities: function () {\n                return this.allEntitiesLive;\n            },\n            \n            /**\n             * This method returns an entity representing the collision map of the world.\n             *\n             * @method getWorldTerrain\n             * @return {Entity} - An entity describing the collision map of the world. This entity typically includes a `CollisionTiles` component.\n             */\n            getWorldTerrain: function () {\n                return this.terrain;\n            },\n            \n            /**\n             * This method returns a list of collision objects describing soft collisions between an entity and a list of other entities.\n             *\n             * @method getEntityCollisions\n             * @param entity {Entity} The entity to test against the world.\n             * @return collisions {Array} This is a list of collision objects describing the soft collisions.\n             */\n            getEntityCollisions: function (entity) {\n                var collisions = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n                \n                this.checkEntityForSoftCollisions(entity, function (collision) {\n                    collisions.push(_Data_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].setUp(collision));\n                });\n                \n                return collisions;\n            },\n            \n            /**\n             * This method returns a list of collision objects describing collisions between a shape and a list of other entities.\n             *\n             * @method getShapeCollisions\n             * @param shape {CollisionShape} The shape to check for collisions.\n             * @param collisionTypes {Array of strings} The collision types to check against.\n             * @return collisions {Array} This is a list of collision objects describing the soft collisions.\n             */\n            getShapeCollisions: function (shape, collisionTypes) {\n                var collisions = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n                \n                this.checkShapeForCollisions(shape, collisionTypes, function (collision) {\n                    collisions.push(_Data_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].setUp(collision));\n                });\n                \n                return collisions;\n            },\n\n            /**\n             * This method returns a list of collision objects describing collisions between a point and a list of other entities.\n             *\n             * @method getPointCollisions\n             * @param x {number} The x-axis value.\n             * @param y {number} The y-axis value.\n             * @param collisionTypes {Array of strings} The collision types to check against.\n             * @return collisions {Array} This is a list of collision objects describing the soft collisions.\n             */\n            getPointCollisions: function (x, y, collisionTypes) {\n                var collisions = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n                \n                this.checkPointForCollisions(x, y, collisionTypes, function (collision) {\n                    collisions.push(_Data_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].setUp(collision));\n                });\n                \n                return collisions;\n            }\n        }\n    });\n}());\n\n\n//# sourceURL=webpack://platypus/./src/components/HandlerCollision.js?");

/***/ }),

/***/ "./src/components/HandlerController.js":
/*!*********************************************!*\
  !*** ./src/components/HandlerController.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../factory.js */ \"./src/factory.js\");\n/**\n * This component handles capturing and relaying input information to the entities that care about it. It takes mouse, keyboard, and custom input messages. State messages are sent immediately to the entities when they are received, the 'HandlerController' message is sent to demarcate ticks.\n *\n * @namespace platypus.components\n * @class HandlerController\n * @uses platypus.Component\n */\n/* global platypus, window */\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    const\n        keyMap = { //Note: if this list is changed, be sure to update https://github.com/PBS-KIDS/Platypus/wiki/Handler-controller-key-list\n            kc0: 'unknown',\n            kc8: 'backspace',\n            kc9: 'tab',\n            kc12: 'numpad-5-shift',\n            kc13: 'enter',\n            kc16: 'shift',\n            kc17: 'ctrl',\n            kc18: 'alt',\n            kc19: 'pause',\n            kc20: 'caps-lock',\n            kc27: 'esc',\n            kc32: 'space',\n            kc33: 'page-up',\n            kc34: 'page-down',\n            kc35: 'end',\n            kc36: 'home',\n            kc37: 'left-arrow',\n            kc38: 'up-arrow',\n            kc39: 'right-arrow',\n            kc40: 'down-arrow',\n            kc42: 'numpad-multiply',\n            kc43: 'numpad-add',\n            kc44: 'print-screen',\n            kc45: 'insert',\n            kc46: 'delete',\n            kc47: 'numpad-division',\n            kc48: '0',\n            kc49: '1',\n            kc50: '2',\n            kc51: '3',\n            kc52: '4',\n            kc53: '5',\n            kc54: '6',\n            kc55: '7',\n            kc56: '8',\n            kc57: '9',\n            kc59: 'semicolon',\n            kc61: 'equals',\n            kc65: 'a',\n            kc66: 'b',\n            kc67: 'c',\n            kc68: 'd',\n            kc69: 'e',\n            kc70: 'f',\n            kc71: 'g',\n            kc72: 'h',\n            kc73: 'i',\n            kc74: 'j',\n            kc75: 'k',\n            kc76: 'l',\n            kc77: 'm',\n            kc78: 'n',\n            kc79: 'o',\n            kc80: 'p',\n            kc81: 'q',\n            kc82: 'r',\n            kc83: 's',\n            kc84: 't',\n            kc85: 'u',\n            kc86: 'v',\n            kc87: 'w',\n            kc88: 'x',\n            kc89: 'y',\n            kc90: 'z',\n            kc91: 'left-windows-start',\n            kc92: 'right-windows-start',\n            kc93: 'windows-menu',\n            kc96: 'back-quote',\n            kc106: 'numpad-multiply',\n            kc107: 'numpad-add',\n            kc109: 'numpad-minus',\n            kc110: 'numpad-period',\n            kc111: 'numpad-division',\n            kc112: 'f1',\n            kc113: 'f2',\n            kc114: 'f3',\n            kc115: 'f4',\n            kc116: 'f5',\n            kc117: 'f6',\n            kc118: 'f7',\n            kc119: 'f8',\n            kc120: 'f9',\n            kc121: 'f10',\n            kc122: 'f11',\n            kc123: 'f12',\n            kc144: 'num-lock',\n            kc145: 'scroll-lock',\n            kc186: 'semicolon',\n            kc187: 'equals',\n            kc188: 'comma',\n            kc189: 'hyphen',\n            kc190: 'period',\n            kc191: 'forward-slash',\n            kc192: 'back-quote',\n            kc219: 'open-bracket',\n            kc220: 'back-slash',\n            kc221: 'close-bracket',\n            kc222: 'quote'\n        };\n\n    return Object(_factory_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        \n        id: 'HandlerController',\n        \n        initialize: function () {\n            this.callbackKeyUp   = null;\n            this.callbackKeyDown = null;\n            \n            if (platypus.game.settings.debug) { // If this is a test build, leave in the browser key combinations so debug tools can be opened as expected.\n                this.callbackKeyDown = function (event) {\n                    this.keyDown(event);\n                }.bind(this);\n                this.callbackKeyUp = function (event) {\n                    this.keyUp(event);\n                }.bind(this);\n            } else { // Otherwise remove default browser behavior for key inputs so that they do not interfere with game-play.\n                this.callbackKeyDown = function (event) {\n                    this.keyDown(event);\n                    event.preventDefault(); // this may be too aggressive - if problems arise, we may need to limit this to certain key combos that get in the way of game-play. Example: (event.metaKey && event.keyCode == 37) causes an accidental cmd key press to send the browser back a page while playing and hitting the left arrow button.\n                }.bind(this);\n                this.callbackKeyUp = function (event) {\n                    this.keyUp(event);\n                    event.preventDefault(); // this may be too aggressive - if problems arise, we may need to limit this to certain key combos that get in the way of game-play. Example: (event.metaKey && event.keyCode == 37) causes an accidental cmd key press to send the browser back a page while playing and hitting the left arrow button.\n                }.bind(this);\n            }\n            \n            window.addEventListener('keydown', this.callbackKeyDown, true);\n            window.addEventListener('keyup',   this.callbackKeyUp,   true);\n        },\n        events: {\n            /**\n             * Sends a 'handle-controller' message to all the entities the component is handling. If an entity does not handle the message, it's removed it from the entity list.\n             *\n             * @method 'tick'\n             * @param tick {Object} An object containing tick data.\n             */\n            \"tick\": function (tick) {\n\n                /**\n                 * Sent to entities on each tick to handle whatever they need to regarding controls.\n                 *\n                 * @event 'handle-controller'\n                 * @param tick {Object} An object containing tick data.\n                 */\n                if (this.owner.triggerEventOnChildren) {\n                    this.owner.triggerEventOnChildren('handle-controller', tick);\n                }\n            }\n        },\n        methods: {\n            keyDown: function (event) {\n\n                /**\n                 *  Message sent to an entity when a key goes from up to down.\n                 *\n                 * @event 'key:[keyId]:down'\n                 * @param event {DOMEvent} The DOM event that triggered the keydown event.\n                 */\n                if (this.owner.triggerEventOnChildren) {\n                    this.owner.triggerEventOnChildren('key:' + (keyMap['kc' + event.keyCode] || ('key-code-' + event.keyCode)) + ':down', event);\n                }\n            },\n            keyUp: function (event) {\n\n                /**\n                 * Message sent to child entities when a key goes from down to up.\n                 *\n                 * @event 'key:[keyId]:up'\n                 * @param event {DOMEvent} The DOM event that triggered the keyup event.\n                 */\n                if (this.owner.triggerEventOnChildren) {\n                    this.owner.triggerEventOnChildren('key:' + (keyMap['kc' + event.keyCode] || ('key-code-' + event.keyCode)) + ':up', event);\n                }\n            },\n            destroy: function () {\n                window.removeEventListener('keydown', this.callbackKeyDown);\n                window.removeEventListener('keyup',   this.callbackKeyUp);\n            }\n        }\n    });\n}());\n\n\n//# sourceURL=webpack://platypus/./src/components/HandlerController.js?");

/***/ }),

/***/ "./src/components/HandlerLogic.js":
/*!****************************************!*\
  !*** ./src/components/HandlerLogic.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var _AABB_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../AABB.js */ \"./src/AABB.js\");\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../factory.js */ \"./src/factory.js\");\n/**\n * A component that handles updating logic components. Each tick it calls all the entities that accept 'handle-logic' messages. This component is usually used on an \"action-layer\".\n *\n * @namespace platypus.components\n * @class HandlerLogic\n * @uses platypus.Component\n **/\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    var addAll = function (all, active) {\n            var j = all.length;\n            \n            active.length = 0;\n            while (j--) {\n                active.push(all[j]);\n            }\n        },\n        withinBounds = function (child, camera) {\n            return child.alwaysOn || (child.aabb && camera.collides(child.getAABB())) || (typeof child.x === 'undefined') || camera.containsPoint(child.x, child.y);\n        },\n        checkCamera = function (all, active, camera) {\n            var j = all.length,\n                child = null;\n            \n            active.length = 0;\n            while (j--) {\n                child = all[j];\n                if (withinBounds(child, camera)) {\n                    active.push(child);\n                }\n            }\n        },\n        hasLogic = function (item/*, index, arr*/) {\n            return (item === 'handle-logic' || item === 'handle-post-collision-logic' || item === 'prepare-logic' || item === 'state-changed' || item === 'handle-movement');\n        };\n\n    return Object(_factory_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({\n        id: \"HandlerLogic\",\n        properties: {\n            /**\n             * Whether logic should always run on all entities or only run on entities within the visible camera area (plus the buffer amount specified by the `buffer` property).\n             *\n             * @property alwaysOn\n             * @type Boolean\n             * @default false\n             */\n            alwaysOn: false\n        },\n        publicProperties: {\n            /**\n             * The buffer area around the camera in which entity logic is active. This property is available on the Entity as `entity.buffer`.\n             *\n             * @property buffer\n             * @type number\n             * @default camera width / 10\n             */\n            buffer: -1,\n            \n            /**\n             * The length in milliseconds of a single logic step. If the framerate drops too low, logic is run for each step of this many milliseconds. This property is available on the Entity as `entity.stepLength`.\n             *\n             * @property stepLength\n             * @type number\n             * @default 5\n             */\n            stepLength: 5,\n            \n            /**\n             * The maximum number of steps to take for a given tick, to prevent lag overflow.\n             *\n             * @property maxStepsPerTick\n             * @type number\n             * @default 100\n             */\n            maxStepsPerTick: 100,\n            \n            /**\n             * Whether logic should occur at an alternate speed. This is useful for simulations where the game should speed up or slow down.\n             *\n             * @property timeMultiplier\n             * @type number\n             * @default 1\n             */\n            timeMultiplier: 1\n        },\n        initialize: function () {\n            this.entities = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n            this.activeEntities = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n            this.removals = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n            \n            this.inLogicLoop = false;\n\n            if (this.alwaysOn) {\n                this.updateList = addAll;\n                this.camera = null;\n            } else {\n                this.updateList = checkCamera;\n                this.camera = _AABB_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp();\n            }\n            \n            this.paused = 0;\n            this.leftoverTime = 0;\n            this.message = {\n                delta: this.stepLength,\n                tick: null,\n                camera: this.camera,\n                entities: this.activeEntities\n            };\n        },\n        \n        events: {\n            /**\n             * Called when an entity has been updated and should be considered for adding to or removing from the handler.\n             *\n             * @method 'child-entity-updated'\n             * @param entity {platypus.Entity} The entity that is being considered.\n             */\n            \"child-entity-updated\": function (entity) {\n                var j = this.entities.indexOf(entity),\n                    logical = entity.getMessageIds().some(hasLogic);\n\n                if (logical && (j < 0)) {\n                    this.entities.push(entity);\n                    \n                    // Add to the active entities list so that the collision loop is aware of and can handle the addition.\n                    if (this.inLogicLoop && (!this.camera || withinBounds(entity, this.camera))) {\n                        this.activeEntities.push(entity);\n                    }\n                } else if (!logical && (j >= 0)) {\n                    Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSplice\"])(this.entities, j);\n                    if (this.inLogicLoop) {\n                        this.removals.push(entity);\n                    }\n                }\n            },\n\n            /**\n             * Called when a new entity has been added and should be considered for addition to the handler. If the entity has a 'handle-logic' message id it's added to the list of entities.\n             *\n             * @method 'child-entity-added'\n             * @param entity {platypus.Entity} The entity that is being considered for addition to the handler.\n             */\n            \"child-entity-added\": function (entity) {\n                if (entity.getMessageIds().some(hasLogic)) {\n                    this.entities.push(entity);\n                    \n                    // Add to the active entities list so that the collision loop is aware of and can handle the addition.\n                    if (this.inLogicLoop && (!this.camera || withinBounds(entity, this.camera))) {\n                        this.activeEntities.push(entity);\n                    }\n                }\n            },\n\n            /**\n             * Called when an entity should be removed from the list of logically updated entities.\n             *\n             * @method 'child-entity-removed'\n             * @param entity {platypus.Entity} The entity to be removed from the handler.\n             */\n            \"child-entity-removed\": function (entity) {\n                var j = this.entities.indexOf(entity);\n                \n                if (j >= 0) {\n                    Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSplice\"])(this.entities, j);\n                    if (this.inLogicLoop) {\n                        this.removals.push(entity);\n                    }\n                }\n            },\n            \n            /**\n             * When this event is triggered, `handle-logic` messages cease to be triggered on each tick.\n             *\n             * @method 'pause-logic'\n             * @param [options] {Object}\n             * @param [options.time] {number} If set, this will pause the logic for this number of milliseconds. If not set, logic is paused until an `unpause-logic` message is triggered.\n             */\n            \"pause-logic\": function (resp) {\n                if (resp && resp.time) {\n                    this.paused = resp.time;\n                } else {\n                    this.paused = -1;\n                }\n                if (this.owner.triggerEventOnChildren) {\n                    /**\n                     * Notifies children entities that logic has been paused.\n                     *\n                     * @event 'logic-paused'\n                     */\n                    this.owner.triggerEventOnChildren('logic-paused');\n                }\n            },\n            \n            /**\n             * When this event is triggered, `handle-logic` messages begin firing each tick.\n             *\n             * @method 'unpause-logic'\n             */\n            \"unpause-logic\": function () {\n                this.paused = 0;\n                if (this.owner.triggerEventOnChildren) {\n                    /**\n                     * Notifies children entities that logic has been unpaused.\n                     *\n                     * @event 'logic-unpaused'\n                     */\n                    this.owner.triggerEventOnChildren('logic-unpaused');\n                }\n            },\n            \n            /**\n             * Changes the active logic area when the camera location changes.\n             *\n             * @method 'camera-update'\n             * @param camera {Object}\n             * @param camera.viewport {platypus.AABB} The AABB describing the camera viewport in world units.\n             */\n            \"camera-update\": function (camera) {\n                var buffer = this.buffer,\n                    cam = this.camera,\n                    vp = null;\n                \n                if (cam) {\n                    if (buffer === -1) {\n                        buffer = camera.viewport.width / 10; // sets a default buffer based on the size of the world units if the buffer was not explicitly set.\n                    }\n                    \n                    vp = camera.viewport;\n                    cam.setBounds(vp.left - buffer, vp.top - buffer, vp.right + buffer, vp.bottom + buffer);\n                }\n            },\n            \n            /**\n             * Sends a 'handle-logic' message to all the entities the component is handling. If an entity does not handle the message, it's removed it from the entity list.\n             *\n             * @method 'tick'\n             * @param tick {Object} Tick information that is passed on to children entities via \"handle-logic\" events.\n             * @param tick.delta {number} The time passed since the last tick.\n             */\n            \"tick\": function (resp) {\n                var i = 0,\n                    j = 0,\n                    cycles = 0,\n                    entity = null,\n                    msg = this.message,\n                    actives = this.activeEntities,\n                    removals = this.removals,\n                    stepLength = this.stepLength;\n                \n                this.leftoverTime += (resp.delta * this.timeMultiplier);\n                cycles = Math.floor(this.leftoverTime / stepLength) || 1;\n        \n                // This makes the frames smoother, but adds variance into the calculations\n        //        msg.delta = this.leftoverTime / cycles;\n        //        this.leftoverTime = 0;\n                \n                // This makes the frames more exact, but varying step numbers between ticks can cause movement to be jerky\n        //        msg.delta = Math.min(this.leftoverTime, this.stepLength);\n        //        this.leftoverTime = Math.max(this.leftoverTime - (cycles * this.stepLength), 0);\n        \n                // This makes the frames exact, but varying step numbers between ticks can cause movement to be jerky\n                msg.delta = stepLength;\n                this.leftoverTime = Math.max(this.leftoverTime - (cycles * stepLength), 0);\n        \n                msg.tick = resp;\n                \n                this.updateList(this.entities, actives, this.camera);\n                \n                //Prevents game lockdown when processing takes longer than time alotted.\n                cycles = Math.min(cycles, this.maxStepsPerTick);\n                \n                while (cycles--) {\n                    \n                    if (this.paused > 0) {\n                        this.paused -= stepLength;\n                        if (this.paused < 0) {\n                            this.paused = 0;\n                        }\n                    }\n                    \n                    if (!this.paused) {\n                        this.inLogicLoop = true;\n                        \n                        /**\n                         * This event is triggered on the top-level layer to signify a \"handle-logic\" event is about to be triggered on children. This is unique from the layer's \"tick\" event in that it occurs the same number of times as the \"handle-logic\" event and will not occur if HandlerLogic is paused.\n                         *\n                         * @event 'handle-logic'\n                         * @param tick.delta {Number} The time that has passed since the last tick.\n                         * @param tick.camera {null|platypus.AABB} The range of the logic camera area. This is typically larger than the visible camera. This value is `null` if `alwaysOn` is set to `true` on this component.\n                         * @param tick.entities {Array} This is a list of all the logically active entities.\n                         */\n                        this.owner.triggerEvent('handle-logic', msg);\n                    \n                        if (this.owner.triggerEventOnChildren) {\n                            this.owner.triggerEventOnChildren('handle-ai', msg);\n                        }\n\n                        i = actives.length;\n                        while (i--) {\n                            entity = actives[i];\n                            \n                            /**\n                             * This event is triggered on children entities to run anything that should occur before \"handle-logic\". For example, removing or adding components should happen here and not in \"handle-logic\".\n                             *\n                             * @event 'prepare-logic'\n                             * @param tick {Object}\n                             * @param tick.delta {Number} The time that has passed since the last tick.\n                             * @param tick.camera {null|platypus.AABB} The range of the logic camera area. This is typically larger than the visible camera. This value is `null` if `alwaysOn` is set to `true` on this component.\n                             * @param tick.entities {Array} This is a list of all the logically active entities.\n                             */\n                            entity.triggerEvent('prepare-logic', msg);\n\n                            /**\n                             * This event is triggered on children entities to run their logic.\n                             *\n                             * @event 'handle-logic'\n                             * @param tick {Object}\n                             * @param tick.delta {Number} The time that has passed since the last tick.\n                             * @param tick.camera {null|platypus.AABB} The range of the logic camera area. This is typically larger than the visible camera. This value is `null` if `alwaysOn` is set to `true` on this component.\n                             * @param tick.entities {Array} This is a list of all the logically active entities.\n                             */\n                            entity.triggerEvent('handle-logic', msg);\n\n                            /**\n                             * This event is triggered on children entities to move. This happens immediately after logic so entity logic can determine movement.\n                             *\n                             * @event 'handle-movement'\n                             * @param tick {Object}\n                             * @param tick.delta {Number} The time that has passed since the last tick.\n                             * @param tick.camera {null|platypus.AABB} The range of the logic camera area. This is typically larger than the visible camera. This value is `null` if `alwaysOn` is set to `true` on this component.\n                             * @param tick.entities {Array} This is a list of all the logically active entities.\n                             */\n                            entity.triggerEvent('handle-movement', msg);\n                        }\n                        this.inLogicLoop = false;\n                        \n                        // This handles removing active entities from the list before collision checking, state-changing, etc.\n                        if (removals.length) {\n                            i = removals.length;\n                            while (i--) {\n                                j = actives.indexOf(removals[i]);\n                                if (j >= 0) {\n                                    Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSplice\"])(actives, j);\n                                }\n                            }\n                            removals.length = 0;\n                        }\n                        \n                        i = actives.length;\n                        /**\n                         * This event is triggered on the entity (layer) to test collisions once logic has been completed.\n                         *\n                         * @event 'check-collision-group'\n                         * @param tick {Object}\n                         * @param tick.delta {Number} The time that has passed since the last tick.\n                         * @param tick.camera {null|platypus.AABB} The range of the logic camera area. This is typically larger than the visible camera. This value is `null` if `alwaysOn` is set to `true` on this component.\n                         * @param tick.entities {Array} This is a list of all the logically active entities.\n                         */\n                        if (this.owner.triggerEvent('check-collision-group', msg)) { // If a collision group is attached, make sure collision is processed on each logic tick.\n                            /**\n                             * This event is triggered on entities to run logic that may depend upon collision responses.\n                             *\n                             * @event 'handle-post-collision-logic'\n                             * @param tick {Object}\n                             * @param tick.delta {Number} The time that has passed since the last tick.\n                             * @param tick.camera {null|platypus.AABB} The range of the logic camera area. This is typically larger than the visible camera. This value is `null` if `alwaysOn` is set to `true` on this component.\n                             * @param tick.entities {Array} This is a list of all the logically active entities.\n                             */\n                                \n                            /**\n                             * Triggered on entities when the entity's state has been changed.\n                             *\n                             * @event 'state-changed'\n                             * @param state {Object} A list of key/value pairs representing the owner's state (this value equals `entity.state`).\n                             */\n                            while (i--) {\n                                entity = actives[i];\n                                entity.triggerEvent('handle-post-collision-logic', msg);\n                                if (entity.lastState.update(entity.state)) {\n                                    entity.triggerEvent('state-changed', entity.state);\n                                }\n                            }\n                        } else {\n                            while (i--) {\n                                entity = actives[i];\n                                if (entity.lastState.update(entity.state)) {\n                                    entity.triggerEvent('state-changed', entity.state);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        },\n        \n        methods: {\n            destroy: function () {\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.entities);\n                this.entities = null;\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.activeEntities);\n                this.activeEntities = null;\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.removals);\n                this.removals = null;\n            }\n        }\n    });\n}());\n\n\n//# sourceURL=webpack://platypus/./src/components/HandlerLogic.js?");

/***/ }),

/***/ "./src/components/HandlerRender.js":
/*!*****************************************!*\
  !*** ./src/components/HandlerRender.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pixi.js */ \"pixi.js\");\n/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(pixi_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Data_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Data.js */ \"./src/Data.js\");\n/* harmony import */ var _Interactive_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Interactive.js */ \"./src/components/Interactive.js\");\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../factory.js */ \"./src/factory.js\");\n/**\n * A component that handles updating the render components on entities that are rendering via PIXI. Calls 'handle-render on children entities every tick. Also initializes handlers for mouse events on the layer level.\n *\n * @namespace platypus.components\n * @class HandlerRender\n * @uses platypus.Component\n */\n/* global platypus */\n\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    return Object(_factory_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])({\n\n        id: \"HandlerRender\",\n\n        properties: {\n            /**\n             * Defines whether the entity will respond to touch and click events. Setting this value will create an Interactive component on this entity with these properties. For example:\n             *\n             *  \"interactive\": {\n             *      \"hover\": false,\n             *      \"hitArea\": {\n             *          \"x\": 10,\n             *          \"y\": 10,\n             *          \"width\": 40,\n             *          \"height\": 40\n             *      }\n             *  }\n             *\n             * @property interactive\n             * @type Boolean|Object\n             * @default false\n             */\n            interactive: false\n        },\n\n        publicProperties: {\n            /**\n             * This is the container holding all children's disply objects for this layer. It's an available property on the layer entity.\n             *\n             * @property worldContainer\n             * @type PIXI.Container\n             * @default null\n             */\n            worldContainer: null,\n        },\n\n        initialize: function () {\n            let definition = null;\n            \n            this.worldContainer = this.worldContainer || new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Container\"]();\n            this.worldContainer.name = '';\n\n            if (this.interactive) {\n                definition = _Data_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp(\n                    'container', this.worldContainer,\n                    'hitArea', this.interactive.hitArea,\n                    'hover', this.interactive.hover,\n                    'relativeToSelf', true\n                );\n                this.owner.addComponent(new _Interactive_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](this.owner, definition));\n                definition.recycle();\n            }\n\n            this.renderMessage = _Data_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp(\n                'delta', 0,\n                'container', this.worldContainer\n            );\n        },\n\n        events: {\n            /**\n             * Once the entity is loaded, this component triggers \"render-world\" to notify other components about the entities' display container.\n             *\n             * @method 'load'\n             */\n            \"load\": function () {\n                /**\n                 * Once the entity is loaded, this component triggers \"render-world\" to notify other components about the entities' display container.\n                 *\n                 * @event 'render-world'\n                 * @param data {Object}\n                 * @param data.world {PIXI.Container} Contains entities to be rendered.\n                 */\n                this.owner.triggerEvent('render-world', {\n                    world: this.worldContainer\n                });\n\n                /**\n                 * This event is triggered once HandlerRender is ready to handle interactivity.\n                 *\n                 * @event 'input-on'\n                 */\n                this.owner.triggerEvent('input-on');\n            },\n\n            /**\n             * Called when a new entity has been added to the parent and should be considered for addition to the handler. Entities are sent a reference the Container that we're rendering to, so they can add their display objects to it and the delta from the lastest tick.\n             *\n             * @method 'child-entity-added'\n             * @param entity {platypus.Entity} The entity added to the parent.\n             */\n            \"child-entity-added\": function (entity) {\n                if (entity.container) {\n                    this.setParentRenderContainer(entity, entity.renderParent);\n                }\n                \n                /**\n                 * Triggered on an entity added to the parent.\n                 *\n                 * @event 'handle-render-load'\n                 * @param data {Object}\n                 * @param data.delta {Number} The delta time for this tick.\n                 * @param data.container {PIXI.Container} The display Container the entities display objects should be added to.\n                 */\n                entity.triggerEvent('handle-render-load', this.renderMessage);\n            },\n\n            /**\n             * Pauses the children of this render Container. If a pause time is not provided. It remains paused until 'unpause-render' is called.\n             *\n             * @method 'pause-render'\n             * @param [data] {Object}\n             * @param data.time {Number} How long to pause.\n             */\n            \"pause-render\": function (timeData) {\n                if (timeData && timeData.time) {\n                    this.paused = timeData.time;\n                } else {\n                    this.paused = -1;\n                }\n                if (this.owner.triggerEventOnChildren) {\n                    /**\n                     * Notifies children entities that rendering updates have been paused.\n                     *\n                     * @event 'render-paused'\n                     */\n                    this.owner.triggerEventOnChildren('render-paused');\n                }\n            },\n\n            /**\n             * Unpauses the children of this render Container.\n             *\n             * @method 'unpause-render'\n             */\n            \"unpause-render\": function () {\n                this.paused = 0;\n                if (this.owner.triggerEventOnChildren) {\n                    /**\n                     * Notifies children entities that rendering updates have been unpaused.\n                     *\n                     * @event 'render-unpaused'\n                     */\n                    this.owner.triggerEventOnChildren('render-unpaused');\n                }\n            },\n\n            /**\n             * Sends a 'handle-render' message to all the children in the Container. The children in the Container are also paused/unpaused if needed and sorted according to their z value.\n             *\n             * @method 'tick'\n             * @param tick {Object} An object containing tick data.\n             */\n            \"tick\": function (tick) {\n                const message = this.renderMessage,\n                    worldContainer = this.worldContainer;\n\n                message.delta = tick.delta;\n\n                if (this.paused > 0) {\n                    this.paused -= tick.delta;\n                    if (this.paused <= 0) {\n                        this.paused = 0;\n                    }\n                }\n\n                if (!this.paused) {\n                    /**\n                     * Triggered every tick on owner and its children entities.\n                     *\n                     * @event 'handle-render'\n                     * @param data {Object}\n                     * @param data.delta {Number} The delta time for this tick.\n                     * @param data.container {PIXI.Container} The display Container the entities display objects should be added to.\n                     */\n                    this.owner.triggerEvent('handle-render', message);\n\n                    if (this.owner.triggerEventOnChildren) {\n                        this.owner.triggerEventOnChildren('handle-render', message);\n                    }\n                }\n\n                if (worldContainer.reorder) {\n                    worldContainer.reorder = false;\n                    worldContainer.children.sort((a, b) => a.z - b.z);\n                }\n            },\n            /**\n             * Sets the parent render container of an entity to that of the given entity or entity with the given id.\n             *\n             * @method 'set-parent-render-container'\n             * @param entity {Object} The entity to relocate.\n             * @param entityOrId {Object|String} The entity or id of the entity that will act as the parent container.\n             */\n            \"set-parent-render-container\": function (entity, entityOrId) {\n                this.setParentRenderContainer(entity, entityOrId);\n            }\n\n        },\n        methods: {\n            setParentRenderContainer: function (entity, entityOrId) {\n                let container = null;\n\n                entity.removeFromParentContainer();\n\n                if (!entityOrId) {\n                    container = this.worldContainer;\n\n                } else if (typeof entityOrId === \"string\") {\n\n                    const otherEntity = this.owner.getEntityById(entityOrId);\n                    if (otherEntity) {\n                        container = otherEntity.container;\n                    } else {\n                        //Didn't find group.\n                        platypus.debug.warn(\"Trying to add to non-existent entity, added to World container instead.\");\n                        container = this.worldContainer;\n                    }\n\n                } else {\n                    container = entityOrId.container;\n                }\n\n                entity.addToParentContainer(container);\n\n            },\n            destroy: function () {\n                this.worldContainer = null;\n                this.renderMessage.recycle();\n                this.renderMessage = null;\n            }\n        }\n    });\n}());\n\n\n//# sourceURL=webpack://platypus/./src/components/HandlerRender.js?");

/***/ }),

/***/ "./src/components/Interactive.js":
/*!***************************************!*\
  !*** ./src/components/Interactive.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pixi.js */ \"pixi.js\");\n/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(pixi_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _AABB_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../AABB.js */ \"./src/AABB.js\");\n/* harmony import */ var _Data_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Data.js */ \"./src/Data.js\");\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../factory.js */ \"./src/factory.js\");\n/**\n * This component accepts touches and clicks on the entity. It is typically automatically added by a render component that requires interactive functionality.\n *\n * @class Interactive\n * @uses platypus.Component\n */\n\n\n\n\n\nconst\n    getId = function (event) {\n        const\n            data = event.data,\n            originalEvent = data.originalEvent;\n\n        return originalEvent.type.substr(0, 5) + (data.identifier || (originalEvent.changedTouches && originalEvent.changedTouches[0] && originalEvent.changedTouches[0].identifier) || 0);\n    },\n    pointerInstances = {},\n    orphanPointers = [];\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Object(_factory_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])({\n    id: 'Interactive',\n\n    properties: {\n        /**\n         * Sets the container that represents the interactive area.\n         *\n         * @property container\n         * @type PIXI.Container\n         * @default null\n         */\n        \"container\": null,\n\n        /**\n         * Sets the hit area for interactive responses by describing the dimensions of a clickable rectangle:\n         *\n         *     \"hitArea\": {\n         *         \"x\": 10,\n         *         \"y\": 10,\n         *         \"width\": 40,\n         *         \"height\": 40\n         *     }\n         *\n         * Or a circle:\n         *\n         *     \"hitArea\": {\n         *         \"x\": 10,\n         *         \"y\": 10,\n         *         \"radius\": 40\n         *     }\n         *\n         * Or use an array of numbers to define a polygon: [x1, y1, x2, y2, ...]\n         *\n         *     \"hitArea\": [-10, -10, 30, -10, 30, 30, -5, 30]\n         *\n         * Defaults to the container if not specified.\n         *\n         * @property hitArea\n         * @type Object\n         * @default null\n         */\n        \"hitArea\": null,\n\n        /**\n         * Sets whether the entity should respond to mouse hovering.\n         *\n         * @property hover\n         * @type Boolean\n         * @default false\n         */\n        \"hover\": false,\n\n        /**\n         * Used when returning world coordinates. Typically coordinates are relative to the parent, but when this component is added to the layer level, coordinates must be relative to self.\n         *\n         * @property relativeToSelf\n         * @type String\n         * @default false\n         */\n        \"relativeToSelf\": false\n    },\n    \n    publicProperties: {\n        /**\n         * Determines whether hovering over the sprite should alter the cursor.\n         *\n         * @property buttonMode\n         * @type Boolean\n         * @default false\n         */\n        buttonMode: false\n    },\n    \n    initialize: function () {\n        this.pressed = false;\n        this.camera = _AABB_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp();\n        if (this.hitArea) {\n            this.container.hitArea = this.setHitArea(this.hitArea);\n        }\n    },\n\n    events: {\n        /**\n         * Listens for this event to determine whether this sprite is visible.\n         *\n         * @method 'camera-update'\n         * @param camera.viewport {platypus.AABB} Camera position and size.\n         */\n        \"camera-update\": function (camera) {\n            this.camera.set(camera.viewport);\n        },\n\n        /**\n         * Listens to this event to update whether the interactive element should be in button mode.\n         *\n         * @method 'handle-render'\n         */\n        \"handle-render\": function () {\n            if (this.buttonMode !== this.container.buttonMode) {\n                this.container.buttonMode = this.buttonMode;\n            }\n        },\n\n        /**\n         * This event dispatches a PIXI.Event on this component's PIXI.Sprite. Useful for rerouting mouse/keyboard events.\n         *\n         * @method 'dispatch-event'\n         * @param event {Object | PIXI.Event} The event to dispatch.\n         */\n        \"dispatch-event\": function (event) {\n            this.sprite.dispatchEvent(this.sprite, event.event, event.data);\n        },\n        \n        /**\n         * Adds input event listeners to the sprite, enabling input.\n         *\n         * @method 'input-on'\n         */\n        \"input-on\": function () {\n            if (!this.removeInputListeners) {\n                this.addInputs();\n            }\n        },\n        \n        /**\n         * Removes the input event listeners on the sprite, disabling input.\n         *\n         * @method 'input-off'\n         */\n        \"input-off\": function () {\n            if (this.removeInputListeners) {\n                this.removeInputListeners();\n            }\n        },\n\n        /**\n         * This component listens for its own \"pointerdown\" event to track pressed state to trigger \"pressmove\" and \"pressup\" events.\n         *\n         * @method 'pointerdown'\n         */\n        \"pointerdown\": function () {\n            this.pressed = true;\n        },\n\n        /**\n         * This component listens for its own \"pointermove\" event to trigger \"pressmove\" events.\n         *\n         * @method 'pointermove'\n         * @param {Object} event\n         */\n        \"pointermove\": function (event) {\n            if (this.pressed && ((pointerInstances[getId(event.pixiEvent)] === this))) {\n                /**\n                 * This event is triggered on press move (drag).\n                 *\n                 * @event 'pressmove'\n                 * @param event {DOMEvent} The original DOM pointer event.\n                 * @param pixiEvent {PIXI.interaction.InteractionEvent} The Pixi pointer event.\n                 * @param x {Number} The x coordinate in world units.\n                 * @param y {Number} The y coordinate in world units.\n                 * @param entity {platypus.Entity} The entity receiving this event.\n                 */\n                this.owner.triggerEvent('pressmove', event);\n            }\n        },\n\n        /**\n         * This component listens for its own \"pointerup\" event to track pressed state and trigger \"pressup\" events.\n         *\n         * @method 'pointerup'\n         * @param {Object} event\n         */\n        \"pointerup\": function (event) {\n            if (this.pressed) {\n                /**\n                 * This event is triggered on press up.\n                 *\n                 * @event 'pressup'\n                 * @param event {DOMEvent} The original DOM pointer event.\n                 * @param pixiEvent {PIXI.interaction.InteractionEvent} The Pixi pointer event.\n                 * @param x {Number} The x coordinate in world units.\n                 * @param y {Number} The y coordinate in world units.\n                 * @param entity {platypus.Entity} The entity receiving this event.\n                 */\n                this.owner.triggerEvent('pressup', event);\n                this.pressed = false;\n            }\n        },\n\n        /**\n         * This component listens for its own \"pointerupoutside\" event to track pressed state and trigger \"pressup\" events.\n         *\n         * @method 'pointerupoutside'\n         * @param {Object} event\n         */\n        \"pointerupoutside\": function (event) {\n            if (this.pressed) {\n                this.owner.triggerEvent('pressup', event);\n                this.pressed = false;\n            }\n        },\n\n        /**\n         * This component listens for its own \"pointercancel\" event to track pressed state and trigger \"pressup\" events.\n         *\n         * @method 'pointercancel'\n         * @param {Object} event\n         */\n        \"pointercancel\": function (event) {\n            if (this.pressed) {\n                this.owner.triggerEvent('pressup', event);\n                this.pressed = false;\n            }\n        },\n\n        /**\n         * Sets the hit area for interactive responses by describing the dimensions of a clickable rectangle:\n         *\n         *     \"hitArea\": {\n         *         \"x\": 10,\n         *         \"y\": 10,\n         *         \"width\": 40,\n         *         \"height\": 40\n         *     }\n         *\n         * Or a circle:\n         *\n         *     \"hitArea\": {\n         *         \"x\": 10,\n         *         \"y\": 10,\n         *         \"radius\": 40\n         *     }\n         *\n         * Or use an array of numbers to define a polygon: [x1, y1, x2, y2, ...]\n         *\n         *     \"hitArea\": [-10, -10, 30, -10, 30, 30, -5, 30]\n         *\n         * Defaults to the container if set to `null`.\n         *\n         * @method 'set-hit-area'\n         * @param {Object} shape\n         */\n        \"set-hit-area\": function (shape) {\n            this.setHitArea(shape);\n        }\n    },\n    \n    methods: {\n        addInputs: (function () {\n            var\n                trigger = function (eventName, event) {\n                    var camera = this.camera,\n                        container = this.container,\n                        msg = null,\n                        matrix = null,\n                        target = this.owner;\n                    \n                    if (\n                        !container || //TML - This is in case we do a scene change using an event and the container is destroyed.\n                        !event.data.originalEvent // This is a workaround for a bug in Pixi 3 where phantom hover events are triggered. - DDD 7/20/16\n                        ) {\n                        return;\n                    }\n\n                    matrix = this.relativeToSelf ? container.transform.worldTransform : container.parent.transform.worldTransform;\n                    msg = _Data_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(\n                        \"event\", event.data.originalEvent,\n                        \"pixiEvent\", event,\n                        \"x\", event.data.global.x / matrix.a + camera.left,\n                        \"y\", event.data.global.y / matrix.d + camera.top,\n                        \"entity\", target\n                    );\n\n                    target.trigger(eventName, msg);\n                    msg.recycle();\n                },\n                triggerPointerDown = function (event) {\n                    const id = getId(event);\n\n                    if (pointerInstances[id]) { // Hmm, this is a shared identifer - not supposed to happen. We'll save for later to make sure it gets its \"pointerup\" event.\n                        orphanPointers.push(pointerInstances[id]);\n                    }\n                    pointerInstances[id] = this;\n\n                    /**\n                     * This event is triggered on pointer down.\n                     *\n                     * @event 'pointerdown'\n                     * @param event {DOMEvent} The original DOM pointer event.\n                     * @param pixiEvent {PIXI.interaction.InteractionEvent} The Pixi pointer event.\n                     * @param x {Number} The x coordinate in world units.\n                     * @param y {Number} The y coordinate in world units.\n                     * @param entity {platypus.Entity} The entity receiving this event.\n                     */\n                    trigger.call(this, 'pointerdown', event);\n                    event.currentTarget.mouseTarget = true;\n                },\n                triggerPointerMove = function (event) {\n                    /**\n                     * This event is triggered on pointer move.\n                     *\n                     * @event 'pointermove'\n                     * @param event {DOMEvent} The original DOM pointer event.\n                     * @param pixiEvent {PIXI.interaction.InteractionEvent} The Pixi pointer event.\n                     * @param x {Number} The x coordinate in world units.\n                     * @param y {Number} The y coordinate in world units.\n                     * @param entity {platypus.Entity} The entity receiving this event.\n                     */\n                    trigger.call(this, 'pointermove', event);\n                    event.currentTarget.mouseTarget = true;\n                },\n                triggerPointerTap = function (event) {\n                    /**\n                     * This event is triggered on pointer tap.\n                     *\n                     * @event 'pointertap'\n                     * @param event {DOMEvent} The original DOM pointer event.\n                     * @param pixiEvent {PIXI.interaction.InteractionEvent} The Pixi pointer event.\n                     * @param x {Number} The x coordinate in world units.\n                     * @param y {Number} The y coordinate in world units.\n                     * @param entity {platypus.Entity} The entity receiving this event.\n                     */\n                    trigger.call(this, 'pointertap', event);\n                },\n                triggerPointerOut = function (event) {\n\n                    /**\n                     * This event is triggered on pointer out.\n                     *\n                     * @event 'pointerout'\n                     * @param event {DOMEvent} The original DOM pointer event.\n                     * @param pixiEvent {PIXI.interaction.InteractionEvent} The Pixi pointer event.\n                     * @param x {Number} The x coordinate in world units.\n                     * @param y {Number} The y coordinate in world units.\n                     * @param entity {platypus.Entity} The entity receiving this event.\n                     */\n                    trigger.call(this, 'pointerout', event);\n                },\n                triggerPointerOver = function (event) {\n                    /**\n                     * This event is triggered on pointer over.\n                     *\n                     * @event 'pointerover'\n                     * @param event {DOMEvent} The original DOM pointer event.\n                     * @param pixiEvent {PIXI.interaction.InteractionEvent} The Pixi pointer event.\n                     * @param x {Number} The x coordinate in world units.\n                     * @param y {Number} The y coordinate in world units.\n                     * @param entity {platypus.Entity} The entity receiving this event.\n                     */\n                    trigger.call(this, 'pointerover', event);\n                },\n                triggerPointerUp = function (event) {\n                    const\n                        id = getId(event);\n                    let target = null;\n\n                    if (pointerInstances[id] === this) {\n                        // eslint-disable-next-line consistent-this\n                        target = this;\n                        pointerInstances[id] = null;\n                    } else if (orphanPointers.length) {\n                        target = orphanPointers[orphanPointers.length - 1];\n                        orphanPointers.length -= 1;\n                    } else if (pointerInstances[id]) {\n                        target = pointerInstances[id];\n                    } else {\n                        return;\n                    }\n\n                    /**\n                     * This event is triggered on pointer up.\n                     *\n                     * @event 'pointerup'\n                     * @param event {DOMEvent} The original DOM pointer event.\n                     * @param pixiEvent {PIXI.interaction.InteractionEvent} The Pixi pointer event.\n                     * @param x {Number} The x coordinate in world units.\n                     * @param y {Number} The y coordinate in world units.\n                     * @param entity {platypus.Entity} The entity receiving this event.\n                     */\n                    trigger.call(target, 'pointerup', event);\n                    event.currentTarget.mouseTarget = false;\n                    \n                    if (event.currentTarget.removeDisplayObject) {\n                        event.currentTarget.removeDisplayObject();\n                    }\n                },\n                triggerPointerUpOutside = function (event) {\n                    const\n                        id = getId(event);\n                    let target = null;\n\n                    if (pointerInstances[id] === this) {\n                        // eslint-disable-next-line consistent-this\n                        target = this;\n                        pointerInstances[id] = null;\n                    } else if (orphanPointers.length) {\n                        target = orphanPointers[orphanPointers.length - 1];\n                        orphanPointers.length -= 1;\n                    } else if (pointerInstances[id]) {\n                        target = pointerInstances[id];\n                    } else {\n                        return;\n                    }\n\n                    /**\n                     * This event is triggered on pointer up outside.\n                     *\n                     * @event 'pointerupoutside'\n                     * @param event {DOMEvent} The original DOM pointer event.\n                     * @param pixiEvent {PIXI.interaction.InteractionEvent} The Pixi pointer event.\n                     * @param x {Number} The x coordinate in world units.\n                     * @param y {Number} The y coordinate in world units.\n                     * @param entity {platypus.Entity} The entity receiving this event.\n                     */\n                    trigger.call(target, 'pointerupoutside', event);\n                    event.currentTarget.mouseTarget = false;\n                    \n                    if (event.currentTarget.removeDisplayObject) {\n                        event.currentTarget.removeDisplayObject();\n                    }\n                },\n                triggerPointerCancel = function (event) {\n                    const\n                        id = getId(event);\n                    let target = null;\n\n                    if (pointerInstances[id] === this) {\n                        // eslint-disable-next-line consistent-this\n                        target = this;\n                        pointerInstances[id] = null;\n                    } else if (orphanPointers.length) {\n                        target = orphanPointers[orphanPointers.length - 1];\n                        orphanPointers.length -= 1;\n                    } else if (pointerInstances[id]) {\n                        target = pointerInstances[id];\n                    } else {\n                        return;\n                    }\n\n                    /**\n                     * This event is triggered on pointer cancel.\n                     *\n                     * @event 'pointercancel'\n                     * @param event {DOMEvent} The original DOM pointer event.\n                     * @param pixiEvent {PIXI.interaction.InteractionEvent} The Pixi pointer event.\n                     * @param x {Number} The x coordinate in world units.\n                     * @param y {Number} The y coordinate in world units.\n                     * @param entity {platypus.Entity} The entity receiving this event.\n                     */\n                    trigger.call(target, 'pointercancel', event);\n                    event.currentTarget.mouseTarget = false;\n                    \n                    if (event.currentTarget.removeDisplayObject) {\n                        event.currentTarget.removeDisplayObject();\n                    }\n                },\n                removeInputListeners = function (sprite, pointerdown, pointerup, pointerupoutside, pointercancel, pointermove, pointertap, pointerover, pointerout) {\n                    var key = '';\n\n                    for (key in pointerInstances) {\n                        if (pointerInstances.hasOwnProperty(key) && (pointerInstances[key] === this)) {\n                            pointerInstances[key] = null;\n                        }\n                    }\n\n                    sprite.removeListener('pointerdown', pointerdown);\n                    sprite.removeListener('pointerup', pointerup);\n                    sprite.removeListener('pointerupoutside', pointerupoutside);\n                    sprite.removeListener('pointercancel', pointercancel);\n                    sprite.removeListener('pointermove', pointermove);\n                    sprite.removeListener('pointertap', pointertap);\n\n                    if (this.hover) {\n                        sprite.removeListener('pointerover', pointerover);\n                        sprite.removeListener('pointerout',  pointerout);\n                    }\n                    sprite.interactive = false;\n                    this.removeInputListeners = null;\n                };\n\n            return function () {\n                var sprite    = this.container,\n                    pointerdown = null,\n                    pointerover = null,\n                    pointerout  = null,\n                    pointermove = null,\n                    pointerup = null,\n                    pointerupoutside = null,\n                    pointercancel = null,\n                    pointertap = null;\n                \n                // The following appends necessary information to displayed objects to allow them to receive touches and clicks\n                sprite.interactive = true;\n                \n                pointerdown = triggerPointerDown.bind(this);\n                pointermove = triggerPointerMove.bind(this);\n                pointerup = triggerPointerUp.bind(this);\n                pointerupoutside = triggerPointerUpOutside.bind(this);\n                pointercancel = triggerPointerCancel.bind(this);\n                pointertap = triggerPointerTap.bind(this);\n                \n                sprite.addListener('pointerdown', pointerdown);\n                sprite.addListener('pointerup', pointerup);\n                sprite.addListener('pointerupoutside', pointerupoutside);\n                sprite.addListener('pointercancel', pointercancel);\n                sprite.addListener('pointermove', pointermove);\n                sprite.addListener('pointertap', pointertap);\n\n                if (this.hover) {\n                    pointerover = triggerPointerOver.bind(this);\n                    pointerout  = triggerPointerOut.bind(this);\n\n                    sprite.addListener('pointerover', pointerover);\n                    sprite.addListener('pointerout', pointerout);\n                }\n\n                this.removeInputListeners = removeInputListeners.bind(this, sprite, pointerdown, pointerup, pointerupoutside, pointercancel, pointermove, pointertap, pointerover, pointerout);\n            };\n        }()),\n\n        setHitArea: (function () {\n            var savedHitAreas = {}; //So generated hitAreas are reused across identical entities.\n            \n            return function (shape) {\n                var ha  = null,\n                    sav = '';\n                \n                sav = JSON.stringify(shape);\n                \n                ha = savedHitAreas[sav];\n\n                if (!ha) {\n                    if (Array.isArray(shape)) {\n                        ha = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Polygon\"](shape);\n                    } else if (shape.radius) {\n                        ha = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Circle\"](shape.x || 0, shape.y || 0, shape.radius);\n                    } else {\n                        ha = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Rectangle\"](shape.x || 0, shape.y || 0, shape.width || this.owner.width || 0, shape.height || this.owner.height || 0);\n                    }\n                    \n                    savedHitAreas[sav] = ha;\n                }\n                \n                return ha;\n            };\n        }()),\n\n        toJSON: function () { // This component is added by another component, so it shouldn't be returned for reconstruction.\n            return null;\n        },\n\n        destroy: (function () {\n            var\n                removeAfterMouseUp = function () {\n                    this.container.parent.removeChild(this.container);\n                    this.container = null;\n                };\n\n            return function () {\n                if (this.removeInputListeners) {\n                    this.removeInputListeners();\n                }\n\n                this.camera.recycle();\n                \n                // This handles removal after the mouseup event to prevent weird input behaviors. If it's not currently a mouse target, we let the render component handle its removal from the parent container.\n                if (this.container.mouseTarget && this.container.parent) {\n                    this.container.visible = false;\n                    this.container.removeDisplayObject = removeAfterMouseUp.bind(this);\n                }\n            };\n        }())\n    }\n}));\n\n\n//# sourceURL=webpack://platypus/./src/components/Interactive.js?");

/***/ }),

/***/ "./src/components/LevelBuilder.js":
/*!****************************************!*\
  !*** ./src/components/LevelBuilder.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../factory.js */ \"./src/factory.js\");\n/* harmony import */ var pako__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! pako */ \"./node_modules/pako/index.js\");\n/* harmony import */ var pako__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(pako__WEBPACK_IMPORTED_MODULE_2__);\n/**\n * This component works in tandem with `TiledLoader` by taking several Tiled maps and combining them before `TiledLoader` processes them. Tiled maps must use the same tilesets for this to function correctly.\n *\n * Note: Set \"manuallyLoad\" to `true` in the `TiledLoader` component JSON definition so that it will wait for this component's \"load-level\" call.\n *\n * @namespace platypus.components\n * @class LevelBuilder\n * @uses platypus.Component\n */\n/* global atob, platypus */\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    const\n        maskXFlip = 0x80000000,\n        decodeBase64 = (function () {\n            var decodeString = function (str, index) {\n                    return (((str.charCodeAt(index)) + (str.charCodeAt(index + 1) << 8) + (str.charCodeAt(index + 2) << 16) + (str.charCodeAt(index + 3) << 24 )) >>> 0);\n                },\n                decodeArray = function (arr, index) {\n                    return ((arr[index] + (arr[index + 1] << 8) + (arr[index + 2] << 16) + (arr[index + 3] << 24 )) >>> 0);\n                };\n            \n            return function (data, compression) {\n                var index = 4,\n                    arr   = [],\n                    step1 = atob(data.replace(/\\\\/g, ''));\n                    \n                if (compression === 'zlib') {\n                    step1 = Object(pako__WEBPACK_IMPORTED_MODULE_2__[\"inflate\"])(step1);\n                    while (index <= step1.length) {\n                        arr.push(decodeArray(step1, index - 4));\n                        index += 4;\n                    }\n                } else {\n                    while (index <= step1.length) {\n                        arr.push(decodeString(step1, index - 4));\n                        index += 4;\n                    }\n                }\n                \n                return arr;\n            };\n        }()),\n        decodeLayer = function (layer) {\n            if (layer.encoding === 'base64') {\n                layer.data = decodeBase64(layer.data, layer.compression);\n                layer.encoding = 'csv'; // So we won't have to decode again.\n            }\n            return layer;\n        },\n        mergeData = function (levelData, levelMergeAxisLength, segmentData, segmentMergeAxisLength, nonMergeAxisLength, mergeAxis) {\n            var x        = 0,\n                y        = 0,\n                z        = 0,\n                combined = Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSlice\"])(levelData);\n\n            if (mergeAxis === 'horizontal') {\n                for (y = nonMergeAxisLength - 1; y >= 0; y--) {\n                    for (x = y * segmentMergeAxisLength, z = 0; x < (y + 1) * segmentMergeAxisLength; x++, z++) {\n                        combined.splice(((y + 1) * levelMergeAxisLength) + z, 0, segmentData[x]);\n                    }\n                }\n                return combined;\n            } else if (mergeAxis === 'vertical') {\n                return levelData.concat(segmentData);\n            }\n            \n            return null;\n        },\n        mergeObjects  = function (obj1s, obj2s, mergeAxisLength, mergeAxis) {\n            var i    = 0,\n                j    = '',\n                list = Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSlice\"])(obj1s),\n                obj  = null;\n\n            for (i = 0; i < obj2s.length; i++) {\n                obj = {};\n                for (j in obj2s[i]) {\n                    if (obj2s[i].hasOwnProperty(j)) {\n                        obj[j] = obj2s[i][j];\n                    }\n                }\n                if (mergeAxis === 'horizontal') {\n                    obj.x += mergeAxisLength;\n                } else if (mergeAxis === 'vertical') {\n                    obj.y += mergeAxisLength;\n                }\n                list.push(obj);\n            }\n            return list;\n        },\n        mergeSegment  = function (level, segment, mergeAxis) {\n            var i = 0,\n                j = '';\n\n            if (!level.tilewidth && !level.tileheight) {\n                //set level tile size data if it's not already set.\n                level.tilewidth  = segment.tilewidth;\n                level.tileheight = segment.tileheight;\n            } else if (level.tilewidth !== segment.tilewidth || level.tileheight !== segment.tileheight) {\n                platypus.debug.warn('Component LevelBuilder: Your map has segments with different tile sizes. All tile sizes must match. Segment: ' + segment);\n            }\n\n            if (mergeAxis === 'horizontal') {\n                if (level.height === 0) {\n                    level.height = segment.height;\n                } else if (level.height !== segment.height) {\n                    platypus.debug.warn('Component LevelBuilder: You are trying to merge segments with different heights. All segments need to have the same height. Level: ' + level + ' Segment: ' + segment);\n                }\n            } else if (mergeAxis === 'vertical') {\n                if (level.width === 0) {\n                    level.width = segment.width;\n                } else if (level.width !== segment.width) {\n                    platypus.debug.warn('Component LevelBuilder: You are trying to merge segments with different widths. All segments need to have the same width. Level: ' + level + ' Segment: ' + segment);\n                }\n            }\n\n            for (i = 0; i < segment.layers.length; i++) {\n                if (!level.layers[i]) {\n                    const layer = level.layers[i] = {};\n\n                    //if the level doesn't have a layer yet, we're creating it and then copying it from the segment.\n                    decodeLayer(segment.layers[i]);\n                    \n                    for (j in segment.layers[i]) {\n                        if (segment.layers[i].hasOwnProperty(j)) {\n                            layer[j] = segment.layers[i][j];\n                        }\n                    }\n\n                    // If we're adding objects, make sure that they're offset correctly.\n                    if (layer.objects) {\n                        if (mergeAxis === 'horizontal') {\n                            layer.objects = mergeObjects([], layer.objects, level.width * level.tilewidth, mergeAxis);\n                        } else if (mergeAxis === 'vertical') {\n                            layer.objects = mergeObjects([], layer.objects, level.height * level.tileheight, mergeAxis);\n                        }\n                    }\n                } else if (level.layers[i].type === segment.layers[i].type) {\n                    //if the level does have a layer, we're appending the new data to it.\n                    if (level.layers[i].data && segment.layers[i].data) {\n                        // Make sure we're not trying to merge compressed levels.\n                        decodeLayer(segment.layers[i]);\n                        \n                        if (mergeAxis === 'horizontal') {\n                            level.layers[i].data = mergeData(level.layers[i].data, level.width, segment.layers[i].data, segment.width, level.height, mergeAxis);\n                            level.layers[i].width += segment.width;\n                        } else if (mergeAxis === 'vertical') {\n                            level.layers[i].data = mergeData(level.layers[i].data, level.height, segment.layers[i].data, segment.height, level.width, mergeAxis);\n                            level.layers[i].height += segment.height;\n                        }\n                    } else if (level.layers[i].objects && segment.layers[i].objects) {\n                        if (mergeAxis === 'horizontal') {\n                            level.layers[i].objects = mergeObjects(level.layers[i].objects, segment.layers[i].objects, level.width * level.tilewidth, mergeAxis);\n                        } else if (mergeAxis === 'vertical') {\n                            level.layers[i].objects = mergeObjects(level.layers[i].objects, segment.layers[i].objects, level.height * level.tileheight, mergeAxis);\n                        }\n                    }\n                } else {\n                    platypus.debug.warn('Component LevelBuilder: The layers in your level segments do not match. Level: ' + level + ' Segment: ' + segment);\n                }\n            }\n\n            if (mergeAxis === 'horizontal') {\n                level.width += segment.width;\n            } else if (mergeAxis === 'vertical') {\n                level.height += segment.height;\n            }\n\n            //Go through all the STUFF in segment and copy it to the level if it's not already there.\n            for (j in segment) {\n                if (segment.hasOwnProperty(j) && !level[j]) {\n                    level[j] = segment[j];\n                }\n            }\n        },\n        mergeLevels = function (levelSegments) {\n            var i = 0,\n                j = 0,\n                levelDefinitions = platypus.game.settings.levels,\n                row = {\n                    height: 0,\n                    width: 0,\n                    layers: []\n                },\n                level = {\n                    height: 0,\n                    width: 0,\n                    layers: []\n                };\n\n            for (i = 0; i < levelSegments.length; i++) {\n                row = {\n                    height: 0,\n                    width: 0,\n                    layers: []\n                };\n                for (j = 0; j < levelSegments[i].length; j++) {\n                    //Merge horizontally\n                    if (typeof levelSegments[i][j] === 'string') {\n                        const\n                            levelDefinitionLabel = levelSegments[i][j],\n                            transformIndex = levelDefinitionLabel.indexOf(':');\n                        let levelDefinition = levelDefinitions[levelDefinitionLabel];\n                        \n                        // check for transform\n                        if (!levelDefinition && (transformIndex >= 0)) {\n                            const transform = levelDefinitionLabel.substring(transformIndex + 1);\n\n                            levelDefinition = levelDefinitions[levelDefinitionLabel.substring(0, transformIndex)];\n                            if (transform === 'mirror') {\n                                levelDefinition = levelDefinitions[levelDefinitionLabel] = mirrorSegment(levelDefinition);\n                            }\n                        }\n                        mergeSegment(row, levelDefinition, 'horizontal');\n                    } else {\n                        mergeSegment(row, levelSegments[i][j], 'horizontal');\n                    }\n                }\n                //Then merge vertically\n                mergeSegment(level, row, 'vertical');\n            }\n            return level;\n        },\n        mirrorSegment = function (segment) {\n            const\n                newSegment = {\n                    layers: []\n                },\n                width = segment.width * segment.tilewidth;\n\n            for (let i = 0; i < segment.layers.length; i++) {\n                const\n                    toLayer = newSegment.layers[i] = {},\n                    fromLayer = segment.layers[i];\n\n                decodeLayer(fromLayer);\n                \n                for (const key in fromLayer) {\n                    if (fromLayer.hasOwnProperty(key)) {\n                        toLayer[key] = fromLayer[key];\n                    }\n                }\n\n                if (fromLayer.data) {\n                    const fromData = fromLayer.data,\n                        toData = toLayer.data = [],\n                        segmentWidth = segment.width;\n\n                    for (let j = 0; j < fromData.length; j++) {\n                        const cell = fromData[segmentWidth * ((j / segmentWidth) >> 0) + segmentWidth - 1 - (j % segmentWidth)];\n\n                        toData[j] = cell ? maskXFlip ^ cell : 0;\n                    }\n                }\n\n                // If we're adding objects, make sure that they're mirrored correctly.\n                if (fromLayer.objects) {\n                    const\n                        fromObjects = fromLayer.objects,\n                        toObjects = toLayer.objects = [];\n\n                    for (let j = 0; j < fromObjects.length; j++) {\n                        const\n                            fromObject = fromObjects[j],\n                            toObject = toObjects[j] = {};\n\n                        for (const key in fromObject) {\n                            if (fromObject.hasOwnProperty(key)) {\n                                toObject[key] = fromObject[key];\n                            }\n                        }\n                        toObject.x = width - fromObject.x - (fromObject.width || 0); // subtract object width since its top-left corner is the origin.\n                        if (fromObject.rotation) {\n                            toObject.rotation = -fromObject.rotation;\n                        }\n                        if (fromObject.polygon) {\n                            toObject.polygon = mirrorPoints(fromObject.polygon);\n                        }\n                        if (fromObject.polyline) {\n                            toObject.polyline = mirrorPoints(fromObject.polyline);\n                        }\n                    }\n                }\n            }\n\n            //Go through all the STUFF in segment and copy it to the level if it's not already there.\n            for (const key in segment) {\n                if (segment.hasOwnProperty(key) && !newSegment[key]) {\n                    newSegment[key] = segment[key];\n                }\n            }\n\n            return newSegment;\n        },\n        mirrorPoints = function (points) {\n            const\n                arr = [];\n            let i = points.length;\n\n            while (i--) {\n                arr.push({\n                    x: -points[i].x,\n                    y: points[i].y\n                });\n            }\n            arr.unshift(arr.pop()); // so the same point is at the beginning.\n\n            return arr;\n        };\n\n    return Object(_factory_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])({\n        id: 'LevelBuilder',\n        \n        properties: {\n            /**\n             * If true, no single map piece is used twice in the creation of the combined map.\n             *\n             * @property useUniques\n             * @type Boolean\n             * @default true\n             */\n            useUniques: true,\n\n            /**\n             * A 1D or 2D array of level piece ids. The template defines how the pieces will be arranged and which pieces can be used where. The template must be rectangular in dimensions.\n             *\n             *      \"levelTemplate\": [ [\"start\", \"forest\"], [\"forest\", \"end\"] ]\n             *\n             * @property levelTemplate\n             * @type Array\n             * @default null\n             */\n            levelTemplate: null,\n\n            /**\n             * This is an object of key/value pairs listing the pieces that map to an id in the level template. The value can be specified as a string or array. A piece will be randomly chosen from an array when that idea is used. If levelPieces is not defined, ids in the template map directly to level names.\n             *\n             *      \"levelPieces\": {\n             *          \"start\"  : \"start-map\",\n             *          \"end\"      : \"end-map\",\n             *          \"forest\" : [\"forest-1\", \"forest-2\", \"forest-3\"],\n             *          \"river\": [\"river-1\", \"river-1:mirror\"] // adding \":mirror\" takes the referenced map and flips it horizontally to add variety.\n             *      }\n             *\n             * @property levelPieces\n             * @type Object\n             * @default null\n             */\n            levelPieces: null\n        },\n\n        publicProperties: {\n        },\n        \n        initialize: function () {\n            this.levelMessage = {level: null, persistentData: null};\n        },\n\n        events: {// These are messages that this component listens for\n\n            /**\n             * When the layer has loaded, LevelBuilder compiles the level based on the template and pieces and sends it to the TiledLoader.\n             *\n             * @method 'layer-loaded'\n             * @param persistentData {Object} The persistent data from the previous scene.\n             */\n            \"layer-loaded\": function (data) {\n                var templateRow  = null,\n                    piecesToCopy = null,\n                    x            = '',\n                    y            = 0,\n                    i            = 0,\n                    j            = 0;\n                \n                this.levelMessage.persistentData = data;\n\n                this.levelTemplate = (data && data.levelTemplate) || this.levelTemplate;\n                this.useUniques = (data && data.useUniques) || this.useUniques;\n                piecesToCopy = (data && data.levelPieces) || this.levelPieces;\n                this.levelPieces = {};\n                if (piecesToCopy) {\n                    for (x in piecesToCopy) {\n                        if (piecesToCopy.hasOwnProperty(x)) {\n                            if (typeof piecesToCopy[x] === \"string\") {\n                                this.levelPieces[x] = piecesToCopy[x];\n                            } else if (piecesToCopy[x].length) {\n                                this.levelPieces[x] = [];\n                                for (y = 0; y < piecesToCopy[x].length; y++) {\n                                    this.levelPieces[x].push(piecesToCopy[x][y]);\n                                }\n                            } else {\n                                throw ('Level Builder: Level pieces of incorrect type: ' + piecesToCopy[x]);\n                            }\n                        }\n                    }\n                }\n\n                if (this.levelTemplate) {\n                    if (this.levelTemplate) {\n                        this.levelMessage.level = [];\n                        for (i = 0; i < this.levelTemplate.length; i++) {\n                            templateRow = this.levelTemplate[i];\n                            if (typeof templateRow === \"string\") {\n                                this.levelMessage.level[i] = this.getLevelPiece(templateRow);\n                            } else if (templateRow.length) {\n                                this.levelMessage.level[i] = [];\n                                for (j = 0; j < templateRow.length; j++) {\n                                    this.levelMessage.level[i][j] = this.getLevelPiece(templateRow[j]);\n                                }\n                            } else {\n                                throw ('Level Builder: Template row is neither a string or array. What is it?');\n                            }\n                        }\n                    } else {\n                        platypus.debug.warn('Level Builder: Template is not defined');\n                    }\n                } else {\n                    platypus.debug.warn('Level Builder: There is no level template.');\n                }\n                \n                if (this.levelMessage.level) {\n                    this.levelMessage.level = mergeLevels(this.levelMessage.level);\n                    /**\n                     * Dispatched when the scene has loaded and the level has been composited. This occurs before \"load-level\" to send out level before it's loaded in case it needs to be saved or edited before being loaded.\n                     *\n                     * @event 'created-level'\n                     * @param data {Object}\n                     * @param data.level {Object} An object describing the level dimensions, tiles, and entities.\n                     * @param data.persistentData {Object} The persistent data passed from the last scene. We add levelBuilder data to it to pass on.\n                     * @param data.persistentData.levelTemplate {Object} A 1D or 2D array of level piece ids. The template defines how the pieces will be arranged and which pieces can be used where. The template must be rectangular in dimensions.\n                     * @param data.persistentData.levelPieces {Object} An object of key/value pairs listing the pieces that map to an id in the level template.\n                     * @param data.persistentData.useUniques {Boolean} If true, no single map piece is used twice in the creation of the combined map.\n                     */\n                    this.owner.triggerEvent('created-level', this.levelMessage);\n\n                    /**\n                     * Dispatched when the scene has loaded and the level has been composited so TileLoader can begin loading the level.\n                     *\n                     * @event 'load-level'\n                     * @param data {Object}\n                     * @param data.level {Object} An object describing the level dimensions, tiles, and entities.\n                     * @param data.persistentData {Object} The persistent data passed from the last scene. We add levelBuilder data to it to pass on.\n                     * @param data.persistentData.levelTemplate {Object} A 1D or 2D array of level piece ids. The template defines how the pieces will be arranged and which pieces can be used where. The template must be rectangular in dimensions.\n                     * @param data.persistentData.levelPieces {Object} An object of key/value pairs listing the pieces that map to an id in the level template.\n                     * @param data.persistentData.useUniques {Boolean} If true, no single map piece is used twice in the creation of the combined map.\n                     */\n                    this.owner.triggerEvent('load-level', this.levelMessage);\n                }\n            }\n        },\n        \n        methods: {// These are methods that are called by this component.\n            getLevelPiece: function (type) {\n                var pieces = this.levelPieces[type] || type,\n                    temp   = null,\n                    random = 0;\n                \n                if (pieces) {\n                    if (typeof pieces === \"string\") {\n                        if (this.useUniques) {\n                            temp = pieces;\n                            this.levelPieces[type] = null;\n                            return temp;\n                        } else {\n                            return pieces;\n                        }\n                    } else if (pieces.length) {\n                        random = Math.floor(Math.random() * pieces.length);\n                        if (this.useUniques) {\n                            return Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSplice\"])(this.levelPieces[type], random);\n                        } else {\n                            return pieces[random];\n                        }\n                    } else {\n                        throw ('Level Builder: There are no MORE level pieces of type: ' + type);\n                    }\n                } else {\n                    throw ('Level Builder: There are no level pieces of type: ' + type);\n                }\n            },\n            destroy: function () {\n                this.levelMessage.level = null;\n                this.levelMessage.persistentData = null;\n                this.levelMessage = null;\n            }\n        },\n        \n        publicMethods: {\n            /**\n             * Accepts a list of levels to be merged and returns a level definition with the references combined.\n             *\n             * @param {Array} levels\n             * @return {Object}\n             */\n            mergeLevels: function (levels) {\n                return mergeLevels(levels);\n            }\n        },\n        \n        getAssetList: function (def, props, defaultProps) {\n            var i = 0,\n                arr = null,\n                assets = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(),\n                key = '',\n                levels = null;\n            \n            if (def && def.levelPieces) {\n                levels = def.levelPieces;\n            } else if (props && props.levelPieces) {\n                levels = props.levelPieces;\n            } else if (defaultProps && defaultProps.levelPieces) {\n                levels = defaultProps.levelPieces;\n            }\n            \n            if (levels) {\n                for (key in levels) {\n                    if (levels.hasOwnProperty(key)) {\n                        // Offload to TiledLoader since it has level-parsing handling\n                        if (Array.isArray(levels[key])) {\n                            for (i = 0; i < levels[key].length; i++) {\n                                arr = platypus.components.TiledLoader.getAssetList({\n                                    level: levels[key][i]\n                                }, props, defaultProps);\n                                Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"union\"])(assets, arr);\n                                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(arr);\n                            }\n                        } else {\n                            arr = platypus.components.TiledLoader.getAssetList({\n                                level: levels[key]\n                            }, props, defaultProps);\n                            Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"union\"])(assets, arr);\n                            _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(arr);\n                        }\n                    }\n                }\n            }\n            \n            return assets;\n        }\n    });\n}());\n\n\n//# sourceURL=webpack://platypus/./src/components/LevelBuilder.js?");

/***/ }),

/***/ "./src/components/LogicAngularMovement.js":
/*!************************************************!*\
  !*** ./src/components/LogicAngularMovement.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../factory.js */ \"./src/factory.js\");\n/**\n * This component moves the entity in the direction of an internally stored angle value. When moving, the entity constantly accelerates the entity in a direction up to a max velocity.\n *\n * @namespace platypus.components\n * @class LogicAngularMovement\n * @uses platypus.Component\n */\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    return Object(_factory_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])({\n        \n        id: 'LogicAngularMovement',\n        \n        properties: {\n            /**\n             * The max velocity.\n             *\n             * @property maxVelocity\n             * @type Number\n             * @default 3\n             */\n            maxVelocity: 3,\n\n            /**\n             * The rate of acceleration.\n             *\n             * @property acceleration\n             * @type Number\n             * @default 0.01\n             */\n            acceleration: 0.01,\n\n            /**\n             * The offset between the rotation value of the entity and the rotation of the art.\n             *\n             * @property visualOffset\n             * @type Number\n             * @default 0\n             */\n            visualOffset: 0,\n\n            /**\n             * The starting heading at which the entity will accelerate. In radians.\n             *\n             * @property startAngle\n             * @type Number\n             * @default 0\n             */\n            startAngle: 0\n        },\n\n        publicProperties: {\n\n        },\n\n        initialize: function () {\n            this.angle     = this.startAngle;\n            this.v         = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(0, 0);\n            this.moving    = false;\n            this.piOverTwo = Math.PI / 2;\n            this.owner.rotation = this.owner.rotation || this.visualOffset;\n        },\n\n        events: {\n\n            /**\n             * Updates the position, velocity, and rotation of the entity\n             *\n             * @method 'handle-logic'\n             * @param tick {Object} The tick data.\n             */\n            \"handle-logic\": function (tick) {\n                var PI  = Math.PI,\n                    sin = Math.sin,\n                    cos = Math.cos,\n                    min = Math.min,\n                    max = Math.max,\n                    delta        = tick.delta,\n                    currentAngle = 0;\n                \n                if (this.moving) {\n                    this.v[0] += this.acceleration * cos(this.angle) * delta;\n                    this.v[1] += this.acceleration * sin(this.angle) * delta;\n                    if (this.v[0] === 0) {\n                        if (this.v[1] > 0) {\n                            currentAngle = this.piOverTwo;\n                        } else if (this.v[1] < 0) {\n                            currentAngle = -this.piOverTwo;\n                        } else {\n                            currentAngle = this.angle;\n                        }\n                    } else {\n                        currentAngle = Math.atan(this.v[1] / this.v[0]);\n                        if (this.v[0] < 0) {\n                            currentAngle = PI + currentAngle;\n                        }\n                    }\n                    if (this.v[0] >= 0) {\n                        this.v[0] = min(this.v[0], this.maxVelocity * cos(currentAngle));\n                    } else {\n                        this.v[0] = max(this.v[0], this.maxVelocity * cos(currentAngle));\n                    }\n                    if (this.v[1] >= 0) {\n                        this.v[1] = min(this.v[1], this.maxVelocity * sin(currentAngle));\n                    } else {\n                        this.v[1] = max(this.v[1], this.maxVelocity * sin(currentAngle));\n                    }\n                    \n                    this.owner.x += this.v[0];\n                    this.owner.y += this.v[1];\n\n                    this.owner.rotation = (currentAngle * (180 / PI)) + this.visualOffset;\n                }\n            },\n            /**\n             * Sets the internal heading angle in the component.\n             *\n             * @method 'set-angle'\n             * @param angle {Number} The value you want to set the angle to.\n             */\n            \"set-angle\": function (angle) {\n                this.angle = angle;\n            },\n            /**\n             * Start the entity accelerating toward the heading angle.\n             *\n             * @method 'move'\n             */\n            \"move\": function () {\n                this.moving = true;\n            },\n            /**\n             * Stops the movement toward the heading angle.\n             *\n             * @method 'stop'\n             */\n            \"stop\": function () {\n                this.moving = false;\n                this.v[0] = 0;\n                this.v[1] = 0;\n            },\n            /**\n             * Set the max velocity.\n             *\n             * @method 'set-max-velocity'\n             * @param newMaxV {Number} The max velocity value.\n             */\n            \"set-max-velocity\": function (newMaxV) {\n                this.maxVelocity = newMaxV;\n            }\n        },\n        \n        methods: {\n            destroy: function () {\n                this.v.recycle();\n            }\n        }\n    });\n}());\n\n\n//# sourceURL=webpack://platypus/./src/components/LogicAngularMovement.js?");

/***/ }),

/***/ "./src/components/LogicAttachment.js":
/*!*******************************************!*\
  !*** ./src/components/LogicAttachment.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Entity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Entity.js */ \"./src/Entity.js\");\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../factory.js */ \"./src/factory.js\");\n/**\n * Creates an entity and connects it with the owner entity. This is useful for entities that have a one-to-one relationship with a given entity and must move as if connected to the host entity.\n *\n * @namespace platypus.components\n * @class LogicAttachment\n * @uses platypus.Component\n */\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    var\n        trigger = function () {\n            var attachment = this.attachment;\n            \n            if (attachment) {\n                attachment.trigger.apply(attachment, arguments);\n            }\n        };\n\n    return Object(_factory_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({\n\n        id: 'LogicAttachment',\n\n        properties: {\n            /**\n             * An owner state, set to true when the attachment is attached. Meant to be read by other components or used in rendering.\n             *\n             * @property attachState\n             * @type String\n             * @default 'attached'\n             */\n            attachState: 'attached',\n\n            /**\n             * The type of the entity to be attached.\n             *\n             * @property attachment\n             * @type String\n             * @default ''\n             */\n            attachment: '',\n\n            /**\n             * This is an object of key/value pairs. The keys are events this component is listening for locally, the value is the new event to be broadcast on the attached entity. The value can also be an array of events to be fired.\n             *\n             *      \"events\": {\n             *          \"sleeping\": \"good-night\",\n             *          \"awake\": [\"alarm\", \"get-up\"]\n             *      }\n             *\n             * @property events\n             * @type Object\n             * @default null\n             */\n            events: null,\n\n            /**\n             * Whether the attachment starts out attached.\n             *\n             * @property startAttached\n             * @type Boolean\n             * @default false\n             */\n            startAttached: false,\n\n            /**\n             * The offset of the attached entity in x from the attachee.\n             *\n             * @property offsetX\n             * @type Number\n             * @default 0\n             */\n            offsetX: 0,\n\n            /**\n             * The offset of the attached entity in y from the attachee.\n             *\n             * @property offsetY\n             * @type Number\n             * @default 0\n             */\n            offsetY: 0,\n\n            /**\n             * The offset of the attached entity in z from the attachee.\n             *\n             * @property offsetZ\n             * @type Number\n             * @default 0\n             */\n            offsetZ: 0.01\n        },\n\n        initialize: function () {\n            var event = '',\n                events = this.events;\n            \n            this.state = this.owner.state;\n\n            this.state.set(this.attachState, this.startAttached);\n            this.attachmentPosition = {\n                x: 0,\n                y: 0,\n                z: 0,\n                dx: 0,\n                dy: 0\n            };\n            this.attachmentProperties = {\n                type: this.attachment,\n                properties: this.attachmentPosition\n            };\n\n            this.attachment = null;\n            this.isAttached = this.startAttached;\n\n            // Messages that this component listens for and then triggers on the attached entity.\n            if (events) {\n                for (event in events) {\n                    if (events.hasOwnProperty(event)) {\n                        this.addEventListener(event, trigger.bind(this, events[event]));\n                    }\n                }\n            }\n        },\n\n        events: {// These are messages that this component listens for\n\n            /**\n             * On receiving this message, updates the attached entity's position.\n             *\n             * @method 'handle-logic'\n             */\n            \"handle-logic\": function () {\n                var offset = 0,\n                    state  = this.state;\n\n                if (this.isAttached) {\n                    if (!this.attachment) {\n                        this.attachmentPosition.x = this.owner.x;\n                        this.attachmentPosition.y = this.owner.y;\n                        this.attachmentPosition.z = this.owner.z;\n                        this.attachment = this.owner.parent.addEntity(this.attachmentProperties);\n                    }\n                    \n                    if (this.attachment.destroyed) {\n                        this.owner.parent.removeEntity(this.attachment);\n                        this.attachment = null;\n                        this.isAttached = false;\n                    } else {\n                        this.attachment.x = this.owner.x;\n                        offset = this.offsetX;\n                        if (state.get('left')) { //TODO: Base this on object orientation. - DDD 3/2/2016\n                            offset *= -1;\n                            this.attachment.rotation = 180;\n                        } else if (state.get('right')) {\n                            this.attachment.rotation = 0;\n                        }\n                        this.attachment.x += offset;\n\n                        this.attachment.y = this.owner.y;\n                        offset = this.offsetY;\n                        if (state.get('top')) {\n                            offset *= -1;\n                            this.attachment.rotation = 90;\n                        } else if (state.get('bottom')) {\n                            this.attachment.rotation = -90;\n                        }\n                        this.attachment.y += offset;\n\n                        this.attachment.z = this.owner.z;\n                        this.attachment.z += this.offsetZ;\n                    }\n                } else if (this.attachment) {\n                    this.owner.parent.removeEntity(this.attachment);\n                    this.attachment = null;\n                }\n                \n                state.set(this.attachState, this.isAttached);\n            },\n\n            /**\n             * Creates and attaches the entity. The input value makes it possible to attach the entity on user input.\n             *\n             * @method 'attach'\n             * @param input {Object} An input object.\n             * @param input.pressed {Boolean} If set to true, the entity is created and attached.\n             */\n            \"attach\": function (input) {\n                this.isAttached = !input || (input.pressed !== false);\n            },\n            /**\n             * Detaches and removes the entity.\n             *\n             * @method 'detach'\n             */\n            \"detach\": function () {\n                this.isAttached = false;\n            },\n            /**\n             * Changes the x, y, and z offset of the attachment.\n             *\n             * @method 'change-attachment-offset'\n             * @param offset {Object} An object containing the offset values.\n             * @param input.x {Number} The new X offset.\n             * @param input.y {Number} The new Y offset.\n             * @param input.y {Number} The new Z offset.\n             */\n            \"change-attachment-offset\": function (offset) {\n                if (typeof offset.x !== 'undefined') {\n                    this.offsetX = offset.x;\n                } else if (typeof offset.y !== 'undefined') {\n                    this.offsetY = offset.y;\n                } else if (typeof offset.z !== 'undefined') {\n                    this.offsetZ = offset.z;\n                }\n            }\n        },\n\n        methods: {\n            destroy: function () {\n                this.state.set(this.attachState, false);\n                if (this.attachment) {\n                    this.owner.parent.removeEntity(this.attachment);\n                    this.attachment = null;\n                }\n                this.isAttached = false;\n                this.state = null;\n            }\n        },\n        \n        getAssetList: function (def, props, defaultProps) {\n            var attachment = def.attachment || props.attachment || defaultProps.attachment;\n            \n            if (attachment) {\n                return _Entity_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getAssetList({\n                    type: attachment\n                });\n            }\n            \n            return _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp();\n        }\n    });\n}());\n\n\n//# sourceURL=webpack://platypus/./src/components/LogicAttachment.js?");

/***/ }),

/***/ "./src/components/LogicButton.js":
/*!***************************************!*\
  !*** ./src/components/LogicButton.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _AABB_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../AABB.js */ \"./src/AABB.js\");\n/* harmony import */ var _Data_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Data.js */ \"./src/Data.js\");\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../factory.js */ \"./src/factory.js\");\n/**\n * Provides button functionality for a RenderSprite component.\n *\n * @namespace platypus.components\n * @class LogicButton\n * @uses platypus.Component\n */\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    return Object(_factory_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({\n\n        id: 'LogicButton',\n\n        properties: {\n            /**\n             * The event to trigger when pressed.\n             *\n             * @property onPress\n             * @type String\n             * @default \"\"\n             */\n            \"onPress\": \"\",\n\n            /**\n             * The event to trigger when released.\n             *\n             * @property onRelease\n             * @type String\n             * @default \"\"\n             */\n            \"onRelease\": \"\",\n\n            /**\n             * The event to trigger when cancelled.\n             *\n             * @property onCancel\n             * @type String\n             * @default \"\"\n             */\n            \"onCancel\": \"\",\n\n            /**\n             * The event to trigger when the user mouses over the button\n             *\n             * @property hoverAudio\n             * @type String or an Array of Strings and Message Objects\n             * @default \"\"\n             */\n            \"onHover\": \"\",\n\n            /**\n             * Whether this button's actions should be limited to the initial press/release.\n             *\n             * @property useOnce\n             * @type Boolean\n             * @default false\n             */\n            \"useOnce\": false,\n\n            /**\n             * Whether this button should start disabled.\n             *\n             * @property disabled\n             * @type Boolean\n             * @default false\n             */\n            \"disabled\": false,\n\n            /**\n             * Determines whether this button should behave as a toggle.\n             *\n             * @property toggle\n             * @type Boolean\n             * @default false\n             */\n            \"toggle\": false,\n\n            /**\n             * Specifies whether the button starts off 'pressed'; typically only useful for toggle buttons.\n             *\n             * @property pressed\n             * @type Boolean\n             * @default false\n             */\n            \"pressed\": false\n        },\n\n        publicProperties: {\n            /**\n             * This sets the distance in world units from the bottom of the camera's world viewport. If set, it will override the entity's y coordinate. This property is accessible on the entity as `entity.bottom`.\n             *\n             * @property bottom\n             * @type Number\n             * @default null\n             */\n            \"bottom\": null,\n\n            /**\n             * This sets the distance in world units from the left of the camera's world viewport. If set, it will override the entity's x coordinate. This property is accessible on the entity as `entity.left`.\n             *\n             * @property left\n             * @type Number\n             * @default null\n             */\n            \"left\": null,\n\n            /**\n             * This sets the distance in world units from the right of the camera's world viewport. If set, it will override the entity's x coordinate. This property is accessible on the entity as `entity.right`.\n             *\n             * @property right\n             * @type Number\n             * @default null\n             */\n            \"right\": null,\n\n            /**\n             * This sets the distance in world units from the top of the camera's world viewport. If set, it will override the entity's y coordinate. This property is accessible on the entity as `entity.top`.\n             *\n             * @property top\n             * @type Number\n             * @default null\n             */\n            \"top\": null\n        },\n\n        initialize: function () {\n            var state = this.owner.state;\n            \n            this.aabb = _AABB_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp();\n            this.lastBottom = null;\n            this.lastLeft = null;\n            this.lastRight = null;\n            this.lastTop = null;\n\n            this.state = state;\n            state.set('disabled', this.disabled);\n            state.set('released', !this.pressed);\n            state.set('pressed', this.pressed);\n            state.set('highlighted', false);\n            this.owner.buttonMode = !this.disabled;\n            this.cancelled = false;\n\n            this.readyToToggle = false;\n        },\n\n        events: {\n            /**\n             * This component uses location updates to reposition the entity if its bottom, left, right, or top properties have been set.\n             *\n             * @method 'handle-logic'\n             */\n            \"handle-logic\": function () {\n                var bottom = this.bottom,\n                    left = this.left,\n                    right = this.right,\n                    top = this.top;\n\n                if ((this.lastBottom !== bottom) || (this.lastLeft !== left) || (this.lastRight !== right) || (this.lastTop !== top)) {\n                    this.updatePosition(this.aabb);\n                    this.lastBottom = bottom;\n                    this.lastLeft = left;\n                    this.lastRight = right;\n                    this.lastTop = top;\n                }\n            },\n\n            /**\n             * This component listens for camera updates to reposition the entity if its bottom, left, right, or top properties have been set.\n             *\n             * @method 'camera-update'\n             * @param camera {platypus.Data} Camera update information\n             * @param camera.viewport {platypus.AABB} The bounding box describing the camera viewport location in the world.\n             */\n            \"camera-update\": function (camera) {\n                this.aabb.set(camera.viewport);\n                this.updatePosition(this.aabb);\n            },\n\n            /**\n             * Triggers events per the component's definition when a press is made.\n             *\n             * @method 'pointerdown'\n             */\n            \"pointerdown\": function (eventData) {\n                if (!this.state.get('disabled')) {\n                    if (this.toggle) {\n                        this.readyToToggle = true;\n                    } else {\n                        if (this.onPress) {\n                            this.owner.trigger(this.onPress);\n                        }\n\n                        /**\n                         * This event is triggered when the button is pressed to mimic keypress events. If the button is a toggle button, this only occurs on up-to-down.\n                         *\n                         * @event 'pressed'\n                         * @param buttonState {platypus.Data} The state of the button\n                         * @param buttonState.pressed {Boolean} This is `true` for the 'pressed' event.\n                         * @param buttonState.released {Boolean} This is `false` for the 'pressed' event.\n                         * @param buttonState.triggered {Boolean} This is `true` for the 'pressed' event.\n                         * @param buttonState.entity {platypus.Entity} The entity for which the original event occurred.\n                         */\n                        this.updateStateAndTrigger('pressed');\n                        if (eventData && eventData.pixiEvent && eventData.pixiEvent.stopPropagation) { // ensure a properly formed event has been sent\n                            eventData.pixiEvent.stopPropagation();\n                        }\n\n                        // Doing this prevents the call from reccurring.\n                        if (this.useOnce && this.removeEventListener) {\n                            this.removeEventListener('pointerdown');\n                        }\n                    }\n                }\n            },\n\n            /**\n             * Triggers events per the component's definition when a press is released.\n             *\n             * @method 'pressup'\n             */\n            \"pressup\": function (eventData) {\n                var state = this.state;\n\n                if (!state.get('disabled')) {\n                    if (this.cancelled) {\n                        if (this.onCancel) {\n                            this.owner.trigger(this.onCancel);\n                        }\n\n                        /**\n                         * This event is triggered when the button is pressed and the mouse/touch is dragged off-target before release.\n                         *\n                         * @event 'cancelled'\n                         * @param buttonState {platypus.Data} The state of the button\n                         * @param buttonState.pressed {Boolean} This is `false` for the 'cancelled' event.\n                         * @param buttonState.released {Boolean} This is `true` for the 'cancelled' event.\n                         * @param buttonState.triggered {Boolean} This is `false` for the 'cancelled' event.\n                         * @param buttonState.entity {platypus.Entity} The entity for which the original event occurred.\n                         */\n                        this.updateStateAndTrigger('cancelled');\n                    } else if (this.toggle) {\n                        if (this.readyToToggle) {\n                            if (state.get('pressed')) {\n                                this.updateStateAndTrigger('released');\n                            } else {\n                                this.updateStateAndTrigger('pressed');\n                            }\n                        }\n                    } else {\n                        if (this.onRelease) {\n                            this.owner.trigger(this.onRelease);\n                        }\n\n                        /**\n                         * This event is triggered when the button is released, or on the down-to-up change for toggle buttons.\n                         *\n                         * @event 'released'\n                         * @param buttonState {platypus.Data} The state of the button\n                         * @param buttonState.pressed {Boolean} This is `false` for the 'released' event.\n                         * @param buttonState.released {Boolean} This is `true` for the 'released' event.\n                         * @param buttonState.triggered {Boolean} This is `false` for the 'released' event.\n                         * @param buttonState.entity {platypus.Entity} The entity for which the original event occurred.\n                         */\n                        this.updateStateAndTrigger('released');\n                    }\n                    if (eventData && eventData.pixiEvent && eventData.pixiEvent.stopPropagation) { // ensure a properly formed event has been sent\n                        eventData.pixiEvent.stopPropagation();\n                    }\n\n                    // Doing this prevents the call from reccurring.\n                    if (this.useOnce && this.removeEventListener) { //Second check is to ensure method exists which won't be the case if a result of the press is the button being destroyed.\n                        this.removeEventListener('pressup');\n                        this.state.set('disabled', true);\n                        this.owner.buttonMode = false;\n                    }\n                }\n\n                this.cancelled = false;\n                this.readyToToggle = false;\n            },\n\n            /**\n             * If a press moves over the button, it's not cancelled.\n             *\n             * @method 'pointerover'\n             */\n            \"pointerover\": function () {\n                if (this.onHover) {\n                    this.owner.trigger(this.onHover);\n                }\n                if (this.state.get('pressed')) {\n                    this.cancelled = false;\n                }\n            },\n\n            /**\n             * If a press moves off of the button, it's cancelled.\n             *\n             * @method 'pointerout'\n             */\n            \"pointerout\": function () {\n                if (this.state.get('pressed')) {\n                    this.cancelled = true;\n                }\n            },\n            \n            /**\n             * Disables the entity.\n             *\n             * @method 'disable'\n             */\n            \"disable\": function () {\n                this.state.set('disabled', true);\n                this.owner.buttonMode = false;\n            },\n            \n            /**\n             * Enables the entity.\n             *\n             * @method 'enable'\n             */\n            \"enable\": function () {\n                this.state.set('disabled', false);\n                this.owner.buttonMode = true;\n            },\n\n            /**\n             * Toggles whether the entity is disabled.\n             *\n             * @method 'toggle-disabled'\n             */\n            \"toggle-disabled\": function () {\n                var value = this.state.get('disabled');\n                \n                this.owner.buttonMode = value;\n                this.state.set('disabled', !value);\n            },\n            \n            /**\n             * Sets the entity's highlighted state to `true`.\n             *\n             * @method 'highlight'\n             */\n            \"highlight\": function () {\n                this.state.set('highlighted', true);\n            },\n            \n            /**\n             * Sets the entity's highlighted state to `false`.\n             *\n             * @method 'unhighlight'\n             */\n            \"unhighlight\": function () {\n                this.state.set('highlighted', false);\n            },\n            \n            /**\n             * Toggles the entity's highlighted state.\n             *\n             * @method 'toggle-highlight'\n             */\n            \"toggle-highlight\": function () {\n                var state = this.state;\n\n                state.set('highlighted', !state.get('highlighted'));\n            }\n        },\n        \n        methods: {\n            updatePosition: function (vp) {\n                var bottom = this.bottom,\n                    left = this.left,\n                    owner = this.owner,\n                    right = this.right,\n                    top = this.top;\n\n                if (typeof left === 'number') {\n                    owner.x = vp.left + left;\n                } else if (typeof right === 'number') {\n                    owner.x = vp.right - right;\n                }\n\n                if (typeof top === 'number') {\n                    owner.y = vp.top + top;\n                } else if (typeof bottom === 'number') {\n                    owner.y = vp.bottom - bottom;\n                }\n            },\n\n            updateStateAndTrigger: function (event) {\n                var message = null,\n                    owner = this.owner,\n                    state = this.state,\n                    pressed = state.get('pressed'),\n                    released = state.get('released'),\n                    toggled = false;\n                \n                if (released && (event === 'pressed')) {\n                    state.set('pressed', true);\n                    state.set('released', false);\n                    toggled = true;\n                } else if (pressed && ((event === 'released') || (event === 'cancelled'))) {\n                    state.set('pressed', false);\n                    state.set('released', true);\n                    toggled = true;\n                }\n\n                if (toggled) {\n                    message = _Data_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp(\n                        'released', pressed,\n                        'pressed', released,\n                        'triggered', released,\n                        'entity', owner\n                    );\n                    owner.triggerEvent(event, message);\n                    message.recycle();\n                }\n            },\n\n            destroy: function () {\n                this.aabb.recycle();\n                this.aabb = null;\n                this.owner.buttonMode = false;\n                this.state = null;\n            }\n        }\n    });\n}());\n\n\n//# sourceURL=webpack://platypus/./src/components/LogicButton.js?");

/***/ }),

/***/ "./src/components/LogicCarrier.js":
/*!****************************************!*\
  !*** ./src/components/LogicCarrier.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../factory.js */ \"./src/factory.js\");\n/**\n * This component allows this entity carry other entities with which it collides. Entities that this component should carry need to have a [[Logic-Portable]] component attached to notify this entity that they are portable.\n *\n * @namespace platypus.components\n * @class LogicCarrier\n * @uses platypus.Component\n */\n/* global platypus */\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    return Object(_factory_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        id: 'LogicCarrier',\n        initialize: function () {},\n        events: {\n            /**\n             * On receiving this message, the component ensures that it has a peer collision group component, and adds one if not.\n             *\n             * @method 'load'\n             */\n            \"load\": function () {\n                /**\n                 * On receiving a `carry-me` message, this component triggers this message to add the portable peer to the collision group.\n                 *\n                 * @event 'add-collision-entity'\n                 * @param entity {platypus.Entity} The entity being added to the collision group.\n                 */\n                if (!this.owner.triggerEvent('add-collision-entity', this.owner)) {\n                    // This message wasn't handled, so add a CollisionGroup component and try again!\n                    this.owner.addComponent(new platypus.components.CollisionGroup(this.owner, {}));\n                    this.owner.triggerEvent('add-collision-entity', this.owner);\n                }\n            },\n\n            /**\n             * On receiving this message, the component triggers `add-collision-entity` on the entity to add the peer entity to its collision group.\n             *\n             * @method 'carry-me'\n             * @param message.entity {platypus.Entity} The peer entity requesting to be carried.\n             */\n            \"carry-me\": function (resp) {\n                this.owner.triggerEvent('add-collision-entity', resp.entity);\n            },\n\n            /**\n             * On receiving this message, the component triggers `remove-collision-entity` on the entity to remove the peer entity from its collision group.\n             *\n             * @method 'carry-me'\n             * @param message.entity {platypus.Entity} The peer entity requesting to be released.\n             */\n            \"release-me\": function (resp) {\n                /**\n                 * On receiving a `release-me` message, this component triggers this message to remove the portable peer to the collision group.\n                 *\n                 * @event 'remove-collision-entity'\n                 * @param entity {platypus.Entity} The entity being removed from the collision group.\n                 */\n                this.owner.triggerEvent('remove-collision-entity', resp.entity);\n            }\n        }\n    });\n}());\n\n\n//# sourceURL=webpack://platypus/./src/components/LogicCarrier.js?");

/***/ }),

/***/ "./src/components/LogicDestroyMe.js":
/*!******************************************!*\
  !*** ./src/components/LogicDestroyMe.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../factory.js */ \"./src/factory.js\");\n/**\n * This component allows an entity to be removed from the stage when \"destroy-me\" is triggered.\n *\n * @namespace platypus.components\n * @class LogicDestroyMe\n * @uses platypus.Component\n */\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    return Object(_factory_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        id: 'LogicDestroyMe',\n        \n        properties: {\n            /**\n             * Time in milliseconds after the \"destroy-me\" message is heard before entity should be removed.\n             *\n             * @property delay\n             * @type number\n             * @default 0\n             */\n            delay: 0,\n\n            /**\n             * Whether this entity has been destroyed. Typically `false` until a \"destroy-me\" event has been triggered.\n             *\n             * @property destroyed\n             * @type boolean\n             * @default false\n             */\n            destroyed: false\n        },\n        \n        events: {// These are messages that this component listens for\n\n            /**\n             * On a `tick` logic message, the component checks whether it should be removed or not.\n             *\n             * @method 'prepare-logic'\n             * @param message.delta {number} To measure the delay before removal, the component keeps a running count of step lengths.\n             */\n            \"prepare-logic\": function (tick) {\n                var dT = tick.delta;\n                \n                if (this.destroyed && !this.owner.state.get('paused')) {\n                    this.delay -= dT;\n                    if (this.delay <= 0) {\n                        this.owner.parent.removeEntity(this.owner);\n                    }\n                }\n            },\n            \n            /**\n             * This component will set the entity up for removal on receiving this message.\n             *\n             * @method 'destroy-me'\n             */\n            \"destroy-me\": function () {\n                this.destroyed = true;\n            }\n                   \n        }\n    });\n}());\n\n\n//# sourceURL=webpack://platypus/./src/components/LogicDestroyMe.js?");

/***/ }),

/***/ "./src/components/LogicDirectionalMovement.js":
/*!****************************************************!*\
  !*** ./src/components/LogicDirectionalMovement.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Vector_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Vector.js */ \"./src/Vector.js\");\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../factory.js */ \"./src/factory.js\");\n/**\n * This component changes the [Motion](platypus.components.Motion.html) of an entity according to its current speed and heading. It accepts directional messages that can stand alone, or come from a mapped controller, in which case it checks the `pressed` value of the message before changing its course.\n *\n * @namespace platypus.components\n * @class LogicDirectionalMovement\n * @uses platypus.Component\n */\n/* global platypus */\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    var processDirection = function (direction) {\n            return function (state) {\n                this[direction] = !state || (state.pressed !== false);\n            };\n        },\n        doNothing = function () {},\n        rotate = {\n            x: function (heading, lastHeading) {\n                if (heading !== lastHeading) {\n                    if (((heading > 180) && (lastHeading <= 180)) || ((heading <= 180) && (lastHeading > 180))) {\n                        this.owner.triggerEvent('transform', 'vertical');\n                    }\n                }\n            },\n            y: function (heading, lastHeading) {\n                if (heading !== lastHeading) {\n                    if (((heading > 90 && heading <= 270) && (lastHeading <= 90 || lastHeading > 270)) || ((heading <= 90 || heading > 270) && (lastHeading > 90 && lastHeading <= 270))) {\n                        this.owner.triggerEvent('transform', 'horizontal');\n                    }\n                }\n            },\n            z: function (heading, lastHeading) {\n                if (heading !== lastHeading) {\n                    this.owner.triggerEvent('replace-transform', 'rotate-' + heading);\n                }\n            }\n        };\n    \n    return Object(_factory_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])({\n        id: 'LogicDirectionalMovement',\n        \n        properties: {\n            /**\n             * Defines the axis around which the entity should be transformed. Defaults to \"y\" for platforming behavior. Use \"z\" for top-down behavior.\n             *\n             * @property axis\n             * @type String\n             * @default \"y\"\n             */\n            axis: 'y',\n\n            /**\n             * Defines the distance in world units that the entity should be moved per millisecond.\n             *\n             * @property speed\n             * @type Number\n             * @default 0.3\n             */\n            speed: 0.3\n        },\n        \n        initialize: function () {\n            var state = this.state = this.owner.state;\n            \n            if (typeof this.speed === 'number') {\n                this.speed = [this.speed, 0, 0];\n            }\n            this.initialVector = _Vector_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp(this.speed);\n            this.reorient = rotate[this.axis];\n            if (!this.reorient) {\n                this.reorient = doNothing;\n            }\n            \n            this.moving = state.set('moving', false);\n            this.left   = state.set('left', false);\n            this.right  = state.set('right', false);\n            this.up     = state.set('up', false);\n            this.down   = state.set('down', false);\n\n            this.upLeft = false;\n            this.upRight = false;\n            this.downLeft = false;\n            this.downRight = false;\n            \n            this.heading = 0;\n            this.owner.heading = this.owner.heading || 0;\n        },\n        events: {\n            /**\n             * This method checks to make sure there is a `Mover` component attached and sets up initial heading.\n             *\n             * @method 'component-added'\n             */\n            \"component-added\": function (component) {\n                if (component === this) {\n                    if (!this.owner.addMover) {\n                        platypus.debug.warn('The \"LogicDirectionalMovement\" component requires a \"Mover\" component to function correctly.');\n                        return;\n                    }\n\n                    this.direction = this.owner.addMover({\n                        velocity: this.speed,\n                        drag: 0,\n                        friction: 0,\n                        stopOnCollision: false,\n                        orient: false,\n                        aliases: {\n                            \"moving\": \"control-velocity\"\n                        }\n                    }).velocity;\n                    \n                    if (this.owner.heading !== this.heading) {\n                        this.direction.setVector(this.initialVector).rotate((this.owner.heading / 180) * Math.PI);\n                        this.heading = this.owner.heading;\n                    }\n                    \n                    this.owner.triggerEvent('moving', this.moving);\n                }\n            },\n            \n            /**\n             * On receiving this message, the component updates its direction of motion according to its current state.\n             *\n             * @method 'handle-logic'\n             */\n            \"handle-logic\": function () {\n                var state = this.state,\n                    up        = this.up        || this.upLeft || this.upRight,\n                    upLeft    = this.upLeft    || (this.up   && this.left),\n                    left      = this.left      || this.upLeft || this.downLeft,\n                    downLeft  = this.downLeft  || (this.down && this.left),\n                    down      = this.down      || this.downLeft || this.downRight,\n                    downRight = this.downRight || (this.down && this.right),\n                    right     = this.right     || this.upRight || this.downRight,\n                    upRight   = this.upRight   || (this.up   && this.right);\n                \n                if ((left && right) || (up && down)) {\n                    this.moving = false;\n                } else if (upLeft) {\n                    this.moving = true;\n                    this.heading = 225;\n                } else if (upRight) {\n                    this.moving = true;\n                    this.heading = 315;\n                } else if (downLeft) {\n                    this.moving = true;\n                    this.heading = 135;\n                } else if (downRight) {\n                    this.moving = true;\n                    this.heading = 45;\n                } else if (left) {\n                    this.moving = true;\n                    this.heading = 180;\n                } else if (right) {\n                    this.moving = true;\n                    this.heading = 0;\n                } else if (up) {\n                    this.moving = true;\n                    this.heading = 270;\n                } else if (down) {\n                    this.moving = true;\n                    this.heading = 90;\n                } else {\n                    this.moving = false;\n                    \n                    // This is to retain the entity's direction even if there is no movement. There's probably a better way to do this since this is a bit of a retrofit. - DDD\n                    switch (this.heading) {\n                    case 270:\n                        up = true;\n                        break;\n                    case 90:\n                        down = true;\n                        break;\n                    case 180:\n                        left = true;\n                        break;\n                    case 225:\n                        up = true;\n                        left = true;\n                        break;\n                    case 315:\n                        up = true;\n                        right = true;\n                        break;\n                    case 135:\n                        down = true;\n                        left = true;\n                        break;\n                    case 45:\n                        down = true;\n                        right = true;\n                        break;\n                    case 0:\n                    default:\n                        right = true;\n                        break;\n                    }\n                }\n                \n                if (this.owner.heading !== this.heading) {\n                    this.direction.setVector(this.initialVector).rotate((this.heading / 180) * Math.PI);\n                    this.reorient(this.heading, this.owner.heading);\n                    this.owner.heading = this.heading;\n                }\n                \n                //TODO: possibly remove the separation of this.state.direction and this.direction to just use state?\n                if (state.get('moving') !== this.moving) {\n                    this.owner.triggerEvent('moving', this.moving);\n                    state.set('moving', this.moving);\n                }\n\n                state.set('up', up);\n                state.set('right', right);\n                state.set('down', down);\n                state.set('left', left);\n            },\n\n            /**\n             * On receiving this message, this component updates its heading accordingly.\n             *\n             * @method 'go-down'\n             * @param [message.pressed] {Boolean} If `message` is included, the component checks the value of `pressed`: true causes movement in the triggered direction, false turns off movement in that direction. Note that if no message is included, the only way to stop movement in a particular direction is to trigger `stop` on the entity before progressing in a new heading. This allows triggering `up` and `left` in sequence to cause `up-left` movement on the entity.\n             */\n            \"go-down\": processDirection('down'),\n\n            /**\n             * On receiving this message, this component updates its heading accordingly.\n             *\n             * @method 'go-south'\n             * @param [message.pressed] {Boolean} If `message` is included, the component checks the value of `pressed`: true causes movement in the triggered direction, false turns off movement in that direction. Note that if no message is included, the only way to stop movement in a particular direction is to trigger `stop` on the entity before progressing in a new heading. This allows triggering `up` and `left` in sequence to cause `up-left` movement on the entity.\n             */\n            \"go-south\": processDirection('down'),\n\n            /**\n             * On receiving this message, this component updates its heading accordingly.\n             *\n             * @method 'go-down-left'\n             * @param [message.pressed] {Boolean} If `message` is included, the component checks the value of `pressed`: true causes movement in the triggered direction, false turns off movement in that direction. Note that if no message is included, the only way to stop movement in a particular direction is to trigger `stop` on the entity before progressing in a new heading. This allows triggering `up` and `left` in sequence to cause `up-left` movement on the entity.\n             */\n            \"go-down-left\": processDirection('downLeft'),\n\n            /**\n             * On receiving this message, this component updates its heading accordingly.\n             *\n             * @method 'go-southwest'\n             * @param [message.pressed] {Boolean} If `message` is included, the component checks the value of `pressed`: true causes movement in the triggered direction, false turns off movement in that direction. Note that if no message is included, the only way to stop movement in a particular direction is to trigger `stop` on the entity before progressing in a new heading. This allows triggering `up` and `left` in sequence to cause `up-left` movement on the entity.\n             */\n            \"go-southwest\": processDirection('downLeft'),\n\n            /**\n             * On receiving this message, this component updates its heading accordingly.\n             *\n             * @method 'go-left'\n             * @param [message.pressed] {Boolean} If `message` is included, the component checks the value of `pressed`: true causes movement in the triggered direction, false turns off movement in that direction. Note that if no message is included, the only way to stop movement in a particular direction is to trigger `stop` on the entity before progressing in a new heading. This allows triggering `up` and `left` in sequence to cause `up-left` movement on the entity.\n             */\n            \"go-left\": processDirection('left'),\n\n            /**\n             * On receiving this message, this component updates its heading accordingly.\n             *\n             * @method 'go-west'\n             * @param [message.pressed] {Boolean} If `message` is included, the component checks the value of `pressed`: true causes movement in the triggered direction, false turns off movement in that direction. Note that if no message is included, the only way to stop movement in a particular direction is to trigger `stop` on the entity before progressing in a new heading. This allows triggering `up` and `left` in sequence to cause `up-left` movement on the entity.\n             */\n            \"go-west\": processDirection('left'),\n\n            /**\n             * On receiving this message, this component updates its heading accordingly.\n             *\n             * @method 'go-up-left'\n             * @param [message.pressed] {Boolean} If `message` is included, the component checks the value of `pressed`: true causes movement in the triggered direction, false turns off movement in that direction. Note that if no message is included, the only way to stop movement in a particular direction is to trigger `stop` on the entity before progressing in a new heading. This allows triggering `up` and `left` in sequence to cause `up-left` movement on the entity.\n             */\n            \"go-up-left\": processDirection('upLeft'),\n\n            /**\n             * On receiving this message, this component updates its heading accordingly.\n             *\n             * @method 'go-northwest'\n             * @param [message.pressed] {Boolean} If `message` is included, the component checks the value of `pressed`: true causes movement in the triggered direction, false turns off movement in that direction. Note that if no message is included, the only way to stop movement in a particular direction is to trigger `stop` on the entity before progressing in a new heading. This allows triggering `up` and `left` in sequence to cause `up-left` movement on the entity.\n             */\n            \"go-northwest\": processDirection('upLeft'),\n\n            /**\n             * On receiving this message, this component updates its heading accordingly.\n             *\n             * @method 'go-up'\n             * @param [message.pressed] {Boolean} If `message` is included, the component checks the value of `pressed`: true causes movement in the triggered direction, false turns off movement in that direction. Note that if no message is included, the only way to stop movement in a particular direction is to trigger `stop` on the entity before progressing in a new heading. This allows triggering `up` and `left` in sequence to cause `up-left` movement on the entity.\n             */\n            \"go-up\": processDirection('up'),\n\n            /**\n             * On receiving this message, this component updates its heading accordingly.\n             *\n             * @method 'go-north'\n             * @param [message.pressed] {Boolean} If `message` is included, the component checks the value of `pressed`: true causes movement in the triggered direction, false turns off movement in that direction. Note that if no message is included, the only way to stop movement in a particular direction is to trigger `stop` on the entity before progressing in a new heading. This allows triggering `up` and `left` in sequence to cause `up-left` movement on the entity.\n             */\n            \"go-north\": processDirection('up'),\n\n            /**\n             * On receiving this message, this component updates its heading accordingly.\n             *\n             * @method 'go-up-right'\n             * @param [message.pressed] {Boolean} If `message` is included, the component checks the value of `pressed`: true causes movement in the triggered direction, false turns off movement in that direction. Note that if no message is included, the only way to stop movement in a particular direction is to trigger `stop` on the entity before progressing in a new heading. This allows triggering `up` and `left` in sequence to cause `up-left` movement on the entity.\n             */\n            \"go-up-right\": processDirection('upRight'),\n\n            /**\n             * On receiving this message, this component updates its heading accordingly.\n             *\n             * @method 'go-northeast'\n             * @param [message.pressed] {Boolean} If `message` is included, the component checks the value of `pressed`: true causes movement in the triggered direction, false turns off movement in that direction. Note that if no message is included, the only way to stop movement in a particular direction is to trigger `stop` on the entity before progressing in a new heading. This allows triggering `up` and `left` in sequence to cause `up-left` movement on the entity.\n             */\n            \"go-northeast\": processDirection('upRight'),\n\n            /**\n             * On receiving this message, this component updates its heading accordingly.\n             *\n             * @method 'go-right'\n             * @param [message.pressed] {Boolean} If `message` is included, the component checks the value of `pressed`: true causes movement in the triggered direction, false turns off movement in that direction. Note that if no message is included, the only way to stop movement in a particular direction is to trigger `stop` on the entity before progressing in a new heading. This allows triggering `up` and `left` in sequence to cause `up-left` movement on the entity.\n             */\n            \"go-right\": processDirection('right'),\n\n            /**\n             * On receiving this message, this component updates its heading accordingly.\n             *\n             * @method 'go-east'\n             * @param [message.pressed] {Boolean} If `message` is included, the component checks the value of `pressed`: true causes movement in the triggered direction, false turns off movement in that direction. Note that if no message is included, the only way to stop movement in a particular direction is to trigger `stop` on the entity before progressing in a new heading. This allows triggering `up` and `left` in sequence to cause `up-left` movement on the entity.\n             */\n            \"go-east\": processDirection('right'),\n\n            /**\n             * On receiving this message, this component updates its heading accordingly.\n             *\n             * @method 'go-down-right'\n             * @param [message.pressed] {Boolean} If `message` is included, the component checks the value of `pressed`: true causes movement in the triggered direction, false turns off movement in that direction. Note that if no message is included, the only way to stop movement in a particular direction is to trigger `stop` on the entity before progressing in a new heading. This allows triggering `up` and `left` in sequence to cause `up-left` movement on the entity.\n             */\n            \"go-down-right\": processDirection('downRight'),\n\n            /**\n             * On receiving this message, this component updates its heading accordingly.\n             *\n             * @method 'go-southeast'\n             * @param [message.pressed] {Boolean} If `message` is included, the component checks the value of `pressed`: true causes movement in the triggered direction, false turns off movement in that direction. Note that if no message is included, the only way to stop movement in a particular direction is to trigger `stop` on the entity before progressing in a new heading. This allows triggering `up` and `left` in sequence to cause `up-left` movement on the entity.\n             */\n            \"go-southeast\": processDirection('downRight'),\n            \n            /**\n             * Stops motion in all directions until movement messages are again received.\n             *\n             * @method 'stop'\n             * @param message.pressed (boolean) - Optional. If `message` is included, the component checks the value of `pressed`: a value of false will not stop the entity.\n             */\n            \"stop\": function (state) {\n                if (!state || (state.pressed !== false)) {\n                    this.left = false;\n                    this.right = false;\n                    this.up = false;\n                    this.down = false;\n                    this.upLeft = false;\n                    this.upRight = false;\n                    this.downLeft = false;\n                    this.downRight = false;\n                }\n            },\n            \n            /**\n             * Set the direction the entity should face while stopped.\n             *\n             * @method 'face'\n             * @param direction {String} A value such as \"north\" or \"left\" to point the entity in a particular direction.\n             */\n            \"face\": (function () {\n                var headings = {\n                    up: 270,\n                    north: 270,\n                    down: 90,\n                    south: 90,\n                    left: 180,\n                    west: 180,\n                    right: 0,\n                    east: 0,\n                    \"up-left\": 225,\n                    northwest: 225,\n                    \"up-right\": 315,\n                    northeast: 315,\n                    \"down-left\": 135,\n                    southwest: 135,\n                    \"down-right\": 45,\n                    southeast: 45\n                };\n                \n                return function (direction) {\n                    this.heading = headings[direction] || 0;\n                };\n            }()),\n            \n            /**\n             * Changes the velocity of the Entity when in motion.\n             *\n             * @method 'accelerate'\n             * @param velocity {Number|platypus.Vector} The magnitude or Vector to multiply the current velocity by.\n             */\n            \"accelerate\": function (velocity) {\n                this.initialVector.normalize().multiply(velocity);\n                this.direction.normalize().multiply(velocity);\n            }\n        },\n        \n        methods: {\n            destroy: function () {\n                this.initialVector.recycle();\n                this.state = null;\n            }\n        }\n    });\n}());\n\n\n//# sourceURL=webpack://platypus/./src/components/LogicDirectionalMovement.js?");

/***/ }),

/***/ "./src/components/LogicDragDrop.js":
/*!*****************************************!*\
  !*** ./src/components/LogicDragDrop.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _AABB_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../AABB.js */ \"./src/AABB.js\");\n/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pixi.js */ \"pixi.js\");\n/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(pixi_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../factory.js */ \"./src/factory.js\");\n/**\n * A component that allows an object to be dragged and dropped. Can use collision to prevent dropping the objects in certain locations.\n *\n * @namespace platypus.components\n * @class LogicDragDrop\n * @uses platypus.Component\n */\n/* global platypus */\n\n\n\n\nconst\n    claimHitArea = new pixi_js__WEBPACK_IMPORTED_MODULE_1__[\"Rectangle\"](-2000, -2000, 4000, 4000);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Object(_factory_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({\n    id: 'LogicDragDrop',\n    \n    properties: {\n        /**\n         * Sets the renderParent while being dragged.\n         *\n         * @property dragRenderParent\n         * @type string\n         * @default ''\n         */\n        dragRenderParent: '',\n        \n        /**\n         * Sets whether a click-move should start the dragging behavior in addition to click-drag. This value is ignored for mobile devices.\n         *\n         * @property stickyClick\n         * @type Boolean\n         * @default false\n         */\n        stickyClick: false\n    },\n    \n    initialize: function () {\n        this.aabb = _AABB_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp();\n        this.nextX = this.owner.x;\n        this.nextY = this.owner.y;\n        this.lastZ = this.owner.z;\n        this.grabOffsetX = 0;\n        this.grabOffsetY = 0;\n        this.state = this.owner.state;\n        this.state.set('dragging', false);\n        this.state.set('noDrop', false);\n        this.tryDrop = false;\n        this.hitSomething = false;\n        this.hasCollision = false;\n        \n        if (platypus.supports.mobile) {\n            this.stickyClick = false;\n        }\n    },\n\n    events: {\n        /**\n         * This component listens for camera updates to know when a dragged item goes off-camera.\n         *\n         * @method 'camera-update'\n         * @param camera {platypus.Data} Camera update information\n         * @param camera.viewport {platypus.AABB} The bounding box describing the camera viewport location in the world.\n         */\n        \"camera-update\": function (camera) {\n            this.aabb.set(camera.viewport);\n            this.checkCamera();\n        },\n\n        /**\n         * This component listens for added components to determine whether it should check for collision.\n         *\n         * @method 'component-added'\n         * @param component {platypus.Component} Component added to entity.\n         * @param component.type {String} Type of component to detect whether it's a collision component.\n         */\n        \"component-added\": function (component) {\n            if (component.type === 'CollisionBasic') {\n                this.hasCollision = true;\n            }\n        },\n        \n        /**\n         * Listens for this event to check bounds.\n         *\n         * @method 'prepare-logic'\n         */\n        \"prepare-logic\": function () {\n            this.checkCamera(); // may end dragging\n        },\n\n        /**\n         * Updates the object's location on the handle-logic tick.\n         *\n         * @method 'handle-logic'\n         */\n        \"handle-logic\": function () {\n            if (this.state.get('dragging')) {\n                this.owner.x = this.nextX;\n                this.owner.y = this.nextY;\n                this.owner.triggerEvent('hovering');\n            }\n            \n            this.state.set('noDrop', false);\n        },\n\n        /**\n         * Resolves whether the object state after we check if there are any collisions. If the object was dropped and can be dropped, it is.\n         *\n         * @method 'handle-post-collision-logic'\n         */\n        \"handle-post-collision-logic\": function () {\n            if (this.tryDrop) {\n                this.tryDrop = false;\n                if (this.hitSomething) {\n                    this.dropFailed = false;\n                    this.state.set('noDrop', true);\n                    this.state.set('dragging', true);\n                    this.owner.dragMode = true;\n                } else {\n                    this.state.set('noDrop', false);\n                    this.state.set('dragging', false);\n                    this.owner.dragMode = false;\n                }\n            } else if (this.hitSomething) {\n                this.state.set('noDrop', true);\n            }\n            this.hitSomething = false;\n        },\n\n        /**\n         * The pointerdown event fires when we're grabbing the object. Starts the drag.\n         *\n         * @method 'pointerdown'\n         * @param eventData {platypus.Data} The event data.\n         */\n        \"pointerdown\": function (eventData) {\n            if (this.sticking) {\n                this.sticking = false;\n                this.releasePointer();\n                this.release();\n            } else {\n                this.nextX = this.owner.x;\n                this.nextY = this.owner.y;\n                this.lastZ = this.owner.z;\n                this.grabOffsetX = (eventData.x >> 0) - this.owner.x;\n                this.grabOffsetY = (eventData.y >> 0) - this.owner.y;\n                this.state.set('dragging', true);\n                if (this.dragRenderParent !== this.owner.renderParent) {\n                    this.originalRenderParent = this.owner.renderParent;\n                    this.owner.parent.triggerEvent(\"set-parent-render-container\", this.owner, this.dragRenderParent);\n                }\n                this.owner.dragMode = true;\n                this.sticking = this.stickyClick;\n                if (this.sticking) {\n                    this.claimPointer();\n                }\n            }\n            \n            eventData.pixiEvent.stopPropagation();\n        },\n\n        /**\n         * The pressup event fires when we're trying to drop the object.\n         *\n         * @method 'pressup'\n         * @param eventData {platypus.Data} The event data.\n         */\n        \"pressup\": function (eventData) {\n            if (!this.sticking) {\n                this.release();\n            }\n            \n            eventData.pixiEvent.stopPropagation();\n        },\n\n        /**\n         * The pointermove event tells us when we're dragging a \"stickyClick\" object.\n         *\n         * @method 'pointermove'\n         * @param eventData {platypus.Data} The event data.\n         */\n        \"pointermove\": function (eventData) {\n            if (this.sticking) {\n                this.nextX = eventData.x - this.grabOffsetX;\n                this.nextY = eventData.y - this.grabOffsetY;\n                \n                eventData.event.preventDefault();\n                eventData.pixiEvent.stopPropagation();\n            }\n        },\n\n        /**\n         * The pressmove event tells us when we're dragging the object.\n         *\n         * @method 'pressmove'\n         * @param eventData {platypus.Data} The event data.\n         */\n        \"pressmove\": function (eventData) {\n            this.nextX = eventData.x - this.grabOffsetX;\n            this.nextY = eventData.y - this.grabOffsetY;\n            if (this.sticking && (this.nextX !== this.owner.x || this.nextY !== this.owner.y)) {\n                this.sticking = false;\n                this.releasePointer();\n            }\n            \n            eventData.event.preventDefault();\n            eventData.pixiEvent.stopPropagation();\n        },\n\n        /**\n         * This message comes from the collision system letting us know the object is currently in a location that it cannot be dropped.\n         *\n         * @method 'no-drop'\n         */\n        \"no-drop\": function () {\n            this.hitSomething = true;\n        }\n    },\n    \n    methods: {// These are methods that are called by this component.\n        checkCamera: function () {\n            if (this.state && this.state.get('dragging') && !this.aabb.containsPoint(this.nextX + this.grabOffsetX, this.nextY + this.grabOffsetY)) {\n                if (this.sticking) {\n                    this.sticking = false;\n                    this.releasePointer();\n                }\n                this.release();\n            }\n        },\n\n        claimPointer: function () {\n            this.lastHitArea = this.owner.container.hitArea;\n\n            this.owner.container.hitArea = claimHitArea; // capture all the clicks!\n        },\n\n        releasePointer: function () {\n            this.owner.container.hitArea = this.lastHitArea;\n        },\n\n        release: function () {\n            if (this.hasCollision) {\n                this.tryDrop = true;\n            } else {\n                this.state.set('noDrop', false);\n                this.state.set('dragging', false);\n                if (this.originalRenderParent) {\n                    this.owner.parent.triggerEvent(\"set-parent-render-container\", this.owner, this.originalRenderParent);\n                }\n                this.owner.dragMode = false;\n                this.owner.z = this.lastZ;\n            }\n            this.owner.triggerEvent('dropped', this.owner);\n        },\n        \n        destroy: function () {\n            this.state.set('dragging', false);\n            this.owner.dragMode = false;\n            this.state.set('noDrop', false);\n            this.state = null;\n            this.aabb.recycle();\n            this.aabb = null;\n            this.owner.z = this.lastZ;\n        }\n    }\n}));\n\n\n//# sourceURL=webpack://platypus/./src/components/LogicDragDrop.js?");

/***/ }),

/***/ "./src/components/LogicImpactLaunch.js":
/*!*********************************************!*\
  !*** ./src/components/LogicImpactLaunch.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Vector_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Vector.js */ \"./src/Vector.js\");\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../factory.js */ \"./src/factory.js\");\n/**\n# COMPONENT **LogicImpactLaunch**\nThis component will cause the entity to move in a certain direction on colliding with another entity.\n\n## Dependencies:\n- [[HandlerLogic]] (on entity's parent) - This component listens for a logic tick message to maintain and update its location.\n\n## Messages\n\n### Listens for:\n- **handle-logic** - On a `tick` logic message, the component updates its location according to its current state.\n- **impact-launch** - On receiving this message, the component causes the entity's position to change according to the preset behavior.\n  - @param collisionInfo.x (number) - Either 1,0, or -1. 1 if we're colliding with an object on our right. -1 if on our left. 0 if not at all.\n  - @param collisionInfo.y (number) - Either 1,0, or -1. 1 if we're colliding with an object on our bottom. -1 if on our top. 0 if not at all.\n- **hit-solid** - On receiving this message, the component discontinues its impact-launch behavior.\n  - @param collisionInfo.y (number) - Either 1,0, or -1. If colliding below, impact-launch behavior ceases.\n\n## JSON Definition:\n    {\n      \"type\": \"LogicImpactLaunch\",\n      \n      \"state\": \"launching\",\n      // Optional: This sets the state of the entity while it's being launched. Defaults to \"stunned\".\n      \n      \"accelerationX\": 5,\n      \"accelerationY\": 5,\n      // Optional: acceleration entity should have in world units while being launched. Defaults to -0.2 for x and -0.6 for y.\n      \n      \"flipX\": true,\n      \"flipY\": true\n      // Optional: whether the directions of acceleration should flip according to the direction of the collision. Defaults to false for y and true for x.\n    }\n\n*/\n/* global platypus */\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    return Object(_factory_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])({\n        id: 'LogicImpactLaunch',\n        \n        properties: {\n            accelerationX: -0.3,\n            accelerationY: -0.8,\n            flipX: true,\n            flipY: false\n        },\n        \n        initialize: function (definition) {\n            this.stunState = definition.state || \"stunned\";\n            \n            this.flipX = this.flipX ? -1 : 1;\n            this.flipY = this.flipY ? -1 : 1;\n\n            this.justJumped = false;\n            this.stunned = false;\n            \n            this.state = this.owner.state;\n            this.state.set('impact', false);\n            this.state.set(this.stunState, false);\n        },\n        \n        events: {\n            \"component-added\": function (component) {\n                if (component === this) {\n                    if (!this.owner.addMover) {\n                        platypus.debug.warn('The \"LogicDirectionalMovement\" component requires a \"Mover\" component to function correctly.');\n                        return;\n                    }\n\n                    this.direction = this.owner.addMover({\n                        velocity: [0, 0, 0],\n                        orient: false\n                    }).velocity;\n                    this.vector = _Vector_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp();\n                }\n            },\n\n            \"handle-logic\": function () {\n                this.state.set('impact', this.justJumped);\n                this.state.set(this.stunState, this.stunned);\n\n                if (this.justJumped) {\n                    this.direction.setVector(this.vector);\n                    this.justJumped = false;\n                    this.stunned = true;\n                }\n            },\n            \n            \"impact-launch\": function (collisionInfo) {\n                var dx = collisionInfo.x,\n                    dy = collisionInfo.y;\n                \n                if (collisionInfo.entity) {\n                    dx = collisionInfo.entity.x - this.owner.x;\n                    dy = collisionInfo.entity.y - this.owner.y;\n                }\n\n                if (!this.stunned) {\n                    this.justJumped = true;\n                    if (dx >= 0) {\n                        this.vector.x = this.accelerationX;\n                    } else if (dx < 0) {\n                        this.vector.x = this.accelerationX * this.flipX;\n                    }\n                    if (dy >= 0) {\n                        this.vector.y = this.accelerationY;\n                    } else if (dy < 0) {\n                        this.vector.y = this.accelerationY * this.flipY;\n                    }\n                }\n            },\n            \n            \"hit-solid\": function (collisionInfo) {\n                if (this.stunned && (collisionInfo.y > 0)) {\n                    this.direction.x = 0;\n                    this.direction.y = 0;\n                    this.stunned = false;\n                }\n            }\n        },\n        \n        methods: {\n            destroy: function () {\n                this.vector.recycle();\n                this.state = null;\n            }\n        }\n    });\n}());\n\n\n//# sourceURL=webpack://platypus/./src/components/LogicImpactLaunch.js?");

/***/ }),

/***/ "./src/components/LogicPacingPlatform.js":
/*!***********************************************!*\
  !*** ./src/components/LogicPacingPlatform.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../factory.js */ \"./src/factory.js\");\n/**\n# COMPONENT **LogicPacingPlatform**\nThis component changes the (x, y) position of an object according to its speed and heading and alternates back and forth. This is useful for in-place moving platforms.\n\n## Dependencies:\n- [[HandlerLogic]] (on entity's parent) - This component listens for a logic tick message to maintain and update its location.\n\n## Messages\n\n### Listens for:\n- **handle-logic** - On a `tick` logic message, the component updates its location according to its current state.\n  - @param message.delta - To determine how far to move the entity, the component checks the length of the tick.\n\n## JSON Definition:\n    {\n      \"type\": \"LogicDirectionalMovement\",\n      \n      \"angle\": 3.14,\n      // Optional. Defines the angle of movement in radians. Defaults to 0 (horizontal, starts moving right).\n      \n      \"distance\": 440,\n      // Optional. Declares distance in world units that the entity should move back and forth across. Defaults to 128.\n      \n      \"period\": 6000,\n      // Optional. Sets the time in milliseconds that the entity should take to make a complete movement cycle. Defaults to 4 seconds (4000).\n      \n      \"startPos\": 0\n      // Optional. Position in the cycle that the movement should begin. Defaults in the middle at 0; PI/2 and -PI/2 will put you at the extremes.\n    }\n*/\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    return Object(_factory_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        \n        id: 'LogicPacingPlatform',\n        \n        initialize: function (definition) {\n            this.ang      = this.owner.angle      || definition.angle     || 0; //PI/2 makes it go down first\n            this.dist     = this.owner.distance || definition.distance || 128; //Distance in pixels\n            this.dX       = this.dist * Math.cos(this.ang);\n            this.dY       = this.dist * Math.sin(this.ang);\n            this.period   = this.owner.period    || definition.period     || 4000;\n            this.time     = 0;\n            this.startPos = this.owner.startPos || definition.startPos || 0; //PI/2 and -PI/2 will put you at the extremes\n            this.offset   = 0;\n            this.originX  = this.owner.x;\n            this.originY  = this.owner.y;\n        },\n\n        events: {// These are messages that this component listens for\n            \"handle-logic\": function (update) {\n                var period = this.period,\n                    delta = update.delta;\n                \n                this.time += delta;\n                if (this.time > period) {\n                    this.time = this.time % period;\n                }\n                this.offset = (this.time / period) * (2 * Math.PI);\n                \n                this.owner.x = this.originX + Math.sin(this.offset + this.startPos) * this.dX;\n                this.owner.y = this.originY + Math.sin(this.offset + this.startPos) * this.dY;\n            }\n        }\n    });\n}());\n\n\n//# sourceURL=webpack://platypus/./src/components/LogicPacingPlatform.js?");

/***/ }),

/***/ "./src/components/LogicPortable.js":
/*!*****************************************!*\
  !*** ./src/components/LogicPortable.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../factory.js */ \"./src/factory.js\");\n/**\n * This component allows this entity to be carried by other entities with which it collides. Entities that should carry this entity need to have a [[Logic-Carrier]] component attached.\n *\n * @namespace platypus.components\n * @class LogicPortable\n * @uses platypus.Component\n */\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    return Object(_factory_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        id: 'LogicPortable',\n        properties: {\n            /**\n             * This is an object specifying the directions that this portable entity can be carried on. Default is {down:true}, but \"up\", \"down\", \"left\", and/or \"right\" can be specified as object properties set to `true`.\n             *\n             * @property portableDirections\n             * @type Object\n             * @default {\"down\": true}\n             */\n            portableDirections: {\n                down: true //default is false, 'true' means as soon as carrier is connected downward\n            }\n        },\n        initialize: function () {\n            this.carrier = this.lastCarrier = null;\n            this.message = {\n                entity: this.owner\n            };\n        },\n        events: {\n            /**\n             * On receiving this message, this component triggers 'carry-me' or 'release-me' if its connection to a carrying entity has changed.\n             *\n             * @method 'handle-logic'\n             */\n            \"handle-logic\": function () {\n                var msg = this.message;\n                \n                if (this.carrierConnected) {\n                    if (this.carrier !== this.lastCarrier) {\n                        if (this.lastCarrier) {\n                            this.lastCarrier.triggerEvent('release-me', msg);\n                        }\n\n                        /**\n                         * This message is triggered on a potential carrying peer, notifying the peer that this entity is portable.\n                         *\n                         * @event 'carry-me'\n                         * @param message.entity {platypus.Entity} This entity, requesting to be carried.\n                         */\n                        this.carrier.triggerEvent('carry-me', msg);\n                    }\n                    \n                    this.carrierConnected = false;\n                } else if (this.carrier) {\n\n                    /**\n                     * This message is triggered on the current carrier, notifying them to release this entity.\n                     *\n                     * @event 'release-me'\n                     * @param message.entity {platypus.Entity} This entity, requesting to be released.\n                     */\n                    this.carrier.triggerEvent('release-me', msg);\n                    this.carrier = null;\n                }\n                this.lastCarrier = this.carrier;\n            },\n\n            /**\n             * On receiving this message, this component determines whether it is hitting its carrier or another entity. If it is hitting a new carrier, it will broadcast 'carry-me' on the next game step.\n             *\n             * @method 'hit-solid'\n             * @param collisionInfo.entity {platypus.Entity} The entity with which the collision occurred.\n             * @param collisionInfo.x {Number} -1, 0, or 1 indicating on which side of this entity the collision occurred: left, neither, or right respectively.\n             * @param collisionInfo.y {Number} -1, 0, or 1 indicating on which side of this entity the collision occurred: top, neither, or bottom respectively.\n             */\n            \"hit-solid\": function (collisionInfo) {\n                if (collisionInfo.y > 0) {\n                    this.updateCarrier(collisionInfo.entity, 'down');\n                } else if (collisionInfo.y < 0) {\n                    this.updateCarrier(collisionInfo.entity, 'up');\n                } else if (collisionInfo.x < 0) {\n                    this.updateCarrier(collisionInfo.entity, 'left');\n                } else if (collisionInfo.x > 0) {\n                    this.updateCarrier(collisionInfo.entity, 'right');\n                }\n            },\n\n            /**\n             * On receiving this message, this component immediately triggers 'release-me' on its owner's carrier.\n             *\n             * @method 'force-release'\n             */\n            \"force-release\": function () {\n                if (this.carrier) {\n                    this.carrier.triggerEvent('release-me', this.message);\n                }\n                this.carrier = null;\n                this.lastCarrier = this.carrier;\n                this.carrierConnected = false;\n            }\n        },\n        methods: {\n            updateCarrier: function (entity, direction) {\n                if (this.portableDirections[direction]) {\n                    if (entity) {\n                        if (entity !== this.carrier) {\n                            this.carrier = entity;\n                        }\n                        this.carrierConnected = true;\n                    }\n                }\n            }\n        }\n    });\n}());\n\n\n//# sourceURL=webpack://platypus/./src/components/LogicPortable.js?");

/***/ }),

/***/ "./src/components/LogicPortal.js":
/*!***************************************!*\
  !*** ./src/components/LogicPortal.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _DataMap_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../DataMap.js */ \"./src/DataMap.js\");\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../factory.js */ \"./src/factory.js\");\n/**\n# COMPONENT **LogicPortal**\nA component which changes the scene when activated. When the portal receives an occupied message it sends the entity in that message notifying it. This message is meant to give the entity a chance to activate the portal in the manner it wants. The portal can also be activated by simply telling it to activate.\n\n## Dependencies\n- [[HandlerLogic]] (on entity's parent) - This component listens for a \"handle-logic\" message it then checks to see if it should change the scene if the portal is activated.\n- [[SceneChanger]] (on entity) - This component listens for the \"new-scene\" message that the LogicPortal sends and actually handles the scene changing.\n- [[CollisionBasic]] (on entity) - Not required, but if we want the 'occupied-portal' call to fire on collision you'll need to have a CollisionBasic component on the portal.\n\n## Messages\n\n### Listens for:\n- **handle-logic** - Checks to see if we should change scene if the portal is activated.\n- **occupied-portal** - This message takes an entity and then sends the entity a 'portal-waiting' message. The idea behind this was that you could use it with collision. When an entity gets in front of the portal the collision sends this message, we then tell the entity that collided to do whatever it needs and then it calls back to activate the portal.\n  - @param message.entity (entity Object) - The entity that will receive the 'portal-waiting' message.\n- **activate-portal** - This message turns the portal on. The next 'handle-logic' call will cause a change of scene.\n\n### Local Broadcasts:\n- **new-scene** - Calls the 'SceneChanger' component to tell it to change scenes.\n  - @param object.destination (string) - The id of the scene that we want to go to.\n\n### Peer Broadcasts:\n- **portal-waiting** - Informs another object that the portal is waiting on it to send the activate message.\n  - @param entity - This is the portal entity. To be used so that the object can communicate with it directly.\n\n## JSON Definition\n    {\n      \"type\": \"name-of-component\",\n      \"destination\" : \"level-2\"\n      //Required - The destination scene to which the portal will take us. In most cases this will come into the portal from Tiled where you'll set a property on the portal you place.\n    }\n*/\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    return Object(_factory_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])({\n        id: 'LogicPortal',\n        initialize: function (definition) {\n            var i = 0,\n                entrants = definition.entrants || definition.entrant || 'no one',\n                state = this.owner.state;\n             \n            this.destination = this.owner.destination || definition.destination;\n            this.used = false;\n            this.ready = false;\n            this.wasReady = false;\n\n            this.entrants = _DataMap_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp();\n            if (Array.isArray(entrants)) {\n                for (i = 0; i < entrants.length; i++) {\n                    this.entrants.set(entrants[i], false);\n                }\n            } else {\n                this.entrants.set(entrants, false);\n            }\n            \n            this.state = state;\n\n            state.set('occupied', false);\n            state.set('ready', true);\n        },\n        events: {\n            \"handle-logic\": function () {\n                var entrants = this.entrants,\n                    keys = entrants.keys,\n                    i = keys.length,\n                    occupied = false,\n                    ready = true,\n                    state = this.state;\n                \n                if (!this.used && this.activated) {\n                    this.owner.triggerEvent(\"port-\" + this.destination);\n                    this.used = true;\n                } else if (this.ready && !this.wasReady) {\n                    this.owner.triggerEvent('portal-waiting');\n                    this.wasReady = true;\n                } else if (this.wasReady && !this.ready) {\n                    this.owner.triggerEvent('portal-not-waiting');\n                    this.wasReady = false;\n                }\n                \n                \n                //Reset portal for next collision run.\n                while (i--) {\n                    if (entrants[keys[i]]) {\n                        occupied = true;\n                        entrants.set(keys[i], false);\n                    } else {\n                        ready = false;\n                    }\n                }\n                state.set('occupied', occupied);\n                state.set('ready', ready);\n                this.ready = false;\n            },\n            \"occupied-portal\": function (collision) {\n                var entrants = this.entrants,\n                    keys = entrants.keys,\n                    i = keys.length;\n                \n                entrants.set(collision.entity.type, true);\n                \n                while (i--) {\n                    if (!entrants.get(keys[i])) {\n                        return;\n                    }\n                }\n                \n                this.ready = true;\n            },\n            \"activate-portal\": function () {\n                this.activated = true;\n            }\n        },\n        methods: {\n            destroy: function () {\n                this.state = null;\n                this.entrants.recycle();\n                this.entrants = null;\n            }\n        }\n    });\n}());\n\n\n//# sourceURL=webpack://platypus/./src/components/LogicPortal.js?");

/***/ }),

/***/ "./src/components/LogicPushable.js":
/*!*****************************************!*\
  !*** ./src/components/LogicPushable.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../factory.js */ \"./src/factory.js\");\n/**\n# COMPONENT **LogicPushable**\nA component that enables an entity to be pushed.\n\n## Dependencies\n- [[HandlerLogic]] (on entity's parent) - This component listens for a \"handle-logic\" message. It then moves the entity if it's being pushed.\n- [[CollisionBasic]] (on entity) - This component listens for messages from the CollisionBasic component. In particular 'hit-solid' and 'push-entity' are coming from collision.\n\n## Messages\n\n### Listens for:\n- **handle-logic** - Checks to see if we're being pushed. If so, we get pushed. Then resets values.\n  - @param resp.delta (number) - The time since the last tick.\n- **push-entity** - Received when we collide with an object that can push us. We resolve which side we're colliding on and set up the currentPushX and currentPushY values so we'll move on the handle-logic call.\n  - @param collisionInfo.x (number) - Either 1,0, or -1. 1 if we're colliding with an object on our right. -1 if on our left. 0 if not at all.\n  - @param collisionInfo.y (number) - Either 1,0, or -1. 1 if we're colliding with an object on our bottom. -1 if on our top. 0 if not at all.\n- **hit-solid** - Called when the entity collides with a solid object. Stops the object from being pushed further in that direction.\n  - @param collisionInfo.x (number) - Either 1,0, or -1. 1 if we're colliding with an object on our right. -1 if on our left. 0 if not at all.\n  - @param collisionInfo.y (number) - Either 1,0, or -1. 1 if we're colliding with an object on our bottom. -1 if on our top. 0 if not at all.\n\n## JSON Definition\n    {\n      \"type\": \"LogicPushable\",\n       \"xPush\" : .01,\n      //Optional - The distance per millisecond this object can be pushed in x. Defaults to .01.\n      \"yPush\" : .01,\n      //Optional - The distance per millisecond this object can be pushed in y. Defaults to .01.\n      \"push\" : .01\n      //Optional - The distance per millisecond this object can be pushed in x and y. Overwritten by the more specific values xPush and yPush. Defaults to .01.\n    }\n*/\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    var setMagnitude = function (direction, magnitude) {\n        return (direction / Math.abs(direction)) * magnitude;\n    };\n    \n    return Object(_factory_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])({\n        id: 'LogicPushable',\n        initialize: function (definition) {\n            this.yPush = definition.push || definition.yPush || 0;\n            this.xPush = definition.push || definition.xPush || 0.1;\n            if (definition.roll) {\n                this.radius = definition.radius || this.owner.radius || ((this.owner.width || this.owner.height || 2) / 2);\n                this.owner.orientation = this.owner.orientation || 0;\n            } else {\n                this.radius = 0;\n            }\n            this.currentPushX = 0;\n            this.currentPushY = 0;\n            this.lastX = this.owner.x;\n            this.lastY = this.owner.y;\n            this.pushers = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n        },\n        events: {\n            \"handle-logic\": function (resp) {\n                var i = 0,\n                    delta = resp.delta;\n                \n                if (this.currentPushY) {\n                    this.owner.y += setMagnitude(this.currentPushY, this.yPush * delta);\n                    this.currentPushY = 0;\n                }\n                if (this.currentPushX) {\n                    this.owner.x += setMagnitude(this.currentPushX, this.xPush * delta);\n                    this.currentPushX = 0;\n                }\n                if ((this.lastX !== this.owner.x) || (this.lastY !== this.owner.y)) {\n                    if (this.radius) {\n                        this.owner.orientation += (this.owner.x + this.owner.y - this.lastX - this.lastY) / this.radius;\n                    }\n                    this.lastX = this.owner.x;\n                    this.lastY = this.owner.y;\n                }\n                for (i = 0; i < this.pushers.length; i++) {\n                    this.pushers[i].triggerEvent('pushed', this.owner);\n                }\n                this.pushers.length = 0;\n            },\n            \"push-entity\": function (collisionInfo) {\n                var x = (collisionInfo.x || 0),\n                    y = (collisionInfo.y || 0);\n                \n                this.currentPushX -= x;\n                this.currentPushY -= y;\n                if ((this.yPush && y) || (this.xPush && x)) {\n                    this.pushers.push(collisionInfo.entity);\n                }\n            },\n            \"hit-solid\": function (collisionInfo) {\n                if (((collisionInfo.y > 0) && (this.vY > 0)) || ((collisionInfo.y < 0) && (this.vY < 0))) {\n                    this.vY = 0;\n                } else if (((collisionInfo.x < 0) && (this.vX < 0)) || ((collisionInfo.x > 0) && (this.vX > 0))) {\n                    this.vX = 0;\n                }\n                return true;\n            }\n        },\n        \n        methods: {\n            destroy: function () {\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.pushers);\n            }\n        }\n    });\n}());\n\n\n//# sourceURL=webpack://platypus/./src/components/LogicPushable.js?");

/***/ }),

/***/ "./src/components/LogicRebounder.js":
/*!******************************************!*\
  !*** ./src/components/LogicRebounder.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Vector_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Vector.js */ \"./src/Vector.js\");\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../factory.js */ \"./src/factory.js\");\n/**\n# COMPONENT **LogicRebounder**\nThis component works with `CollisionBasic` to cause entities to bounce away on solid collisions.\n\n## Dependencies\n- [[CollisionBasic]] - Relies on collision messages to perform rebounding movement.\n\n## Messages\n\n### Listens for:\n- **handle-logic** - On receiving this message, `LogicRebounder` clears its stored collision information.\n- **hit-static** - On receiving this message, `LogicRebounder` rebounds.\n  - @param message.direction (2d vector) - This is the direction in which the collision occurred, tangental to the impact interface.\n- **hit-non-static** - On receiving this message, `LogicRebounder` rebounds.\n  - @param message.direction (2d vector) - This is the direction in which the collision occurred, tangental to the impact interface.\n  - @param message.entity ([[entity]]) - This is the entity with which this entity is colliding.\n- **share-velocity** - On receiving this message, `LogicRebounder` stores collision information.\n  - @param entity ([[entity]]) - This is the entity with which this entity is colliding.\n\n### Peer Broadcasts:\n- **share-velocity** - This component triggers this message to prevent double collision calls.\n  - @param entity ([[entity]]) - This entity.\n\n## JSON Definition\n    {\n      \"type\": \"LogicRebounder\",\n      \n      \"mass\": 12,\n      // Optional. Relative size of the entity. Defaults to 1.\n      \n      \"elasticity\": 0.4\n      // Optional. Bounciness of the entity. Defaults to 0.8.\n    }\n*/\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    return Object(_factory_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({\n        id: 'LogicRebounder',\n        \n        initialize: function (definition) {\n            _Vector_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].assign(this.owner, 'velocity', 'dx', 'dy', 'dz');\n\n            this.owner.mass = this.owner.mass || definition.mass || 1;\n            this.elasticity = definition.elasticity || 0.8;\n            \n            this.v = _Vector_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp(0, 0, 0);\n            this.incidentVector = _Vector_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp(0, 0, 0);\n            \n            this.staticCollisionOccurred = false;\n            this.nonStaticCollisionOccurred = false;\n            \n            this.hitThisTick = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp();\n            this.otherV = _Vector_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp(0, 0, 0);\n            this.otherVelocityData = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp();\n        },\n\n        events: {// These are messages that this component listens for\n            \"handle-logic\": function () {\n                var i = 0;\n                \n                this.hitThisTick.length = 0;\n                for (i = 0; i < this.otherVelocityData.length; i++) {\n                    this.otherVelocityData[i].velocity.recycle();\n                }\n                this.otherVelocityData.length = 0;\n            },\n            \"hit-static\": function (collData) {\n                var magnitude = 0,\n                    other = collData.entity,\n                    x = 0;\n\n                for (x = 0; x < this.hitThisTick.length; x++) {\n                    if (other === this.hitThisTick[x]) {\n                        return;\n                    }\n                }\n                this.hitThisTick.push(other);\n                \n                this.v.setVector(this.owner.velocity);\n                this.incidentVector.setVector(collData.direction);\n                \n                magnitude = this.v.scalarProjection(this.incidentVector);\n                if (!isNaN(magnitude)) {\n                    this.incidentVector.scale(magnitude * (1 + this.elasticity));\n                    this.v.subtractVector(this.incidentVector);\n                }\n                \n                this.owner.velocity.setVector(this.v);\n            },\n            \"hit-non-static\": function (collData) {\n                var x = 0,\n                    other          = collData.entity,\n                    otherVSet      = false,\n                    relevantV      = 0,\n                    otherRelevantV = 0,\n                    reboundV       = 0;\n                \n                x = this.hitThisTick.indexOf(other);\n                if (x >= 0) {\n                    return;\n                }\n                this.hitThisTick.push(other);\n                \n                for (x = 0; x < this.otherVelocityData.length; x++) {\n                    if (other === this.otherVelocityData[x].entity) {\n                        this.otherV.setVector(this.otherVelocityData[x].velocity);\n                        otherVSet = true;\n                        break;\n                    }\n                }\n                \n                if (!otherVSet) {\n                    this.otherV.setVector(other.velocity);\n                    other.triggerEvent('share-velocity', this.owner);\n                }\n                \n                this.v.setVector(this.owner.velocity);\n                this.incidentVector.setVector(collData.direction);\n                \n                \n                relevantV = this.v.scalarProjection(this.incidentVector);\n                relevantV = (isNaN(relevantV)) ? 0 : relevantV;\n                otherRelevantV = this.otherV.scalarProjection(this.incidentVector);\n                otherRelevantV = (isNaN(otherRelevantV)) ? 0 : otherRelevantV;\n                \n                reboundV = (relevantV * (this.owner.mass - other.mass) + 2 * other.mass * otherRelevantV) / (this.owner.mass + other.mass);\n                \n                this.incidentVector.scale(reboundV - relevantV);\n                \n                this.owner.velocity.setVector(this.incidentVector);\n                \n            },\n            \"share-velocity\": function (other) {\n                this.otherVelocityData.push({\n                    entity: other,\n                    velocity: _Vector_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp(other.velocity)\n                });\n            }\n        },\n        \n        methods: {// These are methods that are called by this component.\n            destroy: function () {\n                this.v.recycle();\n                this.incidentVector.recycle();\n                this.otherV.recycle();\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].recycle(this.hitThisTick);\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].recycle(this.otherVelocityData);\n            }\n        },\n        \n        publicMethods: {// These are methods that are available on the entity.\n\n        }\n    });\n}());\n\n\n//# sourceURL=webpack://platypus/./src/components/LogicRebounder.js?");

/***/ }),

/***/ "./src/components/LogicRegionSpawner.js":
/*!**********************************************!*\
  !*** ./src/components/LogicRegionSpawner.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Entity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Entity.js */ \"./src/Entity.js\");\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../factory.js */ \"./src/factory.js\");\n/**\n# COMPONENT **LogicRegionSpawner**\nThis component spawns new entities within a given area at set intervals.\n\n## Dependencies\n- [[HandlerLogic]] (on entity's parent) - This component listens for a logic tick message to determine whether to spawn another entity.\n\n## Messages\n\n### Listens for:\n- **handle-logic** - On a `tick` logic message, the component determines whether to spawn another entity.\n  - @param message.delta - To determine whether to spawn, the component keeps a running count of tick lengths.\n\n## JSON Definition\n    {\n      \"type\": \"LogicRegionSpawner\",\n      // List all additional parameters and their possible values here.\n      \n      \"spawn\": \"teddy-bear\",\n      // Required. String identifying the type of entity to spawn.\n      \n      \"interval\": 30000,\n      // Optional. Time in milliseconds between spawning an entity. Defaults to 1000.\n      \n      \"regions\": {\n      // If spawning entity covers a large area, the spawned entities can be randomly spawned over a regional grid, so that the whole area gets a somewhat uniform coverage of spawned entities\n\n        \"width\": 4000,\n        \"height\": 5000,\n        // Optional. Dimensions of a spawning region in world units. Defaults to entity's dimensions. The entity's dimensions are sliced into chunks of this size for spawn distribution.\n      }\n    }\n*/\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    return Object(_factory_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({\n        \n        id: 'LogicRegionSpawner',\n        \n        initialize: function (definition) {\n            var x       = 0,\n                y       = 0,\n                columns = 1,\n                rows    = 1,\n                width   = 0,\n                height  = 0,\n                rw      = 0,\n                rh      = 0;\n            \n            this.spawnPosition = {\n                x: 0,\n                y: 0\n            };\n            this.spawnProperties = {\n                type: definition.spawn,\n                properties: this.spawnPosition\n            };\n            \n            this.regions = null;\n            this.usedRegions = null;\n            this.regionWidth = 0;\n            this.regionHeight = 0;\n            if (definition.regions) {\n                this.regions = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp();\n                this.usedRegions = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp();\n                this.regionWidth  = width  = definition.regions.width  || this.owner.width;\n                this.regionHeight = height = definition.regions.height || this.owner.height;\n                columns = Math.round(this.owner.width  / width);\n                rows    = Math.round(this.owner.height / height);\n                for (x = 0; x < columns; x++) {\n                    for (y = 0; y < rows; y++) {\n                        rw = Math.min(width,  this.owner.width  - x * width);\n                        rh = Math.min(height, this.owner.height - y * height);\n                        this.regions.push({\n                            x: x * width,\n                            y: y * height,\n                            width: rw,\n                            height: rh\n                        });\n                    }\n                }\n            }\n            \n            this.interval = this.owner.interval || definition.interval || 1000;\n            this.time = 0;\n        },\n\n        events: {// These are messages that this component listens for\n            \"handle-logic\": function (resp) {\n                var regions = this.regions,\n                    region  = null;\n                \n                this.time += resp.delta;\n                \n                if (this.time > this.interval) {\n                    this.time -= this.interval;\n                    \n                    if (regions) {\n                        if (!regions.length) {\n                            this.regions = this.usedRegions;\n                            this.usedRegions = regions;\n                            regions = this.regions;\n                        }\n                        \n                        region = regions[Math.floor(regions.length * Math.random())];\n                        \n                        this.spawnPosition.x = this.owner.x - (this.owner.regX || 0) + (region.x + (Math.random() * region.width));\n                        this.spawnPosition.y = this.owner.y - (this.owner.regY || 0) + (region.y + (Math.random() * region.height));\n                    } else {\n                        this.spawnPosition.x = this.owner.x - (this.owner.regX || 0) + (Math.random() * this.owner.width);\n                        this.spawnPosition.y = this.owner.y - (this.owner.regY || 0) + (Math.random() * this.owner.height);\n                    }\n\n                    this.owner.parent.addEntity(this.spawnProperties);\n                }\n            }\n        },\n        \n        methods: {\n            destroy: function () {\n                if (this.regions) {\n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].recycle(this.regions);\n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].recycle(this.usedRegions);\n                }\n            }\n        },\n        \n        getAssetList: function (def, props, defaultProps) {\n            var spawn = def.spawn || props.spawn || defaultProps.spawn;\n            \n            if (spawn) {\n                return _Entity_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getAssetList({\n                    type: spawn\n                });\n            }\n            \n            return _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp();\n        }\n    });\n}());\n\n\n//# sourceURL=webpack://platypus/./src/components/LogicRegionSpawner.js?");

/***/ }),

/***/ "./src/components/LogicRotationalMovement.js":
/*!***************************************************!*\
  !*** ./src/components/LogicRotationalMovement.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../factory.js */ \"./src/factory.js\");\n/**\n * This component changes the (x, y) position of an object according to its current speed and heading. It maintains its own heading information independent of other components allowing it to be used simultaneously with other logic components like [[Logic-Pushable]]. It accepts directional messages that can stand alone, or come from a mapped controller, in which case it checks the `pressed` value of the message before changing its course accordingly.\n *\n * @namespace platypus.components\n * @class LogicRotationalMovement\n * @uses platypus.Component\n */\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    const\n        cos = Math.cos,\n        sin = Math.sin,\n        polarToCartesianX = function (m, a) {\n            return m * cos(a);\n        },\n        polarToCartesianY = function (m, a) {\n            return m * sin(a);\n        };\n    \n    return Object(_factory_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        id: 'LogicRotationalMovement',\n\n        properties: {\n            /**\n             * Defines the distance in world units that the entity should be moved per millisecond.\n             *\n             * @property speed\n             * @type Number\n             * @default 0.3\n             */\n            \"speed\": 0.3,\n            \n            /**\n             * Radian orientation that entity should begin in. Defaults to 0 (facing right).\n             *\n             * @property angle\n             * @type Number\n             * @default 0\n             */\n            \"angle\": 0,\n            \n            /**\n             * Unit in radians that the angle should change per millisecond.\n             *\n             * @property degree\n             * @type Number\n             * @default 1\n             */\n            \"degree\": 1\n        },\n\n        initialize: function () {\n            var state = this.owner.state;\n            \n            this.magnitude = 0;\n            \n            this.state = state;\n            state.set('moving', false);\n            state.set('turningRight', false);\n            state.set('turningLeft', false);\n    \n            this.owner.orientation  = 0;\n            \n            this.moving = false;\n            this.turningRight = false;\n            this.turningLeft = false;\n        },\n        events: {\n            /**\n             * On receiving this event, the component updates its location according to its current state.\n             *\n             * @method 'handle-logic'\n             * @param tick.delta {Number} To determine how far to move the entity, the component checks the length of the tick.\n             */\n            \"handle-logic\": function (tick) {\n                var state = this.state;\n                \n                if (this.turningRight) {\n                    this.angle += this.degree * tick.delta / 15;\n                }\n        \n                if (this.turningLeft) {\n                    this.angle -= this.degree * tick.delta / 15;\n                }\n                \n                if (this.moving) {\n                    this.owner.x += (polarToCartesianX(this.magnitude, this.angle) * tick.delta);\n                    this.owner.y += (polarToCartesianY(this.magnitude, this.angle) * tick.delta);\n                }\n                \n                state.set('moving', this.moving);\n                state.set('turningLeft', this.turningLeft);\n                state.set('turningRight', this.turningRight);\n                \n                if (this.owner.orientation !== this.angle * Math.PI / 180) {\n                    this.owner.orientation = this.angle * Math.PI / 180;\n                    this.owner.triggerEvent('orientation-updated');\n                }\n            },\n\n            /**\n             * This rotates the entity by a delta in radians.\n             *\n             * @method 'rotate'\n             * @param angleDelta {Number} The change in angle.\n             */\n            \"rotate\": function (angleDelta) {\n                this.angle += angleDelta;\n            },\n\n            /**\n             * On receiving this event, the entity turns right.\n             *\n             * @method 'turn-right'\n             * @param [state.pressed] {boolean} If `state` is included, the component checks the value of `pressed`: true causes movement in the triggered direction, false turns off movement in that direction. Note that if no message is included, the only way to stop movement in a particular direction is to trigger `stop` on the entity before progressing in a new orientation.\n             */\n            \"turn-right\": function (state) {\n                if (state) {\n                    this.turningRight = state.pressed;\n                } else {\n                    this.turningRight = true;\n                }\n            },\n\n            /**\n             * On receiving this event, the entity turns left.\n             *\n             * @method 'turn-left'\n             * @param [state.pressed] {boolean} If `state` is included, the component checks the value of `pressed`: true causes movement in the triggered direction, false turns off movement in that direction. Note that if no message is included, the only way to stop movement in a particular direction is to trigger `stop` on the entity before progressing in a new orientation.\n             */\n            \"turn-left\": function (state) {\n                if (state) {\n                    this.turningLeft = state.pressed;\n                } else {\n                    this.turningLeft = true;\n                }\n            },\n\n            /**\n             * On receiving this event, the entity goes forward.\n             *\n             * @method 'go-forward'\n             * @param [state.pressed] {boolean} If `state` is included, the component checks the value of `pressed`: true causes movement in the triggered direction, false turns off movement in that direction. Note that if no message is included, the only way to stop movement in a particular direction is to trigger `stop` on the entity before progressing in a new orientation.\n             */\n            \"go-forward\": function (state) {\n                if (!state || state.pressed) {\n                    this.moving = true;\n                    this.magnitude = this.speed;\n                } else {\n                    this.moving = false;\n                }\n            },\n\n            /**\n             * On receiving this event, the entity goes backward.\n             *\n             * @method 'go-backward'\n             * @param [state.pressed] {boolean} If `state` is included, the component checks the value of `pressed`: true causes movement in the triggered direction, false turns off movement in that direction. Note that if no message is included, the only way to stop movement in a particular direction is to trigger `stop` on the entity before progressing in a new orientation.\n             */\n            \"go-backward\": function (state) {\n                if (!state || state.pressed) {\n                    this.moving = true;\n                    this.magnitude = -this.speed;\n                } else {\n                    this.moving = false;\n                }\n            },\n\n            /**\n             * Stops rotational and linear motion until movement messages are again received.\n             *\n             * @method 'stop'\n             * @param [state.pressed] {Boolean} If `state` is included, the component checks the value of `pressed`: a value of false will not stop the entity.\n             */\n            \"stop\": function (state) {\n                if (!state || state.pressed) {\n                    this.moving = false;\n                    this.turningLeft = false;\n                    this.turningRight = false;\n                }\n            },\n\n            /**\n             * Stops linear motion until movement messages are again received.\n             *\n             * @method 'stop-moving'\n             * @param [state.pressed] {Boolean} If `state` is included, the component checks the value of `pressed`: a value of false will not stop the entity.\n             */\n            \"stop-moving\": function (state) {\n                if (!state || state.pressed) {\n                    this.moving = false;\n                }\n            },\n\n            /**\n             * Stops rotational motion until movement messages are again received.\n             *\n             * @method 'stop-turning'\n             * @param [state.pressed] {Boolean} If `state` is included, the component checks the value of `pressed`: a value of false will not stop the entity.\n             */\n            \"stop-turning\": function (state) {\n                if (!state || state.pressed) {\n                    this.turningLeft = false;\n                    this.turningRight = false;\n                }\n            }\n        },\n        \n        methods: {\n            destroy: function () {\n                this.state = null;\n            }\n        }\n    });\n}());\n\n\n//# sourceURL=webpack://platypus/./src/components/LogicRotationalMovement.js?");

/***/ }),

/***/ "./src/components/LogicSpawner.js":
/*!****************************************!*\
  !*** ./src/components/LogicSpawner.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Entity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Entity.js */ \"./src/Entity.js\");\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../factory.js */ \"./src/factory.js\");\n/**\n# COMPONENT **LogicSpawner**\nThis component creates an entity and propels it away. This is useful for casting, firing, tossing, and related behaviors.\n\n## Dependencies:\n- [[HandlerLogic]] (on entity's parent) - This component listens for a logic tick message to determine whether it should be spawning or not.\n\n## Messages\n\n### Listens for:\n- **handle-logic** - On a `tick` logic message, the component checks its current state to decide whether to spawn entities.\n- **spawn** - creates an entity on the following tick message.\n  - @param message.pressed (boolean) - Optional. If `message` is included, the component checks the value of `pressed`: false results in no entities being created. Is this primarily for controller input.\n\n## JSON Definition\n    {\n      \"type\": \"LogicSpawner\"\n      // List all additional parameters and their possible values here.\n\n      \"spawneeClass\": \"wet-noodle\",\n      // Required: string identifying the type of entity to create.\n      \n      \"state\": \"tossing\",\n      // Optional. The entity state that should be true while entities are being created. Defaults to \"firing\".\n      \n      \"speed\": 4,\n      // Optional. The velocity with which the entity should start. Initial direction is determined by this entity's facing states (\"top\", \"right\", etc).\n      \n      \"offsetX\": 45,\n      \"offsetY\": -20,\n      // Optional. Location relative to the entity where the should be located once created. Defaults to (0, 0).\n    }\n*/\n/* global platypus */\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    return Object(_factory_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({\n        \n        id: 'LogicSpawner',\n        \n        initialize: function (definition) {\n            var className = this.owner.spawneeClass || definition.spawneeClass,\n                prop = '',\n                x = 0;\n\n            this.state = this.owner.state;\n            this.stateName = definition.state || 'spawning';\n            this.originalZ = (platypus.game.settings.entities[className] && platypus.game.settings.entities[className].properties && platypus.game.settings.entities[className].properties.z) || 0;\n            this.speed = definition.speed || this.owner.speed || 0;\n\n            this.state.set(this.stateName, false);\n            \n            this.spawneeProperties = {\n                x: 0,\n                y: 0,\n                z: 0,\n                dx: 0,\n                dy: 0,\n                spawner: this.owner\n            };\n            \n            if (definition.passOnProperties) {\n                for (x = 0; x < definition.passOnProperties.length; x++) {\n                    prop = definition.passOnProperties[x];\n                    if (this.owner[prop]) {\n                        this.spawneeProperties[prop] = this.owner[prop];\n                    }\n                }\n            }\n            \n            \n            this.propertiesContainer = {\n                type: className,\n                properties: this.spawneeProperties\n            };\n            \n            this.offsetX = this.owner.offsetX || definition.offsetX || 0;\n            this.offsetY = this.owner.offsetY || definition.offsetY || 0;\n            \n            this.firing = false;\n        },\n\n        events: {// These are messages that this component listens for\n            \"handle-logic\": function () {\n                var offset = 0,\n                    state  = this.state;\n                \n                if (this.firing) {\n                    this.spawneeProperties.x = this.owner.x;\n                    this.spawneeProperties.y = this.owner.y;\n                    this.spawneeProperties.z = this.owner.z + this.originalZ;\n                    \n                    offset = this.offsetX;\n                    if (state.get('left')) {\n                        offset *= -1;\n                    }\n                    this.spawneeProperties.x += offset;\n                    \n                    offset = this.offsetY;\n                    if (state.get('top')) {\n                        offset *= -1;\n                    }\n                    this.spawneeProperties.y += offset;\n                    \n                    if (this.speed) {\n                        if (state.get('top')) {\n                            this.spawneeProperties.dy = -this.speed;\n                        } else if (state.get('bottom')) {\n                            this.spawneeProperties.dy = this.speed;\n                        } else {\n                            delete this.spawneeProperties.dy;\n                        }\n                        if (state.get('left')) {\n                            this.spawneeProperties.dx = -this.speed;\n                        } else if (state.get('right')) {\n                            this.spawneeProperties.dx = this.speed;\n                        } else {\n                            delete this.spawneeProperties.dx;\n                        }\n                    } else {\n                        delete this.spawneeProperties.dx;\n                        delete this.spawneeProperties.dy;\n                    }\n                    \n                    this.parent.addEntity(this.propertiesContainer);\n                }\n                \n                state.set(this.stateName, this.firing);\n\n                this.firing = false;\n            },\n            \"spawn\": function (value) {\n                this.firing = !value || (value.pressed !== false);\n                \n                this.parent = this.owner.parent; //proofing against this entity being destroyed prior to spawned entity. For example, when a destroyed entity spawns a drop.\n            }\n        },\n        \n        methods: {\n            destroy: function () {\n                this.state = null;\n            }\n        },\n        \n        getAssetList: function (def, props, defaultProps) {\n            var spawn = def.spawneeClass || props.spawneeClass || defaultProps.spawneeClass;\n            \n            if (spawn) {\n                return _Entity_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getAssetList({\n                    type: spawn\n                });\n            }\n            \n            return _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp();\n        }\n    });\n}());\n\n\n//# sourceURL=webpack://platypus/./src/components/LogicSpawner.js?");

/***/ }),

/***/ "./src/components/LogicStateMachine.js":
/*!*********************************************!*\
  !*** ./src/components/LogicStateMachine.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var _DataMap_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../DataMap.js */ \"./src/DataMap.js\");\n/* harmony import */ var _StateMap_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../StateMap.js */ \"./src/StateMap.js\");\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../factory.js */ \"./src/factory.js\");\n/**\n# COMPONENT **LogicStateMachine**\nThis component is a general purpose state-machine for an entity, taking in various message inputs to determine the entity's state and triggering messages as necessary when a certain state occurs or several state combinations are in place.\n\n## Dependencies:\n- [[HandlerLogic]] (on entity's parent) - This component listens for a logic tick message to maintain and update its location.\n\n## Messages\n\n### Listens for:\n- **handle-logic** - On a `tick` logic message, the component checks sustained inputs for changes in state.\n- **update-state** - Updates the entity's state according to this message's state information.\n  - @param message (object) - This is an object of key/value pairs where keys are states and the values are booleans to turn on and off states.\n- **state-changed** - Updates the entity's state according to this message's state information, and broadcasts any applicable messages.\n  - @param message (object) - This is an object of key/value pairs where keys are states and the values are booleans to turn on and off states.\n- **[input messages]** - This component listens for messages as determined by the JSON settings.\n\n### Local Broadcasts:\n- **[output messages]** - This component triggers output messages as determined by the JSON settings.\n\n## JSON Definition\n    {\n      \"type\": \"LogicStateMachine\",\n      \n      \"inputs\":{\n      // This is a list of messages that this component should listen for to change states.\n      \n        \"smell-toast\":{\n        // If the entity triggers \"smell-toast\", this component will change the state of the entity as follows:\n        \n          \"smelling-food\": true,\n          \"smelling-nothing\": false\n        },\n        \n        \"go-to-store\":{\n          \"at-store\": true\n        }\n      },\n      \n      \"sustained-inputs\":{\n      // These are messages that must be triggered every tick for the state to remain true: if not, they become false.\n        \"near-grover\": \"smelling-trash\"\n      }\n    }\n*/\n\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    var changeState = function (changes, state) {\n            state.update(changes);\n        },\n        changeSustainedState = function (change, state) {\n            state.set(change, true);\n        },\n        handleResult = null,\n        handleOutput = null,\n        setUpOutputs = function (outs) {\n            var data = null,\n                key = '';\n            \n            if (!outs || (typeof outs !== 'object') || Array.isArray(outs) || outs.event) {\n                return outs;\n            } else {\n                data = _DataMap_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp();\n                for (key in outs) {\n                    if (outs.hasOwnProperty(key)) {\n                        data.set(key, setUpOutputs(outs[key]));\n                    }\n                }\n                return data;\n            }\n        },\n        recycleOutputs = function (outs) {\n            var keys = outs.keys,\n                i = keys.length;\n\n            if (outs instanceof _DataMap_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]) {\n                while (i--) {\n                    recycleOutputs(outs[keys[i]]);\n                }\n                outs.recycle();\n            }\n        };\n    \n    handleResult = function (title, state, last, checks, changed, self, queue) {\n        var i = 0,\n            key = '',\n            keys = null,\n            message = checks.message || (checks.message === 0) || (checks.message === false),\n            value = null;\n\n        if (changed) {\n            if (typeof checks === 'string') {\n                self.triggerEvent(checks);\n                return;\n            } else if (Array.isArray(checks)) {\n                for (i = 0; i < checks.length; i++) {\n                    handleResult(title, state, last, checks[i], changed, self, queue);\n                }\n                return;\n            } else if (checks.event && (message || checks.delay)) {\n                if (checks.delay) {\n                    queue.push(checks);\n                } else {\n                    self.trigger(checks.event, checks.message);\n                }\n                return;\n            } else if (checks.get) {\n                value = checks.get('true');\n                if (value) {\n                    handleResult(title, state, last, value, changed, self, queue);\n                }\n            }\n        }\n\n        keys = checks.keys;\n        if (keys) {\n            i = keys.length;\n            while (i--) {\n                key = keys[i];\n                if (key !== 'true') {\n                    handleOutput(key, state, last, checks.get(key), changed, self, queue);\n                }\n            }\n        }\n    };\n    \n    handleOutput = function (title, state, last, checks, changed, self, queue) {\n        var c     = changed,\n            value = false,\n            st = \"\",\n            stateValue = false;\n\n        if (title.charAt(0) === '!') {\n            st = title.substring(1);\n            stateValue = state.get(st);\n            value = (stateValue === false);\n            if ((title !== 'outputs') && (last.get(st) !== stateValue)) {\n                c = true;\n            }\n        } else {\n            stateValue = state.get(title);\n            value = (stateValue === true);\n            if ((title !== 'outputs') && (last.get(title) !== stateValue)) {\n                c = true;\n            }\n        }\n\n        if (value || (title === 'outputs')) {\n            handleResult(title, state, last, checks, c, self, queue);\n        }\n    };\n\n    return Object(_factory_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])({\n        id: 'LogicStateMachine',\n        \n        properties: {\n            /**\n             * This is the list of events containing key/value pairs that describe state changes to make for the given event.\n             *\n             *     {\n             *         \"smell-toast\": {\n             *             \"smelling-food\": true,\n             *             \"smelling-nothing\": false\n             *         },\n             *         \"go-to-store\": {\n             *             \"at-store\": true\n             *         }\n             *     }\n             *\n             * @property inputs\n             * @type Object\n             * @default null\n             */\n            inputs: null,\n            \n            /**\n             * These are messages that should be triggered when certain conditions are met. The messages are only triggered the instant the condition is met, until the conditions are no longer met and then once again met. Example:\n             *\n             *     {\n             *         \"smelling-food\": { // Keys map to states, and if true, the value of the key is processed. In this case, the value of the \"smelling-food\" key is another object of key/value pairs, giving us another layer of checks.\n             *             \"!smelling-trash\": \"time-to-eat\", // This key is an inverse check, meaning that the \"smelling-trash\" state of the entity must be false to continue along this path. This time the value is a string, so the string \"time-to-eat\" is treated as a message to be broadcast if the entity is both \"smelling-food\" and not \"smelling-trash\".\n             *             \"true\": \"belly-rumble\" // In some cases, a message should be triggered for a set of states, while still doing deeper state checks like above. \"true\" will always handle the next layer of values if the parent key was true.\n             *         },\n             *         \"smelling-trash\": \"feeling-sick\" // Multiple states can be handled to multiple depths, like a list of if () statements\n             *         \"!smelling-nothing\": {\n             *             \"!smelling-trash\":{\n             *                 \"!at-store\": \"go-to-store\", // Note that the \"go-to-store\" message will change this entity's state to \"at-store\" according to \"inputs\" above, but LogicStateMachine uses a cache of states when broadcasting output messages, so the next section will not be processed until the next state check.\n             *                 \"at-store\":{\n             *                     \"have-money\": \"buy-more-food\",\n             *                     \"!have-money\": \"buy-less-food\"\n             *                 }\n             *             }\n             *         }\n             *     }\n             *\n             * @property outputs\n             * @type Object\n             * @default null\n             */\n            outputs: null\n        },\n        \n        initialize: function (definition) {\n            var i = 0,\n                inputDefinition = this.inputs,\n                key = '',\n                keys = null,\n                state = null,\n                stateObjects = null,\n                susDef = definition[\"sustained-inputs\"],\n                thisState = this.owner.state;\n            \n            this.state = thisState;\n            \n            if (inputDefinition) {\n                stateObjects = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n                for (key in inputDefinition) {\n                    if (inputDefinition.hasOwnProperty(key)) {\n                        state = _StateMap_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(inputDefinition[key]);\n                        stateObjects.push(state);\n                        this.addEventListener(key, changeState.bind(this, state, thisState));\n                        keys = state.keys;\n                        i = keys.length;\n                        while (i--) {\n                            if (!thisState.has(keys[i])) { // set initial value to false if it's currently undefined.\n                                thisState.set(keys[i], false);\n                            }\n                        }\n                    }\n                }\n                this.stateObjects = stateObjects;\n            }\n\n            this.sustainedState = _StateMap_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp();\n            if (susDef) {\n                for (key in susDef) {\n                    if (susDef.hasOwnProperty(key)) {\n                        this.addEventListener(key, changeSustainedState.bind(this, susDef[key], this.sustainedState));\n                        this.sustainedState.set(susDef[key], false);\n                        thisState.set(susDef[key], false);\n                    }\n                }\n            }\n\n            this.snapshot = _StateMap_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp();\n            this.last = _StateMap_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp();\n            this.queueTimes = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n            this.queue = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n            this.outputs = setUpOutputs(this.outputs);\n        },\n\n        events: {\n            \"handle-logic\": function (resp) {\n                var susState = this.sustainedState,\n                    key = '',\n                    keys = susState.keys,\n                    i = keys.length,\n                    state = this.state;\n                \n                while (i--) {\n                    key = keys[i];\n                    state.set(key, susState.get(key));\n                    susState.set(key, false);\n                }\n                \n                i = this.queue.length;\n                while (i--) {\n                    this.queueTimes[i] -= resp.delta;\n                    \n                    if (this.queueTimes[i] <= 0) {\n                        this.owner.trigger(this.queue[i].event, this.queue[i].message);\n                        Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSplice\"])(this.queueTimes, i);\n                        Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSplice\"])(this.queue, i);\n                    }\n                }\n            },\n            \n            \"update-state\": function (state) {\n                this.state.update(state);\n            },\n            \n            \"state-changed\": function (state) {\n                var i = 0,\n                    queue = null,\n                    ss = this.snapshot;\n                \n                if (this.outputs) {\n                    ss.update(state);\n                    \n                    queue = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n                    handleOutput('outputs', ss, this.last, this.outputs, false, this.owner, queue);\n                    i = queue.length;\n                    while (i--) {\n                        this.queue.push(queue[i]);\n                        this.queueTimes.push(queue[i].delay);\n                    }\n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(queue);\n                    \n                    this.last.update(ss);\n                }\n            }\n        },\n        \n        methods: {\n            destroy: function () {\n                var i = 0,\n                    so = this.stateObjects;\n                \n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.queueTimes);\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.queue);\n                \n                if (so) {\n                    i = so.length;\n                    while (i--) {\n                        so[i].recycle();\n                    }\n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(so);\n                    this.stateObjects = null;\n                }\n\n                this.sustainedState.recycle();\n                this.snapshot.recycle();\n                this.last.recycle();\n                \n                this.state = null;\n                this.inputs = null;\n            }\n        }\n    });\n}());\n\n\n//# sourceURL=webpack://platypus/./src/components/LogicStateMachine.js?");

/***/ }),

/***/ "./src/components/LogicSwitch.js":
/*!***************************************!*\
  !*** ./src/components/LogicSwitch.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../factory.js */ \"./src/factory.js\");\n/**\n# COMPONENT **LogicSwitch**\nThis component serves as a switch in the game world, typically tied to collision events such that this entity changes state when another entity collides or passed over.\n\n## Dependencies:\n- [[HandlerLogic]] (on entity's parent) - This component listens for a logic tick message to maintain and update its state.\n\n## Messages\n\n### Listens for:\n- **handle-logic** - On a `tick` logic message, the component determines its state and triggers messages accordingly.\n- **switch-pressed** - Causes the switch to be in a pressed state.\n\n### Local Broadcasts:\n- **switch-on** - This message is triggered when the switch has just been pressed.\n- **switch-off** - This message is triggered when the switch has just been released.\n- **initial-press** - This message is triggered the first time the switch is pressed. This occurs before the \"switch-on\" message is triggered.\n\n## JSON Definition:\n    {\n      \"type\": \"LogicSwitch\",\n      \n      \"sticky\": true\n      // Optional. Whether a pressed switch should stay pressed once collision messages cease. Defaults to `false`.\n    }\n*/\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    return Object(_factory_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        \n        id: 'LogicSwitch',\n        \n        initialize: function (definition) {\n            this.state = this.owner.state;\n            this.pressed = false;\n            this.wasPressed = this.pressed;\n            this.sticky = definition.sticky || false;\n            this.state.set('pressed', false);\n            this.initialPress = true;\n        },\n\n        events: {// These are messages that this component listens for\n            \"handle-logic\": function () {\n                if (this.sticky) {\n                    if (this.pressed && !this.wasPressed) {\n                        this.state.set('pressed', true);\n                        this.wasPressed = true;\n                        this.owner.triggerEvent('switch-on');\n                    }\n                } else {\n                    if (this.pressed !== this.wasPressed) {\n                        if (this.pressed) {\n                            this.state.set('pressed', true);\n                            this.owner.triggerEvent('switch-on');\n                        } else {\n                            this.state.set('pressed', false);\n                            this.owner.triggerEvent('switch-off');\n                        }\n                    }\n                    this.wasPressed = this.pressed;\n                    this.pressed = false;\n                }\n            },\n            'switch-pressed': function () {\n                this.pressed = true;\n                if (this.initialPress) {\n                    this.owner.triggerEvent('initial-press');\n                    this.initialPress = false;\n                }\n            }\n        },\n        \n        methods: {\n            destroy: function () {\n                this.state = null;\n            }\n        }\n    });\n}());\n\n\n//# sourceURL=webpack://platypus/./src/components/LogicSwitch.js?");

/***/ }),

/***/ "./src/components/LogicTeleportee.js":
/*!*******************************************!*\
  !*** ./src/components/LogicTeleportee.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Vector_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Vector.js */ \"./src/Vector.js\");\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../factory.js */ \"./src/factory.js\");\n/**\n# COMPONENT **LogicTeleportee**\nThis component causes an entity to teleport when receiving a teleport message.\n\n## Dependencies:\n- [[CollisionBasic]] (on entity) - This component triggers \"relocate-entity\" to perform teleport, for which \"CollisionBasic\" listens.\n- [[HandlerLogic]] (on entity's parent) - This component listens for a logic tick message to maintain and update its location.\n\n## Messages\n\n### Listens for:\n- **handle-logic** - On a `tick` logic message, the component updates its location according to its current state.\n- **teleport** - Teleports the entity to its set destination.\n- **set-destination** - Sets the destination to teleport to in world coordinates.\n  - @param message.x, message.y (number) - The position in world coordinates to set the teleport destination to.\n- **hit-telepoint** - Sets the destination to the colliding entity's coordinates: useful for checkpoint behavior.\n  - @param message ([[Entity]]) - The entity whose coordinates will be the teleport destination.\n\n### Local Broadcasts:\n- **relocate-entity** - Broadcasts the new location for the entity.\n  - @param message.x, message.y (number) - The position in world coordinates to set the teleport destination to.\n- **teleport-complete** - Triggered once the entity has been moved to the new location.\n\n## JSON Definition\n    {\n      \"type\": \"LogicTeleportee\"\n    }\n*/\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    return Object(_factory_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])({\n        id: 'LogicTeleportee',\n        \n        initialize: function () {\n            this.teleportDestination = _Vector_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp();\n            this.teleportNow = false;\n            this.DestinationSet = false;\n            this.message = {\n                position: this.teleportDestination\n            };\n        },\n\n        events: {// These are messages that this component listens for\n            \"handle-logic\": function () {\n                if (this.teleportNow) {\n                    this.owner.triggerEvent('relocate-entity', this.message);\n                    this.teleportNow = false;\n                    this.owner.triggerEvent('teleport-complete');\n                }\n            },\n            \"teleport\": function () {\n                if (this.destinationSet) {\n                    this.teleportNow = true;\n                }\n            },\n            \"set-destination\": function (position) {\n                this.setDestination(position);\n            },\n            \"hit-telepoint\": function (collisionInfo) {\n                this.setDestination(collisionInfo.entity);\n            }\n        },\n        \n        methods: {\n            setDestination: function (position) {\n                this.teleportDestination.setXYZ(position.x, position.y, this.owner.z);\n                this.destinationSet = true;\n            },\n            \n            destroy: function () {\n                this.teleportDestination.recycle();\n            }\n        }\n    });\n}());\n\n\n//# sourceURL=webpack://platypus/./src/components/LogicTeleportee.js?");

/***/ }),

/***/ "./src/components/LogicTeleporter.js":
/*!*******************************************!*\
  !*** ./src/components/LogicTeleporter.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../factory.js */ \"./src/factory.js\");\n/**\n# COMPONENT **LogicTeleporter**\nThis component listens for redirected collision messages and fires a message on the colliding entity to specify where the colliding entity should relocate itself.\n\n## Dependencies:\n- [[Collision-Basic]] (on entity) - This component listens for collision messages on the entity.\n- [[Entity-Container]] (on entity's parent) - This component listens for new peer entities being added on its parent to find its teleport destination.\n\n## Messages\n\n### Listens for:\n- **peer-entity-added** - This teleporter listens as other entities are added so it can recognize the entity it should teleport colliding objects to.\n  - @param message (object) - expects an entity as the message object in order to determine whether it is the requested teleportation destination.\n- **teleport-entity** - On receiving this message, the component will fire `teleport` on the colliding entity, sending this.destination. The colliding entity must handle the `teleport` message and relocate itself.\n  - @param message.x (integer) - uses `x` to determine if collision occurred on the left (-1) or right (1) of this entity.\n  - @param message.y (integer) - uses `y` to determine if collision occurred on the top (-1) or bottom (1) of this entity.\n  - @param message.entity (object) - triggers a `teleport` message on `entity`.\n\n### Peer Broadcasts:\n- **teleport** - On receiving a `teleport-entity` message, if the colliding entity is colliding on the teleporter's facing side, this message is triggered on the colliding entity.\n  - @param message (object) - sends the destination entity as the message object, the x and y coordinates being the most important information for the listening entity.\n\n## JSON Definition:\n    {\n      \"type\": \"LogicTeleporter\",\n      \n      \"facing\": \"up\",\n      // Optional: \"up\", \"down\", \"left\", or \"right\". Will only trigger \"teleport\" if colliding entity collides on the facing side of this entity. If nothing is specified, all collisions fire a \"teleport\" message on the colliding entity.\n      \n      \"teleportId\": \"Destination entity's linkId property\"\n      // Required: String that matches the \"linkId\" property of the destination entity. This destination entity is passed on a \"teleport\" message so teleporting entity knows where to relocate.\n    }\n\n*/\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    return Object(_factory_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        id: 'LogicTeleporter',\n\n        initialize: function (definition) {\n            \n            this.destination = null;\n            this.linkId = this.owner.teleportId || definition.teleportId;\n            this.facing = this.owner.facing || definition.facing || false; //TODO: Should probably deprecate this in favor of orientation. - DDD 3/2/2016\n        \n            if (this.facing) {\n                this.owner.state.set('facing-' + this.facing, true);\n            }\n        },\n\n        events: {// These are messages that this component listens for\n            \"peer-entity-added\": function (entity) {\n                if (!this.destination && (entity.linkId === this.linkId)) {\n                    this.destination = entity;\n                }\n            },\n    \n            \"teleport-entity\": function (collisionInfo) {\n                switch (this.facing) {\n                case 'up':\n                    if (collisionInfo.y < 0) {\n                        collisionInfo.entity.triggerEvent('teleport', this.destination);\n                    }\n                    break;\n                case 'right':\n                    if (collisionInfo.x > 0) {\n                        collisionInfo.entity.triggerEvent('teleport', this.destination);\n                    }\n                    break;\n                case 'down':\n                    if (collisionInfo.y > 0) {\n                        collisionInfo.entity.triggerEvent('teleport', this.destination);\n                    }\n                    break;\n                case 'left':\n                    if (collisionInfo.x < 0) {\n                        collisionInfo.entity.triggerEvent('teleport', this.destination);\n                    }\n                    break;\n                default:\n                    collisionInfo.entity.triggerEvent('teleport', this.destination);\n                    break;\n                }\n            }\n        },\n        \n        methods: {// These are methods that are called on the component\n            \"destroy\": function () {\n                this.destination = null;\n            }\n        }\n        \n    });\n}());\n\n//# sourceURL=webpack://platypus/./src/components/LogicTeleporter.js?");

/***/ }),

/***/ "./src/components/LogicTimer.js":
/*!**************************************!*\
  !*** ./src/components/LogicTimer.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../factory.js */ \"./src/factory.js\");\n/**\n * A timer that can used to trigger events. The timer can increment and decrement. It can be an interval timer, going off over and over. Has a max time which it will not exceed by default this is 1 hour.\n *\n * @namespace platypus.components\n * @class LogicTimer\n * @uses platypus.Component\n */\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    return Object(_factory_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        id: 'LogicTimer',\n\n        properties: {\n            /**\n             * The starting time for the timer.\n             *\n             * @property time\n             * @type Number\n             * @default 0\n             */\n            time: 0,\n\n            /**\n             * The time when the alarm will trigger the alarm message. Defaults to `0``, which never triggers the alarm.\n             *\n             * @property alarmTime\n             * @type Number\n             * @default 0\n             */\n            alarmTime: 0,\n\n            /**\n             * Whether or not the alarm fires at intervals of the alarmTime.\n             *\n             * @property isInterval\n             * @type Boolean\n             * @default false\n             */\n            isInterval: false,\n\n            /**\n             * The message sent when the alarm goes off.\n             *\n             * @property alarmMessage\n             * @type String\n             * @default ''\n             */\n            alarmMessage: '',\n\n            /**\n             * The message sent when the timer updates.\n             *\n             * @property updateMessage\n             * @type String\n             * @default ''\n             */\n            updateMessage: '',\n\n            /**\n             * Whether the alarm starts on.\n             *\n             * @property isOn\n             * @type Boolean\n             * @default true\n             */\n            isOn: true,\n\n            /**\n             * Whether the timer is incrementing or decrementing. If the value is `false` it is decrementing.\n             *\n             * @property isIncrementing\n             * @type Boolean\n             * @default true\n             */\n            isIncrementing: true,\n\n            /**\n             * The max value in MS, positive or negative, that the timer will count to. Once reached, it stops counting. Defaults to one hour.\n             *\n             * @property maxTime\n             * @type Number\n             * @default 3600000\n             */\n            maxTime: 3600000,\n\n            /**\n             * Whether this alarm should reset to full initial time if restarted after being stopped.\n             *\n             * @property resetOnStop\n             * @type Boolean\n             * @default false\n             */\n            resetOnStop: false\n        },\n\n        initialize: function () {\n            this.prevTime = this.time;\n        },\n\n        events: {\n            /**\n             * This component listens for this event to perform countdown and trigger alarm as needed.\n             *\n             * @method 'handle-logic'\n             * @param {Number} tick.delta\n             */\n            \"handle-logic\": function (tick) {\n                if (this.isOn) {\n                    this.prevTime = this.time;\n                    if (this.isIncrementing) {\n                        this.time += tick.delta;\n                    } else {\n                        this.time -= tick.delta;\n                    }\n                    \n                    if (Math.abs(this.time) > this.maxTime) {\n                        //If the timer hits the max time we turn it off so we don't overflow anything.\n                        if (this.time > 0) {\n                            this.time = this.maxTime;\n                        } else if (this.time < 0) {\n                            this.time = -this.maxTime;\n                        }\n                        this.triggerEvent('stop-timer');\n                    }\n                    \n                    if (this.alarmTime !== 0) {\n                        if (this.isInterval) {\n                            if (this.isIncrementing) {\n                                if (Math.floor(this.time / this.alarmTime) > Math.floor(this.prevTime / this.alarmTime)) {\n                                    this.owner.trigger(this.alarmMessage);\n                                }\n                            } else if (Math.floor(this.time / this.alarmTime) < Math.floor(this.prevTime / this.alarmTime)) {\n                                this.owner.trigger(this.alarmMessage);\n                            }\n                        } else if (this.isIncrementing) {\n                            if (this.time > this.alarmTime && this.prevTime < this.alarmTime) {\n                                this.owner.trigger(this.alarmMessage);\n                            }\n                        } else if (this.time < this.alarmTime && this.prevTime > this.alarmTime) {\n                            this.owner.trigger(this.alarmMessage);\n                        }\n                    }\n                }\n                this.owner.trigger(this.updateMessage, {time: this.time});\n            },\n\n            /**\n             * Sets time for alarm.\n             *\n             * @method 'set-timer'\n             * @param {Number} data.time Time to set for alarm.\n             */\n            \"set-timer\": function (data) {\n                this.time = data.time;\n            },\n\n            /**\n             * Starts the timer's countdown.\n             *\n             * @method 'start-timer'\n             */\n            \"start-timer\": function () {\n                this.isOn = true;\n            },\n\n            /**\n             * Stops the timer's countdown. If `resetOnStop` is `true`, resets timer.\n             *\n             * @method 'stop-timer'\n             */\n            \"stop-timer\": function () {\n                this.isOn = false;\n                if (this.resetOnStop) {\n                    this.time = 0;\n                }\n            }\n        }\n    });\n}());\n\n\n//# sourceURL=webpack://platypus/./src/components/LogicTimer.js?");

/***/ }),

/***/ "./src/components/LogicWindUpRacer.js":
/*!********************************************!*\
  !*** ./src/components/LogicWindUpRacer.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../factory.js */ \"./src/factory.js\");\n/**\n * Replicates logic for a wind-up toy: listens for a wind-up message over a series of ticks to charge, and then begins racing once the charge is complete.\n *\n * @namespace platypus.components\n * @class LogicWindUpRacer\n * @uses platypus.Component\n */\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    return Object(_factory_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        \n        id: 'LogicWindUpRacer',\n        \n        properties: {\n            /**\n             * Velocity at which the entity should travel while racing.\n             *\n             * @property speed\n             * @type Number\n             * @default 0.3\n             */\n            speed: 0.3,\n            \n            /**\n             * Time in milliseconds that entity will race before coming to a stop.\n             *\n             * @property raceTime\n             * @type Number\n             * @default 5000\n             */\n            raceTime: 5000,\n            \n            /**\n             * Time in milliseconds that entity needs to receive wind-up calls before racing can begin.\n             *\n             * @property windTime\n             * @type Number\n             * @default 500\n             */\n            windTime: 500\n        },\n        \n        initialize: function () {\n            var thisState = this.owner.state;\n            \n            this.windProgress = 0;\n            \n            this.winding = false;\n            this.racing = false;\n            this.blocked = false;\n            this.right = false;\n            this.left = false;\n            \n            this.state = thisState;\n            thisState.set('windingUp', false);\n            thisState.set('racing', false);\n            thisState.set('blocked', false);\n        },\n\n        events: {\n            /**\n             * On a `tick` logic message, the component updates its charging counter if necessary.\n             *\n             * @method 'handle-logic'\n             * @param message.delta {Number} To determine how much to charge, the component checks the length of the tick.\n             */\n            \"handle-logic\": function (resp) {\n                var thisState = this.state;\n                \n                if (this.racing) {\n\n                    /**\n                     * This event is triggered when winding is finished and the entity begins racing.\n                     *\n                     * @event 'racing'\n                     */\n                    if (!this.blocked && this.right && thisState.get('right')) {\n                        this.owner.x += this.speed * resp.delta;\n                        this.owner.triggerEvent('racing');\n                    } else if (!this.blocked && this.left && thisState.get('left')) {\n                        this.owner.x -= this.speed * resp.delta;\n                        this.owner.triggerEvent('racing');\n                    } else {\n                        this.racing = false;\n\n                        /**\n                         * This event is triggered when the entity stops racing.\n                         *\n                         * @event 'stopped-racing'\n                         */\n                        this.owner.triggerEvent('stopped-racing');\n                    }\n                } else if (this.winding) {\n                    if ((this.right && thisState.get('right')) || (this.left && thisState.get('left'))) {\n                        this.windProgress += resp.delta;\n                    }\n\n                    /**\n                     * This event is triggered as the entity winds up.\n                     *\n                     * @event 'winding'\n                     * @param fraction {Number} The amount of progress that has been made from 0 to 1.\n                     */\n                    this.owner.triggerEvent('winding', this.windProgress / this.windTime);\n                } else if (this.windProgress) {\n                    if (this.windProgress >= this.windTime) {\n                        this.racing = true;\n                    }\n                    this.windProgress = 0;\n\n                    /**\n                     * This event is triggered when the entity stops winding.\n                     *\n                     * @event 'stopped-winding'\n                     */\n                    this.owner.triggerEvent('stopped-winding');\n                }\n                \n                thisState.set('windingUp', this.winding);\n                thisState.set('racing', this.racing);\n                thisState.set('blocked', this.blocked);\n                this.blocked = false;\n            },\n            \n            /**\n             * Causes the entity to stop racing.\n             *\n             * @method 'stop-racing'\n             */\n            \"stop-racing\": function () {\n                this.racing = false;\n                this.owner.triggerEvent('stopped-racing');\n            },\n            \n            /**\n             * Causes the entity to wind up for a race.\n             *\n             * @method 'wind-up'\n             * @param message.pressed {Boolean} If `message` is included, the component checks the value of `pressed`: `false` causes winding to stop.\n             */\n            \"wind-up\": function (value) {\n                this.winding = !value || (value.pressed !== false);\n                this.right = this.state.get('right');\n                this.left  = this.state.get('left');\n            },\n            \n            /**\n             * On receiving this message, the entity stops racing.\n             *\n             * @method 'hit-solid'\n             * @param collision.x {Number} Either 1,0, or -1. 1 if we're colliding with an object on our right. -1 if on our left. 0 if not at all.\n             */\n            \"hit-solid\": function (collision) {\n                if (collision.x) {\n                    if (this.racing && ((this.right && (collision.x > 0)) || (this.left && (collision.x < 0)))) {\n                        this.blocked = true;\n                        \n                        /**\n                         * This message is triggered if the entity collides while racing.\n                         *\n                         * @event 'blocked'\n                         * @param collision {platypus.CollisionData} Collision information from the entity or tile that blocked movement.\n                         */\n                        this.owner.triggerEvent('blocked', collision);\n                    }\n                }\n            }\n        },\n    \n        methods: {\n            destroy: function () {\n                this.state.set('windingUp', false);\n                this.state.set('racing', false);\n                this.state.set('blocked', false);\n                this.state = null;\n            }\n        }\n    });\n}());\n\n\n//# sourceURL=webpack://platypus/./src/components/LogicWindUpRacer.js?");

/***/ }),

/***/ "./src/components/Motion.js":
/*!**********************************!*\
  !*** ./src/components/Motion.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Vector_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Vector.js */ \"./src/Vector.js\");\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../factory.js */ \"./src/factory.js\");\n/**\n * This component works in tandem with the [Mover](platypus.components.Mover.html) component by adding a vector of motion to the entity. This component is typically created by `Mover` and doesn't need to be added separately.\n *\n * @namespace platypus.components\n * @class Motion\n * @uses platypus.Component\n */\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    var isTrue = function () {\n            return true;\n        },\n        getState = function (state, stateName) {\n            return state.get(stateName);\n        },\n        instantUpdate = function (getInstantState, getActiveVelocityState, instantSuccess) {\n            var state  = getInstantState(),\n                vState = getActiveVelocityState();\n            \n            if (this.activeVelocity) {\n                if (this.enact && !vState) { // Turn off ready if the state doesn't allow it.\n                    this.ready = false;\n                }\n\n                if (this.ready && this.enact && state) {\n                    this.ready = false; // to insure a single instance until things are reset\n                    this.velocity.setVector(this.instant);\n                    if (instantSuccess) {\n                        this.owner.triggerEvent(instantSuccess);\n                    }\n                } else if (!this.ready && !(this.enact && state)) {\n                    this.ready = true;\n                    this.decay();\n                } else if (vState) {\n                    return null;\n                }\n                return this.velocity;\n            } else {\n                return null;\n            }\n        },\n        gradualUpdate = function (getActiveVelocityState, delta) {\n            if (this.activeVelocity && getActiveVelocityState()) {\n                if (this.activeAcceleration) {\n                    this.move(delta);\n                }\n\n                return this.velocity;\n            } else {\n                return null;\n            }\n        },\n        createController = function (component, definition) {\n            var state = component.owner.state,\n                getActiveVelocityState = (definition.controlState ? getState.bind(null, state, definition.controlState) : isTrue),\n                getInstantState =        (definition.instantState ? getState.bind(null, state, definition.instantState) : isTrue);\n\n            if (component.instant || definition.instantState) {\n                component.instant = true;\n                component.update = instantUpdate.bind(component, getInstantState, getActiveVelocityState, definition.instantSuccess);\n            } else {\n                component.update = gradualUpdate.bind(component, getActiveVelocityState);\n            }\n        };\n    \n    return Object(_factory_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])({\n        \n        id: 'Motion',\n\n        properties: {\n            /**\n             * Whether this motion should automatically re-orient when the entity re-orients.\n             *\n             * @property orient\n             * @type boolean\n             * @default true\n             */\n            orient: true,\n            \n            /**\n             * A vector, Array, or number specifying the acceleration of the motion. Numbers apply magnitude along the x-axis. Arrays map to [x, y, z] on the vector.\n             *\n             * @property acceleration\n             * @type platypus.Vector|Array|number\n             * @default Vector(0, 0, 0)\n             */\n            acceleration: 0,\n            \n            /**\n             * Whether this motion should apply acceleration to the entity. Defaults to `true` unless an initial acceleration is left unset.\n             *\n             * @property activeAcceleration\n             * @type boolean\n             * @default true\n             */\n            activeAcceleration: true,\n            \n            /**\n             * Whether this motion should apply acceleration to the entity.\n             *\n             * @property activeVelocity\n             * @type boolean\n             * @default true\n             */\n            activeVelocity: true,\n            \n            /**\n             * This is the highest magnitude allowed for the motion vector.\n             *\n             * @property maxMagnitude\n             * @type number\n             * @default Infinity\n             */\n            maxMagnitude: Infinity,\n            \n            /**\n             * When this state on the entity changes, this motion's active state is changed to match. If an \"event\" property is also set on this component, both the event and the state must be true for the motion to be active.\n             *\n             * @property controlState\n             * @type String\n             * @default \"\"\n             */\n            controlState: \"\",\n            \n            /**\n             * If instant or instantState are set, the motion is only triggered for a single step and must be re-triggered to activate again. When the instantState on the entity becomes `true`, this motion's active state is changed to match. If an \"instantState\" property is also set on this component, both the event and the state must be true for the motion to be active.\n             *\n             * @property instant\n             * @type Boolean\n             * @default false\n             */\n            instant: false,\n            \n            /**\n             * If instant or instantState are set, the motion is only triggered for a single step and must be re-triggered to activate again. When the instantState on the entity becomes `true`, this motion's active state is changed to match. If an \"instant\" property is also set on this component, both the event and the state must be true for the motion to be active. If \"event\" or \"controlState\" are also defined, they must also be `true` to trigger an instant motion on the entity.\n             *\n             * @property instantState\n             * @type String\n             * @default \"\"\n             */\n            instantState: \"\",\n            \n            /**\n             * If instantState is set, this event is triggered when the intance of motion occurs on the entity.\n             *\n             * @property instantSuccess\n             * @type String\n             * @default \"\"\n             */\n            instantSuccess: \"\",\n            \n            /**\n             * This determines if setting active to `false` (via the control event or state) should dampen velocity. This is a ratio applied to the vector magnitude between 0 and 1. This is useful for events like jumping where a longer keypress should jump farther than a shorter keypress.\n             *\n             * @property instantDecay\n             * @type number\n             * @default null\n             */\n            instantDecay: null,\n            \n            /**\n             * A vector, Array, or number specifying the direction and magnitude of the motion. Numbers apply magnitude along the x-axis. Arrays map to [x, y, z] on the vector.\n             *\n             * @property velocity\n             * @type platypus.Vector|Array|number\n             * @default Vector(0, 0, 0)\n             */\n            velocity: 0,\n            \n            stopOnCollision: true,\n            \n            drag: -1,\n            friction: -1\n        },\n        \n        initialize: function (definition) {\n            if (!this.acceleration) {\n                this.activeAcceleration = false;\n            }\n            this.acceleration = _Vector_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp(this.acceleration);\n            this.velocity     = _Vector_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp(this.velocity);\n\n            this.triggered = false;\n            this.ready = true;\n            \n            if (typeof this.instantDecay === \"number\") {\n                this.capMagnitude = this.velocity.magnitude() * this.instantDecay;\n            } else {\n                this.capMagnitude = -1;\n            }\n            \n            createController(this, definition);\n            \n            if (this.instant) {\n                this.enact = false;\n                this.instant = _Vector_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp(this.velocity);\n                this.velocity.setXYZ(0, 0, 0);\n            }\n\n            if (this.orient) { // Orient vectors in case the entity is in a transformed position.\n                this.owner.triggerEvent('orient-vector', this.velocity);\n                this.owner.triggerEvent('orient-vector', this.acceleration);\n            }\n        },\n\n        events: {\n            /**\n             * This event controls whether this velocity is active or inactive.\n             *\n             * @method 'control-velocity'\n             * @param control {Object|boolean} If `true`, this motion becomes active. If `false` or `{pressed: false}`, the motion becomes inactive.\n             */\n            \"control-velocity\": function (control) {\n                this.activeVelocity = (control && (control.pressed !== false));\n            },\n            \n            /**\n             * This event sets the velocity to inactive.\n             *\n             * @method 'stop-velocity'\n             */\n            \"stop-velocity\": function () {\n                this.activeVelocity = false;\n            },\n            \n            /**\n             * This event sets the velocity to active.\n             *\n             * @method 'start-velocity'\n             */\n            \"start-velocity\": function () {\n                this.activeVelocity = true;\n            },\n            \n            /**\n             * This event controls whether the acceleration is active or inactive.\n             *\n             * @method 'control-acceleration'\n             * @param control {Object|boolean} If `true`, this motion becomes active. If `false` or `{pressed: false}`, the motion becomes inactive.\n             */\n            \"control-acceleration\": function (control) {\n                this.activeAcceleration = (control && (control.pressed !== false));\n            },\n            \n            /**\n             * This event sets the acceleration to inactive.\n             *\n             * @method 'stop-acceleration'\n             */\n            \"stop-acceleration\": function () {\n                this.activeAcceleration = false;\n            },\n            \n            /**\n             * This event sets the acceleration to active.\n             *\n             * @method 'start-acceleration'\n             */\n            \"start-acceleration\": function () {\n                this.activeAcceleration = true;\n            },\n            \n            /**\n            * This event triggers an instant motion.\n            *\n            * @method 'instant-motion'\n            * @param control {Object|boolean} If `true`, this motion becomes active. If `false` or `{triggered: false}`, the motion becomes inactive.\n            */\n            \"instant-motion\": function (control) {\n                this.enact = (control && (control.triggered !== false));\n            },\n\n            /**\n            * This event triggers the beginning of an instant motion.\n            *\n            * @method 'instant-begin'\n            */\n            \"instant-begin\": function () {\n                this.enact = true;\n            },\n\n            /**\n            * This event triggers the end of an instant motion.\n            *\n            * @method 'instant-end'\n            */\n            \"instant-end\": function () {\n                this.enact = false;\n            },\n            \n            /**\n            * This event modifies the properties of this Motion.\n            *\n            * @method 'set-motion'\n            * @param motion {Object} A list of key/value pairs corresponding to motion values.\n            * @param [motion.maxMagnitude] {Number} A value describing the maximum velocity or acceleration the motion vector can exert on the Entity.\n            */\n            \"set-motion\": function (motion) {\n                if (motion.acceleration) {\n                    this.acceleration.set(motion.acceleration);\n                }\n                if (motion.velocity) {\n                    this.velocity.set(motion.velocity);\n                    if (typeof this.instantDecay === \"number\") {\n                        this.capMagnitude = this.velocity.magnitude() * this.instantDecay;\n                    } else {\n                        this.capMagnitude = -1;\n                    }\n                }\n                if (typeof motion.maxMagnitude === \"number\") {\n                    this.maxMagnitude = motion.maxMagnitude;\n                }\n            }\n        },\n\n        methods: {\n            move: function (delta) {\n                var v = _Vector_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp(this.acceleration).multiply(delta);\n                \n                this.velocity.add(v);\n                v.recycle();\n                \n                if (this.velocity.magnitude() > this.maxMagnitude) {\n                    this.velocity.normalize().multiply(this.maxMagnitude);\n                }\n                return this.velocity;\n            },\n            \n            // This handles things like variable height jumping by adjusting the jump velocity to the pre-determined cap velocity for jump-button release.\n            decay: function () {\n                if ((this.capMagnitude >= 0) && (this.velocity.magnitude() > this.capMagnitude)) {\n                    this.velocity.normalize().multiply(this.capMagnitude);\n                }\n            },\n            \n            destroy: function () {\n                if (this.orient) {\n                    this.owner.triggerEvent('remove-vector', this.acceleration);\n                    this.owner.triggerEvent('remove-vector', this.velocity);\n                }\n                this.acceleration.recycle();\n                this.velocity.recycle();\n                if (this.instant) {\n                    this.instant.recycle();\n                }\n            }\n        },\n        \n        publicMethods: {\n        }\n    });\n}());\n\n\n//# sourceURL=webpack://platypus/./src/components/Motion.js?");

/***/ }),

/***/ "./src/components/Mover.js":
/*!*********************************!*\
  !*** ./src/components/Mover.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var _Vector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Vector.js */ \"./src/Vector.js\");\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../factory.js */ \"./src/factory.js\");\n/**\n * This component handles entity motion via velocity and acceleration changes. This is useful for directional movement, gravity, bounce-back collision reactions, jumping, etc.\n *\n * @namespace platypus.components\n * @class Mover\n * @uses platypus.Component\n */\n/* global platypus */\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    var tempVector = _Vector_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp(),\n        updateMax   = function (delta, interim, goal, time) {\n            if (delta && (interim !== goal)) {\n                if (interim < goal) {\n                    return Math.min(interim + delta * time, goal);\n                } else {\n                    return Math.max(interim - delta * time, goal);\n                }\n            }\n            \n            return interim;\n        },\n        clampNumber = function (v, d) {\n            var mIn = this.maxMagnitudeInterim = updateMax(this.maxMagnitudeDelta, this.maxMagnitudeInterim, this.maxMagnitude, d);\n            \n            if (v.magnitude() > mIn) {\n                v.normalize().multiply(mIn);\n            }\n        },\n        clampObject = function (v, d) {\n            var max = this.maxMagnitude,\n                mD  = this.maxMagnitudeDelta,\n                mIn = this.maxMagnitudeInterim;\n\n            mIn.up    = updateMax(mD, mIn.up,    max.up,    d);\n            mIn.right = updateMax(mD, mIn.right, max.right, d);\n            mIn.down  = updateMax(mD, mIn.down,  max.down,  d);\n            mIn.left  = updateMax(mD, mIn.left,  max.left,  d);\n            \n            if (v.x > 0) {\n                if (v.x > mIn.right) {\n                    v.x = mIn.right;\n                }\n            } else if (v.x < 0) {\n                if (v.x < -mIn.left) {\n                    v.x = -mIn.left;\n                }\n            }\n\n            if (v.y > 0) {\n                if (v.y > mIn.down) {\n                    v.y = mIn.down;\n                }\n            } else if (v.y < 0) {\n                if (v.y < -mIn.up) {\n                    v.y = -mIn.up;\n                }\n            }\n        };\n        \n    return Object(_factory_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({\n        \n        id: 'Mover',\n\n        properties: {\n            /** This is a normalized vector describing the direction the ground should face away from the entity.\n             *\n             * @property ground\n             * @type Array|Vector\n             * @default Vector(0, 1)\n             */\n            ground: [0, 1]\n        },\n        \n        publicProperties: {\n            /**\n             * A list of key/value pairs describing vectors or vector-like objects describing acceleration and velocity on the entity. See the [\"Motion\"](\"Motion\"%20Component.html) component for properties.\n             *\n             * @property movers\n             * @type Array\n             * @default []\n             */\n            movers: [],\n            \n            /**\n             * If specified, the property adds gravity motion to the entity.\n             *\n             * @property gravity\n             * @type number|Array|Vector\n             * @default: 0\n             */\n            gravity: 0,\n            \n            /**\n             * If specified, the property adds jumping motion to the entity.\n             *\n             * @property jump\n             * @type number|Array|Vector\n             * @default: 0\n             */\n            jump: 0,\n            \n            /**\n             * If specified, the property adds velocity to the entity.\n             *\n             * @property speed\n             * @type number|Array|Vector\n             * @default: 0\n             */\n            speed: 0,\n            \n            /**\n             * This property determines how quickly velocity is dampened when the entity is not in a \"grounded\" state. This should be a value between 1 (no motion) and 0 (no drag).\n             *\n             * @property drag\n             * @type number\n             * @default 0.01\n             */\n            drag: 0.01,\n            \n            /**\n             * This property determines how quickly velocity is dampened when the entity is in a \"grounded\" state. This should be a value between 1 (no motion) and 0 (no friction).\n             *\n             * @property friction\n             * @type number\n             * @default 0.06\n             */\n            friction: 0.06,\n            \n            /**\n             * This property determines the maximum amount of velocity this entity can maintain. This can be a number or an object describing maximum velocity in a particular direction. For example:\n             *\n             *     {\n             *         \"up\": 8,\n             *         \"right\": 12,\n             *         \"down\": 0.4,\n             *         \"left\": 12\n             *     }\n             *\n             * @property maxMagnitude\n             * @type number|Object\n             * @default Infinity\n             */\n            maxMagnitude: Infinity,\n            \n            /**\n             * This property determines the rate of change to new maximum amount of velocities.\n             *\n             * @property maxMagnitudeDelta\n             * @type number\n             * @default 0\n             */\n            maxMagnitudeDelta: 0,\n            \n            /**\n             * This property determines whether orientation changes should apply external velocities from pre-change momentum.\n             *\n             * @property reorientVelocities\n             * @type Boolean\n             * @default true\n             */\n            reorientVelocities: true\n        },\n        \n        initialize: function () {\n            var maxMagnitude = Infinity,\n                max = this.maxMagnitude,\n                thisState = this.owner.state;\n            \n            _Vector_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].assign(this.owner, 'position',  'x',  'y',  'z');\n            _Vector_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].assign(this.owner, 'velocity', 'dx', 'dy', 'dz');\n\n            this.position = this.owner.position;\n            this.velocity = this.owner.velocity;\n            this.lastVelocity = _Vector_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp(this.velocity);\n            this.collision = null;\n            \n            this.pause = false;\n            \n            // Copy movers so we're not re-using mover definitions\n            this.moversCopy = this.movers;\n            this.movers = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n\n            this.velocityChanges = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n            this.velocityDirections = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n\n            this.ground = _Vector_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp(this.ground);\n            \n            this.state = thisState;\n            thisState.set('grounded', false);\n            \n            Object.defineProperty(this.owner, \"maxMagnitude\", {\n                get: function () {\n                    return maxMagnitude;\n                },\n                set: function (max) {\n                    if (typeof max === 'number') {\n                        this.clamp = clampNumber;\n                        maxMagnitude = max;\n                        if (!this.maxMagnitudeDelta) {\n                            this.maxMagnitudeInterim = max;\n                        }\n                    } else {\n                        this.clamp = clampObject;\n                        if (typeof maxMagnitude === 'number') {\n                            maxMagnitude = {\n                                up: maxMagnitude,\n                                right: maxMagnitude,\n                                down: maxMagnitude,\n                                left: maxMagnitude\n                            };\n                        }\n                        if (typeof max.up === 'number') {\n                            maxMagnitude.up = max.up;\n                        }\n                        if (typeof max.right === 'number') {\n                            maxMagnitude.right = max.right;\n                        }\n                        if (typeof max.down === 'number') {\n                            maxMagnitude.down = max.down;\n                        }\n                        if (typeof max.left === 'number') {\n                            maxMagnitude.left = max.left;\n                        }\n\n                        if (typeof this.maxMagnitudeInterim === 'number') {\n                            if (this.maxMagnitudeDelta) {\n                                this.maxMagnitudeInterim = {\n                                    up: this.maxMagnitudeInterim,\n                                    right: this.maxMagnitudeInterim,\n                                    down: this.maxMagnitudeInterim,\n                                    left: this.maxMagnitudeInterim\n                                };\n                            } else {\n                                this.maxMagnitudeInterim = {\n                                    up: maxMagnitude.up,\n                                    right: maxMagnitude.right,\n                                    down: maxMagnitude.down,\n                                    left: maxMagnitude.left\n                                };\n                            }\n                        } else if (!this.maxMagnitudeDelta) {\n                            this.maxMagnitudeInterim.up    = maxMagnitude.up;\n                            this.maxMagnitudeInterim.right = maxMagnitude.right;\n                            this.maxMagnitudeInterim.down  = maxMagnitude.down;\n                            this.maxMagnitudeInterim.left  = maxMagnitude.left;\n                        }\n                    }\n                }.bind(this)\n            });\n            this.maxMagnitudeInterim = 0;\n            this.maxMagnitude = max;\n        },\n\n        events: {\n            /**\n             * When a [\"Motion\"](\"Motion\"%20Component.html) component is added, this component adds it to its list of movers.\n             *\n             * @method 'component-added'\n             * @param component {\"Motion\" Component} The motion to add as a mover on this entity.\n             */\n            \"component-added\": function (component) {\n                if (component.type === 'Motion') {\n                    this.movers.push(component);\n                }\n            },\n            \n            /**\n             * When a [\"Motion\"](\"Motion\"%20Component.html) component is removed, this component removes it from its list of movers.\n             *\n             * @method 'component-removed'\n             * @param component {\"Motion\" Component} The motion to remove as a mover from this entity.\n             */\n            \"component-removed\": function (component) {\n                var i = 0;\n                \n                if (component.type === 'Motion') {\n                    i = this.movers.indexOf(component);\n                    if (i >= 0) {\n                        Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSplice\"])(this.movers, i);\n                    }\n                }\n            },\n            \n            /**\n             * This component listens for a \"load\" event before setting up its mover list.\n             *\n             * @method 'load'\n             */\n            \"load\": function () {\n                var i = 0,\n                    movs = this.moversCopy;\n                \n                delete this.moversCopy;\n                for (i = 0; i < movs.length; i++) {\n                    this.addMover(movs[i]);\n                }\n                \n                this.externalForces = this.addMover({\n                    velocity: [0, 0, 0],\n                    orient: false\n                }).velocity;\n                \n                // Set up speed property if supplied.\n                if (this.speed) {\n                    if (!isNaN(this.speed)) {\n                        this.speed = [this.speed, 0, 0];\n                    }\n                    this.speed = this.addMover({\n                        velocity: this.speed,\n                        controlState: \"moving\"\n                    }).velocity;\n                }\n\n                // Set up gravity property if supplied.\n                if (this.gravity) {\n                    if (!isNaN(this.gravity)) {\n                        this.gravity = [0, this.gravity, 0];\n                    }\n                    this.gravity = this.addMover({\n                        acceleration: this.gravity,\n                        orient: false,\n                        aliases: {\n                            \"gravitate\": \"control-acceleration\"\n                        }\n                    }).acceleration;\n                }\n                \n                // Set up jump property if supplied.\n                if (this.jump) {\n                    if (!isNaN(this.jump)) {\n                        this.jump = [0, this.jump, 0];\n                    }\n                    this.jump = this.addMover({\n                        velocity: this.jump,\n                        instant: true,\n                        controlState: \"grounded\",\n                        state: \"jumping\",\n                        instantSuccess: \"just-jumped\",\n                        instantDecay: 0.2,\n                        aliases: {\n                            \"jump\": \"instant-motion\"\n                        }\n                    }).instant;\n                }\n            },\n            \n            /**\n             * On each \"handle-movement\" event, this component moves the entity according to the list of movers on the entity.\n             *\n             * @method 'handle-movement'\n             * @param tick {Object}\n             * @param tick.delta {number} The amount of time in milliseconds since the last tick.\n             */\n            \"handle-movement\": function (tick) {\n                var delta    = tick.delta,\n                    m        = null,\n                    thisState = this.state,\n                    vect     = null,\n                    velocity = this.velocity,\n                    position = this.position,\n                    movers   = this.movers,\n                    i        = movers.length;\n                \n                if (thisState.get('paused') || this.paused) {\n                    return;\n                }\n                \n                if (!velocity.equals(this.lastVelocity, 2)) {\n                    this.externalForces.addVector(velocity).subtractVector(this.lastVelocity);\n                }\n                \n                velocity.setXYZ(0, 0, 0);\n                \n                while (i--) {\n                    m = movers[i].update(delta);\n                    if (m) {\n                        if (this.grounded) { // put this in here to match earlier behavior\n                            if (movers[i].friction !== -1) {\n                                m.multiply(1 - movers[i].friction);\n                            } else {\n                                m.multiply(1 - this.friction);\n                            }\n                        } else if (movers[i].drag !== -1) {\n                            m.multiply(1 - movers[i].drag);\n                        } else {\n                            m.multiply(1 - this.drag);\n                        }\n                        velocity.add(m);\n                    }\n                }\n\n                this.clamp(velocity, delta);\n                this.lastVelocity.setVector(velocity);\n                \n                vect = _Vector_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp(velocity).multiply(delta);\n                position.add(vect);\n                vect.recycle();\n                \n                thisState.set('grounded', this.grounded);\n                \n                this.grounded = false;\n            },\n            \n            /**\n             * On receiving this message, this component stops all velocities along the axis of the collision direction and sets \"grounded\" to `true` if colliding with the ground.\n             *\n             * @method 'hit-solid'\n             * @param collisionInfo {Object}\n             * @param collisionInfo.direction {platypus.Vector} The direction of collision from the entity's position.\n             */\n            \"hit-solid\": function (collisionInfo) {\n                var s = 0,\n                    e = 0,\n                    entityV = collisionInfo.entity && collisionInfo.entity.velocity,\n                    direction = collisionInfo.direction,\n                    add = true,\n                    vc = this.velocityChanges,\n                    vd = this.velocityDirections,\n                    i = vc.length;\n                \n                if (direction.dot(this.ground) > 0) {\n                    this.grounded = true;\n                }\n\n                s = this.velocity.scalarProjection(direction);\n                if (s > 0) {\n                    if (entityV) {\n                        e = Math.max(entityV.scalarProjection(direction), 0);\n                        if (e < s) {\n                            s = e;\n                        } else {\n                            s = 0;\n                        }\n                    } else {\n                        s = 0;\n                    }\n                    \n                    while (i--) {\n                        if ((s < vc[i]) && (vd[i].dot(direction) > 0)) {\n                            vc[i] = s;\n                            vd[i].setVector(direction);\n                            add = false;\n                            break;\n                        }\n                    }\n                    \n                    if (add) {\n                        vc.push(s);\n                        vd.push(_Vector_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp(direction));\n                    }\n                }\n            },\n            \n            \"handle-post-collision-logic\": function () {\n                var direction = null,\n                    ms = this.movers,\n                    vc = this.velocityChanges,\n                    vd = this.velocityDirections,\n                    i = vc.length,\n                    j = ms.length,\n                    m = null,\n                    s = 0,\n                    sdi = 0,\n                    soc = null,\n                    v = tempVector;\n                \n                if (i) {\n                    soc = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n                    \n                    while (j--) {\n                        m = ms[j];\n                        if (m.stopOnCollision) {\n                            soc.push(m);\n                        }\n                    }\n                    \n                    while (i--) {\n                        direction = vd[i];\n                        s = vc[i];\n                        j = soc.length;\n                        sdi = s / j;\n                        while (j--) {\n                            m = soc[j];\n                            v.setVector(direction).normalize().multiply(sdi - m.velocity.scalarProjection(direction));\n                            m.velocity.add(v);\n                        }\n                        direction.recycle();\n                    }\n                    \n                    vc.length = 0;\n                    vd.length = 0;\n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(soc);\n                }\n            },\n            \n            /**\n             * Update mover properties.\n             *\n             * @method 'set-mover'\n             * @param mover {Object}\n             * @param [mover.maxMagnitude] {Number|Object} New maximums for magnitude.\n             * @param [mover.magnitude] {Number} Delta for the change in maximums.\n             */\n            \"set-mover\": function (mover) {\n                if (typeof mover.maxMagnitudeDelta === 'number') {\n                    this.maxMagnitudeDelta = mover.maxMagnitudeDelta;\n                }\n                \n                if (mover.maxMagnitude) {\n                    this.maxMagnitude = mover.maxMagnitude;\n                }\n            },\n            \n            /**\n             * Stops all movement on the Entity.\n             *\n             * @method 'pause-movment'\n             */\n            \"pause-movement\": function () {\n                this.paused = true;\n            },\n            \n            /**\n             * Unpauses all movement on the Entity.\n             *\n             * @method 'unpause-movment'\n             */\n            \"unpause-movement\": function () {\n                this.paused = false;\n            },\n            \n            /**\n             * Handles velocity change if velocities should not be re-oriented.\n             *\n             * @method 'orientation-updated'\n             * @param matrix {Array} A 3x3 matrix describing the orientation change.\n             */\n            \"orientation-updated\": function (matrix) {\n                if (!this.reorientVelocities) {\n                    this.lastVelocity.multiply(matrix);\n                }\n            }\n        },\n        \n        methods: {\n            destroy: function () {\n                var i = 0,\n                    max = this.maxMagnitude;\n                \n                for (i = this.movers.length - 1; i >= 0; i--) {\n                    this.removeMover(this.movers[i]);\n                }\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.movers);\n                \n                this.ground.recycle();\n                this.lastVelocity.recycle();\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.velocityChanges);\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.velocityDirections);\n                \n                delete this.owner.maxMagnitude; // remove property handlers\n                this.owner.maxMagnitude = max;\n                \n                this.state = null;\n            }\n        },\n        \n        publicMethods: {\n            /**\n             * This method adds a mover to the entity in the form of a [\"Motion\"](\"Motion\"%20Component.html) component definition.\n             *\n             * @method addMover\n             * @param mover {Object} For motion definition properties, see the [\"Motion\"](\"Motion\"%20Component.html) component.\n             * @return motion {\"Motion\" Component}\n             */\n            addMover: function (mover) {\n                var m = this.owner.addComponent(new platypus.components.Motion(this.owner, mover));\n\n                return m;\n            },\n            \n            /**\n             * This method removes a mover from the entity.\n             *\n             * @method removeMover\n             * @param motion {\"Motion\" Component}\n             */\n            removeMover: function (m) {\n                this.owner.removeComponent(m);\n            }\n        }\n    });\n}());\n\n//# sourceURL=webpack://platypus/./src/components/Mover.js?");

/***/ }),

/***/ "./src/components/Node.js":
/*!********************************!*\
  !*** ./src/components/Node.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var _Vector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Vector.js */ \"./src/Vector.js\");\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../factory.js */ \"./src/factory.js\");\n/**\n# COMPONENT **Node**\nThis component causes an entity to be a position on a [[NodeMap]]. This component should not be confused with `NodeResident` which should be used on entities that move around on a NodeMap: `Node` simply represents a non-moving location on the NodeMap.\n  \n## JSON Definition\n    {\n      \"type\": \"NodeResident\",\n      \n      \"nodeId\": \"city-hall\",\n      // Optional. The id of the node that this entity should start on. Uses the entity's nodeId property if not set here.\n      \n      \"nodes\": ['path','sidewalk','road'],\n      // Optional. This is a list of node types that this entity can reside on. If not set, entity can reside on any type of node.\n      \n      \"shares\": ['friends','neighbors','city-council-members'],\n      // Optional. This is a list of entities that this entity can reside with on the same node. If not set, this entity cannot reside with any entities on the same node.\n      \n      \"speed\": 5,\n      // Optional. Sets the speed with which the entity moves along an edge to an adjacent node. Default is 0 (instantaneous movement).\n      \n      \"updateOrientation\": true\n      // Optional. Determines whether the entity's orientation is updated by movement across the NodeMap. Default is false.\n    }\n*/\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    return Object(_factory_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({\n        \n        id: 'Node',\n        \n        publicProperties: {\n            x: 0,\n            y: 0,\n            z: 0\n        },\n        \n        initialize: function (definition) {\n            this.nodeId = definition.nodeId || this.owner.nodeId || this.owner.id || String(Math.random());\n            \n            if ((typeof this.nodeId !== 'string') && (this.nodeId.length)) {\n                this.nodeId = definition.nodeId.join('|');\n            }\n            \n            this.owner.nodeId = this.nodeId;\n            \n            this.owner.isNode = true;\n            this.map = this.owner.map = this.owner.map || this.owner.parent || null;\n            this.contains = this.owner.contains = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n            this.edgesContain = this.owner.edgesContain = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n            \n            _Vector_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].assign(this.owner, 'position', 'x', 'y', 'z');\n            \n            this.neighbors = this.owner.neighbors = definition.neighbors || this.owner.neighbors || {};\n        },\n        \n        events: {\n            \"add-neighbors\": function (neighbors) {\n                var i = 0,\n                    direction = null;\n                \n                for (direction in neighbors) {\n                    if (neighbors.hasOwnProperty(direction)) {\n                        this.neighbors[direction] = neighbors[direction];\n                    }\n                }\n                \n                for (i = 0; i < this.contains.length; i++) {\n                    this.contains[i].triggerEvent('set-directions');\n                }\n            },\n            \"remove-neighbor\": function (nodeOrNodeId) {\n                var i  = null,\n                    id = nodeOrNodeId;\n                \n                if (typeof id !== 'string') {\n                    id = id.nodeId;\n                }\n\n                for (i in this.neighbors) {\n                    if (this.neighbors.hasOwnProperty(i)) {\n                        if (typeof this.neighbors[i] === 'string') {\n                            if (this.neighbors[i] === id) {\n                                delete this.neighbors[i];\n                                break;\n                            }\n                        } else if (this.neighbors[i].nodeId === id) {\n                            delete this.neighbors[i];\n                            break;\n                        }\n                    }\n                }\n            }\n        },\n        \n        methods: {\n            destroy: function () {\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.contains);\n                this.contains = this.owner.contains = null;\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.edgesContain);\n                this.edgesContain = this.owner.edgesContain = null;\n            }\n        },\n        \n        publicMethods: {\n            getNode: function (desc) {\n                var neighbor = null;\n                \n                //map check\n                if (!this.map && this.owner.map) {\n                    this.map = this.owner.map;\n                }\n                \n                if (this.neighbors[desc]) {\n                    neighbor = this.neighbors[desc];\n                    if (neighbor.isNode) {\n                        return neighbor;\n                    } else if (typeof neighbor === 'string') {\n                        neighbor = this.map.getNode(neighbor);\n                        if (neighbor) {\n                            this.neighbors[desc] = neighbor;\n                            return neighbor;\n                        }\n                    } else if (neighbor.length) {\n                        neighbor = this.map.getNode(neighbor.join('|'));\n                        if (neighbor) {\n                            this.neighbors[desc] = neighbor;\n                            return neighbor;\n                        }\n                    }\n                    return null;\n                } else {\n                    return null;\n                }\n            },\n            addToNode: function (entity) {\n                var i = 0;\n                \n                for (i = 0; i < this.contains.length; i++) {\n                    if (this.contains[i] === entity) {\n                        return false;\n                    }\n                }\n                this.contains.push(entity);\n                return entity;\n            },\n            removeFromNode: function (entity) {\n                var i = 0;\n                \n                for (i = 0; i < this.contains.length; i++) {\n                    if (this.contains[i] === entity) {\n                        return Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSplice\"])(this.contains, i);\n                    }\n                }\n                return false;\n            },\n            addToEdge: function (entity) {\n                var i = 0;\n                \n                for (i = 0; i < this.edgesContain.length; i++) {\n                    if (this.edgesContain[i] === entity) {\n                        return false;\n                    }\n                }\n                this.edgesContain.push(entity);\n                return entity;\n            },\n            removeFromEdge: function (entity) {\n                var i = 0;\n                \n                for (i = 0; i < this.edgesContain.length; i++) {\n                    if (this.edgesContain[i] === entity) {\n                        return Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSplice\"])(this.edgesContain, i);\n                    }\n                }\n                return false;\n            }\n        }\n    });\n}());\n\n\n//# sourceURL=webpack://platypus/./src/components/Node.js?");

/***/ }),

/***/ "./src/components/NodeMap.js":
/*!***********************************!*\
  !*** ./src/components/NodeMap.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var _Entity_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Entity.js */ \"./src/Entity.js\");\n/* harmony import */ var _Vector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Vector.js */ \"./src/Vector.js\");\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! config */ \"./src/config/development.js\");\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(config__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../factory.js */ \"./src/factory.js\");\n/* harmony import */ var recycle__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! recycle */ \"./node_modules/recycle/recycle.js\");\n/**\n * This component sets up a NodeMap to be used by the [NodeResident](platypus.components.NodeResident.html) component on this entity's child entities.\n *\n * @namespace platypus.components\n * @class NodeMap\n * @uses platypus.Component\n */\n\n\n\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    var Node = function (definition, map) { // This is a basic node object, but can be replaced by entities having a `Node` component if more functionality is needed.\n            if (definition.id) {\n                if (typeof definition.id === 'string') {\n                    this.id = definition.id;\n                } else if (Array.isArray(definition.id)) {\n                    this.id = definition.id.join('|');\n                } else {\n                    this.id = String(Math.random());\n                }\n            } else {\n                this.id = String(Math.random());\n            }\n\n            this.isNode = true;\n            this.map = map;\n            this.contains = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n            this.type = definition.type || '';\n\n            if (!this.position) {\n                _Vector_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].assign(this, 'position', 'x', 'y', 'z');\n            }\n            this.x = definition.x || 0;\n            this.y = definition.y || 0;\n            this.z = definition.z || 0;\n\n            this.neighbors = definition.neighbors || {};\n        },\n        proto = Node.prototype;\n    \n    proto.getNode = function (desc) {\n        var neighbor = null;\n        \n        if (this.neighbors[desc]) {\n            neighbor = this.neighbors[desc];\n            if (neighbor.isNode) {\n                return neighbor;\n            } else if (typeof neighbor === 'string') {\n                neighbor = this.map.getNode(neighbor);\n                if (neighbor) {\n                    this.neighbors[desc] = neighbor;\n                    return neighbor;\n                }\n            } else if (Array.isArray(neighbor)) {\n                neighbor = this.map.getNode(neighbor.join('|'));\n                if (neighbor) {\n                    this.neighbors[desc] = neighbor;\n                    return neighbor;\n                }\n            }\n            return null;\n        } else {\n            return null;\n        }\n    };\n\n    proto.add = function (entity) {\n        var i = 0;\n        \n        for (i = 0; i < this.contains.length; i++) {\n            if (this.contains[i] === entity) {\n                return false;\n            }\n        }\n        this.contains.push(entity);\n        return entity;\n    };\n    \n    proto.remove = function (entity) {\n        var i = 0;\n        \n        for (i = 0; i < this.contains.length; i++) {\n            if (this.contains[i] === entity) {\n                return Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSplice\"])(this.contains, i);\n            }\n        }\n        return false;\n    };\n    \n    recycle__WEBPACK_IMPORTED_MODULE_5__[\"default\"].add(Node, 'Node', Node, function () {\n        _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.contains);\n    }, true, config__WEBPACK_IMPORTED_MODULE_3___default.a.dev);\n    \n    return Object(_factory_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])({\n        id: 'NodeMap',\n        \n        publicProperties: {\n            /**\n             * An array of node definitions to create the NodeMap. A node definition can take the following form:\n             *\n             *         {\n             *           \"NodeId\": \"Node1\",\n             *           // A string or array that becomes the id of the Node. Arrays are joined using \"|\" to create the id string.\n             *           \"type\": \"path\",\n             *           // A string that determines the type of the node.\n             *           \"x\": 0,\n             *           // Sets the x axis position of the node.\n             *           \"y\": 0,\n             *           // Sets the y axis position of the node.\n             *           \"z\": 0,\n             *           // Sets the z axis position of the node.\n             *           \"neighbors\": {\n             *           // A list of key/value pairs where the keys are directions from the node and values are node ids.\n             *             \"west\": \"node0\",\n             *             \"east\": \"node2\"\n             *           }\n             *         }\n             *\n             * @property map\n             * @type Array\n             * @default []\n             */\n            map: []\n        },\n        \n        initialize: function () {\n            var i   = 0,\n                map = this.map;\n            \n            this.map   = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(); // Original map is node definitions, so we replace it with actual nodes.\n            this.nodes = {};\n            this.residentsAwaitingNode = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n            \n            for (i = 0; i < map.length; i++) {\n                this.addNode(Node.setUp(map[i], this));\n            }\n        },\n\n        events: {\n            /**\n             * Expects a node definition to create a node in the NodeMap.\n             *\n             * @method 'add-node'\n             * @param definition {Object} Key/value pairs.\n             * @param definition.nodeId {String|Array} This value becomes the id of the Node. Arrays are joined using \"|\" to create the id string.\n             * @param definition.type {String} This determines the type of the node.\n             * @param definition.x {String} Sets the x axis position of the node.\n             * @param definition.y {String} Sets the y axis position of the node.\n             * @param definition.z {String} Sets the z axis position of the node.\n             * @param definition.neighbors {Object} A list of key/value pairs where the keys are directions from the node and values are node ids. For example: {\"west\": \"node12\"}.\n             */\n            \"add-node\": function (nodeDefinition) {\n                var i = 0,\n                    entity = null,\n                    node   = null;\n                \n                if (nodeDefinition.isNode) {// if it's already a node, put it on the map.\n                    node = nodeDefinition;\n                    nodeDefinition.map = this;\n                } else {\n                    node = Node.setUp(nodeDefinition, this);\n                }\n                \n                this.addNode(node);\n                \n                for (i = this.residentsAwaitingNode.length - 1; i >= 0; i--) {\n                    entity = this.residentsAwaitingNode[i];\n                    if (node.id === entity.nodeId) {\n                        Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSplice\"])(this.residentsAwaitingNode, i);\n                        entity.node = this.getNode(entity.nodeId);\n                        entity.triggerEvent('on-node', entity.node);\n                    }\n                }\n            },\n\n            /**\n             * Checks the child entity for a nodeId and if found adds the child to the corresponding node.\n             *\n             * @method 'child-entity-added'\n             * @param entity {platypus.Entity} The entity that may be placed on a node, or if the entity is a node it is added to the map of nodes.\n             */\n            \"child-entity-added\": function (entity) {\n                if (entity.isNode) {        // a node\n                    this.owner.triggerEvent('add-node', entity);\n                } else if (entity.nodeId) { // a NodeResident\n                    entity.node = this.getNode(entity.nodeId);\n                    if (!entity.node) {\n                        this.residentsAwaitingNode.push(entity);\n                    } else {\n                        entity.triggerEvent('on-node', entity.node);\n                    }\n                }\n            }\n        },\n        \n        methods: {\n            addNode: function (node) {\n                this.map.push(node);\n                this.nodes[node.id] = node;\n            },\n            \n            destroy: function () {\n                var i = 0;\n                \n                // Destroy simple node objects.\n                for (i = 0; i < this.map.length; i++) {\n                    if (!(this.map[i] instanceof _Entity_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])) {\n                        this.map[i].recycle();\n                    }\n                }\n                \n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.map);\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.residentsAwaitingNode);\n            }\n        },\n        \n        publicMethods: {\n            /**\n             * Gets a node by node id.\n             *\n             * @method getNode\n             * @param id {String|Array|Node} This id of the node to retrieve. If an array or more than one parameter is supplied, values are concatenated with \"|\" to create a single string id. Supplying a node returns the same node (useful for processing a mixed list of nodes and node ids).\n             */\n            getNode: function () {\n                var i       = 0,\n                    id      = '',\n                    divider = '',\n                    args    = arguments;\n                \n                if (args.length === 1) {\n                    if (args[0].isNode) {\n                        return args[0];\n                    } else if (Array.isArray(args[0])) {\n                        args = args[0];\n                    }\n                }\n                \n                for (i = 0; i < args.length; i++) {\n                    id += divider + args[i];\n                    divider = '|';\n                }\n\n                return this.nodes[id] || null;\n            },\n            \n            /**\n             * Finds the closest node to a given point, with respect to any inclusion or exclusion lists.\n             *\n             * method getClosestNode\n             * @param point {platypus.Vector} A location for which a closest node is being found.\n             * @param [including] {Array} A list of nodes to include in the search. If not set, the entire map is searched.\n             * @param [excluding] {Array} A list of nodes to exclude from the search.\n             */\n            getClosestNode: function (point, including, excluding) {\n                var i = 0,\n                    j = 0,\n                    p1 = _Vector_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(point),\n                    p2 = _Vector_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(),\n                    m = 0,\n                    list = including || this.map,\n                    closest = null,\n                    d = Infinity;\n                \n                for (i = 0; i < list.length; i++) {\n                    m = p2.setVector(p1).subtractVector(list[i].position).magnitude();\n                    if (m < d) {\n                        if (excluding) {\n                            j = excluding.indexOf(list[i]);\n                            if (j >= 0) {\n                                break;\n                            }\n                        }\n                        \n                        d = m;\n                        closest = list[i];\n                    }\n                }\n                \n                p1.recycle();\n                p2.recycle();\n                \n                return closest;\n            }\n        }\n    });\n}());\n\n\n//# sourceURL=webpack://platypus/./src/components/NodeMap.js?");

/***/ }),

/***/ "./src/components/NodeResident.js":
/*!****************************************!*\
  !*** ./src/components/NodeResident.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../factory.js */ \"./src/factory.js\");\n/**\n# COMPONENT **NodeResident**\nThis component connects an entity to its parent's [[NodeMap]]. It manages navigating the NodeMap and triggering events on the entity related to its position.\n\n## Dependencies\n- [[NodeMap]] (on entity's parent) - This component uses the `NodeMap` to determine its location and navigate to other nodes.\n- [[HandlerLogic]] (on entity's parent) - This component listens for a logic tick message to maintain and update its location.\n\n## Messages\n\n### Listens for:\n- **handle-logic** - On a `tick` logic message, the component updates its location and triggers messages regarding its neighbors.\n  - @param message.delta (Number) - This component uses the current time to determine its progress along an edge if moving from node to node on the map.\n- **on-node** - Sets the entity's position to the sent node, updates its coordinates, and triggers messages regarding its neighbors if any.\n  - @param node (Node) - The node that this entity should be located on.\n- **leave-node** - Removes the entity from its current node if it's on one.\n- **goto-node** - Begins moving the entity along edges to get to sent node.\n  - @param node (Node) - The node that this entity should move to.\n- **follow** - Causes this entity to follow another entity. The leading entity must also have a `NodeResident` component and exist in the NodeMap.\n  - @param entity (Entity) - The entity that this entity should follow.\n\n### Local Broadcasts:\n- **next-to-[entity-type]** - This message is triggered when the entity is placed on a node. It will trigger on all neighboring entities, as well as on itself on behalf of neighboring entities.\n  - @param entity (Entity) - The entity that is next to the listening entity.\n- **with-[entity-type]** - This message is triggered when the entity is placed on a node. It will trigger on all entities residing on the same node, as well as on itself on behalf of all resident entities.\n  - @param entity (Entity) - The entity that is with the listening entity.\n- **left-node** - Triggered when the entity leaves a node.\n  - @param node (Node) - The node that the entity just left.\n- **[Messages specified in definition]** - When the entity is placed on a node, it checks out the type of node and triggers a message on the entity if an event is listed for the current node type.\n\n## States\n- **on-node** - This state is true when the entity is on a node.\n- **moving** - This state is true when the entity is moving from one node to another.\n- **going-[direction]** - This state is true when the entity is moving (or has just moved) in a direction (determined by the NodeMap) from one node to another.\n  \n## JSON Definition\n    {\n      \"type\": \"NodeResident\",\n      \n      \"nodeId\": \"city-hall\",\n      // Optional. The id of the node that this entity should start on. Uses the entity's nodeId property if not set here.\n      \n      \"nodes\": {\"path\": \"walking\", \"sidewalk\": \"walking\", \"road\": \"driving\"],\n      // Optional. This is a list of node types that this entity can reside on. If not set, entity can reside on any type of node.\n      \n      \"shares\": ['friends','neighbors','city-council-members'],\n      // Optional. This is a list of entities that this entity can reside with on the same node. If not set, this entity can reside with any entities on the same node.\n      \n      \"speed\": 5,\n      // Optional. Sets the speed with which the entity moves along an edge to an adjacent node. Default is 0 (instantaneous movement).\n      \n      \"updateOrientation\": true\n      // Optional. Determines whether the entity's orientation is updated by movement across the NodeMap. Default is false.\n    }\n*/\n\n/**\n * This component connects an entity to its parent's [[NodeMap]]. It manages navigating the NodeMap and triggering events on the entity related to its position.\n *\n * @namespace platypus.components\n * @class NodeResident\n * @uses platypus.Component\n */\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    var createGateway = function (nodeDefinition, map, gateway) {\n            return function () {\n                // ensure it's a node if one is available at this gateway\n                var node = map.getNode(nodeDefinition);\n\n                if (this.isPassable(node)) {\n                    this.destinationNodes.length = 0;\n                    this.destinationNodes.push(node);\n\n                    if (this.node) {\n                        this.onEdge(node);\n                    } else {\n                        this.distance = 0;\n                    }\n                    this.progress = 0;\n\n                    this.setState('going-' + gateway);\n                    return true;\n                }\n\n                return false;\n            };\n        },\n        distance = function (origin, destination) {\n            var x = destination.x - origin.x,\n                y = destination.y - origin.y,\n                z = destination.z - origin.z;\n\n            return Math.sqrt(x * x + y * y + z * z);\n        },\n        angle = function (origin, destination, distance, ratio) {\n            var x = destination.x - origin.x,\n                y = destination.y - origin.y,\n                a = 0;\n\n            if (origin.rotation && destination.rotation) {\n                x = (origin.rotation + 180) % 360;\n                y = (destination.rotation + 180) % 360;\n                return (x * (1 - ratio) + y * ratio + 180) % 360;\n            } else {\n                if (!distance) {\n                    return a;\n                }\n\n                a = Math.acos(x / distance);\n                if (y < 0) {\n                    a = (Math.PI * 2) - a;\n                }\n                return a * 180 / Math.PI;\n            }\n        },\n        axisProgress = function (r, o, d, f) {\n            return o * (1 - r) + d * r + f;\n        },\n        isFriendly = function (entities, kinds) {\n            var x = 0,\n                y = 0,\n                found = false;\n\n            if (kinds === null) {\n                return true;\n            }\n\n            for (x = 0; x < entities.length; x++) {\n                for (y = 0; y < kinds.length; y++) {\n                    if (entities[x].type === kinds[y]) {\n                        found = true;\n                    }\n                }\n                if (!found) {\n                    return false;\n                } else {\n                    found = false;\n                }\n            }\n\n            return true;\n        };\n\n    return Object(_factory_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])({\n        \n        id: 'NodeResident',\n        \n        publicProperties: {\n\n            /**\n             * This describes the rate at which a node resident should progress along an edge to another node. This property is set on the entity itself and can be manipulated in real-time.\n             *\n             * @property speed\n             * @type Number\n             * @default 0\n             */\n            speed: 0\n        },\n        \n        initialize: function (definition) {\n            var offset = definition.offset || this.owner.nodeOffset || {};\n            \n            this.nodeId = this.owner.nodeId = definition.nodeId || this.owner.nodeId;\n            \n            this.neighbors = {};\n            this.friendlyNodes = definition.nodes || null;\n            this.friendlyEntities = definition.shares || null;\n            this.snapToNodes = definition.snapToNodes || false;\n            this.updateOrientation = definition.updateOrientation || false;\n            this.distance = 0;\n            this.buffer   = definition.buffer || 0;\n            this.progress = 0;\n            this.offset = {\n                x: offset.x || 0,\n                y: offset.y || 0,\n                z: offset.z || 0\n            };\n            this.destinationNodes = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n            this.algorithm = definition.algorithm || distance;\n            \n            this.state = this.owner.state;\n            this.state.set('moving', false);\n            this.state.set('on-node', false);\n            this.currentState = '';\n        },\n        \n        events: {\n            \"set-algorithm\": function (algorithm) {\n                this.algorithm = algorithm || distance;\n            },\n            \"handle-logic\": function (resp) {\n                var i = 0,\n                    ratio    = 0,\n                    momentum = 0,\n                    node     = null,\n                    arr = null;\n                \n                if (!this.owner.node) {\n                    arr = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(this.owner.x, this.owner.y);\n                    this.owner.triggerEvent('on-node', this.owner.parent.getClosestNode(arr));\n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(arr);\n                    \n                    /**\n                     * This event is triggered if the entity is placed on the map but not assigned a node. It is moved to the nearest node and \"in-location\" is triggered.\n                     *\n                     * @event 'in-location'\n                     * @param entity {platypus.Entity} The entity that is in location.\n                     */\n                    this.owner.triggerEvent('in-location', this.owner);\n                }\n\n                if (this.followEntity) {\n                    node = this.followEntity.node || this.followEntity;\n                    if (node && node.isNode && (node !== this.node)) {\n                        this.lag = 0;\n                        this.state.set('moving', this.gotoNode());\n                        if (this.followDistance) {\n                            momentum = this.lag;\n                        }\n                    } else {\n                        this.followEntity = null;\n                    }\n                } else {\n                    momentum = this.speed * resp.delta;\n                }\n\n                // if goto-node was blocked, try again.\n                if (this.blocked) {\n                    this.blocked = false;\n                    if (this.goingToNode) {\n                        this.owner.triggerEvent('goto-closest-node', this.goingToNode);\n                    }\n                }\n                \n                if (this.destinationNodes.length) {\n                    this.state.set('moving', (this.speed !== 0));\n                    if (this.node) {\n                        this.onEdge(this.destinationNodes[0]);\n                    } else if (!this.lastNode) {\n                        this.owner.triggerEvent('on-node', this.destinationNodes[0]);\n                        this.destinationNodes.shift();\n                        if (!this.destinationNodes.length) {\n                            this.state.set('moving', false);\n                            return;\n                        }\n                    }\n                    \n                    if (this.snapToNodes) {\n                        for (i = 0; i < this.destinationNodes.length; i++) {\n                            this.owner.triggerEvent('on-node', this.destinationNodes[i]);\n                        }\n                        this.destinationNodes.length = 0;\n                    } else {\n                        while (this.destinationNodes.length && momentum) {\n                            if ((this.progress + momentum) >= this.distance) {\n                                node = this.destinationNodes[0];\n                                momentum -= (this.distance - this.progress);\n                                this.progress = 0;\n                                this.destinationNodes.shift();\n                                this.owner.triggerEvent('on-node', node);\n                                if (this.destinationNodes.length && momentum) {\n                                    this.onEdge(this.destinationNodes[0]);\n                                }\n                            } else {\n                                this.progress += momentum;\n                                ratio = this.progress / this.distance;\n                                this.owner.x = axisProgress(ratio, this.lastNode.x, this.destinationNodes[0].x, this.offset.x);\n                                this.owner.y = axisProgress(ratio, this.lastNode.y, this.destinationNodes[0].y, this.offset.y);\n                                this.owner.z = axisProgress(ratio, this.lastNode.z, this.destinationNodes[0].z, this.offset.z);\n                                if (this.updateOrientation) {\n                                    this.owner.rotation = angle(this.lastNode, this.destinationNodes[0], this.distance, ratio);\n                                }\n                                momentum = 0;\n                            }\n                        }\n                    }\n                } else {\n                    this.state.set('moving', false);\n                }\n            },\n            \"on-node\": function (node) {\n                var j = 0,\n                    entities = null;\n                \n                this.owner.node = this.node = node; //TODO: not sure if this needs to be accessible outside this component.\n                this.node.removeFromEdge(this.owner);\n                if (this.lastNode) {\n                    this.lastNode.removeFromEdge(this.owner);\n                }\n                this.node.addToNode(this.owner);\n                \n                this.setState('on-node');\n                \n                this.owner.x = this.node.x + this.offset.x;\n                this.owner.y = this.node.y + this.offset.y;\n                this.owner.z = this.node.z + this.offset.z;\n                if (this.updateOrientation && this.node.rotation) {\n                    this.owner.rotation = this.node.rotation;\n                }\n                \n                //add listeners for directions\n                this.owner.triggerEvent('set-directions');\n                \n                //trigger mapped messages for node types\n                if (this.friendlyNodes && this.friendlyNodes[node.type]) {\n                    this.owner.trigger(this.friendlyNodes[node.type], node);\n                }\n\n                //trigger \"with\" events\n                entities = node.contains;\n                for (j = 0; j < entities.length; j++) {\n                    if (this.owner !== entities[j]) {\n                        entities[j].triggerEvent(\"with-\" + this.owner.type, this.owner);\n                        this.owner.triggerEvent(\"with-\" + entities[j].type, entities[j]);\n                    }\n                }\n            },\n            \"leave-node\": function () {\n                if (this.node) {\n                    this.node.removeFromNode(this.owner);\n                    this.owner.triggerEvent('left-node', this.node);\n                    this.owner.triggerEvent('remove-directions');\n                }\n                this.lastNode = this.node;\n                this.node = null;\n            },\n            \"goto-node\": function (node) {\n                this.gotoNode(node);\n            },\n            \"follow\": function (entityOrNode) {\n                if (entityOrNode.entity) {\n                    this.followDistance = entityOrNode.distance;\n                    this.followEntity = entityOrNode.entity;\n                } else {\n                    this.followDistance = 0;\n                    this.followEntity = entityOrNode;\n                }\n            },\n            \"goto-closest-node\": (function () {\n                var checkList = function (here, list) {\n                        var i = 0;\n\n                        for (i = 0; i < list.length; i++) {\n                            if (list[i] === here) {\n                                return true;\n                            }\n                        }\n\n                        return false;\n                    },\n                    checkType = function (here, type) {\n                        return (here.type === type);\n                    },\n                    checkObjectType = function (here, node) {\n                        return (here.type === node.type);\n                    };\n                \n                return function (nodesOrNodeType) {\n                    var travResp = null,\n                        depth    = 20, //arbitrary limit\n                        origin   = this.node || this.lastNode,\n                        test     = null,\n                        steps    = nodesOrNodeType.steps || 0,\n                        nodes    = null;\n\n                    this.goingToNode = nodesOrNodeType;\n                    \n                    if (typeof nodesOrNodeType === 'string') {\n                        test = checkType;\n                    } else if (typeof nodesOrNodeType.type === 'string') {\n                        test = checkObjectType;\n                    } else {\n                        test = checkList;\n                    }\n                    \n                    if (origin && nodesOrNodeType && !test(origin, nodesOrNodeType)) {\n                        nodes = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n                        travResp = this.traverseNode({\n                            depth: depth,\n                            origin: origin,\n                            position: origin,\n                            test: test,\n                            destination: nodesOrNodeType,\n                            nodes: nodes,\n                            shortestPath: Infinity,\n                            distance: 0,\n                            found: false,\n                            algorithm: this.algorithm,\n                            blocked: false\n                        });\n                        \n                        travResp.distance -= this.progress;\n                        \n                        if (travResp.found) {\n                            //TODO: should probably set this up apart from this containing function\n                            if (this.followEntity) {\n                                if (!this.followDistance) {\n                                    this.setPath(travResp, steps);\n                                } else if ((travResp.distance + (this.followEntity.progress || 0)) > this.followDistance) {\n                                    this.lag = travResp.distance + (this.followEntity.progress || 0) - this.followDistance;\n                                    this.setPath(travResp, steps);\n                                } else {\n                                    this.lag = 0;\n                                }\n                            } else {\n                                this.setPath(travResp, steps);\n                            }\n                        } else if (travResp.blocked) {\n                            this.blocked = true;\n                        }\n                        \n                        _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(nodes);\n                    }\n                };\n            }()),\n            \"set-directions\": function () {\n                var i = '',\n                    j = 0,\n                    entities = null,\n                    node     = this.node,\n                    nextNode = null;\n                \n                this.owner.triggerEvent('remove-directions');\n                \n                for (i in node.neighbors) {\n                    if (node.neighbors.hasOwnProperty(i)) {\n                        this.neighbors[i] = createGateway(node.neighbors[i], node.map, i);\n                        this.addEventListener(i, this.neighbors[i]);\n\n                        //trigger \"next-to\" events\n                        nextNode = node.map.getNode(node.neighbors[i]);\n                        if (nextNode) {\n                            entities = nextNode.contains;\n                            for (j = 0; j < entities.length; j++) {\n                                entities[j].triggerEvent(\"next-to-\" + this.owner.type, this.owner);\n                                this.owner.triggerEvent(\"next-to-\" + entities[j].type, entities[j]);\n                            }\n                        }\n                    }\n                }\n            },\n            \"remove-directions\": function () {\n                var i = '';\n                \n                for (i in this.neighbors) {\n                    if (this.neighbors.hasOwnProperty(i)) {\n                        this.removeEventListener(i, this.neighbors[i]);\n                        delete this.neighbors[i];\n                    }\n                }\n            }\n        },\n        \n        methods: {\n            gotoNode: (function () {\n                var test = function (here, there) {\n                    return (here === there);\n                };\n                \n                return function (node) {\n                    var travResp = null,\n                        depth = 20, //arbitrary limit\n                        origin = this.node || this.lastNode,\n                        nodes = null,\n                        moving = false;\n                    \n                    if (!node && this.followEntity) {\n                        node = this.followEntity.node || this.followEntity.lastNode || this.followEntity;\n                    }\n                    \n                    if (origin && node && (this.node !== node)) {\n                        nodes = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n                        \n                        travResp = this.traverseNode({\n                            depth: depth,\n                            origin: origin,\n                            position: origin,\n                            test: test,\n                            destination: node,\n                            nodes: nodes,\n                            shortestPath: Infinity,\n                            distance: 0,\n                            found: false,\n                            algorithm: this.algorithm,\n                            blocked: false\n                        });\n                        \n                        travResp.distance -= this.progress;\n                        \n                        if (travResp.found) {\n                            //TODO: should probably set this up apart from this containing function\n                            if (this.followEntity) {\n                                if (!this.followDistance) {\n                                    this.setPath(travResp);\n                                    moving = true;\n                                } else if ((travResp.distance + (this.followEntity.progress || 0)) > this.followDistance) {\n                                    this.lag = travResp.distance + (this.followEntity.progress || 0) - this.followDistance;\n                                    this.setPath(travResp);\n                                    moving = true;\n                                } else {\n                                    this.lag = 0;\n                                }\n                            } else {\n                                this.setPath(travResp);\n                                moving = true;\n                            }\n                        } else if (travResp.blocked) {\n                            this.blocked = true;\n                        }\n                        \n                        _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(nodes);\n                    }\n                    \n                    return moving;\n                };\n            }()),\n            \n            isPassable: function (node) {\n                return node && (this.node !== node) && (!this.friendlyNodes || (typeof this.friendlyNodes[node.type] !== 'undefined')) && (!node.contains.length || isFriendly(node.contains, this.friendlyEntities));\n            },\n            traverseNode: function (record) {\n                //TODO: may want to make this use A*. Currently node traversal order is arbitrary and essentially searches entire graph, but does clip out paths that are too long.\n                \n                var i         = 1,\n                    j         = '',\n                    map       = record.position.map,\n                    neighbors = null,\n                    node      = null,\n                    nodeList  = null,\n                    resp      = null,\n                    algorithm = record.algorithm || distance,\n                    savedResp = {\n                        shortestPath: Infinity,\n                        found: false,\n                        blocked: false\n                    },\n                    blocked   = true,\n                    hasNeighbor = false;\n\n                if ((record.depth === 0) || (record.distance > record.shortestPath)) {\n                    // if we've reached our search depth or are following a path longer than our recorded successful distance, bail\n                    return record;\n                } else if (record.test(record.position, record.destination)) {\n                    // if we've reached our destination, set shortest path information and bail.\n                    record.found = true;\n                    record.shortestPath = record.distance;\n                    return record;\n                } else {\n                    //Make sure we do not trace an infinite node loop.\n                    nodeList = record.nodes;\n                    for (i = 1; i < nodeList.length - 1; i++) {\n                        if (nodeList[i] === record.position) {\n                            return record;\n                        }\n                    }\n                        \n                    neighbors = record.position.neighbors;\n                    for (j in neighbors) {\n                        if (neighbors.hasOwnProperty(j)) {\n                            node = map.getNode(neighbors[j]);\n                            hasNeighbor = true;\n                            if (this.isPassable(node)) {\n                                nodeList = Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSlice\"])(record.nodes);\n                                nodeList.push(node);\n                                resp = this.traverseNode({\n                                    depth: record.depth - 1,\n                                    origin: record.origin,\n                                    position: node,\n                                    destination: record.destination,\n                                    test: record.test,\n                                    algorithm: algorithm,\n                                    nodes: nodeList,\n                                    shortestPath: record.shortestPath,\n                                    distance: record.distance + algorithm(record.position, node),\n                                    gateway: record.gateway || j,\n                                    found: false,\n                                    blocked: false\n                                });\n                                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(nodeList);\n                                if (resp.found && (savedResp.shortestPath > resp.shortestPath)) {\n                                    savedResp = resp;\n                                }\n                                blocked = false;\n                            }\n                        }\n                    }\n                    savedResp.blocked = (hasNeighbor && blocked);\n                    return savedResp;\n                }\n            },\n            setPath: function (resp, steps) {\n                if (resp.nodes[0] === this.node) {\n                    resp.nodes.shift();\n                }\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.destinationNodes);\n                this.destinationNodes = Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSlice\"])(resp.nodes);\n                if (steps) {\n                    this.destinationNodes.length = Math.min(steps, this.destinationNodes.length);\n                }\n            },\n            setState: function (state) {\n                if (state === 'on-node') {\n                    this.state.set('on-node', true);\n                } else {\n                    this.state.set('on-node', false);\n                    if (this.currentState) {\n                        this.state.set(this.currentState, false);\n                    }\n                    this.currentState = state;\n                    this.state.set(state, true);\n                }\n            },\n            onEdge: function (toNode) {\n                this.distance = distance(this.node, toNode);\n                if (this.updateOrientation) {\n                    this.owner.rotation = angle(this.node, toNode, this.distance, this.progress / this.distance);\n                }\n                this.node.addToEdge(this.owner);\n                toNode.addToEdge(this.owner);\n                this.owner.triggerEvent('leave-node');\n            },\n            destroy: function () {\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.destinationNodes);\n                this.destinationNodes = null;\n                this.state = null;\n            }\n        }\n    });\n}());\n\n\n//# sourceURL=webpack://platypus/./src/components/NodeResident.js?");

/***/ }),

/***/ "./src/components/Orientation.js":
/*!***************************************!*\
  !*** ./src/components/Orientation.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var _Data_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Data.js */ \"./src/Data.js\");\n/* harmony import */ var _Vector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Vector.js */ \"./src/Vector.js\");\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../factory.js */ \"./src/factory.js\");\n/* harmony import */ var _utils_string_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/string.js */ \"./src/utils/string.js\");\n/**\n * This component handles the orientation of an entity. It maintains an `orientationMatrix` property on the owner to describe the entity's orientation using an affine transformation matrix.\n *\n * Several methods on this component accept either a 3x3 2D Array or a string to describe orientation changes. Accepted strings include:\n *  - \"horizontal\"       - This flips the entity around the y-axis.\n *  - \"vertical\"         - This flips the entity around the x-axis.\n *  - \"diagonal\"         - This flips the entity around the x=y axis.\n *  - \"diagonal-inverse\" - This flips the entity around the x=-y axis.\n *  - \"rotate-90\"        - This rotates the entity 90 degrees clockwise.\n *  - \"rotate-180\"       - This rotates the entity 180 degrees clockwise (noticeable when tweening).\n *  - \"rotate-270\"       - This rotates the entity 90 degrees counter-clockwise.\n *\n * NOTE: This component absorbs specific properties already on the entity into orientation:\n *  - **orientationMatrix**: 3x3 2D array describing an affine transformation.\n *  - If the above is not provided, these properties are used to set initial orientation. This is useful when importing Tiled maps.\n *     - **scaleX**: absorb -1 if described\n *     - **scaleY**: absorb -1 if described\n *     - **rotation**: absorb 90 degree rotations\n *\n * @namespace platypus.components\n * @class Orientation\n * @uses platypus.Component\n */\n\n\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    var normal = _Vector_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(0, 0, 1),\n        origin = _Vector_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(1, 0, 0),\n        matrices = {\n            'identity': [[  1,  0,  0],\n                         [  0,  1,  0],\n                         [  0,  0,  1]],\n            'horizontal': [[ -1,  0,  0],\n                           [  0,  1,  0],\n                           [  0,  0, -1]],\n            'vertical': [[  1,  0,  0],\n                         [  0, -1,  0],\n                         [  0,  0, -1]],\n            'diagonal': [[  0,  1,  0],\n                         [  1,  0,  0],\n                         [  0,  0, -1]],\n            'diagonal-inverse': [[  0, -1,  0],\n                                 [ -1,  0,  0],\n                                 [  0,  0, -1]],\n            'rotate-90': [[  0, -1,  0],\n                          [  1,  0,  0],\n                          [  0,  0,  1]],\n            'rotate-180': [[ -1,  0,  0],\n                           [  0, -1,  0],\n                           [  0,  0,  1]],\n            'rotate-270': [[  0,  1,  0],\n                           [ -1,  0,  0],\n                           [  0,  0,  1]]\n        },\n        multiply = (function () {\n            var cell = function (row, column, m) {\n                var i = 0,\n                    sum = 0;\n\n                for (i = 0; i < row.length; i++) {\n                    sum += row[i] * m[i][column];\n                }\n\n                return sum;\n            };\n\n            return function (a, b, dest) {\n                var i   = 0,\n                    j   = 0,\n                    arr = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n\n                for (i = 0; i < a.length; i++) {\n                    for (j = 0; j < a[0].length; j++) {\n                        arr.push(cell(a[i], j, b));\n                    }\n                }\n\n                for (i = 0; i < a.length; i++) {\n                    for (j = 0; j < a[0].length; j++) {\n                        dest[i][j] = arr.shift();\n                    }\n                }\n                \n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(arr);\n            };\n        }()),\n        identitize = function (m) {\n            var i = 0,\n                j = 0;\n\n            for (i = 0; i < 3; i++) {\n                for (j = 0; j < 3; j++) {\n                    if (i === j) {\n                        m[i][j] = 1;\n                    } else {\n                        m[i][j] = 0;\n                    }\n                }\n            }\n\n            return m;\n        };\n    \n    return Object(_factory_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])({\n        id: 'Orientation',\n        publicProperties: {\n            /**\n             * The Entity's scale along the X-axis will mirror the entity's initial orientation if it is negative. This value is available via `entity.scaleX`, but is not manipulated by this component after instantiation.\n             *\n             * @property scaleX\n             * @type number\n             * @default 1\n             */\n            \"scaleX\": 1,\n\n            /**\n             * The Entity's scale along the Y-axis will flip the entity's initial orientation if it is negative. This value is available via `entity.scaleY`, but is not manipulated by this component after instantiation.\n             *\n             * @property scaleY\n             * @type number\n             * @default 1\n             */\n            \"scaleY\": 1,\n\n            /**\n             * The Entity's rotation will rotate entity's initial orientation if it is a multiple of 90 degrees. This value is available via `entity.rotation`, but is not manipulated by this component after instantiation.\n             *\n             * @property rotation\n             * @type number\n             * @default 0\n             */\n            \"rotation\": 0,\n\n            /**\n             * The Entity's orientation is an angle in radians describing an entity's orientation around the Z-axis. This property is affected by a changing `entity.orientationMatrix` but does not itself change the orientation matrix.\n             *\n             * @property orientation\n             * @type number\n             * @default 0\n             */\n            \"orientation\": 0,\n            \n            /**\n             * The entity's orientation matrix determines the orientation of an entity and its vectors. It's a 3x3 2D Array describing an affine transformation of the entity.\n             *\n             * @property orientationMatrix\n             * @type Array\n             * @default 3x3 identity matrix\n             */\n            \"orientationMatrix\": null\n        },\n        initialize: (function () {\n            var setupOrientation = function (self, orientation) {\n                var vector = _Vector_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(1, 0, 0),\n                    owner  = self.owner,\n                    matrix = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(\n                        _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(1, 0, 0),\n                        _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(0, 1, 0),\n                        _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(0, 0, 1)\n                    );\n                \n                Object.defineProperty(owner, 'orientationMatrix', {\n                    get: function () {\n                        multiply(self.matrixTween, self.matrix, identitize(matrix));\n                        return matrix;\n                    },\n                    enumerable: true\n                });\n\n                delete owner.orientation;\n                Object.defineProperty(owner, 'orientation', {\n                    get: function () {\n                        return vector.signedAngleTo(origin, normal);\n                    },\n                    set: function (value) {\n                        vector.setVector(origin).rotate(value);\n                    },\n                    enumerable: true\n                });\n\n                Object.defineProperty(owner, 'rotation', {\n                    get: function () {\n                        return owner.orientation / Math.PI * 180;\n                    },\n                    set: function (value) {\n                        owner.orientation = value * Math.PI / 180;\n                    },\n                    enumerable: true\n                });\n\n                if (orientation) {\n                    if (typeof orientation !== 'number') {\n                        vector.set(orientation);\n                    } else {\n                        vector.rotate(orientation);\n                    }\n                }\n\n                return vector;\n            };\n            \n            return function () {\n                this.loadedOrientationMatrix = this.orientationMatrix;\n                \n                // This is the stationary transform\n                this.matrix = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(\n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(1, 0, 0),\n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(0, 1, 0),\n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(0, 0, 1)\n                );\n                \n                // This is the tweening transform\n                this.matrixTween = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(\n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(1, 0, 0),\n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(0, 1, 0),\n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(0, 0, 1)\n                );\n                \n                this.relocationMessage = _Data_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp(\n                    \"position\", null\n                );\n                \n                this.vectors  = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n                this.inverses = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n                this.tweens   = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n                \n                this.orientationVector = setupOrientation(this, this.orientation);\n                this.owner.triggerEvent('orient-vector', this.orientationVector);\n                \n                this.owner.state.set('reorienting', false);\n            };\n        }()),\n\n        events: {\n            /**\n             * This component listens for this event prior to loading initial transformations.\n             *\n             * @method 'load'\n             */\n            \"load\": function () {\n                if (this.loadedOrientationMatrix) {\n                    this.transform(this.loadedOrientationMatrix);\n                } else {\n                    if (this.scaleX && this.scaleX < 0) {\n                        this.scaleX = -this.scaleX;\n                        this.transform('horizontal');\n                    }\n                    if (this.scaleY && this.scaleY < 0) {\n                        this.scaleY = -this.scaleY;\n                        this.transform('vertical');\n                    }\n                    if (this.rotation) {\n                        if (((this.rotation + 270) % 360) === 0) {\n                            this.rotation = 0;\n                            this.transform('rotate-90');\n                        } else if (((this.rotation + 180) % 360) === 0) {\n                            this.rotation = 0;\n                            this.transform('rotate-180');\n                        } else if (((this.rotation + 90) % 360) === 0) {\n                            this.rotation = 0;\n                            this.transform('rotate-270');\n                        }\n                    }\n                }\n                delete this.loadedOrientationMatrix;\n            },\n            \n            /**\n             * On the 'handle-logic' event, this component updates any transformational tweening of the entity.\n             *\n             * @method 'handle-logic'\n             * @param tick.delta {number} Time passed since the last logic step.\n             */\n            \"handle-logic\": function (tick) {\n                var i = this.tweens.length,\n                    delta = tick.delta,\n                    state = this.owner.state,\n                    finishedTweening = null,\n                    tween = null,\n                    msg = this.relocationMessage;\n                \n                if (i) {\n                    finishedTweening = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n                    state.set('reorienting', true);\n                    identitize(this.matrixTween);\n                    \n                    while (i--) {\n                        if (this.updateTween(this.tweens[i], delta)) { // finished tweening\n                            finishedTweening.push(Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSplice\"])(this.tweens, i));\n                        }\n                    }\n                    \n                    i = this.vectors.length;\n                    while (i--) {\n                        this.updateVector(this.vectors[i], this.inverses[i]);\n                    }\n                    \n                    i = finishedTweening.length;\n                    while (i--) {\n                        tween = finishedTweening[i];\n                        this.transform(tween.endMatrix);\n                        if (tween.anchor) {\n                            tween.offset.multiply(tween.endMatrix).addVector(tween.anchor);\n                            msg.position = tween.offset;\n                            this.owner.triggerEvent('relocate-entity', msg);\n                            if (tween.recycleOffset) {\n                                tween.offset.recycle();\n                            }\n                        }\n                        tween.onFinished(tween.endMatrix);\n                        tween.recycle();\n                    }\n                    \n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(finishedTweening);\n                } else if (state.get('reorienting')) {\n                    identitize(this.matrixTween);\n                    state.set('reorienting', false);\n                }\n            },\n            \n            /**\n             * On receiving this message, any currently running orientation tweens are immediately completed to give the entity a new stable position.\n             *\n             * @method 'complete-tweens'\n             */\n            \"complete-tweens\": function () {\n                var i = 0;\n                \n                for (i = 0; i < this.tweens.length; i++) {\n                    this.tweens[i].time = this.tweens[i].endTime;\n                }\n            },\n            \n            /**\n             * On receiving this message, any currently running orientation tweens are discarded, returning the entity to its last stable position.\n             *\n             * @method 'drop-tweens'\n             */\n            \"drop-tweens\": function () {\n                var i = 0;\n                \n                i = this.tweens.length;\n                while (i--) {\n                    if (this.tweens[i].offset) {\n                        this.tweens[i].offset.recycle();\n                    }\n                }\n                this.tweens.length = 0;\n                \n                i = this.vectors.length;\n                while (i--) {\n                    this.updateVector(this.vectors[i], this.inverses[i]);\n                }\n            },\n            \n            /**\n             * On receiving a vector via this event, the component will transform the vector using the current orientation matrix and then store the vector and continue manipulating it as the orientation matrix changes.\n             *\n             * @method 'orient-vector'\n             * @param vector {platypus.Vector} The vector whose orientation will be maintained.\n             */\n            \"orient-vector\": function (vector) {\n                var aligned = vector.aligned || false;\n                \n                if (vector.vector) {\n                    vector = vector.vector;\n                }\n                \n                if (this.vectors.indexOf(vector) === -1) {\n                    if (!aligned) {\n                        vector.multiply(this.matrix);\n                    }\n                    this.vectors.push(vector);\n                    this.inverses.push(_Vector_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp());\n                }\n            },\n            \n            /**\n             * On receiving this message, the maintained vector is immediately dropped from the list of maintained vectors.\n             *\n             * @method 'remove-vector'\n             * @param vector {platypus.Vector} The vector to be removed.\n             */\n            \"remove-vector\": function (vector) {\n                var i = this.vectors.indexOf(vector);\n                \n                if (i >= 0) {\n                    Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSplice\"])(this.vectors, i);\n                    Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSplice\"])(this.inverses, i).recycle();\n                }\n            },\n            \n            /**\n             * This message causes the component to begin tweening the entity's orientation over a span of time into the new orientation.\n             *\n             * @method 'tween-transform'\n             * @param options {Object} A list of key/value pairs describing the tween options.\n             * @param options.matrix {Array} A transformation matrix: only required if `transform` is not provided\n             * @param options.transform {String} A transformation type: only required if `matrix` is not provided.\n             * @param options.time {number} The time over which the tween occurs. 0 makes it instantaneous.\n             * @param [options.anchor] {platypus.Vector} The anchor of the orientation change. If not provided, the owner's position is used.\n             * @param [options.offset] {platypus.Vector} If an anchor is supplied, this vector describes the entity's distance from the anchor. It defaults to the entity's current position relative to the anchor position.\n             * @param [options.angle] {number} Angle in radians to transform. This is only valid for rotations and is derived from the transform if not provided.\n             * @param [options.tween] {Function} A function describing the transition. Performs a linear transition by default. See CreateJS Ease for other options.\n             * @param [options.beforeTick] {Function} A function that should be processed before each tick as the tween occurs. This function should return `true`, otherwise the tween doesn't take a step.\n             * @param [options.afterTick] {Function} A function that should be processed after each tick as the tween occurs.\n             * @param [options.onFinished] {Function} A function that should be run once the transition is complete.\n             */\n            \"tween-transform\": (function () {\n                var doNothing = function () {\n                        // Doing nothing!\n                    },\n                    returnTrue = function () {\n                        return true;\n                    },\n                    linearEase = function (t) {\n                        return t;\n                    };\n\n                return function (props) {\n                    var arr = null,\n                        angle  = props.angle || 0,\n                        matrix = props.matrix,\n                        tween  = _Data_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp(\n                            \"transform\", props.transform,\n                            \"anchor\", props.anchor,\n                            \"endTime\", props.time || 0,\n                            \"time\", 0,\n                            \"tween\", props.tween || linearEase,\n                            \"onFinished\", props.onFinished || doNothing,\n                            \"beforeTick\", props.beforeTick || returnTrue,\n                            \"afterTick\", props.afterTick || doNothing\n                        );\n                    \n                    if (!matrix) {\n                        matrix = matrices[props.transform];\n                    }\n                    tween.endMatrix = matrix;\n                    \n                    if (!angle && (props.transform.indexOf('rotate') === 0)) {\n                        switch (props.transform) {\n                        case 'rotate-90':\n                            angle = Math.PI / 2;\n                            break;\n                        case 'rotate-180':\n                            angle = Math.PI;\n                            break;\n                        case 'rotate-270':\n                            angle = -Math.PI / 2;\n                            break;\n                        default:\n                            arr = Object(_utils_string_js__WEBPACK_IMPORTED_MODULE_4__[\"greenSplit\"])(props.transform, '-');\n                            angle = (arr[1] / 180) * Math.PI;\n                            _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(arr);\n                            break;\n                        }\n                    }\n                    tween.angle = angle;\n                    \n                    if (props.anchor) {\n                        tween.offset = props.offset;\n                        if (!tween.offset) {\n                            tween.offset = this.owner.position.copy().subtractVector(props.anchor, 2);\n                            tween.recycleOffset = true;\n                        }\n                    }\n                    \n                    this.tweens.push(tween);\n                };\n            }()),\n            \n            /**\n             * This message performs an immediate transform of the entity by performing the transformation via a prepended matrix multiplication.\n             *\n             * @method 'transform'\n             * @param transform {Array|String} A 3x3 @D Array or a string describing a transformation.\n             */\n            \"transform\": function (transform) {\n                this.transform(transform);\n            },\n            \n            /**\n             * This message performs an immediate transform of the entity by performing the transformation via a prepended matrix multiplication.\n             *\n             * @method 'prepend-transform'\n             * @param transform {Array|String} A 3x3 @D Array or a string describing a transformation.\n             */\n            \"prepend-transform\": function (transform) {\n                this.transform(transform);\n            },\n            \n            /**\n             * This message performs an immediate transform of the entity by performing the transformation via an appended matrix multiplication.\n             *\n             * @method 'append-transform'\n             * @param transform {Array|String} A 3x3 @D Array or a string describing a transformation.\n             */\n            \"append-transform\": function (transform) {\n                this.transform(transform, true);\n            },\n            \n            /**\n             * This message performs an immediate transform of the entity by returning the entity to an identity transform before performing a matrix multiplication.\n             *\n             * @method 'replace-transform'\n             * @param transform {Array|String} A 3x3 @D Array or a string describing a transformation.\n             */\n            \"replace-transform\": function (transform) {\n                if (Array.isArray(transform)) {\n                    this.replace(transform);\n                } else if (typeof transform === 'string') {\n                    if (matrices[transform]) {\n                        this.replace(matrices[transform]);\n                    }\n                }\n            }\n        },\n        \n        methods: {\n            transform: function (transform, append) {\n                if (Array.isArray(transform)) {\n                    this.multiply(transform, append);\n                } else if (typeof transform === 'string') {\n                    if (matrices[transform]) {\n                        this.multiply(matrices[transform], append);\n                    }\n                }\n            },\n            \n            multiply: (function () {\n                return function (m, append) {\n                    var i = 0;\n                    \n                    if (append) {\n                        multiply(this.matrix, m, this.matrix);\n                    } else {\n                        multiply(m, this.matrix, this.matrix);\n                    }\n                    \n                    for (i = 0; i < this.vectors.length; i++) {\n                        this.vectors[i].multiply(m);\n                        this.inverses[i].multiply(m);\n                    }\n                    \n                    /**\n                     * Once a transform is complete, this event is triggered to notify the entity of the completed transformation.\n                     *\n                     * @event 'orientation-updated'\n                     * @param matrix {Array} A 3x3 2D array describing the change in orientation.\n                     */\n                    this.owner.triggerEvent('orientation-updated', m);\n                };\n            }()),\n\n            replace: (function () {\n                var det2 = function (a, b, c, d) {\n                        return a * d - b * c;\n                    },\n                    det3 = function (a) {\n                        var i = 0,\n                            sum = 0;\n\n                        for (i = 0; i < 3; i++) {\n                            sum += a[i][0] * a[(i + 1) % 3][1] * a[(i + 2) % 3][2];\n                            sum -= a[i][2] * a[(i + 1) % 3][1] * a[(i + 2) % 3][0];\n                        }\n                        return sum;\n                    },\n                    invert = function (a) {\n                        var arr = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(), _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(), _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp()),\n                            inv = 1 / det3(a);\n\n                        arr[0].push(det2(a[1][1], a[1][2], a[2][1], a[2][2]) * inv);\n                        arr[0].push(det2(a[0][2], a[0][1], a[2][2], a[2][1]) * inv);\n                        arr[0].push(det2(a[0][1], a[0][2], a[1][1], a[1][2]) * inv);\n                        arr[1].push(det2(a[1][2], a[1][0], a[2][2], a[2][0]) * inv);\n                        arr[1].push(det2(a[0][0], a[0][2], a[2][0], a[2][2]) * inv);\n                        arr[1].push(det2(a[0][2], a[0][0], a[1][2], a[1][0]) * inv);\n                        arr[2].push(det2(a[1][0], a[1][1], a[2][0], a[2][1]) * inv);\n                        arr[2].push(det2(a[0][1], a[0][0], a[2][1], a[2][0]) * inv);\n                        arr[2].push(det2(a[0][0], a[0][1], a[1][0], a[1][1]) * inv);\n\n                        return arr;\n                    };\n                \n                return function (m) {\n                    var inversion = invert(this.matrix);\n                    \n                    // We invert the matrix so we can re-orient all vectors for the incoming replacement matrix.\n                    this.multiply(inversion);\n                    this.multiply(m);\n                    \n                    // clean-up\n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(inversion, 2);\n                };\n            }()),\n            \n            updateTween: (function () {\n                var getMid = function (a, b, t) {\n                    return (a * (1 - t) + b * t);\n                };\n                \n                return function (tween, delta) {\n                    var t = 0,\n                        a = 1,                //  a c -\n                        b = 0,                //  b d -\n                        c = 0,                //  - - z\n                        d = 1,\n                        z = 1,\n                        angle = 0,\n                        m = tween.endMatrix,\n                        matrix = null,\n                        initialOffset = null,\n                        finalOffset = null;\n                    \n                    if (tween.beforeTick(tween.time)) {\n                        tween.time += delta;\n                    }\n                    \n                    if (tween.time >= tween.endTime) {\n                        return true;\n                    }\n                    \n                    t = tween.tween(tween.time / tween.endTime);\n                    \n                    if (tween.angle) {\n                        angle = t * tween.angle;\n                        a = d = Math.cos(angle);\n                        b = Math.sin(angle);\n                        c = -b;\n                    } else {\n                        a = getMid(a, m[0][0], t);\n                        b = getMid(b, m[1][0], t);\n                        c = getMid(c, m[0][1], t);\n                        d = getMid(d, m[1][1], t);\n                        z = getMid(z, m[2][2], t);\n                    }\n                    \n                    matrix = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(\n                        _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(a, c, 0),\n                        _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(b, d, 0),\n                        _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(0, 0, z)\n                    );\n\n                    multiply(this.matrixTween, matrix, this.matrixTween);\n                    \n                    if (tween.anchor) {\n                        initialOffset = _Vector_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(tween.offset).multiply(1 - t);\n                        finalOffset = _Vector_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(tween.offset).multiply(t);\n                        \n                        this.owner.triggerEvent('relocate-entity', {\n                            position: initialOffset.add(finalOffset).multiply(matrix).addVector(tween.anchor)\n                        });\n                        \n                        initialOffset.recycle();\n                        finalOffset.recycle();\n                    }\n\n                    tween.afterTick(t, matrix);\n                    \n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(matrix, 2);\n                    \n                    return false;\n                };\n            }()),\n            \n            updateVector: function (vector, inverse) {\n                inverse.setVector(vector.add(inverse)); // Inverses are stored to return to the original postion, *but* also allow outside changes on the vectors to be retained. This introduces floating point errors on tweened vectors. - DDD 2/10/2016\n                vector.multiply(this.matrixTween);\n                inverse.subtractVector(vector);\n            },\n            \n            destroy: function () {\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.vectors); this.vectors = null;\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.inverses); this.inverses = null;\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.tweens); this.tweens = null;\n                this.orientationVector.recycle(); this.orientationVector = null;\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.orientationMatrix, 2);/* this.orientationMatrix = null; - Only has a setter */\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.matrix, 2); this.matrix = null;\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.matrixTween, 2); this.matrixTween = null;\n                this.relocationMessage.recycle(); this.relocationMessage = null;\n            }\n        }\n    });\n}());\n\n\n//# sourceURL=webpack://platypus/./src/components/Orientation.js?");

/***/ }),

/***/ "./src/components/RandomEvents.js":
/*!****************************************!*\
  !*** ./src/components/RandomEvents.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../factory.js */ \"./src/factory.js\");\n/**\n * This component listens for certain messages, picks a message from a related list of events, and triggers it. This is useful for adding random behaviors to an entity, such as having an entity say one thing from a list of audio clips. For example, defining this component on an Entity may look like this:\n * \n *     {\n *       \"type\": \"RandomEvents\",\n *       \n *       \"events\": {\n *       // This is a key/value list of events to listen for, with each event mapping to an array of events to pick from.\n *       \n *         \"make-sound\": [\"scream\", \"whisper\", \"talk\"]\n *         //on the component receiving the \"make-sound\" message, it will trigger one of the three possible messages listed here.\n *       }\n *     }\n *     \n * @namespace platypus.components\n * @class RandomEvents\n * @uses platypus.Component\n*/\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n\n    var createTrigger = function (eventList) {\n        return function (value, debug) {\n            this.owner.trigger(eventList[Math.floor(Math.random() * eventList.length)], value, debug);\n        };\n    };\n\n    return Object(_factory_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        id: 'RandomEvents',\n        \n        initialize: function (definition) {\n            var event = '';\n            \n            if (definition.events) {\n                for (event in definition.events) {\n                    if (definition.events.hasOwnProperty(event)) {\n                        this.addEventListener(event, createTrigger(definition.events[event]));\n                    }\n                }\n            }\n        }\n    });\n}());\n\n\n//# sourceURL=webpack://platypus/./src/components/RandomEvents.js?");

/***/ }),

/***/ "./src/components/RelativePosition.js":
/*!********************************************!*\
  !*** ./src/components/RelativePosition.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _AABB_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../AABB.js */ \"./src/AABB.js\");\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../factory.js */ \"./src/factory.js\");\n/**\n * This component positions an entity relative to the camera viewport, according to `left`, `top`, `right`, and `left` properties.\n *\n * @class RelativePosition\n * @uses platypus.Component\n */\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    return Object(_factory_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])({\n        \n        id: 'RelativePosition',\n\n        properties: {\n            /**\n             * This optional array sets varying properties depending on the aspect ratio of the camera. This is useful if the camera aspect ratio varies greatly and entities must be repositioned accordingly.\n             *\n             * In this example, the entity maintains a particular horizontal location until the camera viewport becomes narrower than 2:1, at which point it maintains a particular `left` value:\n             *\n             *      \"cameraSizes\": [{\n             *          \"minRatio\": 2, // This block applies for wide aspect ratios until 2:1 is reached.\n             *          \"x\": -1226\n             *      }, {\n             *          \"minRatio\": 0, // This block applies for everything else.\n             *          \"left\": 130\n             *      }]\n             *\n             * @property cameraSizes\n             * @type Array\n             * @default null\n             */\n            cameraSizes: null\n        },\n        \n        publicProperties: {\n            /**\n             * This sets the distance in world units from the bottom of the camera's world viewport. If set, it will override the entity's y coordinate. This property is accessible on the entity as `entity.bottom`.\n             *\n             * @property bottom\n             * @type Number\n             * @default null\n             */\n            bottom: null,\n\n            /**\n             * This sets the distance in world units from the left of the camera's world viewport. If set, it will override the entity's x coordinate. This property is accessible on the entity as `entity.left`.\n             *\n             * @property left\n             * @type Number\n             * @default null\n             */\n            left: null,\n\n            /**\n             * This sets the distance in world units from the right of the camera's world viewport. If set, it will override the entity's x coordinate. This property is accessible on the entity as `entity.right`.\n             *\n             * @property right\n             * @type Number\n             * @default null\n             */\n            right: null,\n\n            /**\n             * This sets the distance in world units from the top of the camera's world viewport. If set, it will override the entity's y coordinate. This property is accessible on the entity as `entity.top`.\n             *\n             * @property top\n             * @type Number\n             * @default null\n             */\n            top: null,\n\n            /**\n             * This sets the scale in X of the entity.\n             *\n             * @property scaleX\n             * @type Number\n             * @default 1\n             */\n            scaleX: 1,\n\n            /**\n             * This sets the scale in Y of the entity.\n             *\n             * @property scaleY\n             * @type Number\n             * @default 1\n             */\n            scaleY: 1,\n\n            /**\n             * This sets the `x` coordinate for the entity. It is overridden by `left` and `right` properties if supplied.\n             *\n             * @property x\n             * @type Number\n             * @default 0\n             */\n            x: 0,\n\n            /**\n             * This sets the `y` coordinate for the entity. It is overridden by `top` and `bottom` properties if supplied.\n             *\n             * @property y\n             * @type Number\n             * @default 0\n             */\n            y: 0\n        },\n        \n        initialize: function (/*definition, callback*/) {\n            this.aabb = _AABB_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp();\n            this.lastBottom = null;\n            this.lastLeft = null;\n            this.lastRight = null;\n            this.lastTop = null;\n            this.cameraSizesIndex = -1;\n        },\n\n        events: {// These are messages that this component listens for\n            /**\n             * This component uses location updates to reposition the entity if its bottom, left, right, or top properties have been set.\n             *\n             * @method 'handle-logic'\n             */\n            \"handle-logic\": function () {\n                var bottom = this.bottom,\n                    left = this.left,\n                    right = this.right,\n                    top = this.top;\n\n                if ((this.lastBottom !== bottom) || (this.lastLeft !== left) || (this.lastRight !== right) || (this.lastTop !== top)) {\n                    this.updatePosition(this.aabb);\n                    this.lastBottom = bottom;\n                    this.lastLeft = left;\n                    this.lastRight = right;\n                    this.lastTop = top;\n                }\n            },\n\n            /**\n             * This component listens for camera updates to reposition the entity if its bottom, left, right, or top properties have been set.\n             *\n             * @method 'camera-update'\n             * @param camera {platypus.Data} Camera update information\n             * @param camera.viewport {platypus.AABB} The bounding box describing the camera viewport location in the world.\n             */\n            \"camera-update\": function (camera) {\n                this.aabb.set(camera.viewport);\n                if (this.cameraSizes) {\n                    this.checkCamera(this.aabb);\n                }\n                this.updatePosition(this.aabb);\n            }\n        },\n        \n        methods: {// These are internal methods that are invoked by this component.\n            checkCamera: function (aabb) {\n                var arr = this.cameraSizes,\n                    i = 0,\n                    ratio = aabb.width / aabb.height;\n\n                for (i = 0; i < arr.length; i++) {\n                    if (ratio > arr[i].minRatio) {\n                        if (i !== this.cameraSizesIndex) {\n                            this.updateProperties(arr[i]);\n                            this.cameraSizesIndex = i;\n                        }\n                        break;\n                    }\n                }\n            },\n\n            updateProperties: function (props) {\n                this.right = (typeof props.right === 'number') ? props.right : null;\n                this.left = (typeof props.left === 'number') ? props.left : null;\n                this.top = (typeof props.top === 'number') ? props.top : null;\n                this.bottom = (typeof props.bottom === 'number') ? props.bottom : null;\n                if (typeof props.x === 'number') {\n                    this.x = props.x;\n                }\n                if (typeof props.y === 'number') {\n                    this.y = props.y;\n                }\n                if (typeof props.scaleX === 'number') {\n                    this.scaleX = props.scaleX;\n                }\n                if (typeof props.scaleY === 'number') {\n                    this.scaleY = props.scaleY;\n                }\n            },\n\n            updatePosition: function (vp) {\n                var bottom = this.bottom,\n                    left = this.left,\n                    owner = this.owner,\n                    right = this.right,\n                    top = this.top;\n\n                if (typeof left === 'number') {\n                    owner.x = vp.left + left;\n                } else if (typeof right === 'number') {\n                    owner.x = vp.right - right;\n                }\n\n                if (typeof top === 'number') {\n                    owner.y = vp.top + top;\n                } else if (typeof bottom === 'number') {\n                    owner.y = vp.bottom - bottom;\n                }\n            },\n\n            destroy: function () {\n                this.aabb.recycle();\n                this.aabb = null;\n            }\n        }\n    });\n}());\n\n\n//# sourceURL=webpack://platypus/./src/components/RelativePosition.js?");

/***/ }),

/***/ "./src/components/RelayFamily.js":
/*!***************************************!*\
  !*** ./src/components/RelayFamily.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../factory.js */ \"./src/factory.js\");\n/**\n * This component allows an entity to communicate directly with one or more entities via the message model, by passing local messages directly to entities in the same family as new triggered events. This component is placed on a single entity and all entities created by this entity become part of its \"family\".\n *\n * @namespace platypus.components\n * @class RelayFamily\n * @uses platypus.Component\n */\n/* global platypus */\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    return Object(_factory_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])({\n        id: 'RelayFamily',\n        \n        properties: {\n            /**\n             * This is an object of key/value pairs. The keys are events this component is listening for locally, the value is the event that will be broadcast to its linked entities. The value can also be an array of events to be fired on linked entities.\n             *\n             *      \"events\": {\n             *          \"sleeping\": \"good-night\",\n             *          \"awake\": [\"alarm\", \"get-up\"]\n             *      }\n             *\n             * @property events\n             * @type Object\n             * @default null\n             */\n            events: null\n        },\n\n        initialize: function () {\n            var event = '';\n            \n            if (this.events) {\n                for (event in this.events) {\n                    if (this.events.hasOwnProperty(event)) {\n                        this.addEventListener(event, this.broadcast.bind(this, null, this.events[event]));\n                    }\n                }\n            }\n    \n            this.owner.familyLinks = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(this.owner);\n        },\n        \n        events: {\n            /**\n             * Called when linking a new member to the family, this event accepts a list of family members from the new member and uses it to link all the family members together.\n             *\n             * @method 'link-family'\n             * @param links {Array|Entities} An array of entities.\n             */\n            \"link-family\": function (links) {\n                var i = 0,\n                    oldList = this.owner.familyLinks,\n                    newList = Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"union\"])(Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"union\"])(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(), links), oldList);\n\n                for (i = 0; i < newList.length; i++) {\n                    newList[i].familyLinks = newList;\n                }\n                this.broadcast(links,   'family-members-added', oldList);\n                this.broadcast(oldList, 'family-members-added', links);\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(oldList);\n            },\n            \n            /**\n             * Called when this entity spawns a new entity, this event links the newly created entity to this entity.\n             *\n             * @method 'entity-created'\n             * @param entity {platypus.Entity} The entity to link.\n             */\n            \"entity-created\": function (entity) {\n                if (!entity.triggerEvent('link-family', this.owner.familyLinks)) {\n                    entity.addComponent(new platypus.components.RelayFamily(entity, {}));\n                    entity.triggerEvent('link-family', this.owner.familyLinks);\n                }\n            }\n        },\n        \n        methods: {\n            broadcast: function (links) {\n                var entities = links || this.owner.familyLinks,\n                    i = 0,\n                    args = Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSlice\"])(arguments);\n\n                args.shift();\n\n                for (i = 0; i < entities.length; i++) {\n                    entities[i].trigger.apply(entities[i], args);\n                }\n                \n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(args);\n            },\n            \n            destroy: function () {\n                var familyLinks = this.owner.familyLinks,\n                    i = familyLinks.indexOf(this.owner);\n                \n                if (i >= 0) {\n                    Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSplice\"])(familyLinks, i);\n                }\n                this.broadcast(familyLinks, 'family-member-removed', this.owner);\n                this.events = null;\n            }\n        }\n    });\n}());\n\n\n//# sourceURL=webpack://platypus/./src/components/RelayFamily.js?");

/***/ }),

/***/ "./src/components/RelayGame.js":
/*!*************************************!*\
  !*** ./src/components/RelayGame.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../factory.js */ \"./src/factory.js\");\n/**\n * This component listens for specified local entity messages and re-broadcasts them at the scene level.\n *\n * @namespace platypus.components\n * @class RelayGame\n * @uses platypus.Component\n */\n/* global platypus */\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    var broadcast = function () {\n        platypus.game.triggerOnChildren.apply(platypus.game, arguments);\n    };\n\n    return Object(_factory_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        id: 'RelayGame',\n        \n        properties: {\n            /**\n             * This is an object of key/value pairs. The keys are events this component is listening for locally, and the value is the event to be broadcast to the scene. The value can also be an array of events to be fired on the scene.\n             *\n             *      \"events\": {\n             *          \"sleeping\": \"good-night\",\n             *          \"awake\": [\"alarm\", \"get-up\"]\n             *      }\n             *\n             * @property events\n             * @type Object\n             * @default null\n             */\n            events: null\n        },\n\n        initialize: function () {\n            var event = '',\n                events = this.events;\n            \n            // Messages that this component listens for and then broadcasts to all layers.\n            if (events) {\n                for (event in events) {\n                    if (events.hasOwnProperty(event)) {\n                        this.addEventListener(event, broadcast.bind(this, events[event]));\n                    }\n                }\n            }\n        }\n    });\n}());\n\n\n//# sourceURL=webpack://platypus/./src/components/RelayGame.js?");

/***/ }),

/***/ "./src/components/RelayLinker.js":
/*!***************************************!*\
  !*** ./src/components/RelayLinker.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../factory.js */ \"./src/factory.js\");\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/**\n * Allows an entity to communicate directly with one or more entities via the message model by passing local events directly to the linked entities as new triggered events.\n *\n * @namespace platypus.components\n * @class RelayLinker\n * @uses platypus.Component\n */\n/* global platypus */\n\n\n\nconst\n    channels = {},\n    broadcast = function (...args) {\n        const channel = this.channel;\n\n        for (let i = 0; i < channel.length; i++) {\n            channel[i].trigger(...args);\n        }\n    };\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Object(_factory_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n    id: 'RelayLinker',\n\n    properties: {\n        /**\n         * The id that defines the 'channel' the linkers are talking on. This should be matched on the entity/entities you want to talk between.\n         *\n         * @property linkId\n         * @type String\n         * @default 'linked'\n         */\n        linkId: 'linked',\n        \n        /**\n         * This is an object of key/value pairs. The keys are events this component is listening for locally, the value is the event to be broadcast to its linked entities. The value can also be an array of events to be fired on linked entities.\n         *\n         *      \"events\": {\n         *          \"sleeping\": \"good-night\",\n         *          \"awake\": [\"alarm\", \"get-up\"]\n         *      }\n         *\n         * @property events\n         * @type Object\n         * @default null\n         */\n        events: null\n    },\n\n    initialize: function () {\n        if (this.events) {\n            for (const event in this.events) {\n                if (this.events.hasOwnProperty(event)) {\n                    this.addEventListener(event, broadcast.bind(this, this.events[event]));\n                }\n            }\n        }\n        \n        if (!this.owner.linkId) {\n            this.owner.linkId = this.linkId;\n        }\n        \n        // Connect channel, or create if it doesn't exist.\n        this.channel = channels[this.linkId];\n        if (!this.channel) {\n            this.channel = channels[this.linkId] = [];\n        }\n    },\n    \n    events: {\n        /**\n         * Called when the object is added to its parent, on receiving this message, the component links itself with objects with the same link id.\n         *\n         * @method 'load'\n         */\n        \"load\": function () {\n            this.channel.push(this.owner);\n        }\n    },\n    \n    methods: {\n        destroy: function () {\n            const index = this.channel.indexOf(this.owner);\n\n            if (index >= 0) {\n                Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"greenSplice\"])(this.channel, index);\n            } else {\n                platypus.debug.warn('RelayLinker: Component destroyed, but entity not found on channel.');\n            }\n            this.events = null;\n        }\n    }\n}));\n\n\n//# sourceURL=webpack://platypus/./src/components/RelayLinker.js?");

/***/ }),

/***/ "./src/components/RelayParent.js":
/*!***************************************!*\
  !*** ./src/components/RelayParent.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../factory.js */ \"./src/factory.js\");\n/**\n * This component listens for specified local entity messages and re-broadcasts them on its parent entity.\n *\n * @namespace platypus.components\n * @class RelayParent\n * @uses platypus.Component\n */\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    \n\n    var broadcast = function () {\n        var parent = this.owner.parent;\n        \n        if (parent) {\n            parent.trigger.apply(parent, arguments);\n        }\n    };\n    \n    return Object(_factory_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        id: 'RelayParent',\n        \n        properties: {\n            /**\n             * This is an object of key/value pairs. The keys are events this component is listening for locally, and the value is the event to be broadcast on the parent. The value can also be an array of events to be triggered on the parent.\n             *\n             *      \"events\": {\n             *          \"sleeping\": \"good-night\",\n             *          \"awake\": [\"alarm\", \"get-up\"]\n             *      }\n             *\n             * @property events\n             * @type Object\n             * @default null\n             */\n            events: null\n        },\n\n        initialize: function () {\n            var event = '',\n                events = this.events;\n            \n            // Messages that this component listens for and then broadcasts to parent.\n            if (events) {\n                for (event in events) {\n                    if (events.hasOwnProperty(event)) {\n                        this.addEventListener(event, broadcast.bind(this, events[event]));\n                    }\n                }\n            }\n        }\n    });\n}());\n\n\n//# sourceURL=webpack://platypus/./src/components/RelayParent.js?");

/***/ }),

/***/ "./src/components/RelaySelf.js":
/*!*************************************!*\
  !*** ./src/components/RelaySelf.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../factory.js */ \"./src/factory.js\");\n/**\n * This component listens for specified local entity messages and re-broadcasts them on itself as other messages.\n *\n * @namespace platypus.components\n * @class RelaySelf\n * @uses platypus.Component\n */\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    var trigger = function () {\n        var owner = this.owner;\n        \n        owner.trigger.apply(owner, arguments);\n    };\n\n    return Object(_factory_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        id: 'RelaySelf',\n        \n        properties: {\n            /**\n             * This is an object of key/value pairs. The keys are events this component is listening for locally, the value is the new event to be broadcast on this entity. The value can also be an array of events to be fired.\n             *\n             *      \"events\": {\n             *          \"sleeping\": \"good-night\",\n             *          \"awake\": [\"alarm\", \"get-up\"]\n             *      }\n             *\n             * @property events\n             * @type Object\n             * @default null\n             */\n            events: null\n        },\n\n        initialize: function () {\n            var event = '',\n                events = this.events;\n            \n            // Messages that this component listens for and then triggers on itself as a renamed message - useful as a logic place-holder for simple entities.\n            if (events) {\n                for (event in events) {\n                    if (events.hasOwnProperty(event)) {\n                        this.addEventListener(event, trigger.bind(this, events[event]));\n                    }\n                }\n            }\n        }\n    });\n}());\n\n\n//# sourceURL=webpack://platypus/./src/components/RelaySelf.js?");

/***/ }),

/***/ "./src/components/RenderAnimator.js":
/*!******************************************!*\
  !*** ./src/components/RenderAnimator.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _StateMap_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../StateMap.js */ \"./src/StateMap.js\");\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../factory.js */ \"./src/factory.js\");\n/**\n * This component is typically added to an entity automatically by a render component. It handles mapping entity states and events to playable animations.\n *\n * @class RenderAnimator\n * @uses platypus.Component\n */\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    var createTest = function (testStates, animation) {\n            if (testStates === 'default') {\n                return defaultTest.bind(null, animation);\n            } else {\n                //TODO: Better clean-up: Create a lot of these without removing them later... DDD 2/5/2016\n                return stateTest.bind(null, animation, _StateMap_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp(testStates));\n            }\n        },\n        defaultTest = function (animation) {\n            return animation;\n        },\n        methodPlay = function (animation, loop, restart) {\n            this.component.playAnimation(animation, loop, restart);\n        },\n        methodStop = function (animation) {\n            this.component.stopAnimation(animation);\n        },\n        stateTest = function (animation, states, ownerState) {\n            if (ownerState.includes(states)) {\n                return animation;\n            }\n            return false;\n        },\n        triggerPlay = function (animation, loop, restart) {\n            /**\n             * On entering a new animation-mapped state, this component triggers this event to play an animation.\n             *\n             * @event 'play-animation'\n             * @param animation {String} Describes the animation to play.\n             * @param loop {Boolean} Whether to loop a playing animation.\n             * @param restart {Boolean} Whether to restart a playing animation.\n             */\n            this.owner.triggerEvent('play-animation', animation, loop, restart);\n        },\n        triggerStop = function (animation) {\n            /**\n             * On attaining an animation-mapped state, this component triggers this event to stop a previous animation.\n             *\n             * @event 'stop-animation'\n             * @param animation {String} Describes the animation to stop.\n             */\n            this.owner.triggerEvent('stop-animation', animation);\n        };\n\n    return Object(_factory_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({\n        id: 'RenderAnimator',\n\n        properties: {\n            /**\n             * An object containg key-value pairs that define a mapping from entity states to the animation that should play. The list is processed from top to bottom, so the most important actions should be listed first (for example, a jumping animation might take precedence over an idle animation). If not specified, an 1-to-1 animation map is created from the list of animations in the sprite sheet definition using the animation names as the keys.\n             *\n             *  \"animationStates\":{\n             *      \"standing\": \"default-animation\"  // On receiving a \"standing\" event, or when this.owner.state.standing === true, the \"default\" animation will begin playing.\n             *      \"ground,moving\": \"walking\",  // Comma separated values have a special meaning when evaluating \"state-changed\" messages. The above example will cause the \"walking\" animation to play ONLY if the entity's state includes both \"moving\" and \"ground\" equal to true.\n             *      \"ground,striking\": \"swing!\", // Putting an exclamation after an animation name causes this animation to complete before going to the next animation. This is useful for animations that would look poorly if interrupted.\n             *      \"default\": \"default-animation\" // Optional. \"default\" is a special property that matches all states. If none of the above states are valid for the entity, it will use the default animation listed here.\n             *  }\n             *\n             * @property animationStates\n             * @type Object\n             * @default null\n             */\n            animationStates: null,\n\n            /**\n             * An object containg key-value pairs that define a mapping from triggered events to the animation that should play.\n             *\n             *     \"animationEvents\":{\n             *         \"move\": \"walk-animation\",\n             *         \"jump\": \"jumping-animation\"\n             *     }\n             *\n             * The above will create two event listeners on the entity, \"move\" and \"jump\", that will play their corresponding animations when the events are triggered.\n             *\n             * @property animationEvents\n             * @type Object\n             * @default null\n             */\n            animationEvents: null,\n\n            /**\n             * Sets a component that this component should be connected to.\n             *\n             * @property component\n             * @type Component\n             * @default null\n             */\n            component: null,\n\n            /**\n             * Optional. Forces animations to complete before starting a new animation. Defaults to `false`.\n             *\n             * @property forcePlayThrough\n             * @type Boolean\n             * @default false\n             */\n            forcePlayThrough: false,\n\n            /**\n             * Whether to restart a playing animation on event.\n             *\n             * @property restart\n             * @type Boolean\n             * @default true\n             */\n            restart: true,\n\n            /**\n             * Whether to loop a playing animation on event.\n             *\n             * @property loop\n             * @type Boolean\n             * @default false\n             */\n            loop: false\n        },\n\n        initialize: (function () {\n            const\n                trigger = function (animation, loop, restart) {\n                    /**\n                     * On receiving an animation-mapped event, this component triggers this event to play an animation.\n                     *\n                     * @event 'play-animation'\n                     * @param animation {String} Describes the animation to play.\n                     * @param loop {Boolean} Whether to loop a playing animation.\n                     * @param restart {Boolean} Whether to restart a playing animation.\n                     */\n                    this.override = animation;\n                    this.owner.triggerEvent('play-animation', animation, loop, restart);\n                },\n                method = function (animation, loop, restart) {\n                    this.override = animation;\n                    this.playAnimation(animation, loop, restart);\n                };\n\n            return function () {\n                const\n                    events = this.animationEvents,\n                    states = this.animationStates;\n\n                //Handle Events:\n                this.override = false;\n                if (events) {\n                    for (const animation in events) {\n                        if (events.hasOwnProperty(animation)) {\n                            if (this.component) {\n                                this.addEventListener(animation, method.bind(this.component, events[animation], this.loop, this.restart));\n                            } else {\n                                this.addEventListener(animation, trigger.bind(this, events[animation], this.loop, this.restart));\n                            }\n                        }\n                    }\n                }\n\n                //Handle States:\n                this.followThroughs = {};\n                this.checkStates = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp();\n                this.state = this.owner.state;\n                this.stateChange = true; //Check state against entity's prior state to update animation if necessary on instantiation.\n                this.lastState = -1;\n\n                if (states) {\n                    for (const anim in states) {\n                        if (states.hasOwnProperty(anim)) {\n                            const animation = states[anim];\n\n                            //TODO: Should probably find a cleaner way to accomplish this. Maybe in the animationMap definition? - DDD\n                            if (animation[animation.length - 1] === '!') {\n                                animation = animation.substring(0, animation.length - 1);\n                                this.followThroughs[animation] = true;\n                            } else {\n                                this.followThroughs[animation] = false;\n                            }\n\n                            this.checkStates.push(createTest(anim, animation));\n                        }\n                    }\n                }\n\n                this.waitingAnimation = false;\n                this.waitingState = 0;\n                this.playWaiting = false;\n                this.animationFinished = false;\n\n                if (this.component) {\n                    this.playAnimation = methodPlay;\n                    this.stopAnimation = methodStop;\n                } else {\n                    this.playAnimation = triggerPlay;\n                    this.stopAnimation = triggerStop;\n                }\n            };\n        } ()),\n\n        events: {\n            /**\n             * This listens for the entity state to change and will update the currently playing animation.\n             *\n             * @method 'state-changed'\n             */\n            \"state-changed\": function () {\n                this.stateChange = true;\n            },\n\n            /**\n             * On receiving this event, the component checks for any waiting animations and begins playing them if so.\n             *\n             * @method 'animation-ended'\n             * @param animation {String} The animation that completed.\n             */\n            \"animation-ended\": function (animation) {\n                if (animation === this.currentAnimation) {\n                    if (this.override && (animation === this.override)) {\n                        this.stateChange = true;\n                        this.override = false;\n                    }\n\n                    if (this.waitingAnimation) {\n                        this.currentAnimation = this.waitingAnimation;\n                        this.waitingAnimation = false;\n                        this.lastState = this.waitingState;\n                        \n                        this.animationFinished = false;\n                        this.playAnimation(this.currentAnimation);\n                    } else {\n                        this.animationFinished = true;\n                    }\n                }\n            },\n\n            /**\n             * This checks to determine whether another animation should begin playing.\n             *\n             * @method update-animation\n             * @param playing {Boolean} Whether the new animation should play or pause on the first frame.\n             */\n            \"update-animation\": function (playing) {\n                var i = 0,\n                    testCase = false;\n\n                if (this.stateChange && !this.override) {\n                    if (this.state.has('visible')) {\n                        this.visible = this.state.get('visible');\n                    }\n                    for (i = 0; i < this.checkStates.length; i++) {\n                        testCase = this.checkStates[i](this.state);\n                        if (testCase) {\n                            if (this.currentAnimation !== testCase) {\n                                if (!this.followThroughs[this.currentAnimation] && (!this.forcePlaythrough || (this.animationFinished || (this.lastState >= +i)))) {\n                                    this.currentAnimation = testCase;\n                                    this.lastState = +i;\n                                    this.animationFinished = false;\n                                    if (playing) {\n                                        this.playAnimation(this.currentAnimation);\n                                    } else {\n                                        this.stopAnimation(this.currentAnimation);\n                                    }\n                                } else {\n                                    this.waitingAnimation = testCase;\n                                    this.waitingState = +i;\n                                }\n                            } else if (this.waitingAnimation && !this.followThroughs[this.currentAnimation]) {// keep animating this animation since this animation has already overlapped the waiting animation.\n                                this.waitingAnimation = false;\n                            }\n                            break;\n                        }\n                    }\n                    this.stateChange = false;\n                }\n            }\n        },\n        \n        methods: {\n            toJSON: function () { // This component is added by another component, so it shouldn't be returned for reconstruction.\n                return null;\n            },\n\n            destroy: function () {\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].recycle(this.checkStates);\n                this.checkStates = null;\n                this.followThroughs = null;\n                this.state = null;\n            }\n        }\n    });\n}());\n\n\n//# sourceURL=webpack://platypus/./src/components/RenderAnimator.js?");

/***/ }),

/***/ "./src/components/RenderContainer.js":
/*!*******************************************!*\
  !*** ./src/components/RenderContainer.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pixi.js */ \"pixi.js\");\n/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(pixi_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _AABB_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../AABB.js */ \"./src/AABB.js\");\n/* harmony import */ var _Data_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Data.js */ \"./src/Data.js\");\n/* harmony import */ var _Interactive_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Interactive.js */ \"./src/components/Interactive.js\");\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../factory.js */ \"./src/factory.js\");\n/* harmony import */ var _utils_string_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/string.js */ \"./src/utils/string.js\");\n/**\n * This component is attached to entities that will appear in the game world. It creates a PIXI Container to contain all other display objects on the entity and keeps the container updates with the entity's location and other dynamic properties.\n *\n * @namespace platypus.components\n * @class RenderContainer\n * @uses platypus.Component\n */\n/* global platypus */\n\n\n\n\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    var ColorMatrixFilter = pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"filters\"].ColorMatrixFilter,\n        pixiMatrix = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Matrix\"](),\n        castValue = function (color) {\n            if (color === null) {\n                return color;\n            }\n            if ((typeof color === 'string') && (color[0] === '#')) {\n                color = '0x' + color.substring(1);\n            }\n            return +color;\n        },\n        processGraphics = (function () {\n            var process = function (gfx, value) {\n                var i = 0,\n                    paren  = value.indexOf('('),\n                    func   = value.substring(0, paren),\n                    values = value.substring(paren + 1, value.indexOf(')')),\n                    polyRay = false;\n\n                if (values.length) {\n                    if (values[0] === '[') {\n                        values = values.substring(1, values.length - 1);\n                        polyRay = true;\n                    }\n                    values = Object(_utils_string_js__WEBPACK_IMPORTED_MODULE_6__[\"greenSplit\"])(values, ',');\n                    i = values.length;\n                    while (i--) {\n                        values[i] = +values[i];\n                    }\n                    if (polyRay) {\n                        gfx[func](values);\n                    } else {\n                        gfx[func].apply(gfx, values);\n                        _utils_array_js__WEBPACK_IMPORTED_MODULE_4__[\"arrayCache\"].recycle(values); // cannot recycle polygon above since it's used by the polygon shape.\n                    }\n                } else {\n                    gfx[func]();\n                }\n            };\n\n            return function (gfx, value) {\n                var i = 0,\n                    arr = Object(_utils_string_js__WEBPACK_IMPORTED_MODULE_6__[\"greenSplit\"])(value, '.');\n\n                for (i = 0; i < arr.length; i++) {\n                    process(gfx, arr[i]);\n                }\n                \n                _utils_array_js__WEBPACK_IMPORTED_MODULE_4__[\"arrayCache\"].recycle(arr);\n            };\n        }());\n    \n    return Object(_factory_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])({\n        \n        id: 'RenderContainer',\n        \n        properties: {\n            /**\n             * Optional. A mask definition that determines where the image should clip. A string can also be used to create more complex shapes via the PIXI graphics API like: \"mask\": \"r(10,20,40,40).drawCircle(30,10,12)\". Defaults to no mask or, if simply set to true, a rectangle using the entity's dimensions. Note that the mask is in world coordinates by default. To make the mask local to the entity's coordinates, set `localMask` to `true` in the RenderContainer properties.\n             *\n             *  \"mask\": {\n             *      \"x\": 10,\n             *      \"y\": 10,\n             *      \"width\": 40,\n             *      \"height\": 40\n             *  },\n             *\n             *  -OR-\n             *\n             *  \"mask\": \"r(10,20,40,40).drawCircle(30,10,12)\"\n             *\n             * @property mask\n             * @type Object\n             * @default null\n             */\n            mask: null,\n\n            /**\n             * Defines whether the entity will respond to touch and click events. Setting this value will create an Interactive component on this entity with these properties. For example:\n             *\n             *  \"interactive\": {\n             *      \"hover\": false,\n             *      \"hitArea\": {\n             *          \"x\": 10,\n             *          \"y\": 10,\n             *          \"width\": 40,\n             *          \"height\": 40\n             *      }\n             *  }\n             *\n             * @property interactive\n             * @type Boolean|Object\n             * @default false\n             */\n            interactive: false,\n\n            /**\n             * Optional. What field this object should use to rotate.\n             *\n             * @property rotate\n             * @type String\n             * @default 'rotation'\n             */\n            rotate: 'rotation',\n\n            /**\n             * Whether this object can be mirrored over X. To mirror it over X set the this.owner.rotation value to be > 90  and < 270.\n             *\n             * @property mirror\n             * @type Boolean\n             * @default false\n             */\n            mirror: false,\n\n            /**\n             * Optional. Whether this object can be flipped over Y. To flip it over Y set the this.owner.rotation to be > 180.\n             *\n             * @property flip\n             * @type Boolean\n             * @default false\n             */\n            flip: false,\n\n            /**\n             * Optional. Whether this object is visible or not. To change the visible value dynamically set this.owner.state.visible to true or false.\n             *\n             * @property visible\n             * @type Boolean\n             * @default false\n             */\n            visible: true,\n\n            /**\n             * Optional. Whether this sprite should be cached into an entity with a `RenderTiles` component (like \"render-layer\"). The `RenderTiles` component must have its \"entityCache\" property set to `true`. Warning! This is a one-direction setting and will remove this component from the entity once the current frame has been cached.\n             *\n             * @property cache\n             * @type Boolean\n             * @default false\n             */\n            cache: false,\n\n            /**\n             * Optional. Ignores the opacity of the owner.\n             *\n             * @property ignoreOpacity\n             * @type Boolean\n             * @default false\n             */\n            ignoreOpacity: false,\n\n            /**\n             * Whether the mask should be relative to the entity's coordinates.\n             *\n             * @property localMask\n             * @type boolean\n             * @default false\n             */\n            localMask: false\n        },\n\n        publicProperties: {\n            /**\n             * Prevents sprite from becoming invisible out of frame and losing mouse input connection.\n             *\n             * @property dragMode\n             * @type Boolean\n             * @default false\n             */\n            dragMode: false,\n\n            /**\n             * The entity or id of the entity that will act as the parent container. If not set, the entity will be rendered in the layer's container.\n             *\n             * @property renderParent\n             * @type String|Object\n             * @default null\n             */\n            renderParent: null,\n\n            /**\n             * Optional. The rotation of the sprite in degrees. All sprites on the same entity are rotated the same amount unless they ignore the rotation value by setting 'rotate' to \"\".\n             *\n             * Boolean values for the \"rotate\" property has been deprecated. Use \"rotation\" or \"orientationMatrix\" to specify the source of rotation for the render container.\n             *\n             * @property rotation\n             * @type Number\n             * @default 0\n             */\n            rotation: 0,\n\n            /**\n             * Optional. The X scaling factor for the image. Defaults to 1.\n             *\n             * @property scaleX\n             * @type Number\n             * @default 1\n             */\n            scaleX: 1,\n\n            /**\n             * Optional. The Y scaling factor for the image. Defaults to 1.\n             *\n             * @property scaleY\n             * @type Number\n             * @default 1\n             */\n            scaleY: 1,\n\n            /**\n             * Optional. The X skew factor of the sprite. Defaults to 0.\n             *\n             * @property skewX\n             * @type Number\n             * @default 0\n             */\n            skewX: 0,\n\n            /**\n             * Optional. The Y skew factor for the image. Defaults to 0.\n             *\n             * @property skewY\n             * @type Number\n             * @default 0\n             */\n            skewY: 0,\n\n            /**\n             * Optional. The tint applied to the sprite. Tint may be specified by number or text. For example, to give the sprite a red tint, set to 0xff0000 or \"#ff0000\". Tint will be stored as a number even when set using text. Defaults to no tint.\n             *\n             * @property tint\n             * @type Number|String\n             * @default null\n             */\n            tint: null,\n\n            /**\n             * Optional. The x position of the entity. Defaults to 0.\n             *\n             * @property x\n             * @type Number\n             * @default 0\n             */\n            x: 0,\n            \n            /**\n             * Optional. The y position of the entity. Defaults to 0.\n             *\n             * @property y\n             * @type Number\n             * @default 0\n             */\n            y: 0,\n            \n            /**\n             * Optional. The z position of the entity. Defaults to 0.\n             *\n             * @property z\n             * @type Number\n             * @default 0\n             */\n            z: 0\n        },\n        \n        initialize: function () {\n            var container = this.container = this.owner.container = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Container\"](),\n                definition = null,\n                initialTint = this.tint;\n\n            if (this.rotate === true) {\n                this.rotate = 'rotation';\n                platypus.debug.warn('RenderContainer: Boolean values for the \"rotate\" property has been deprecated. Use \"rotation\", \"orientationMatrix\", or \"\" to specify the source of rotation for the render container. This property defaults to \"rotation\".');\n            }\n\n            this.parentContainer = null;\n            this.wasVisible = this.visible;\n            this.lastX = this.owner.x;\n            this.lastY = this.owner.y;\n            this.camera = _AABB_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp();\n            this.isOnCamera = true;\n            this.needsCameraCheck = true;\n\n            this._tint = null;\n\n            Object.defineProperty(this.owner, 'tint', {\n                get: function () {\n                    return this._tint;\n                }.bind(this),\n                set: function (value) {\n                    var filters = this.container.filters,\n                        matrix = null,\n                        color = castValue(value);\n\n                    if (color === this._tint) {\n                        return;\n                    }\n\n                    if (color === null) {\n                        if (filters) {\n                            this.container.filters = null;\n                        }\n                    } else {\n                        if (!filters) {\n                            filters = this.container.filters = _utils_array_js__WEBPACK_IMPORTED_MODULE_4__[\"arrayCache\"].setUp(new ColorMatrixFilter());\n                        }\n                        matrix = filters[0].matrix;\n                        matrix[0] = (color & 0xff0000) / 0xff0000; // Red\n                        matrix[6] = (color & 0xff00) / 0xff00; // Green\n                        matrix[12] = (color & 0xff) / 0xff; // Blue\n                    }\n\n                    this._tint = color;\n                }.bind(this)\n            });\n        \n            if (initialTint !== null) {\n                this.tint = initialTint; // feed initial tint through setter.\n            }\n\n            if (this.interactive) {\n                definition = _Data_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(\n                    'container', container,\n                    'hitArea', this.interactive.hitArea,\n                    'hover', this.interactive.hover\n                );\n                this.owner.addComponent(new _Interactive_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](this.owner, definition));\n                definition.recycle();\n            }\n\n            if (this.cache) {\n                this.updateSprite(false);\n                this.owner.cacheRender = this.container;\n            }\n        },\n        \n        events: {\n            /**\n             * On receiving a \"cache\" event, this component triggers \"cache-sprite\" to cache its rendering into the background. This is an optimization for static images to reduce render calls.\n             *\n             * @method 'cache'\n             */\n            \"cache\": function () {\n                this.updateSprite(false);\n                this.owner.cacheRender = this.container;\n                this.cache = true;\n                if (this.owner.parent.triggerEventOnChildren) {\n                    /**\n                     * On receiving a \"cache\" event, this component triggers \"cache-sprite\" to cache its rendering into the background. This is an optimization for static images to reduce render calls.\n                     *\n                     * @event 'cache-sprite'\n                     * @param entity {platypus.Entity} This component's owner.\n                     */\n                    this.owner.parent.triggerEventOnChildren('cache-sprite', this.owner);\n                } else {\n                    platypus.debug.warn('Unable to cache sprite for ' + this.owner.type);\n                }\n            },\n\n            /**\n             * Listens for this event to determine whether this sprite is visible.\n             *\n             * @method 'camera-update'\n             * @param camera.viewport {platypus.AABB} Camera position and size.\n             */\n            \"camera-update\": function (camera) {\n                this.camera.set(camera.viewport);\n                \n                // Set visiblity of sprite if within camera bounds\n                this.needsCameraCheck = true;\n            },\n            \n            /**\n             * A setup message used to add the sprite to the stage. On receiving this message, the component sets its parent container to the stage contained in the message if it doesn't already have one.\n             *\n             * @method 'handle-render-load'\n             * @param data.renderGroups {Array of PIXI.Container} Containers to categorize display of groups of entities.\n             */\n            \"handle-render-load\": function () {\n                /**\n                 * This event is triggered once the RenderSprite is ready to handle interactivity.\n                 *\n                 * @event 'input-on'\n                 */\n                this.owner.triggerEvent('input-on');\n                this.updateSprite(true);\n            },\n            \n            /**\n             * The render update message updates the sprite. If a sprite doesn't have a container, it's removed.\n             *\n             * @method 'handle-render'\n             */\n            \"handle-render\": function () {\n                if (!this.container) { // If this component's removal is pending\n                    return;\n                }\n\n                this.updateSprite(true);\n            },\n            \n            /**\n             * This event makes the sprite invisible.\n             *\n             * @method 'hide-sprite'\n             */\n            \"hide-sprite\": function () {\n                this.visible = false;\n            },\n\n            /**\n             * This event makes the sprite visible.\n             *\n             * @method 'show-sprite'\n             */\n            \"show-sprite\": function () {\n                this.visible = true;\n            },\n            \n            /**\n             * Defines the mask on the container/sprite. If no mask is specified, the mask is set to null.\n             *\n             * @method 'set-mask'\n             * @param mask {Object} The mask. This can specified the same way as the 'mask' parameter on the component.\n             */\n            \"set-mask\": function (mask) {\n                this.setMask(mask);\n            }\n        },\n        \n        methods: {\n            updateSprite: (function () {\n                var sort = function (a, b) {\n                    return a.z - b.z;\n                };\n                \n                return function (uncached) {\n                    var x = 0,\n                        y = 0,\n                        rotation = 0,\n                        matrix = pixiMatrix,\n                        mirrored = 1,\n                        flipped  = 1,\n                        angle    = null;\n                    \n                    x = this.owner.x;\n                    y = this.owner.y;\n                    if (this.rotate === 'rotation') {\n                        rotation = this.rotation;\n                    }\n                    if (this.container.z !== this.owner.z) {\n                        if (this.parentContainer) {\n                            this.parentContainer.reorder = true;\n                        }\n                        this.container.z = this.owner.z;\n                    }\n\n                    if (!this.ignoreOpacity && (this.owner.opacity || (this.owner.opacity === 0))) {\n                        this.container.alpha = this.owner.opacity;\n                    }\n                    \n                    if (this.container.reorder) {\n                        this.container.reorder = false;\n                        this.container.children.sort(sort);\n                        this.needsCameraCheck = true; // reorder is set when adding children, so force another camera check.\n                    }\n                    \n                    if (this.mirror || this.flip) {\n                        angle = this.rotation % 360;\n                        \n                        if (this.mirror && (angle > 90) && (angle < 270)) {\n                            mirrored = -1;\n                        }\n                        \n                        if (this.flip && (angle < 180)) {\n                            flipped = -1;\n                        }\n                    }\n                    \n                    if (this.rotate === 'orientationMatrix') { // This is a 3x3 2D matrix describing an affine transformation.\n                        const o = this.owner.orientationMatrix;\n\n                        matrix.a = o[0][0];\n                        matrix.b = o[1][0];\n                        matrix.tx = x + o[0][2];\n                        matrix.c = o[0][1];\n                        matrix.d = o[1][1];\n                        matrix.ty = y + o[1][2];\n                        this.container.transform.setFromMatrix(matrix);\n                    } else {\n                        this.container.setTransform(x, y, this.scaleX * mirrored, this.scaleY * flipped, (rotation ? (rotation / 180) * Math.PI : 0), this.skewX, this.skewY);\n                    }\n                    \n                    if (this.parentContainer && this.parentContainer.parentUpdated) {\n                        this.needsCameraCheck = true;\n                    }\n                    if (this.container) {\n                        if (this.container.childUpdated) {\n                            this.needsCameraCheck = true;\n                            this.container.childUpdated = false;\n                        }\n                        this.container.parentUpdated = false;\n                    }\n                    // Set isCameraOn of sprite if within camera bounds\n                    if (!this.needsCameraCheck) {\n                        this.needsCameraCheck = (this.lastX !== this.owner.x) || (this.lastY !== this.owner.y);\n                    }\n                    if (uncached && this.container && (this.needsCameraCheck || (!this.wasVisible && this.visible))) {\n                        this.isOnCamera = this.owner.parent.isOnCanvas(this.container.getBounds(false));\n                        this.needsCameraCheck = false;\n                        if (this.parentContainer) {\n                            this.parentContainer.childUpdated = true;\n                        }\n                        this.container.parentUpdated = true;\n                    }\n                    \n                    this.lastX = this.owner.x;\n                    this.lastY = this.owner.y;\n                    this.wasVisible = this.visible;\n                    this.container.visible = (this.visible && this.isOnCamera) || this.dragMode;\n                };\n            }()),\n            \n            setMask: function (shape) {\n                var gfx = null;\n                \n                if (this.mask) {\n                    if (this.localMask) {\n                        this.container.removeChild(this.mask);\n                    } else if (this.parentContainer) {\n                        this.parentContainer.removeChild(this.mask);\n                    }\n                }\n                \n                if (!shape) {\n                    this.mask = this.container.mask = null;\n                    return;\n                }\n                \n                if (shape.isMask || (shape instanceof pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Graphics\"])) {\n                    gfx = shape;\n                } else {\n                    gfx = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Graphics\"]();\n                    gfx.beginFill(0x000000, 1);\n                    if (typeof shape === 'string') {\n                        processGraphics(gfx, shape);\n                    } else if (shape.radius) {\n                        gfx.drawCircle(shape.x || 0, shape.y || 0, shape.radius);\n                    } else if (shape.width && shape.height) {\n                        gfx.drawRect(shape.x || 0, shape.y || 0, shape.width, shape.height);\n                    }\n                    gfx.endFill();\n                }\n                \n                gfx.isMask = true;\n\n                this.mask = this.container.mask = gfx;\n                this.mask.z = 0; //TML 12-4-16 - Masks don't need a Z, but this makes it play nice with the Z-ordering in HandlerRender.\n\n                if (this.localMask) {\n                    this.container.addChild(this.mask);\n                } else if (this.parentContainer) {\n                    this.parentContainer.addChild(this.mask);\n                }\n            },\n            \n            destroy: function () {\n                this.camera.recycle();\n                if (this.parentContainer && !this.container.mouseTarget) {\n                    this.parentContainer.removeChild(this.container);\n                    this.parentContainer = null;\n                } else if (!this.cache) {\n                    this.container.destroy();\n                }\n                this.container = null;\n            }\n        },\n    \n        publicMethods: {\n            /**\n             * Remove this entity's container from the containing rendering container.\n             *\n             * @method removeFromParentContainer\n             */\n            removeFromParentContainer: function () {\n                if (this.parentContainer) {\n                    if (this.mask) {\n                        this.setMask();\n                    }\n\n                    this.parentContainer.removeChild(this.container);\n                }\n            },\n            \n            /**\n             * Add this entity's container to a rendering container.\n             *\n             * @method addToParentContainer\n             * @param {Container} container Container to add this to.\n             */\n            addToParentContainer: function (container) {\n                this.parentContainer = container;\n                this.parentContainer.addChild(this.container);\n                this.parentContainer.reorder = true;\n\n                if (this.mask) {\n                    this.setMask(this.mask);\n                }\n            }\n        }\n    });\n}());\n\n\n//# sourceURL=webpack://platypus/./src/components/RenderContainer.js?");

/***/ }),

/***/ "./src/components/RenderDebug.js":
/*!***************************************!*\
  !*** ./src/components/RenderDebug.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pixi.js */ \"pixi.js\");\n/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(pixi_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! config */ \"./src/config/development.js\");\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(config__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../factory.js */ \"./src/factory.js\");\n/**\n * This component is attached to entities that will appear in the game world. It serves two purposes. First, it displays a rectangle that indicates the location of the entity. By default it uses the specified position and dimensions of the object (in grey). If the object has a collision component it will display the AABB of the collision shape (in pink). If the entity has a LogicCarrier component and is/was carrying an object, a green rectangle will be drawn showing the collision group. The RenderDebug component also allows the developer to right-click on an entity and it will print the object in the debug console.\n *\n * @namespace platypus.components\n * @class RenderDebug\n * @uses platypus.Component\n */\n\n\n\n\n\nconst\n    collisionColors = {},\n    createCollisionColor = function (collisionType) {\n        let\n            r = collisionType.charCodeAt(0) || 0,\n            g = collisionType.charCodeAt(1) || 0,\n            b = collisionType.charCodeAt(2) || 0,\n            min = 0,\n            max = 0;\n        \n        min = Math.min(r, g, b);\n\n        r -= min;\n        g -= min;\n        b -= min;\n\n        max = Math.max(r, g, b, 1);\n            \n        r = (0xCC * r / max) >> 0;\n        g = (0xCC * g / max) >> 0;\n        b = (0xCC * b / max) >> 0;\n\n        return (r << 8) + (g << 4) + b;\n    };\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    var createShape = function (shape, color, left, top, width, height, z, outline) {\n            var newShape = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Graphics\"]().beginFill(color, 0.1);\n\n            if (outline) {\n                newShape.lineStyle(outline, color);\n            }\n\n            switch (shape) {\n            case 'rectangle':\n                newShape.drawRect(left, top, width, height);\n                break;\n            case 'circle':\n                newShape.drawCircle(0, 0, width);\n                break;\n            }\n            newShape.z = z;\n\n            return newShape;\n        },\n        standardizeColor = function (color) {\n            if (typeof color === 'string') {\n                return parseInt(color.replace('#', ''), 16);\n            } else {\n                return color;\n            }\n        };\n    \n    return Object(_factory_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])({\n        \n        id: 'RenderDebug',\n\n        properties: {\n            /**\n             * The color to use to highlight an entity's AABB. For example, use `\"#ffffff\"` or `0xffffff` to set as white.\n             *\n             * @property aabbColor\n             * @type Number|String\n             * @default 0xff88ff\n             */\n            aabbColor: 0xff88ff,\n\n            /**\n             * The color to use to highlight an entity's collision shape. For example, use `\"#ffffff\"` or `0xffffff` to set as white. Will generate a color based on the collision type if not specified.\n             *\n             * @property collisionColor\n             * @type Number|String\n             * @default 0\n             */\n            collisionColor: 0,\n\n            /**\n             * The color to use to highlight the AABB for a group of entities attached to this entity. For example, use `\"#ffffff\"` or `0xffffff` to set as white.\n             *\n             * @property groupColor\n             * @type Number|String\n             * @default 0x00ff00\n             */\n            groupColor: 0x00ff00,\n\n            /**\n             * The color to use to highlight an entity. This property is only used if there is no `CollisionBasic` component attached to the entity: this component uses the entity's `width` and `height` properties if defined. For example, use `\"#ffffff\"` or `0xffffff` to set as white.\n             *\n             * @property renderColor\n             * @type Number|String\n             * @default 0x0000ff\n             */\n            renderColor: 0x0000ff,\n\n            /**\n             * The height of the entity.\n             *\n             * @property height\n             * @type Number\n             * @default 100\n             */\n            width: 100,\n\n            /**\n             * The width of the entity.\n             *\n             * @property width\n             * @type Number\n             * @default 100\n             */\n            height: 100,\n\n            /**\n             * The local offset in z-index for the rendered debug area.\n             *\n             * @property offsetZ\n             * @type Number\n             * @default 10000\n             */\n            offsetZ: 10000\n        },\n        \n        initialize: function () {\n            this.container = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Container\"]();\n            this.parentContainer = this.owner.parent.worldContainer;\n            this.parentContainer.addChild(this.container);\n            this.parentContainer.reorder = true;\n            this.needsCameraCheck = true;\n\n            this.shapes = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp();\n            this.isOutdated = true;\n\n            this.aabbColor = standardizeColor(this.aabbColor);\n            this.collisionColor = this.collisionColor ? standardizeColor(this.collisionColor) : 0;\n            this.groupColor = standardizeColor(this.groupColor);\n            this.renderColor = standardizeColor(this.renderColor);\n        },\n        \n        events: {// These are messages that this component listens for\n            /**\n             * Removes this component if not in a debug build.\n             *\n             * @method 'load'\n             */\n            \"load\": function () {\n                if (!config__WEBPACK_IMPORTED_MODULE_2___default.a.dev) {\n                    this.owner.removeComponent(this);\n                    return;\n                }\n            },\n\n            /**\n             * Listens for this event to determine whether this sprite is visible.\n             *\n             * @method 'camera-update'\n             * @param camera.viewport {platypus.AABB} Camera position and size.\n             */\n            \"camera-update\": function () {\n                // Set visiblity of sprite if within camera bounds\n                this.needsCameraCheck = true;\n            },\n\n            /**\n             * Repositions the pieces of the component in preparation for rendering\n             *\n             * @method 'handle-render'\n             */\n            \"handle-render\": function () {\n                var aabb = null,\n                    offset = -0.5;\n\n                if (this.isOutdated) {\n                    this.updateSprites();\n                    this.isOutdated = false;\n                }\n                \n                if (this.owner.getCollisionGroupAABB) {\n                    aabb = this.owner.getCollisionGroupAABB();\n                    if (!this.groupShape) {\n                        this.groupShape = createShape('rectangle', this.groupColor, offset, offset, 1, 1, this.offsetZ);\n                        this.container.addChild(this.groupShape);\n                    }\n                    this.groupShape.scaleX = aabb.width;\n                    this.groupShape.scaleY = aabb.height;\n                    this.groupShape.x      = aabb.x - this.owner.x;\n                    this.groupShape.y      = aabb.y - this.owner.y;\n                }\n\n                this.update();\n            },\n            \n            /**\n             * On receiving this message, will re-orient itself on the next update.\n             *\n             * @method 'orientation-updated'\n             */\n            \"orientation-updated\": function () {\n                this.isOutdated = true;\n            },\n            \n            /**\n             * On receiving this message, will update collision shapes.\n             *\n             * @method 'collide-on'\n             */\n            \"collide-on\": function () {\n                this.isOutdated = true;\n            },\n            \n            /**\n             * On receiving this message, will update collision shapes.\n             *\n             * @method 'collide-off'\n             */\n            \"collide-off\": function () {\n                this.isOutdated = true;\n            }\n        },\n        \n        methods: {\n            update: function () {\n                var x = 0,\n                    y = 0;\n                \n                x = this.owner.x;\n                y = this.owner.y;\n\n                if (this.container.z !== this.owner.z + 0.000001) {\n                    this.parentContainer.reorder = true;\n                    this.container.z = this.owner.z + 0.000001;\n                }\n\n                this.container.setTransform(x, y, 1, 1, 0, 0, 0);\n                \n                // Set isCameraOn of sprite if within camera bounds\n                if (!this.needsCameraCheck) {\n                    this.needsCameraCheck = (this.lastX !== this.owner.x) || (this.lastY !== this.owner.y);\n                }\n                if (this.needsCameraCheck) {\n                    this.isOnCamera = this.owner.parent.isOnCanvas(this.container.getBounds(false));\n                    this.needsCameraCheck = false;\n                }\n                \n                this.lastX = this.owner.x;\n                this.lastY = this.owner.y;\n                this.container.visible = this.isOnCamera;\n            },\n\n            updateSprites: function () {\n                var owner = this.owner,\n                    z        = this.offsetZ,\n                    i        = 0,\n                    j        = 0,\n                    lineWidth = 2,\n                    width    = this.width,\n                    height   = this.height,\n                    shapes   = null,\n                    aabb     = null,\n                    shape    = null;\n\n                for (i = 0; i < this.shapes.length; i++) {\n                    this.container.removeChild(this.shapes[i]);\n                }\n                this.shapes.length = 0;\n\n                if (owner.getAABB) {\n                    for (j = 0; j < owner.collisionTypes.length; j++) {\n                        const\n                            collisionType = owner.collisionTypes[j];\n\n                        let collisionColor = this.collisionColor || collisionColors[collisionType];\n\n                        if (!collisionColor) {\n                            collisionColor = collisionColors[collisionType] = createCollisionColor(collisionType);\n                        }\n\n                        aabb   = owner.getAABB(collisionType);\n                        width  = this.initialWidth  = aabb.width;\n                        height = this.initialHeight = aabb.height;\n                        shapes = owner.getShapes(collisionType);\n                        \n                        shape  = createShape('rectangle', this.aabbColor, aabb.left - owner.x, aabb.top - owner.y, width, height, z--);\n                        this.shapes.push(shape);\n                        this.container.addChild(shape);\n                        \n                        for (i = 0; i < shapes.length; i++) {\n                            width = shapes[i].width - lineWidth;\n                            height = shapes[i].height - lineWidth;\n                            shape = createShape(shapes[i].type, collisionColor, shapes[i].offsetX - width / 2, shapes[i].offsetY - height / 2, (shapes[i].radius ? shapes[i].radius - lineWidth : width), height, z--, lineWidth);\n                            this.shapes.push(shape);\n                            this.container.addChild(shape);\n                        }\n                    }\n                } else {\n                    shape = createShape('rectangle', this.renderColor, -width / 2, -height / 2, width, height, z--);\n                    this.shapes.push(shape);\n                    this.container.addChild(shape);\n                }\n            },\n            \n            destroy: function () {\n                var i = 0;\n                \n                for (i = 0; i < this.shapes.length; i++) {\n                    this.container.removeChild(this.shapes[i]);\n                }\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].recycle(this.shapes);\n\n                this.parentContainer.removeChild(this.container);\n                this.container = null;\n            }\n        }\n    });\n}());\n\n\n//# sourceURL=webpack://platypus/./src/components/RenderDebug.js?");

/***/ }),

/***/ "./src/components/RenderDestroyMe.js":
/*!*******************************************!*\
  !*** ./src/components/RenderDestroyMe.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../factory.js */ \"./src/factory.js\");\n/**\n * This component will destroy the entity once an animation has finished. This is useful for explosions or similar animations where the entity is no longer needed once the animation completes.\n *\n * @namespace platypus.components\n * @class RenderDestroyMe\n * @uses platypus.Component\n */\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    return Object(_factory_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])({\n        id: 'RenderDestroyMe',\n        \n        properties: {\n            /**\n             * This or animationIds required. This is a String identifying the animation that should destroy this entity on its completion.\n             *\n             * @property animationId\n             * @type String\n             * @default ''\n             */\n            animationId: '',\n            \n            /**\n             * This or animationId required. This is an array of Strings identifying the animations that should destroy this entity on their completion.\n             *\n             * @property animationIds\n             * @type Array\n             * @default null\n             */\n            animationIds: null\n        },\n\n        initialize: function (definition) {\n            if (this.animationId) {\n                this.animationIds = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(definition.animationId);\n            } else if (this.animationIds) {\n                this.animationIds = Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSlice\"])(this.animationIds);\n            }\n        },\n\n        events: {// These are messages that this component listens for\n            /**\n             * On receiving this message, the component matches the animation id with its animation id setting and destroys the entity if they match.\n             *\n             * @method 'animation-ended'\n             * @param animation {String} Animation id for the animation that just finished.\n             */\n            \"animation-ended\": function (animation) {\n                if (!this.animationIds || (this.animationIds.indexOf(animation) >= 0)) {\n                    this.owner.parent.removeEntity(this.owner);\n                }\n            }\n        },\n        \n        methods: {\n            destroy: function () {\n                if (this.animationIds) {\n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.animationIds);\n                    this.animationIds = null;\n                }\n            }\n        }\n    });\n}());\n\n\n//# sourceURL=webpack://platypus/./src/components/RenderDestroyMe.js?");

/***/ }),

/***/ "./src/components/RenderProgress.js":
/*!******************************************!*\
  !*** ./src/components/RenderProgress.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pixi.js */ \"pixi.js\");\n/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(pixi_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../factory.js */ \"./src/factory.js\");\n/**\n * This component creates a visual progress bar that can be used for loading assets or showing other types of progress changes.\n *\n * @namespace platypus.components\n * @class RenderProgress\n * @uses platypus.Component\n */\n/* global platypus */\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    return Object(_factory_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])({\n        \n        id: 'RenderProgress',\n        \n        properties: {\n            //TODO: Document!\n            backgroundColor: 0x000000,\n            \n            color: 0xffffff,\n            \n            mirror: false,\n            \n            flip: false,\n            \n            width: 100,\n            \n            height: 20,\n            \n            regX: 0,\n            \n            regY: 0\n        },\n        \n        publicProperties: {\n            x: 0,\n            \n            y: 0,\n            \n            z: 0\n        },\n        \n        initialize: function () {\n            var b   = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Graphics\"](),\n                f   = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Graphics\"](),\n                con = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Container\"]();\n            \n            this.parentContainer = null;\n            this.background = b;\n            this.progress   = f;\n            this.container  = con;\n            \n            if (typeof this.backgroundColor === 'string') {\n                this.backgroundColor = +this.backgroundColor.replace('#', '0x');\n            }\n            if (typeof this.color === 'string') {\n                this.color = +this.color.replace('#', '0x');\n            }\n            \n            b.f(this.backgroundColor).drawRect(-this.regX, -this.regY, this.width, this.height);\n            f.f(this.color).drawRect(-this.regX, -this.regY, this.width, this.height);\n            f.scale = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Point\"](0.0001, 1);\n            con.addChild(b);\n            con.addChild(f);\n        },\n        \n        events: {\n            \"handle-render-load\": function (resp) {\n                if (!this.parentContainer && resp && resp.container) {\n                    this.parentContainer = resp.container;\n                    this.parentContainer.addChild(this.container);\n                }\n            },\n            \n            \"handle-render\": function (resp) {\n                if (!this.container) { // If this component's removal is pending\n                    return;\n                }\n\n                if (!this.parentContainer) {\n                    if (resp && resp.container) {\n                        this.parentContainer = resp.container;\n                        this.parentContainer.addChild(this.container);\n                    } else {\n                        platypus.debug.warn('No PIXI Stage, removing ProgressRender component from \"' + this.owner.type + '\".');\n                        this.owner.removeComponent(this);\n                    }\n                }\n                \n                this.container.x = this.x;\n                this.container.y = this.y;\n                this.container.z = this.z;\n            },\n            \n            \"update-progress\": function (progress) {\n                if (isNaN(progress)) {\n                    if (typeof progress.fraction === 'number') {\n                        this.progress.scale.x = progress.fraction;\n                    } else if ((typeof progress.total === 'number') && (typeof progress.progress === 'number')) {\n                        this.progress.scale.x = progress.progress / progress.total;\n                    }\n                } else {\n                    this.progress.scale.x = progress;\n                }\n            }\n        },\n        \n        methods: {\n            destroy: function () {\n                if (this.parentContainer) {\n                    this.parentContainer.removeChild(this.container);\n                    this.parentContainer = null;\n                }\n                this.container = null;\n            }\n        }\n    });\n}());\n\n\n//# sourceURL=webpack://platypus/./src/components/RenderProgress.js?");

/***/ }),

/***/ "./src/components/RenderSpine.js":
/*!***************************************!*\
  !*** ./src/components/RenderSpine.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pixi.js */ \"pixi.js\");\n/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(pixi_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var _Data_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Data.js */ \"./src/Data.js\");\n/* harmony import */ var _RenderAnimator_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./RenderAnimator.js */ \"./src/components/RenderAnimator.js\");\n/* harmony import */ var _RenderContainer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./RenderContainer.js */ \"./src/components/RenderContainer.js\");\n/* harmony import */ var _StateMap_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../StateMap.js */ \"./src/StateMap.js\");\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../factory.js */ \"./src/factory.js\");\n/**\n * This component is attached to entities that will appear in the game world. It renders a spine-based puppet. It listens for messages triggered on the entity or changes in the logical state of the entity to play a corresponding animation.\n *\n * @namespace platypus.components\n * @class RenderSpine\n * @uses platypus.Component\n */\n/* global platypus */\n\n\n\n\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ((function () {\n    const\n        BaseTexture = pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"BaseTexture\"],\n        createTest = function (testStates, skin) {\n            if (testStates === 'default') {\n                return defaultTest.bind(null, skin);\n            } else {\n                //TODO: Better clean-up: Create a lot of these without removing them later... DDD 2/5/2016\n                return stateTest.bind(null, skin, _StateMap_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].setUp(testStates));\n            }\n        },\n        defaultTest = function (skin) {\n            return skin;\n        },\n        stateTest = function (skin, states, ownerState) {\n            if (ownerState.includes(states)) {\n                return skin;\n            }\n            return null;\n        },\n        getBaseTexture = function (path, pma) {\n            var asset = platypus.assetCache.get(path.substring(path.lastIndexOf('/') + 1, path.lastIndexOf('.')));\n            \n            if (!asset) {\n                platypus.debug.warn('RenderSpine: \"' + path + '\" is not a loaded asset.');\n            }\n            return new BaseTexture(asset, {\n                alphaMode: pma ? pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"ALPHA_MODES\"].PMA : pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"ALPHA_MODES\"].UNPACK\n            });\n        };\n    \n    return Object(_factory_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"])({\n\n        id: 'RenderSpine',\n\n        properties: {\n            /**\n             * An object containg key-value pairs that define a mapping from entity states to the animation that should play. The list is processed from top to bottom, so the most important actions should be listed first (for example, a jumping animation might take precedence over an idle animation). If not specified, an 1-to-1 animation map is created from the list of animations in the sprite sheet definition using the animation names as the keys.\n             *\n             *  \"animationStates\":{\n             *      \"standing\": \"default-animation\"  // On receiving a \"standing\" event, or when this.owner.state.standing === true, the \"default\" animation will begin playing.\n             *      \"ground,moving\": \"walking\",  // Comma separated values have a special meaning when evaluating \"state-changed\" messages. The above example will cause the \"walking\" animation to play ONLY if the entity's state includes both \"moving\" and \"ground\" equal to true.\n             *      \"ground,striking\": \"swing!\", // Putting an exclamation after an animation name causes this animation to complete before going to the next animation. This is useful for animations that would look poorly if interrupted.\n             *      \"default\": \"default-animation\" // Optional. \"default\" is a special property that matches all states. If none of the above states are valid for the entity, it will use the default animation listed here.\n             *  }\n             *\n             * If `stateBased` is `true` and this property is not set, this component will use the `animationMap` property value to define state mappings.\n             *\n             * @property animationStates\n             * @type Object\n             * @default animationMap\n             */\n            animationStates: null,\n\n            /**\n             * An object containg key-value pairs that define a mapping from triggered events to the animation that should play.\n             *\n             *     \"animationEvents\":{\n             *         \"move\": \"walk-animation\",\n             *         \"jump\": \"jumping-animation\"\n             *     }\n             *\n             * The above will create two event listeners on the entity, \"move\" and \"jump\", that will play their corresponding animations when the events are triggered.\n             *\n             * If `eventBased` is `true` and this property is not set, this component will use the `animationMap` property value to define event mappings.\n             *\n             * @property animationEvents\n             * @type Object\n             * @default animationMap\n             */\n            animationEvents: null,\n\n            /**\n             * Optional. An object containing key-value pairs that define a mapping from triggered events or entity states to the animation that should play. The list is processed from top to bottom, so the most important actions should be listed first (for example, a jumping animation might take precedence over an idle animation). If not specified, an 1-to-1 animation map is created from the list of animations in the skeleton definition using the animation names as the keys.\n             *\n             *  \"animationMap\":{\n             *      \"standing\": \"default-animation\"  // On receiving a \"standing\" event, or when this.owner.state.standing === true, the \"default\" animation will begin playing.\n             *      \"ground,moving\": \"walking\",  // Comma separated values have a special meaning when evaluating \"state-changed\" messages. The above example will cause the \"walking\" animation to play ONLY if the entity's state includes both \"moving\" and \"ground\" equal to true.\n             *      \"ground,striking\": \"swing!\", // Putting an exclamation after an animation name causes this animation to complete before going to the next animation. This is useful for animations that would look poorly if interrupted.\n             *      \"default\": \"default-animation\" // Optional. \"default\" is a special property that matches all states. If none of the above states are valid for the entity, it will use the default animation listed here.\n             *  }\n             *\n             * @property animationMap\n             * @type Object\n             * @default null\n             */\n            animationMap: null,\n\n            /**\n             * Optional. No, this isn't a Stephen R. Lawhead novel. Use this to specify a skin according to the entity's state.\n             *\n             *  \"skinMap\":{\n             *      \"cloaked\": \"cloak\"  // On receiving a \"cloaked\" event, or when `this.owner.state.get('cloaked') === true`, this skin will be activated.\n             *      \"default\": \"normal_attire\" // Optional. \"default\" is a special property that matches all states. If none of the above states are valid for the entity, it will use the default skin listed here.\n             *  }\n             *\n             * @property skinMap\n             * @type Object\n             * @default null\n             */\n            skinMap: null,\n\n            /**\n             * The scaling factor for this sprite relative to the scale of the container.\n             *\n             * @property localScaleX\n             * @type Number|Array|Object\n             * @default 1\n             */\n            localScaleX: 1,\n\n           /**\n            * The scaling factor for this sprite relative to the scale of the container.\n            *\n            * @property localScaleY\n            * @type Number|Array|Object\n            * @default 1\n            */\n            localScaleY: 1,\n\n            /**\n             * Optional. A mask definition that determines where the image should clip. A string can also be used to create more complex shapes via the PIXI graphics API like: \"mask\": \"r(10,20,40,40).drawCircle(30,10,12)\". Defaults to no mask or, if simply set to true, a rectangle using the entity's dimensions.\n             *\n             *  \"mask\": {\n             *      \"x\": 10,\n             *      \"y\": 10,\n             *      \"width\": 40,\n             *      \"height\": 40\n             *  },\n             *\n             *  -OR-\n             *\n             *  \"mask\": \"r(10,20,40,40).drawCircle(30,10,12)\"\n             *\n             * @property mask\n             * @type Object\n             * @default null\n             */\n            mask: null,\n\n            /**\n             * Defines whether the entity will respond to touch and click events. Setting this value will create an Interactive component on this entity with these properties. For example:\n             *\n             *  \"interactive\": {\n             *      \"hover\": false,\n             *      \"hitArea\": {\n             *          \"x\": 10,\n             *          \"y\": 10,\n             *          \"width\": 40,\n             *          \"height\": 40\n             *      }\n             *  }\n             *\n             * @property interactive\n             * @type Boolean|Object\n             * @default false\n             */\n            interactive: false,\n\n            /**\n             * Sets the transition time between animations. If a number is defined, the transition time applies to all animation changes. If an object is specified, the key value pairs should match this syntax where the first part of the key lists the animation currently playing and the second part of the key lists the animation being transitioned to:\n             *\n             *     {\n             *         \"jump:walk\": 0.4,\n             *         \"walk:jump\": 0.2\n             *     }\n             *\n             * @property mixTimes\n             * @type Number|Object\n             * @default 0\n             */\n            mixTimes: 0,\n\n            /**\n             * The offset of the x-axis position of the sprite from the entity's x-axis position.\n             *\n             * @property offsetX\n             * @type Number\n             * @default 0\n             */\n            offsetX: 0,\n\n            /**\n             * The offset of the y-axis position of the sprite from the entity's y-axis position.\n             *\n             * @property offsetY\n             * @type Number\n             * @default 0\n             */\n            offsetY: 0,\n\n            /**\n             * The z-index relative to other render components on the entity.\n             *\n             * @property offsetZ\n             * @type Number\n             * @default 0\n             */\n            offsetZ: 0,\n\n            /**\n             * Text describing an atlas of graphic assets for the Spine animation or an asset id for the same.\n             *\n             * @property atlas\n             * @type String\n             * @default \"\"\n             */\n            atlas: \"\",\n\n            /**\n             * A JSON structure defining a Spine skeleton and behaviors for the animation, or an asset id for the same.\n             *\n             * @property skeleton\n             * @type String|Object\n             * @default null\n             */\n            skeleton: null,\n\n            /**\n             * Whether this object can be mirrored over X. To mirror it over X set the this.owner.rotation value to be > 90  and < 270.\n             *\n             * @property mirror\n             * @type Boolean\n             * @default false\n             */\n            mirror: false,\n\n            /**\n             * Optional. Whether this object can be flipped over Y. To flip it over Y set the this.owner.rotation to be > 180.\n             *\n             * @property flip\n             * @type Boolean\n             * @default false\n             */\n            flip: false,\n\n            /**\n             * Optional. Whether this object is visible or not. To change the visible value dynamically set this.owner.state.visible to true or false.\n             *\n             * @property visible\n             * @type Boolean\n             * @default false\n             */\n            visible: true,\n\n            /**\n             * Optional. Specifies whether this component should create a RenderAnimator component to listen to events matching the animationMap to animate. Set this to true if the component should animate for on events. Default is `false`.\n             *\n             * @property eventBased\n             * @type Boolean\n             * @default false\n             */\n            eventBased: false,\n\n            /**\n             * Optional. Specifies whether the spine image alpha has been premultiplied. Set this to `false` if you see bright borders around image parts. Make sure it's `true` if you see thin black lines around image pieces.\n             *\n             * @property preMultipliedAlpha\n             * @type Boolean\n             * @default true\n             */\n            preMultipliedAlpha: true,\n\n            /**\n             * Optional. Specifies whether this component should create a RenderAnimator component to handle changes in the entity's state that match the animationMap to animate. Set this to true if the component should animate based on `this.owner.state`. Default is `true`.\n             *\n             * @property stateBased\n             * @type Boolean\n             * @default true\n             */\n            stateBased: true\n        },\n\n        publicProperties: {\n            /**\n             * Prevents the spine from becoming invisible out of frame and losing mouse input connection.\n             *\n             * @property dragMode\n             * @type Boolean\n             * @default false\n             */\n            dragMode: false,\n\n            /**\n             * Optional. The X scaling factor for the image. Defaults to 1.\n             *\n             * @property scaleX\n             * @type Number\n             * @default 1\n             */\n            scaleX: 1,\n\n            /**\n             * Optional. The Y scaling factor for the image. Defaults to 1.\n             *\n             * @property scaleY\n             * @type Number\n             * @default 1\n             */\n            scaleY: 1,\n\n            /**\n             * Optional. The X swek factor of the sprite. Defaults to 0.\n             *\n             * @property skewX\n             * @type Number\n             * @default 0\n             */\n            skewX: 0,\n\n            /**\n             * Optional. The Y skew factor for the image. Defaults to 0.\n             *\n             * @property skewY\n             * @type Number\n             * @default 0\n             */\n            skewY: 0,\n\n            /**\n             * Optional. The x position of the entity. Defaults to 0.\n             *\n             * @property x\n             * @type Number\n             * @default 0\n             */\n            x: 0,\n            \n            /**\n             * Optional. The y position of the entity. Defaults to 0.\n             *\n             * @property y\n             * @type Number\n             * @default 0\n             */\n            y: 0,\n            \n            /**\n             * Optional. The z position of the entity. Defaults to 0.\n             *\n             * @property z\n             * @type Number\n             * @default 0\n             */\n            z: 0\n        },\n\n        initialize: (function () {\n            var\n                createAnimationMap = function (animationMap, animations) {\n                    var map  = null,\n                        anim = '';\n\n                    if (animationMap) {\n                        return animationMap;\n                    } else {\n                        // Create 1-to-1 animation map since none was defined\n                        map = {};\n                        for (anim in animations) {\n                            if (animations.hasOwnProperty(anim)) {\n                                map[anim] = anim;\n                            }\n                        }\n                        return map;\n                    }\n                },\n                imageCallback = function (pma, loadFinished, line, callback) {\n                    // Not sure if this handles memory well - keeping it in for now.\n                    var baseTexture = getBaseTexture(line, pma);\n\n                    callback(baseTexture);\n\n                    if (baseTexture.isLoading) {\n                        baseTexture.on('loaded', loadFinished);\n                    } else {\n                        loadFinished();\n                    }\n                },\n                animationEnded = function (index, count) {\n                    /**\n                     * This event fires each time an animation completes.\n                     *\n                     * @event 'animation-ended'\n                     * @param animation {String} The id of the animation that ended.\n                     */\n                    this.owner.triggerEvent('animation-ended', this.currentAnimations[index], count);\n                },\n                handleSpineEvent = function (entry, event) {\n                    var eventName = event.data.name;\n\n                    if (this.playAnimation(eventName)) {\n                        this.spine.update(0.000001);\n                    }\n\n                    this.owner.trigger(eventName, event.data);\n                };\n            \n            return function (def, callback) {\n                const PIXIspine = pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"spine\"],\n                    core = PIXIspine && PIXIspine.core,\n                    Spine = PIXIspine && PIXIspine.Spine;\n                \n                // If PIXI.spine is unavailable, this component doesn't work.\n                if (!Spine || !core) {\n                    platypus.debug.error('RenderSpine requires `PIXI.spine` to function.');\n                    return false;\n                } else {\n                    const\n                        TextureAtlas = core.TextureAtlas,\n                        AtlasAttachmentLoader = core.AtlasAttachmentLoader,\n                        SkeletonJson = core.SkeletonJson,\n                        settings = platypus.game.settings,\n                        atlas = settings.atlases[this.atlas],\n                        skeleton = settings.skeletons[this.skeleton],\n                        spineAtlas = new TextureAtlas(atlas, imageCallback.bind(null, this.preMultipliedAlpha, callback)),\n                        spineJsonParser = new SkeletonJson(new AtlasAttachmentLoader(spineAtlas)),\n                        skeletonData = spineJsonParser.readSkeletonData(skeleton),\n                        spine = this.spine = new Spine(skeletonData),\n                        map = createAnimationMap(this.animationMap, skeleton.animations);\n\n                    let animation = '';\n\n                    spine.state.addListener({\n                        event: handleSpineEvent.bind(this),\n                        complete: animationEnded.bind(this)\n                    });\n                    spine.autoUpdate = false;\n    \n                    this.stateBased = map && this.stateBased;\n                    this.eventBased = map && this.eventBased;\n                    if (map) {\n                        const\n                            definition = _Data_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(\n                                'animationEvents', this.eventBased ? this.animationEvents || map : null,\n                                'animationStates', this.stateBased ? this.animationStates || map : null,\n                                'forcePlayThrough', this.forcePlayThrough,\n                                'component', this\n                            );\n\n                        this.owner.addComponent(new _RenderAnimator_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](this.owner, definition));\n                        definition.recycle();\n\n                        animation = map.default || '';\n                    }\n    \n                    // set up the mixes!\n                    if (this.mixTimes) {\n                        this.setMixTimes(this.mixTimes);\n                    }\n    \n                    // play animation\n                    this.currentAnimations = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp();\n                    if (animation) {\n                        this.playAnimation(animation);\n                    }\n    \n                    spine.x = this.offsetX;\n                    spine.y = this.offsetY;\n                    spine.z = this.offsetZ;\n                    spine.scale.x = this.localScaleX;\n                    spine.scale.y = this.localScaleY;\n    \n                    if (this.skinMap) { // Set up skin map handling.\n                        const switchSkin = function (skin) {\n                                if (this.currentSkin !== skin) {\n                                    this.currentSkin = skin;\n                                    this.spine.skeleton.setSkin(null);\n                                    //this.spine.skeleton.skin = null;\n                                    this.spine.skeleton.setSlotsToSetupPose();\n                                    this.spine.state.apply(this.spine.skeleton);\n                                    if (skin) {\n                                        this.spine.skeleton.setSkinByName(skin);\n                                        this.spine.skeleton.setSlotsToSetupPose();\n                                        //this.playAnimation(this.currentAnimations.join(';'));\n                                        this.spine.state.apply(this.spine.skeleton);\n                                    }\n                                }\n                            },\n                            map = this.skinMap;\n        \n                        this.currentSkin = null;\n\n                            //Handle Events:\n                        if (this.eventBased) {\n                            for (const state in map) {\n                                if (map.hasOwnProperty(state)) {\n                                    this.addEventListener(state, switchSkin.bind(this, map[state]));\n                                }\n                            }\n                        }\n        \n                        //Handle States:\n                        if (this.stateBased) {\n                            this.state = this.owner.state;\n                            this.stateChange = true; //Check state against entity's prior state to update skin if necessary on instantiation.\n                            this.checkStates = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp();\n                            this.skins = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp();\n\n                            for (const state in map) {\n                                if (map.hasOwnProperty(state)) {\n                                    this.checkStates.push(createTest(state, map[state]));\n                                    this.skins.push(state);\n                                }\n                            }\n\n                            this.addEventListener('state-changed', () => {\n                                this.stateChange = true;\n                            });\n                            this.addEventListener('handle-render', () => {\n                                if (this.stateChange) {\n                                    for (let i = 0; i < this.checkStates.length; i++) {\n                                        const testCase = this.checkStates[i](this.state);\n\n                                        if (testCase !== null) {\n                                            switchSkin.call(this, testCase);\n                                            break;\n                                        }\n                                    }\n                                    this.stateChange = false;\n                                }\n                            });\n                        }\n                    }\n    \n                    if (!this.owner.container) {\n                        const\n                            definition = _Data_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(\n                                'interactive', this.interactive,\n                                'mask', this.mask,\n                                'mirror', this.mirror,\n                                'flip', this.flip,\n                                'visible', this.visible,\n                                'cache', this.cache,\n                                'ignoreOpacity', this.ignoreOpacity,\n                                'scaleX', this.scaleX,\n                                'scaleY', this.scaleY,\n                                'skewX', this.skewX,\n                                'skewY', this.skewY\n                            );\n                        this.owner.addComponent(new _RenderContainer_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"](this.owner, definition, this.addToContainer.bind(this)));\n                        definition.recycle();\n                    } else {\n                        this.addToContainer();\n                    }\n                }\n\n                return true; //using callback\n            };\n        }()),\n\n        events: {\n            /**\n             * The render update message updates the spine.\n             *\n             * @method 'handle-render'\n             * @param renderData {Object} Data from the render handler\n             * @param renderData.container {PIXI.Container} The parent container.\n             */\n            \"handle-render\": function (renderData) {\n                if (this.spine) {\n                    /**\n                     * This event is triggered each tick to check for animation updates.\n                     *\n                     * @event 'update-animation'\n                     * @param playing {Boolean} Whether the animation is in a playing or paused state.\n                     */\n                    this.owner.triggerEvent('update-animation', true);\n\n                    this.spine.update(renderData.delta / 1000);\n                }\n            },\n\n            /**\n             * This sets the mix times.\n             *\n             * @method 'set-mix-times'\n             * @param mixTimes {Object} This matches the syntax required for this component's `mixTimes` property\n             */\n            \"set-mix-times\": function (mixTimes) {\n                this.setMixTimes(mixTimes);\n            },\n            \n            /**\n             * This event makes the spine invisible.\n             *\n             * @method 'hide'\n             */\n            \"hide\": function () {\n                this.visible = false;\n            },\n\n            /**\n             * This event makes the spine visible.\n             *\n             * @method 'show'\n             */\n            \"show\": function () {\n                this.visible = true;\n            },\n\n            /**\n             * Stops the sprite's animation.\n             *\n             * @method 'stop-animation'\n             * @param [animation] {String} The animation to show and pause. If not specified, this method simply pauses the current animation.\n             */\n            \"stop-animation\": function (animation) {\n                this.stopAnimation(animation);\n            },\n            \n            /**\n             * Starts the sprite's animation.\n             *\n             * @method 'play-animation'\n             * @param [animation] {String} The animation to play. If not specified, this method simply unpauses the current animation.\n             * @param [loop] {String} Whether the played animation should be looped. Loops by default.\n             */\n            \"play-animation\": function (animation, loop) {\n                this.playAnimation(animation, loop);\n            }\n        },\n\n        methods: {\n            addToContainer: function () {\n                var container = this.owner.container;\n\n                container.addChild(this.spine);\n                container.reorder = true;\n            },\n            \n            playAnimation: function (animation, loop = true) {\n                const spine = this.spine;\n                let animated = 0,\n                    remaining = animation;\n\n                while (remaining) {\n                    const\n                        semicolon = remaining.indexOf(';'),\n                        next = (semicolon >= 0) ? remaining.substring(0, semicolon) : remaining;\n                    \n                    remaining = (semicolon >= 0) ? remaining.substring(semicolon + 1) : '';\n\n                    if (spine.state.hasAnimation(next)) {\n                        this.currentAnimations[animated] = next;\n                        spine.state.setAnimation(animated, next, loop);\n                    }\n                    animated += 1;\n                }\n\n                return animated;\n            },\n\n            stopAnimation: function (animation) {\n                const spine = this.spine;\n                let animated = 0,\n                    remaining = animation;\n\n                while (remaining) {\n                    const\n                        semicolon = remaining.indexOf(';'),\n                        next = (semicolon >= 0) ? remaining.substring(0, semicolon) : remaining;\n                    \n                    remaining = (semicolon >= 0) ? remaining.substring(semicolon + 1) : '';\n\n                    if (spine.state.hasAnimation(next)) {\n                        this.currentAnimations[animated] = next;\n                        spine.state.setAnimation(animated, next, false);\n                    }\n                    animated += 1;\n                }\n\n                this.paused = true;\n                return animated;\n            },\n\n            setMixTimes: function (mixTimes) {\n                var spine = this.spine,\n                    animations = spine.spineData.animations,\n                    colon = 0,\n                    i = 0,\n                    j = 0,\n                    key = '',\n                    stateData = spine.stateData;\n\n                if (typeof mixTimes === 'number') {\n                    i = animations.length;\n                    while (i--) {\n                        j = animations.length;\n                        while (j--) {\n                            if (i !== j) {\n                                stateData.setMix(animations[i].name, animations[j].name, mixTimes);\n                            }\n                        }\n                    }\n                } else {\n                    for (key in mixTimes) {\n                        if (mixTimes.hasOwnProperty(key)) {\n                            colon = key.indexOf(':');\n                            if (colon >= 0) {\n                                stateData.setMix(key.substring(0, colon), key.substring(colon + 1), mixTimes[key]);\n                            }\n                        }\n                    }\n                }\n\n                this.mixTimes = stateData.animationToMixTime;\n            },\n\n            destroy: function () {\n                this.owner.container.removeChild(this.spine);\n                this.spine.destroy();\n                this.spine = null;\n                this.mixTimes = null;\n            }\n        },\n        \n        getAssetList: (function () {\n            var\n                getImages = function (atlas, atlases) {\n                    const images = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp();\n\n                    if (atlas) {\n                        const findReturns = /\\r/g;\n                        let lines = atlas.replace(findReturns, '').split('\\n'),\n                            j = lines.length;\n\n                        if (lines.length === 1) { // id, not an actual atlas\n                            atlas = atlases[atlas];\n                            if (atlas) {\n                                lines = atlas.replace(findReturns, '').split('\\n');\n                            } else {\n                                return images;\n                            }\n                            j = lines.length;\n                        }\n\n                        while (j--) { // Fix up relative image location paths.\n                            if (lines[j].substr(lines[j].length - 4) === '.png') {\n                                images.push(lines[j]);\n                            }\n                        }\n                    }\n\n                    return images;\n                };\n            \n            return function (component, props, defaultProps) {\n                var arr = null,\n                    i = 0,\n                    images = null,\n                    atlases = platypus.game.settings.atlases,\n                    atlas = component.atlas || props.atlas || defaultProps.atlas;\n                \n                if (Array.isArray(atlas)) {\n                    i = atlas.length;\n                    images = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp();\n                    while (i--) {\n                        arr = getImages(atlas[i], atlases);\n                        Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"union\"])(images, arr);\n                        _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].recycle(arr);\n                    }\n                    return images;\n                } else {\n                    return getImages(atlas, atlases);\n                }\n            };\n        }())\n    });\n})());\n\n\n//# sourceURL=webpack://platypus/./src/components/RenderSpine.js?");

/***/ }),

/***/ "./src/components/RenderSprite.js":
/*!****************************************!*\
  !*** ./src/components/RenderSprite.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var _Data_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Data.js */ \"./src/Data.js\");\n/* harmony import */ var _PIXIAnimation_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../PIXIAnimation.js */ \"./src/PIXIAnimation.js\");\n/* harmony import */ var _RenderAnimator_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./RenderAnimator.js */ \"./src/components/RenderAnimator.js\");\n/* harmony import */ var _RenderContainer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./RenderContainer.js */ \"./src/components/RenderContainer.js\");\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../factory.js */ \"./src/factory.js\");\n/**\n * This component is attached to entities that will appear in the game world. It renders a static or animated image. It listens for messages triggered on the entity or changes in the logical state of the entity to play a corresponding animation.\n *\n * @namespace platypus.components\n * @class RenderSprite\n * @uses platypus.Component\n */\n/* global platypus */\n\n\n\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    return Object(_factory_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])({\n        \n        id: 'RenderSprite',\n        \n        properties: {\n            /**\n             * An object containg key-value pairs that define a mapping from entity states to the animation that should play. The list is processed from top to bottom, so the most important actions should be listed first (for example, a jumping animation might take precedence over an idle animation). If not specified, an 1-to-1 animation map is created from the list of animations in the sprite sheet definition using the animation names as the keys.\n             *\n             *  \"animationStates\":{\n             *      \"standing\": \"default-animation\"  // On receiving a \"standing\" event, or when this.owner.state.standing === true, the \"default\" animation will begin playing.\n             *      \"ground,moving\": \"walking\",  // Comma separated values have a special meaning when evaluating \"state-changed\" messages. The above example will cause the \"walking\" animation to play ONLY if the entity's state includes both \"moving\" and \"ground\" equal to true.\n             *      \"ground,striking\": \"swing!\", // Putting an exclamation after an animation name causes this animation to complete before going to the next animation. This is useful for animations that would look poorly if interrupted.\n             *      \"default\": \"default-animation\" // Optional. \"default\" is a special property that matches all states. If none of the above states are valid for the entity, it will use the default animation listed here.\n             *  }\n             *\n             * If `stateBased` is `true` and this property is not set, this component will use the `animationMap` property value to define state mappings.\n             *\n             * @property animationStates\n             * @type Object\n             * @default animationMap\n             */\n            animationStates: null,\n\n            /**\n             * An object containg key-value pairs that define a mapping from triggered events to the animation that should play.\n             *\n             *     \"animationEvents\":{\n             *         \"move\": \"walk-animation\",\n             *         \"jump\": \"jumping-animation\"\n             *     }\n             *\n             * The above will create two event listeners on the entity, \"move\" and \"jump\", that will play their corresponding animations when the events are triggered.\n             *\n             * If `eventBased` is `true` and this property is not set, this component will use the `animationMap` property value to define event mappings.\n             *\n             * @property animationEvents\n             * @type Object\n             * @default animationMap\n             */\n            animationEvents: null,\n\n           /**\n             * spriteSheet can either be a String or an object. If a string, the spritesheet data will be loaded from the file with a matching name in the spritesheet folder. Otherwise the definition is in full here. That spritesheet data defines an EaselJS sprite sheet to use for rendering. See https://createjs.com/docs/easeljs/classes/SpriteSheet.html for the full specification.\n             *\n             *  \"spriteSheet\": 'hero-image'\n             *\n             *  -OR-\n             *\n             *  \"spriteSheet\": {\n             *\n             *      \"images\": [\"example0\", \"example1\"], //Can also define 'image' and give the\n             *      \"frames\": {\n             *          \"width\":  100,\n             *          \"height\": 100,\n             *          \"regY\":   100,\n             *          \"regX\":   50\n             *      },\n             *      \"animations\":{\n             *          \"default-animation\":[2],\n             *          \"walking\": {\"frames\": [0, 1, 2], \"speed\": 4},\n             *          \"swing\": {\"frames\": [3, 4, 5], \"speed\": 4}\n             *      }\n             *  }\n             *\n             *  -OR- an Array of the above (since 0.8.4)\n             *\n             * @property spriteSheet\n             * @type String|Array|Object\n             * @default null\n             */\n            spriteSheet: null,\n\n            /**\n             * Optional. An object containg key-value pairs that define a mapping from triggered events or entity states to the animation that should play. The list is processed from top to bottom, so the most important actions should be listed first (for example, a jumping animation might take precedence over an idle animation). If not specified, an 1-to-1 animation map is created from the list of animations in the sprite sheet definition using the animation names as the keys.\n             *\n             *     \"animationMap\":{\n             *         \"standing\": \"default-animation\"  // On receiving a \"standing\" event, or when this.owner.state.standing === true, the \"default\" animation will begin playing.\n             *         \"ground,moving\": \"walking\",  // Comma separated values have a special meaning when evaluating \"state-changed\" messages. The above example will cause the \"walking\" animation to play ONLY if the entity's state includes both \"moving\" and \"ground\" equal to true.\n             *         \"ground,striking\": \"swing!\", // Putting an exclamation after an animation name causes this animation to complete before going to the next animation. This is useful for animations that would look poorly if interrupted.\n             *         \"default\": \"default-animation\" // Optional. \"default\" is a special property that matches all states. If none of the above states are valid for the entity, it will use the default animation listed here.\n             *     }\n             *\n             * This data may also be used to create a RenderAnimator component on the entity if the `eventBased` or `stateBased` properties are set to `true`.\n             *\n             * @property animationMap\n             * @type Object\n             * @default null\n             */\n            animationMap: null,\n\n            /**\n             * Optional. A mask definition that determines where the image should clip. A string can also be used to create more complex shapes via the PIXI graphics API like: \"mask\": \"r(10,20,40,40).drawCircle(30,10,12)\". Defaults to no mask or, if simply set to true, a rectangle using the entity's dimensions.\n             *\n             *  \"mask\": {\n             *      \"x\": 10,\n             *      \"y\": 10,\n             *      \"width\": 40,\n             *      \"height\": 40\n             *  },\n             *\n             *  -OR-\n             *\n             *  \"mask\": \"r(10,20,40,40).drawCircle(30,10,12)\"\n             *\n             * @property mask\n             * @type Object\n             * @default null\n             */\n            mask: null,\n\n            /**\n             * Defines whether the entity will respond to touch and click events. Setting this value will create an Interactive component on this entity with these properties. For example:\n             *\n             *  \"interactive\": {\n             *      \"hover\": false,\n             *      \"hitArea\": {\n             *          \"x\": 10,\n             *          \"y\": 10,\n             *          \"width\": 40,\n             *          \"height\": 40\n             *      }\n             *  }\n             *\n             * @property interactive\n             * @type Boolean|Object\n             * @default false\n             */\n            interactive: false,\n\n            /**\n             * The offset of the x-axis position of the sprite from the entity's x-axis position.\n             *\n             * @property offsetX\n             * @type Number\n             * @default 0\n             */\n            offsetX: 0,\n\n            /**\n             * The offset of the y-axis position of the sprite from the entity's y-axis position.\n             *\n             * @property offsetY\n             * @type Number\n             * @default 0\n             */\n            offsetY: 0,\n\n            /**\n             * The z-index relative to other render components on the entity.\n             *\n             * @property offsetZ\n             * @type Number\n             * @default 0\n             */\n            offsetZ: 0,\n\n            /**\n             * Whether to restart a playing animation on event.\n             *\n             * @property restart\n             * @type Boolean\n             * @default true\n             */\n            restart: true,\n\n            /**\n             * Whether this object can be mirrored over X. To mirror it over X set the this.owner.rotation value to be > 90  and < 270.\n             *\n             * @property mirror\n             * @type Boolean\n             * @default false\n             */\n            mirror: false,\n\n            /**\n             * Optional. Whether this object can be flipped over Y. To flip it over Y set the this.owner.rotation to be > 180.\n             *\n             * @property flip\n             * @type Boolean\n             * @default false\n             */\n            flip: false,\n\n            /**\n             * Optional. Whether this object is visible or not. To change the visible value dynamically set this.owner.state.visible to true or false.\n             *\n             * @property visible\n             * @type Boolean\n             * @default false\n             */\n            visible: true,\n\n            /**\n             * Optional. Specifies whether this component should create an RenderAnimator component to listen to events matching the animationMap to animate. Set this to true if the component should animate for on events. Default is `false`.\n             *\n             * @property eventBased\n             * @type Boolean\n             * @default false\n             */\n            eventBased: false,\n\n            /**\n             * Optional. Specifies whether this component should create a RenderAnimator component to handle changes in the entity's state that match the animationMap to animate. Set this to true if the component should animate based on `this.owner.state`. Default is `true`.\n             *\n             * @property stateBased\n             * @type Boolean\n             * @default true\n             */\n            stateBased: true,\n\n            /**\n             * Optional. Whether this sprite should be cached into an entity with a `RenderTiles` component (like \"render-layer\"). The `RenderTiles` component must have its \"entityCache\" property set to `true`. Warning! This is a one-direction setting and will remove this component from the entity once the current frame has been cached.\n             *\n             * @property cache\n             * @type Boolean\n             * @default false\n             */\n            cache: false,\n\n            /**\n             * Optional. When using state-based animations, forces animations to complete before starting a new animation. Defaults to false.\n             *\n             * @property forcePlayThrough\n             * @type Boolean\n             * @default false\n             */\n            forcePlayThrough: false,\n\n            /**\n             * Optional. Ignores the opacity of the owner. Used when multiple RenderSprite components are on the same entity.\n             *\n             * @property ignoreOpacity\n             * @type Boolean\n             * @default false\n             */\n            ignoreOpacity: false,\n\n            /**\n             * The scaling factor for this component.\n             *\n             * @property scale\n             * @type Number|Array|Object\n             * @default 1\n             */\n            scale: 1,\n\n            /**\n             * Optional. The X scaling factor for the image. Defaults to 1.\n             *\n             * @property scaleX\n             * @type Number\n             * @default 1\n             */\n            scaleX: 1,\n\n            /**\n             * Optional. The Y scaling factor for the entity. Defaults to 1.\n             *\n             * @property scaleY\n             * @type Number\n             * @default 1\n             */\n            scaleY: 1,\n            \n            /**\n            * The scaling factor for this sprite relative to the scale of the container.\n            *\n            * @property localScaleX\n            * @type Number|Array|Object\n            * @default 1\n            */\n            localScaleX: 1,\n\n           /**\n            * The scaling factor for this sprite relative to the scale of the container.\n            *\n            * @property localScaleY\n            * @type Number|Array|Object\n            * @default 1\n            */\n            localScaleY: 1,\n\n            /**\n             * The skew factor for this component.\n             *\n             * @property skew\n             * @type Number|Array|Object\n             * @default 0\n             */\n            skew: 0,\n\n            /**\n             * Optional. The X skew factor of the entity. Defaults to 0.\n             *\n             * @property skewX\n             * @type Number\n             * @default 0\n             */\n            skewX: 0,\n\n            /**\n             * Optional. The Y skew factor for the entity. Defaults to 0.\n             *\n             * @property skewY\n             * @type Number\n             * @default 0\n             */\n            skewY: 0\n        },\n\n        initialize: (function () {\n            var createAnimationMap = function (animationMap, ss) {\n                    var map  = null,\n                        anim = '';\n\n                    if (animationMap) {\n                        return animationMap;\n                    } else if (Array.isArray(ss.frames) && (ss.frames.length === 1)) {\n                        // This is a single frame animation, so no mapping is necessary\n                        return null;\n                    } else {\n                        // Create 1-to-1 animation map since none was defined\n                        map = {};\n                        for (anim in ss.animations) {\n                            if (ss.animations.hasOwnProperty(anim)) {\n                                map[anim] = anim;\n                            }\n                        }\n                        return map;\n                    }\n                },\n                animationEnded = function (animation) {\n                    /**\n                     * This event fires each time an animation completes.\n                     *\n                     * @event 'animation-ended'\n                     * @param animation {String} The id of the animation that ended.\n                     */\n                    this.owner.triggerEvent('animation-ended', animation);\n                };\n            \n            return function () {\n                var animation = '',\n                    definition = null,\n                    ss = _PIXIAnimation_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].formatSpriteSheet(this.spriteSheet),\n                    map  = null;\n\n                if (ss === _PIXIAnimation_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].EmptySpriteSheet) {\n                    platypus.debug.warn('Entity \"' + this.owner.type + '\": RenderSprite sprite sheet not defined.');\n                }\n                \n                map = createAnimationMap(this.animationMap, ss);\n                this.stateBased = map && this.stateBased;\n                this.eventBased = map && this.eventBased;\n                if (map) {\n                    animation = map.default || '';\n\n                    definition = _Data_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp(\n                        'animationEvents', this.eventBased ? this.animationEvents || map : null,\n                        'animationStates', this.stateBased ? this.animationStates || map : null,\n                        'forcePlayThrough', this.forcePlayThrough,\n                        'restart', this.restart,\n                        'component', this\n                    );\n                    this.owner.addComponent(new _RenderAnimator_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](this.owner, definition));\n                    definition.recycle();\n                }\n                \n                /*\n                 * PIXIAnimation created here:\n                 */\n                this.sprite = new _PIXIAnimation_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](ss, animation);\n                this.sprite.onComplete = animationEnded.bind(this);\n                this.sprite.x = this.offsetX;\n                this.sprite.y = this.offsetY;\n                this.sprite.z = this.offsetZ;\n                this.sprite.scale.x = this.localScaleX;\n                this.sprite.scale.y = this.localScaleY;\n\n                if (!this.owner.container) {\n                    definition = _Data_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp(\n                        'interactive', this.interactive,\n                        'mask', this.mask,\n                        'mirror', this.mirror,\n                        'flip', this.flip,\n                        'visible', this.visible,\n                        'cache', this.cache,\n                        'ignoreOpacity', this.ignoreOpacity,\n                        'scaleX', this.scaleX,\n                        'scaleY', this.scaleY,\n                        'skewX', this.skewX,\n                        'skewY', this.skewY\n                    );\n                    this.owner.addComponent(new _RenderContainer_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"](this.owner, definition, this.addToContainer.bind(this)));\n                    definition.recycle();\n                } else {\n                    this.addToContainer();\n                }\n\n                ss.recycleSpriteSheet();\n            };\n        }()),\n        \n        events: {\n            /**\n             * The render update message updates the sprite. If a sprite doesn't have a container, it's removed.\n             *\n             * @method 'handle-render'\n             * @param renderData {Object} Data from the render handler\n             * @param renderData.container {PIXI.Container} The parent container.\n             */\n            \"handle-render\": function (renderData) {\n                if (this.sprite) {\n                    /**\n                     * This event is triggered each tick to check for animation updates.\n                     *\n                     * @event 'update-animation'\n                     * @param playing {Boolean} Whether the animation is in a playing or paused state.\n                     */\n                    this.owner.triggerEvent('update-animation', true);\n\n                    this.sprite.update(renderData.delta);\n                }\n            },\n            \n            /**\n             * Stops the sprite's animation.\n             *\n             * @method 'stop-animation'\n             * @param [animation] {String} The animation to show and pause. If not specified, this method simply pauses the current animation.\n             */\n            \"stop-animation\": function (animation) {\n                this.stopAnimation(animation);\n            },\n            \n            /**\n             * Starts the sprite's animation.\n             *\n             * @method 'play-animation'\n             * @param [animation] {String} The animation to play. If not specified, this method simply unpauses the current animation.\n             * @param [loop = true] {Boolean} Whether this animation should loop.\n             * @param [restart = true] {Boolean} Whether to restart the animation if it's currently playing.\n             */\n            \"play-animation\": function (animation, loop, restart) {\n                this.playAnimation(animation, loop, restart);\n            }\n        },\n        \n        methods: {\n            addToContainer: function () {\n                const container = this.owner.container;\n\n                container.addChild(this.sprite);\n                container.reorder = true;\n            },\n            \n            playAnimation: function (animation, loop, restart) {\n                var sprite = this.sprite;\n\n                if (animation && sprite.has(animation)) {\n                    sprite.gotoAndPlay(animation, loop, restart);\n                } else {\n                    sprite.play();\n                }\n            },\n\n            stopAnimation: function (animation) {\n                var sprite = this.sprite;\n\n                if (animation && sprite.has(animation)) {\n                    sprite.gotoAndStop(animation);\n                } else {\n                    sprite.stop();\n                }\n            },\n\n            destroy: function () {\n                this.owner.container.removeChild(this.sprite);\n                this.sprite.destroy();\n                this.sprite = null;\n            }\n        },\n        \n        getAssetList: (function () {\n            var\n                getImages = function (ss, spriteSheets) {\n                    if (ss) {\n                        if (typeof ss === 'string') {\n                            return getImages(spriteSheets[ss], spriteSheets);\n                        } else if (ss.images) {\n                            return Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSlice\"])(ss.images);\n                        }\n                    }\n\n                    return _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n                };\n            \n            return function (component, props, defaultProps) {\n                var arr = null,\n                    i = 0,\n                    images = null,\n                    spriteSheets = platypus.game.settings.spriteSheets,\n                    ss = component.spriteSheet || props.spriteSheet || (defaultProps && defaultProps.spriteSheet) || null;\n                \n                if (Array.isArray(ss)) {\n                    i = ss.length;\n                    images = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n                    while (i--) {\n                        arr = getImages(ss[i], spriteSheets);\n                        Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"union\"])(images, arr);\n                        _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(arr);\n                    }\n                    return images;\n                } else {\n                    return getImages(ss, spriteSheets);\n                }\n            };\n        }())\n    });\n}());\n\n\n//# sourceURL=webpack://platypus/./src/components/RenderSprite.js?");

/***/ }),

/***/ "./src/components/RenderText.js":
/*!**************************************!*\
  !*** ./src/components/RenderText.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _RenderContainer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RenderContainer.js */ \"./src/components/RenderContainer.js\");\n/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pixi.js */ \"pixi.js\");\n/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(pixi_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../factory.js */ \"./src/factory.js\");\n/**\n * This component is attached to entities that should display text.\n *\n * @namespace platypus.components\n * @class RenderText\n * @uses platypus.Component\n */\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    const\n        alignments = {\n            horizontal: {\n                left: 0,\n                middle: 0.5,\n                center: 0.5,\n                right: 1\n            },\n            vertical: {\n                top: 0,\n                middle: 0.5,\n                center: 0.5,\n                bottom: 1\n            }\n        };\n    \n    return Object(_factory_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({\n        \n        id: 'RenderText',\n        \n        properties: {\n            /**\n             * The offset of the x-axis position of the text from the entity's x-axis position.\n             *\n             * @property offsetX\n             * @type Number\n             * @default 0\n             */\n            offsetX: 0,\n\n            /**\n             * The offset of the y-axis position of the text from the entity's y-axis position.\n             *\n             * @property offsetY\n             * @type Number\n             * @default 0\n             */\n            offsetY: 0,\n\n            /**\n             * The z-index relative to other render components on the entity.\n             *\n             * @property offsetZ\n             * @type Number\n             * @default 0\n             */\n            offsetZ: 0,\n\n            /**\n             * This is the text to display.\n             *\n             * @property text\n             * @type String\n             * @default \"\"\n             */\n            text: \"\",\n            \n            /**\n             * This is the text style to use. Use the following specification to define the style:\n             *\n             *     {\n             *         \"fontSize\": \"64px\",\n             *         \"fill\": \"#ffffff\",\n             *         \"align\": \"center\", // Can be `left`, `center`, or `right`\n             *         \"fontFamily\": \"arial\", // Any CSS font that has been loaded by the browser\n             *         \"verticalAlign\": \"bottom\" // Can be `top`, `center`, or `bottom`\n             *     }\n             *\n             * See [PIXI.TextStyle documentation](http://pixijs.download/dev/docs/PIXI.TextStyle.html) for a full list of available options.\n             *\n             * @property style\n             * @type Object\n             * @default null\n             */\n            style: null\n        },\n        \n        initialize: function (definition) {\n            var hAlign = alignments.horizontal[this.style.align],\n                vAlign = alignments.vertical[this.style.verticalAlign];\n\n            this.sprite = new pixi_js__WEBPACK_IMPORTED_MODULE_1__[\"Text\"](this.text, this.style);\n            \n            this.sprite.anchor.x = typeof hAlign === 'number' ? hAlign : 0.5;\n            this.sprite.anchor.y = typeof vAlign === 'number' ? vAlign : 1;\n            this.sprite.x = this.offsetX;\n            this.sprite.y = this.offsetY;\n            this.sprite.z = this.offsetZ;\n\n            if (!this.owner.container) {\n                this.owner.addComponent(new _RenderContainer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this.owner, definition, this.addToContainer.bind(this)));\n            } else {\n                this.addToContainer();\n            }\n        },\n        \n        events: {\n            /**\n             * Sets the copy of the text.\n             *\n             * @method 'set-text'\n             * @param text {String} The text to insert.\n             */\n            \"set-text\": function (text) {\n                if (typeof text === 'string') {\n                    this.sprite.text = text;\n                } else {\n                    if (text.style) {\n                        const textStyle = this.sprite.style;\n                        for (const key in text.style) {\n                            if (text.style.hasOwnProperty(key)) {\n                                textStyle[key] = text.style[key];\n                            }\n                        }\n                    }\n                    if (typeof text.text === 'string') {\n                        this.sprite.text = text.text;\n                    }\n                }\n            }\n        },\n        \n        methods: {\n            addToContainer: function () {\n                var container = this.owner.container;\n\n                container.addChild(this.sprite);\n                container.reorder = true;\n            },\n            \n            destroy: function () {\n                this.owner.container.removeChild(this.sprite);\n                this.sprite.destroy();\n                this.sprite = null;\n            }\n        }\n    });\n}());\n\n\n//# sourceURL=webpack://platypus/./src/components/RenderText.js?");

/***/ }),

/***/ "./src/components/RenderTiles.js":
/*!***************************************!*\
  !*** ./src/components/RenderTiles.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pixi.js */ \"pixi.js\");\n/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(pixi_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var _AABB_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../AABB.js */ \"./src/AABB.js\");\n/* harmony import */ var _PIXIAnimation_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../PIXIAnimation.js */ \"./src/PIXIAnimation.js\");\n/* harmony import */ var _RenderContainer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./RenderContainer.js */ \"./src/components/RenderContainer.js\");\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! config */ \"./src/config/development.js\");\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(config__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../factory.js */ \"./src/factory.js\");\n/* harmony import */ var recycle__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! recycle */ \"./node_modules/recycle/recycle.js\");\n/**\n * This component handles rendering tile map backgrounds.\n *\n * When rendering the background, this component figures out what tiles are being displayed and caches them so they are rendered as one image rather than individually.\n *\n * As the camera moves, the cache is updated by blitting the relevant part of the old cached image into a new cache and then rendering tiles that have shifted into the camera's view into the cache.\n *\n * @namespace platypus.components\n * @class RenderTiles\n * @uses platypus.Component\n */\n/* global platypus */\n\n\n\n\n\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    var EDGE_BLEED = 1,\n        EDGES_BLEED = EDGE_BLEED * 2,\n        doNothing = function () {\n            return null;\n        },\n        tempCache = _AABB_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(),\n        sort = function (a, b) {\n            return a.z - b.z;\n        },\n        getPowerOfTwo = function (amount) {\n            var x = 1;\n\n            while (x < amount) {\n                x *= 2;\n            }\n\n            return x;\n        },\n        transformCheck = function (v, tile) {\n            if (0x80000000 & v) {\n                tile.scale.x = -1;\n            }\n            if (0x40000000 & v) {\n                tile.scale.y = -1;\n            }\n            if (0x20000000 & v) {\n                const x = tile.scale.x;\n                tile.scale.x = tile.scale.y;\n                tile.scale.y = -x;\n                tile.rotation = Math.PI / 2;\n            }\n        },\n        Template = function (tileSpriteSheet, id, uninitializedTiles) {\n            this.id = id;\n            this.instances = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp();\n            this.index = 0;\n\n            // jit sprite\n            this.tileSpriteSheet = tileSpriteSheet;\n            this.getNext = this.initializeAndGetNext;\n            this.uninitializedTiles = uninitializedTiles;\n            uninitializedTiles.push(this);\n        },\n        nullTemplate = {\n            getNext: doNothing,\n            destroy: doNothing\n        },\n        prototype = Template.prototype;\n\n    prototype.initializeAndGetNext = function () {\n        this.initialize();\n\n        this.index += 1;\n        return this.instances[0];\n    };\n\n    prototype.initialize = function () {\n        const\n            index = +(this.id.substring(4)),\n            anim = 'tile' + (0x0fffffff & index),\n            tile = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Sprite\"]((this.tileSpriteSheet._animations[anim] || this.tileSpriteSheet._animations.default).texture);\n            \n        transformCheck(index, tile);\n        tile.template = this; // backwards reference for clearing index later.\n        this.instances.push(tile);\n        Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"greenSplice\"])(this.uninitializedTiles, this.uninitializedTiles.indexOf(this));\n\n        delete this.getNext;\n    };\n\n    prototype.getNext = function () {\n        var instance = this.instances[this.index],\n            template = null;\n\n        if (!instance) {\n            template = this.instances[0];\n            instance = this.instances[this.index] = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Sprite\"](template.texture);\n\n            // Copy properties\n            instance.scale    = template.scale;\n            instance.rotation = template.rotation;\n            instance.anchor   = template.anchor || template._animation.anchor;\n        }\n\n        this.index += 1;\n\n        return instance;\n    };\n\n    prototype.clear = function () {\n        this.index = 0;\n    };\n    \n    prototype.destroy = function () {\n        var i = 0;\n        \n        for (i = 0; i < this.instances.length; i++) {\n            this.instances[i].destroy();\n        }\n        \n        _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].recycle(this.instances);\n        this.recycle();\n    };\n\n    recycle__WEBPACK_IMPORTED_MODULE_7__[\"default\"].add(Template, 'Template', Template, null, true, config__WEBPACK_IMPORTED_MODULE_5___default.a.dev);\n\n    return Object(_factory_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"])({\n\n        id: 'RenderTiles',\n\n        properties: {\n            /**\n             * The amount of space in pixels around the edge of the camera that we include in the buffered image. If not set, largest buffer allowed by maximumBuffer is used.\n             *\n             * @property buffer\n             * @type number\n             * @default 0\n             */\n            buffer: 0,\n\n            /**\n             * Determines whether to cache the entire map across one or more texture caches. By default this is `false`; however, if the entire map fits on one or two texture caches, this is set to `true` since it is more efficient than dynamic buffering.\n             *\n             * @property cacheAll\n             * @type Boolean\n             * @default false\n             */\n            cacheAll: false,\n\n            /**\n             * Whether to cache entities on this layer if the entity's render component requests caching.\n             *\n             * @property entityCache\n             * @type boolean\n             * @default false\n             */\n            entityCache: false,\n\n            /**\n             * This is a two dimensional array of the spritesheet indexes that describe the map that you're rendering.\n             *\n             * @property imageMap\n             * @type Array\n             * @default []\n             */\n            imageMap: [],\n\n            /**\n             * The amount of space that is buffered. Defaults to 2048 x 2048 or a smaller area that encloses the tile layer.\n             *\n             * @property maximumBuffer\n             * @type number\n             * @default 2048\n             */\n            maximumBuffer: 2048,\n\n            /**\n             * The x-scale the tilemap is being displayed at.\n             *\n             * @property scaleX\n             * @type number\n             * @default 1\n             */\n            scaleX: 1,\n\n            /**\n             * The y-scale the tilemap is being displayed at.\n             *\n             * @property scaleY\n             * @type number\n             * @default 1\n             */\n            scaleY: 1,\n\n            /**\n             * A sprite sheet describing all the tile images.\n             *\n             * Accepts an array of sprite sheet data since 0.8.4\n             *\n             * @property spriteSheet\n             * @type Object|Array|String\n             * @default null\n             */\n            spriteSheet: null,\n\n            /**\n             * Whether to cache the tile map to a large texture.\n             *\n             * @property tileCache\n             * @type boolean\n             * @default true\n             */\n            tileCache: true,\n\n            /**\n             * This is the height in pixels of individual tiles.\n             *\n             * @property tileHeight\n             * @type number\n             * @default 10\n             */\n            tileHeight: 10,\n\n            /**\n             * This is the width in pixels of individual tiles.\n             *\n             * @property tileWidth\n             * @type number\n             * @default 10\n             */\n            tileWidth: 10,\n            \n            /**\n             * The map's top offset.\n             *\n             * @property top\n             * @type Number\n             * @default 0\n             */\n            top: 0,\n            \n            /**\n             * The map's left offset.\n             *\n             * @property left\n             * @type Number\n             * @default 0\n             */\n            left: 0\n        },\n\n        initialize: function (definition) {\n            var imgMap = this.imageMap;\n\n            this.doMap            = null; //list of display objects that should overlay tile map.\n            this.cachedDisplayObjects = null;\n            this.populate         = this.populateTiles;\n\n            this.tiles            = {};\n\n            this.renderer         = platypus.game.renderer;\n            this.tilesSprite      = null;\n            this.cacheTexture     = null;\n            this.mapContainer      = null;\n            this.laxCam = _AABB_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp();\n\n            // temp values\n            this.worldWidth    = this.tileWidth;\n            this.worldHeight   = this.tileHeight;\n\n            this.cache = _AABB_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp();\n            this.cachePixels = _AABB_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp();\n\n            this.uninitializedTiles = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp();\n\n            // Set up containers\n            this.spriteSheet = _PIXIAnimation_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].formatSpriteSheet(this.spriteSheet);\n            this.tileSpriteSheet = new _PIXIAnimation_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](this.spriteSheet);\n            this.tileContainer = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Container\"]();\n            this.mapContainer = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Container\"]();\n            this.mapContainer.addChild(this.tileContainer);\n            \n            this.reorderedStage = false;\n            this.updateCache = false;\n\n            // Prepare map tiles\n            this.imageMap = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp(this.createMap(imgMap));\n\n            this.tilesWidth  = this.imageMap[0].length;\n            this.tilesHeight = this.imageMap[0][0].length;\n            this.layerWidth  = this.tilesWidth  * this.tileWidth;\n            this.layerHeight = this.tilesHeight * this.tileHeight;\n\n            // Set up buffer cache size\n            this.cacheWidth  = Math.min(getPowerOfTwo(this.layerWidth  + EDGES_BLEED), this.maximumBuffer);\n            this.cacheHeight = Math.min(getPowerOfTwo(this.layerHeight + EDGES_BLEED), this.maximumBuffer);\n\n            if (!this.tileCache) {\n                this.buffer = 0; // prevents buffer logic from running if tiles aren't being cached.\n                this.cacheAll = false; // so tiles are updated as camera moves.\n            }\n\n            this.ready = false;\n\n            if (!this.owner.container) {\n                this.owner.addComponent(new _RenderContainer_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"](this.owner, definition, this.addToContainer.bind(this)));\n            } else {\n                this.addToContainer();\n            }\n        },\n\n        events: {\n            /**\n             * If this component should cache entities, it checks peers for a \"renderCache\" display object and adds the display object to its list of objects to render on top of the tile set.\n             *\n             * @method 'cache-sprite'\n             * @param entity {platypus.Entity} This is the peer entity to be checked for a renderCache.\n             */\n            \"cache-sprite\": function (entity) {\n                this.cacheSprite(entity);\n            },\n\n            /**\n             * If this component should cache entities, it checks peers for a \"renderCache\" display object and adds the display object to its list of objects to render on top of the tile set.\n             *\n             * @method 'peer-entity-added'\n             * @param entity {platypus.Entity} This is the peer entity to be checked for a renderCache.\n             */\n            \"peer-entity-added\": function (entity) {\n                this.cacheSprite(entity);\n            },\n\n            /**\n             * This event adds a layer of tiles to render on top of the existing layer of rendered tiles.\n             *\n             * @method 'add-tiles'\n             * @param message.imageMap {Array} This is a 2D mapping of tile indexes to be rendered.\n             */\n            \"add-tiles\": function (definition) {\n                var map = definition.imageMap;\n\n                if (map) {\n                    this.imageMap.push(this.createMap(map));\n                    this.updateCache = true;\n                }\n            },\n\n            /**\n             * This event edits the tile index of a rendered tile.\n             *\n             * @method 'change-tile'\n             * @param tile {String} A string representing the name of the tile to switch to.\n             * @param x {Number} The column of the tile to edit.\n             * @param y {Number} The row of the tile to edit.\n             * @param [z] {Number} If RenderTiles has multiple layers, this value specifies the layer, with `0` being the bottom-most layer.\n             */\n            \"change-tile\": function (tile, x, y, z) {\n                var map = this.imageMap;\n\n                if (map) {\n                    this.updateTile(tile, map[z || 0], x, y);\n                    this.updateCache = true;\n                }\n            },\n\n            /**\n             * Provides the width and height of the world.\n             *\n             * @method 'camera-loaded'\n             * @param camera {Object}\n             * @param camera.world {platypus.AABB} The dimensions of the world.\n             * @param camera.viewport {platypus.AABB} The AABB describing the camera viewport in world units.\n             */\n            \"camera-loaded\": function (camera) {\n                this.worldWidth  = camera.world.width;\n                this.worldHeight = camera.world.height;\n\n                if (this.buffer && !this.cacheAll) { // do this here to set the correct mask before the first caching.\n                    this.updateBufferRegion(camera.viewport);\n                }\n            },\n\n            /**\n             * Triggered when the camera moves, this function updates which tiles need to be rendered and caches the image.\n             *\n             * @method 'camera-update'\n             * @param camera {Object} Provides information about the camera.\n             * @param camera.viewport {platypus.AABB} The AABB describing the camera viewport in world units.\n             */\n            \"camera-update\": function (camera) {\n                if (this.ready) {\n                    this.updateCamera(camera);\n                }\n            },\n\n            /**\n             * On receiving this message, determines whether to update which tiles need to be rendered and caches the image.\n             *\n             * @method 'handle-render'\n             */\n            \"handle-render\": function () {\n                if (this.updateCache) {\n                    this.updateCache = false;\n                    if (this.cacheGrid) {\n                        this.updateGrid();\n                    } else {\n                        this.update(this.cacheTexture, this.cache);\n                    }\n                } else if (this.uninitializedTiles.length) { // Pre-render any tiles left to be prerendered to reduce lag on camera movement\n                    this.uninitializedTiles[0].initialize();\n                }\n            }\n        },\n\n        methods: {\n            addToContainer: function () {\n                var container = this.container = this.owner.container,\n                    extrusionMargin = 2,\n                    mapContainer = this.mapContainer,\n                    sprite = null,\n                    z = this.owner.z;\n\n                container.reorder = true;\n\n                this.ready = true;\n\n                this.updateRegion(0);\n\n                if (!this.tileCache) {\n                    this.render = doNothing;\n\n                    mapContainer.scale.x = this.scaleX;\n                    mapContainer.scale.y = this.scaleY;\n                    mapContainer.x = this.left;\n                    mapContainer.y = this.top;\n                    mapContainer.z = z;\n                    container.addChild(mapContainer);\n                } else {\n                    this.mapContainerWrapper = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Container\"]();\n                    this.mapContainerWrapper.addChild(mapContainer);\n\n                    if ((this.layerWidth <= this.cacheWidth) && (this.layerHeight <= this.cacheHeight)) { // We never need to recache.\n                        this.cacheAll   = true;\n\n                        this.render = this.renderCache;\n                        this.cacheTexture = pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"RenderTexture\"].create(this.cacheWidth, this.cacheHeight);\n\n                        this.tilesSprite = sprite = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Sprite\"](this.cacheTexture);\n                        sprite.scale.x = this.scaleX;\n                        sprite.scale.y = this.scaleY;\n                        sprite.z = z;\n\n                        this.cache.setBounds(0, 0, this.tilesWidth - 1, this.tilesHeight - 1);\n                        this.update(this.cacheTexture, this.cache);\n                        container.addChild(sprite);\n                    } else if (this.cacheAll || ((this.layerWidth <= this.cacheWidth * 2) && (this.layerHeight <= this.cacheHeight)) || ((this.layerWidth <= this.cacheWidth) && (this.layerHeight <= this.cacheHeight * 2))) { // We cache everything across several textures creating a cache grid.\n                        this.cacheAll = true;\n\n                        // Make sure there's room for the one-pixel extrusion around edges of caches\n                        this.cacheWidth = Math.min(getPowerOfTwo(this.layerWidth + extrusionMargin), this.maximumBuffer);\n                        this.cacheHeight = Math.min(getPowerOfTwo(this.layerHeight + extrusionMargin), this.maximumBuffer);\n                        this.updateRegion(extrusionMargin);\n\n                        this.render = this.renderCacheWithExtrusion;\n                        this.cacheGrid = this.createGrid(container);\n\n                        this.updateCache = true;\n                    } else {\n                        this.render = this.renderCache;\n                        this.cacheAll = false;\n\n                        this.cacheTexture = pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"RenderTexture\"].create(this.cacheWidth, this.cacheHeight);\n\n                        this.tilesSprite = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Sprite\"](this.cacheTexture);\n                        this.tilesSprite.scale.x = this.scaleX;\n                        this.tilesSprite.scale.y = this.scaleY;\n                        this.tilesSprite.z = z;\n\n                        // Set up copy buffer and circular pointers\n                        this.cacheTexture.alternate = pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"RenderTexture\"].create(this.cacheWidth, this.cacheHeight);\n                        this.tilesSpriteCache = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Sprite\"](this.cacheTexture.alternate);\n\n                        this.cacheTexture.alternate.alternate = this.cacheTexture;\n                        container.addChild(this.tilesSprite);\n                    }\n                }\n            },\n\n            cacheSprite: function (entity) {\n                var x = 0,\n                    y = 0,\n                    object = entity.cacheRender,\n                    bounds = null,\n                    top = 0,\n                    bottom = 0,\n                    right = 0,\n                    left = 0;\n\n                // Determine whether to merge this image with the background.\n                if (this.entityCache && object) { //TODO: currently only handles a single display object on the cached entity.\n                    if (!this.doMap) {\n                        this.doMap = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp();\n                        this.cachedDisplayObjects = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp();\n                        this.populate = this.populateTilesAndEntities;\n                    }\n                    this.cachedDisplayObjects.push(object);\n\n                    // Determine range:\n                    bounds = object.getBounds(object.transformMatrix);\n                    bounds.x -= this.left;\n                    bounds.y -= this.top;\n                    top    = Math.max(0, Math.floor(bounds.y / this.tileHeight));\n                    bottom = Math.min(this.tilesHeight, Math.ceil((bounds.y + bounds.height) / this.tileHeight));\n                    left   = Math.max(0, Math.floor(bounds.x / this.tileWidth));\n                    right  = Math.min(this.tilesWidth, Math.ceil((bounds.x + bounds.width) / this.tileWidth));\n\n                    // Find tiles that should include this display object\n                    for (x = left; x < right; x++) {\n                        if (!this.doMap[x]) {\n                            this.doMap[x] = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp();\n                        }\n                        for (y = top; y < bottom; y++) {\n                            if (!this.doMap[x][y]) {\n                                this.doMap[x][y] = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp();\n                            }\n                            this.doMap[x][y].push(object);\n                        }\n                    }\n\n                    // Prevent subsequent draws\n                    entity.removeComponent('RenderSprite');\n\n                    this.updateCache = true; //TODO: This currently causes a blanket cache update - may be worthwhile to only recache if this entity's location is currently in a cache (either cacheGrid or the current viewable area).\n                }\n            },\n\n            convertCamera: function (camera) {\n                var worldWidth  = this.worldWidth / this.scaleX,\n                    worldPosX   = worldWidth - camera.width,\n                    worldHeight = this.worldHeight / this.scaleY,\n                    worldPosY   = worldHeight - camera.height,\n                    laxCam      = this.laxCam;\n\n                if ((worldWidth === this.layerWidth) || !worldPosX) {\n                    laxCam.moveX(camera.x);\n                } else {\n                    laxCam.moveX((camera.left - this.left) * (this.layerWidth - camera.width) / worldPosX + camera.halfWidth + this.left);\n                }\n\n                if ((worldHeight === this.layerHeight) || !worldPosY) {\n                    laxCam.moveY(camera.y);\n                } else {\n                    laxCam.moveY((camera.top - this.top) * (this.layerHeight - camera.height) / worldPosY + camera.halfHeight + this.top);\n                }\n\n                if (camera.width !== laxCam.width || camera.height !== laxCam.height) {\n                    laxCam.resize(camera.width, camera.height);\n                }\n\n                return laxCam;\n            },\n\n            createTile: function (imageName) {\n                // \"tile-1\" is empty, so it remains a null reference.\n                if (imageName === 'tile-1') {\n                    return nullTemplate;\n                }\n\n                return Template.setUp(this.tileSpriteSheet, imageName, this.uninitializedTiles);\n            },\n\n            createMap: function (mapDefinition) {\n                var x = 0,\n                    y = 0,\n                    index = '',\n                    map   = null;\n\n                if (typeof mapDefinition[0][0] !== 'string') { // This is not a map definition: it's an actual RenderTiles map.\n                    return mapDefinition;\n                }\n\n                map = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp();\n                for (x = 0; x < mapDefinition.length; x++) {\n                    map[x] = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp();\n                    for (y = 0; y < mapDefinition[x].length; y++) {\n                        index = mapDefinition[x][y];\n                        this.updateTile(index, map, x, y);\n                    }\n                }\n                \n                return map;\n            },\n            \n            updateCamera: function (camera) {\n                var x = 0,\n                    y = 0,\n                    inFrame = false,\n                    sprite  = null,\n                    ctw     = 0,\n                    cth     = 0,\n                    ctw2    = 0,\n                    cth2    = 0,\n                    cache   = this.cache,\n                    cacheP  = this.cachePixels,\n                    vp      = camera.viewport,\n                    resized = (this.buffer && ((vp.width !== this.laxCam.width) || (vp.height !== this.laxCam.height))),\n                    tempC   = tempCache,\n                    laxCam  = this.convertCamera(vp);\n\n                if (!this.cacheAll && (cacheP.empty || !cacheP.contains(laxCam)) && (this.imageMap.length > 0)) {\n                    if (resized) {\n                        this.updateBufferRegion(laxCam);\n                    }\n                    ctw     = this.cacheTilesWidth - 1;\n                    cth     = this.cacheTilesHeight - 1;\n                    ctw2    = ctw / 2;\n                    cth2    = cth / 2;\n\n                    //only attempt to draw children that are relevant\n                    tempC.setAll(Math.round((laxCam.x - this.left) / this.tileWidth - ctw2) + ctw2, Math.round((laxCam.y - this.top) / this.tileHeight - cth2) + cth2, ctw, cth);\n                    if (tempC.left < 0) {\n                        tempC.moveX(tempC.halfWidth);\n                    } else if (tempC.right > this.tilesWidth - 1) {\n                        tempC.moveX(this.tilesWidth - 1 - tempC.halfWidth);\n                    }\n                    if (tempC.top < 0) {\n                        tempC.moveY(tempC.halfHeight);\n                    } else if (tempC.bottom > this.tilesHeight - 1) {\n                        tempC.moveY(this.tilesHeight - 1 - tempC.halfHeight);\n                    }\n                    \n                    if (!this.tileCache) {\n                        this.update(null, tempC);\n                    } else if (cache.empty || !tempC.contains(cache)) {\n                        this.tilesSpriteCache.texture = this.cacheTexture;\n                        this.cacheTexture = this.cacheTexture.alternate;\n                        this.tilesSprite.texture = this.cacheTexture;\n                        this.update(this.cacheTexture, tempC, this.tilesSpriteCache, cache);\n                    }\n\n                    // Store pixel bounding box for checking later.\n                    cacheP.setAll((cache.x + 0.5) * this.tileWidth + this.left, (cache.y + 0.5) * this.tileHeight + this.top, (cache.width + 1) * this.tileWidth, (cache.height + 1) * this.tileHeight);\n                }\n\n                if (this.cacheGrid) {\n                    for (x = 0; x < this.cacheGrid.length; x++) {\n                        for (y = 0; y < this.cacheGrid[x].length; y++) {\n                            sprite = this.cacheGrid[x][y];\n                            cacheP.setAll((x + 0.5) * this.cacheClipWidth + this.left, (y + 0.5) * this.cacheClipHeight + this.top, this.cacheClipWidth, this.cacheClipHeight);\n\n                            inFrame = cacheP.intersects(laxCam);\n                            if (sprite.visible && !inFrame) {\n                                sprite.visible = false;\n                            } else if (!sprite.visible && inFrame) {\n                                sprite.visible = true;\n                            }\n                            \n                            if (sprite.visible && inFrame) {\n                                sprite.x = vp.left - laxCam.left + x * this.cacheClipWidth + this.left;\n                                sprite.y = vp.top  - laxCam.top  + y * this.cacheClipHeight + this.top;\n                            }\n                        }\n                    }\n                } else if (this.tileCache) {\n                    this.tilesSprite.x = vp.left - laxCam.left + cache.left * this.tileWidth + this.left;\n                    this.tilesSprite.y = vp.top  - laxCam.top  + cache.top  * this.tileHeight + this.top;\n                }\n            },\n\n            updateTile: function (index, map, x, y) {\n                var tile = null,\n                    tiles = this.tiles;\n                \n                if (index.id) {\n                    index = index.id;\n                }\n                tile = tiles[index];\n                if (!tile && (tile !== null)) { // Empty grid spaces are null, so we needn't create a new tile.\n                    tile = tiles[index] = this.createTile(index);\n                }\n                map[x][y] = tile;\n            },\n\n            createGrid: function (container) {\n                var ch = this.cacheHeight,\n                    cw = this.cacheWidth,\n                    cth = this.cacheTilesHeight,\n                    ctw = this.cacheTilesWidth,\n                    h = 0,\n                    w = 0,\n                    outerMargin = EDGES_BLEED,\n                    extrusion = EDGE_BLEED,\n                    rt = null,\n                    sx = this.scaleX,\n                    sy = this.scaleY,\n                    th = this.tileHeight,\n                    tw = this.tileWidth,\n                    tsh = this.tilesHeight,\n                    tsw = this.tilesWidth,\n                    x = 0,\n                    y = 0,\n                    z = this.owner.z,\n                    col = null,\n                    ct = null,\n                    cg = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp();\n\n                for (x = 0; x < tsw; x += ctw) {\n                    col = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp();\n                    cg.push(col);\n                    for (y = 0; y < tsh; y += cth) {\n                        // This prevents us from using too large of a cache for the right and bottom edges of the map.\n                        w = Math.min(getPowerOfTwo((tsw - x) * tw + outerMargin), cw);\n                        h = Math.min(getPowerOfTwo((tsh - y) * th + outerMargin), ch);\n\n                        rt = pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"RenderTexture\"].create(w, h);\n                        rt.frame = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Rectangle\"](extrusion, extrusion, (((w - outerMargin) / tw) >> 0) * tw + extrusion, (((h - outerMargin) / th) >> 0) * th + extrusion);\n                        ct = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Sprite\"](rt);\n                        ct.z = z;\n                        ct.scale.x = sx;\n                        ct.scale.y = sy;\n                        col.push(ct);\n                        container.addChild(ct);\n\n                        z -= 0.000001; // so that tiles of large caches overlap consistently.\n                    }\n                }\n                \n                return cg;\n            },\n            \n            updateRegion: function (margin) {\n                var tw = this.tileWidth * this.scaleX,\n                    th = this.tileHeight * this.scaleY,\n                    ctw = Math.min(this.tilesWidth,  ((this.cacheWidth - EDGES_BLEED)  / tw)  >> 0),\n                    cth = Math.min(this.tilesHeight, ((this.cacheHeight - EDGES_BLEED) / th) >> 0);\n\n                if (!ctw) {\n                    platypus.debug.warn('\"' + this.owner.type + '\" RenderTiles: The tiles are ' + tw + 'px wide which is larger than ' + (this.cacheWidth - EDGES_BLEED) + 'px (maximum cache size of ' + this.cacheWidth + 'px minus a 2px edge bleed). Increase the maximum cache size or reduce tile size.');\n                }\n                if (!cth) {\n                    platypus.debug.warn('\"' + this.owner.type + '\" RenderTiles: The tiles are ' + th + 'px high which is larger than ' + (this.cacheHeight - EDGES_BLEED) + 'px (maximum cache size of ' + this.cacheHeight + 'px minus a 2px edge bleed). Increase the maximum cache size or reduce tile size.');\n                }\n\n                this.cacheTilesWidth  = ctw;\n                this.cacheTilesHeight = cth;\n                this.cacheClipWidth   = ctw * tw;\n                this.cacheClipHeight  = cth * th;\n\n                if (this.tileCache) {\n                    this.mapContainer.mask = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Graphics\"]().beginFill(0x000000).drawRect(0, 0, this.cacheClipWidth + margin, this.cacheClipHeight + margin).endFill();\n                }\n            },\n\n            updateBufferRegion: function (viewport) {\n                var tw = this.tileWidth * this.scaleX,\n                    th = this.tileHeight * this.scaleY;\n\n                this.cacheTilesWidth  = Math.min(this.tilesWidth,  Math.ceil((viewport.width  + this.buffer * 2) / tw), (this.cacheWidth  / tw) >> 0);\n                this.cacheTilesHeight = Math.min(this.tilesHeight, Math.ceil((viewport.height + this.buffer * 2) / th), (this.cacheHeight / th) >> 0);\n\n                this.cacheClipWidth   = this.cacheTilesWidth  * tw;\n                this.cacheClipHeight  = this.cacheTilesHeight * th;\n\n                this.mapContainer.mask = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Graphics\"]().beginFill(0x000000).drawRect(0, 0, this.cacheClipWidth, this.cacheClipHeight).endFill();\n            },\n\n            update: function (texture, bounds, tilesSpriteCache, oldBounds) {\n                this.populate(bounds, oldBounds);\n\n                this.render(bounds, texture, this.mapContainer, this.mapContainerWrapper, tilesSpriteCache, oldBounds);\n\n                if (oldBounds) {\n                    oldBounds.set(bounds);\n                }\n            },\n            \n            populateTiles: function (bounds, oldBounds) {\n                var x = 0,\n                    y = 0,\n                    z = 0,\n                    layer = 0,\n                    tile  = null,\n                    tiles = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp();\n\n                this.tileContainer.removeChildren();\n                for (x = bounds.left; x <= bounds.right; x++) {\n                    for (y = bounds.top; y <= bounds.bottom; y++) {\n                        if (!oldBounds || oldBounds.empty || (y > oldBounds.bottom) || (y < oldBounds.top) || (x > oldBounds.right) || (x < oldBounds.left)) {\n                            for (layer = 0; layer < this.imageMap.length; layer++) {\n                                tile = this.imageMap[layer][x][y].getNext();\n                                if (tile) {\n                                    if (tile.template) {\n                                        tiles.push(tile.template);\n                                    }\n                                    tile.x = (x + 0.5) * this.tileWidth;\n                                    tile.y = (y + 0.5) * this.tileHeight;\n                                    this.tileContainer.addChild(tile);\n                                }\n                            }\n                        }\n                    }\n                }\n\n                // Clear out tile instances\n                for (z = 0; z < tiles.length; z++) {\n                    tiles[z].clear();\n                }\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].recycle(tiles);\n            },\n            \n            populateTilesAndEntities: function (bounds, oldBounds) {\n                var x = 0,\n                    y = 0,\n                    z = 0,\n                    layer   = 0,\n                    tile    = null,\n                    ent     = null,\n                    ents    = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp(),\n                    tiles   = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp(),\n                    oList   = null;\n\n                this.tileContainer.removeChildren();\n                for (x = bounds.left; x <= bounds.right; x++) {\n                    for (y = bounds.top; y <= bounds.bottom; y++) {\n                        if (!oldBounds || oldBounds.empty || (y > oldBounds.bottom) || (y < oldBounds.top) || (x > oldBounds.right) || (x < oldBounds.left)) {\n                            // draw tiles\n                            for (layer = 0; layer < this.imageMap.length; layer++) {\n                                tile = this.imageMap[layer][x][y].getNext();\n                                if (tile) {\n                                    if (tile.template) {\n                                        tiles.push(tile.template);\n                                    }\n                                    tile.x = (x + 0.5) * this.tileWidth;\n                                    tile.y = (y + 0.5) * this.tileHeight;\n                                    this.tileContainer.addChild(tile);\n                                }\n                            }\n\n                            // check for cached entities\n                            if (this.doMap[x] && this.doMap[x][y]) {\n                                oList = this.doMap[x][y];\n                                for (z = 0; z < oList.length; z++) {\n                                    if (!oList[z].drawn) {\n                                        oList[z].drawn = true;\n                                        ents.push(oList[z]);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n\n                this.mapContainer.removeChildren();\n                this.mapContainer.addChild(this.tileContainer);\n\n                // Draw cached entities\n                if (ents.length) {\n                    ents.sort(sort);\n                    for (z = 0; z < ents.length; z++) {\n                        ent = ents[z];\n                        delete ent.drawn;\n                        this.mapContainer.addChild(ent);\n                        if (ent.mask) {\n                            this.mapContainer.addChild(ent.mask);\n                        }\n                    }\n                }\n\n                // Clear out tile instances\n                for (z = 0; z < tiles.length; z++) {\n                    tiles[z].clear();\n                }\n                \n                _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].recycle(tiles);\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].recycle(ents);\n            },\n            \n            renderCache: function (bounds, dest, src, wrapper, oldCache, oldBounds) {\n                var renderer = this.renderer;\n\n                if (oldCache && !oldBounds.empty) {\n                    oldCache.x = oldBounds.left * this.tileWidth;\n                    oldCache.y = oldBounds.top * this.tileHeight;\n                    src.addChild(oldCache); // To copy last rendering over.\n                }\n\n                //clearRenderTexture(renderer, dest);\n                src.x = -bounds.left * this.tileWidth;\n                src.y = -bounds.top * this.tileHeight;\n                renderer.render(wrapper, dest);\n                dest.requiresUpdate = true;\n            },\n\n            renderCacheWithExtrusion: function (bounds, dest, src, wrapper) {\n                var extrusion = 1,\n                    border = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Graphics\"](),\n                    renderer = this.renderer;\n\n                // This mask makes only the extruded border drawn for the next 4 draws so that inner holes aren't extruded in addition to the outer rim.\n                border.lineStyle(1, 0x000000);\n                border.drawRect(0.5, 0.5, this.cacheClipWidth + 1, this.cacheClipHeight + 1);\n\n                //clearRenderTexture(renderer, dest);\n\n                // There is probably a better way to do this. Currently for the extrusion, everything is rendered once offset in the n, s, e, w directions and then once in the middle to create the effect.\n                wrapper.mask = border;\n                src.x = -bounds.left * this.tileWidth;\n                src.y = -bounds.top * this.tileHeight + extrusion;\n                renderer.render(wrapper, dest);\n                src.x = -bounds.left * this.tileWidth + extrusion;\n                src.y = -bounds.top * this.tileHeight;\n                renderer.render(wrapper, dest);\n                src.x = -bounds.left * this.tileWidth + extrusion * 2;\n                src.y = -bounds.top * this.tileHeight + extrusion;\n                renderer.render(wrapper, dest);\n                src.x = -bounds.left * this.tileWidth + extrusion;\n                src.y = -bounds.top * this.tileHeight + extrusion * 2;\n                renderer.render(wrapper, dest);\n                wrapper.mask = null;\n                src.x = -bounds.left * this.tileWidth + extrusion;\n                src.y = -bounds.top * this.tileHeight + extrusion;\n                renderer.render(wrapper, dest);\n                dest.requiresUpdate = true;\n            },\n            \n            updateGrid: function () {\n                var cache = this.cache,\n                    cth = this.cacheTilesHeight,\n                    ctw = this.cacheTilesWidth,\n                    tsh = this.tilesHeight - 1,\n                    tsw = this.tilesWidth - 1,\n                    x = 0,\n                    y = 0,\n                    grid = this.cacheGrid;\n\n                for (x = 0; x < grid.length; x++) {\n                    for (y = 0; y < grid[x].length; y++) {\n                        cache.setBounds(x * ctw, y * cth, Math.min((x + 1) * ctw, tsw), Math.min((y + 1) * cth, tsh));\n                        this.update(grid[x][y].texture, cache);\n                    }\n                }\n            },\n\n            toJSON: function () {\n                var imageMap = this.imageMap[0],\n                    imgMap = [],\n                    x = imageMap.length,\n                    y = 0;\n                \n                while (x--) {\n                    y = imageMap[x].length;\n                    imgMap[x] = [];\n                    while (y--) {\n                        imgMap[x][y] = imageMap[x][y].id;\n                    }\n                }\n\n                return {\n                    type: 'RenderTiles',\n                    buffer: this.buffer,\n                    cacheAll: this.cacheAll,\n                    entityCache: this.entityCache,\n                    imageMap: imgMap,\n                    maximumBuffer: this.maximumBuffer,\n                    scaleX: this.scaleX,\n                    scaleY: this.scaleY,\n                    spriteSheet: this.spriteSheet,\n                    tileCache: this.tileCache,\n                    tileHeight: this.tileHeight,\n                    tileWidth: this.tileWidth,\n                    top: this.top,\n                    left: this.left\n                };\n            },\n\n            destroy: function () {\n                var x = 0,\n                    y = 0,\n                    key = '',\n                    grid = this.cacheGrid,\n                    map = this.doMap,\n                    img = this.imageMap;\n                    \n                if (grid) {\n                    for (x = 0; x < grid.length; x++) {\n                        for (y = 0; y < grid[x].length; y++) {\n                            grid[x][y].texture.destroy(true);\n                            this.container.removeChild(grid[x][y]);\n                        }\n                    }\n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].recycle(grid, 2);\n                    delete this.cacheGrid;\n                } else if (this.tilesSprite) {\n                    if (this.tilesSprite.texture.alternate) {\n                        this.tilesSprite.texture.alternate.destroy(true);\n                    }\n                    this.tilesSprite.texture.destroy(true);\n                    this.container.removeChild(this.tilesSprite);\n                } else {\n                    this.container.removeChild(this.mapContainer);\n                }\n                \n                _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].recycle(img, 2);\n                \n                for (key in this.tiles) {\n                    if (this.tiles.hasOwnProperty(key)) {\n                        this.tiles[key].destroy();\n                    }\n                }\n                this.tiles = null;\n                this.container = null;\n                this.tilesSprite = null;\n                this.spriteSheet.recycleSpriteSheet();\n                \n                if (map) {\n                    for (x = 0; x < this.cachedDisplayObjects.length; x++) {\n                        this.cachedDisplayObjects[x].destroy();\n                    }\n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].recycle(this.cachedDisplayObjects);\n\n                    for (x = 0; x < map.length; x++) {\n                        if (map[x]) {\n                            for (y = 0; y < map.length; y++) {\n                                if (map[x][y]) {\n                                    map[x][y].recycle();\n                                }\n                            }\n                            _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].recycle(map[x]);\n                        }\n                    }\n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].recycle(map);\n                }\n                \n                this.laxCam.recycle();\n                this.cache.recycle();\n                this.cachePixels.recycle();\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].recycle(this.uninitializedTiles);\n            }\n        },\n        \n        getAssetList: (function () {\n            var\n                getImages = function (ss, spriteSheets) {\n                    if (ss) {\n                        if (typeof ss === 'string') {\n                            return getImages(spriteSheets[ss], spriteSheets);\n                        } else if (ss.images) {\n                            return Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"greenSlice\"])(ss.images);\n                        }\n                    }\n\n                    return _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp();\n                };\n            \n            return function (component, props, defaultProps) {\n                var arr = null,\n                    i = 0,\n                    images = null,\n                    spriteSheets = platypus.game.settings.spriteSheets,\n                    ss = component.spriteSheet || props.spriteSheet || defaultProps.spriteSheet;\n                \n                if (ss) {\n                    if (typeof ss === 'string' && (ss !== 'import')) {\n                        return getImages(ss, spriteSheets);\n                    } else if (Array.isArray(ss)) {\n                        i = ss.length;\n                        images = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp();\n                        while (i--) {\n                            arr = getImages(ss[i], spriteSheets);\n                            Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"union\"])(images, arr);\n                            _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].recycle(arr);\n                        }\n                        return images;\n                    } else if (ss.images) {\n                        return Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"greenSlice\"])(ss.images);\n                    }\n                }\n                \n                return _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp();\n            };\n        }())\n    });\n}());\n\n\n//# sourceURL=webpack://platypus/./src/components/RenderTiles.js?");

/***/ }),

/***/ "./src/components/SceneChanger.js":
/*!****************************************!*\
  !*** ./src/components/SceneChanger.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Data_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Data.js */ \"./src/Data.js\");\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../factory.js */ \"./src/factory.js\");\n/**\n * This component allows the entity to initiate a change from the current scene to another scene.\n *\n * @namespace platypus.components\n * @class SceneChanger\n * @extends platypus.Component\n */\n/* global platypus */\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    return Object(_factory_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])({\n        id: 'SceneChanger',\n        \n        properties: {\n            /**\n             * Optional, but must be provided by a \"new-scene\" parameter if not defined here. This causes a \"new-scene\" event to load this set of layers.\n             *\n             * @property loadLayers\n             * @type Array\n             * @default null\n             */\n            loadLayers: null,\n\n            /**\n             * Optional. This causes a \"new-scene\" event to load this scene.\n             *\n             * @property scene\n             * @type String\n             * @default \"\"\n             */\n            scene: \"\",\n\n            /**\n             * Optional, but must be provided by a \"new-scene\" parameter if not defined here. This causes a \"new-scene\" event to unload these layers.\n             *\n             * @property unloadLayers\n             * @type Array\n             * @default null\n             */\n            unloadLayers: null,\n\n            /**\n             * An object containing key/value pairs of information that should be passed into the new layers on the new layers' \"layer-loaded\" and \"layer-live\" events.\n             *\n             * @property persistentData\n             * @type platypus.Data|Object\n             * @default null\n             */\n            persistentData: null\n        },\n        \n        initialize: function () {\n            this.persistentData = _Data_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp(this.persistentData);\n        },\n\n        events: {\n            /**\n             * On receiving this message, a new scene is loaded according to provided parameters or previously determined component settings.\n             *\n             * @method 'new-scene'\n             * @param message.load {String} This is a label corresponding with a predefined layer.\n             * @param message.persistentData {Object} Any values that should be passed to the layers' \"layer-loaded\" and \"layer-live\" events.\n             */\n            \"new-scene\": function (response) {\n                const\n                    loadLayers = (response && response.loadLayers) || this.loadLayers,\n                    scene      = (response && response.scene) || this.scene,\n                    unloadLayers = (response && response.unloadLayers) || this.unloadLayers,\n                    data = (response && response.persistentData) || this.persistentData;\n            \n                if (unloadLayers && unloadLayers.length) {\n                    for (let i = 0; i < unloadLayers.length; i++) {\n                        platypus.game.unload(unloadLayers[i]);\n                    }\n                }\n\n                if (loadLayers && loadLayers.length) {\n                    for (let i = 0; i < loadLayers.length; i++) {\n                        platypus.game.load(loadLayers[i], data);\n                    }\n                }\n\n                if (scene) {\n                    platypus.game.loadScene(scene, data);\n                }\n            },\n\n            /**\n             * On receiving this message, a scene value is stored, waiting for a `new-scene` to make the transition.\n             *\n             * @method 'set-scene'\n             * @param scene {String} This is a label corresponding with a predefined scene.\n             */\n            \"set-scene\": function (scene) {\n                this.scene = scene;\n            },\n\n            /**\n             * On receiving this message, persistent data is stored, waiting for a `new-scene` to make the transition.\n             *\n             * @method 'set-persistent-scene-data'\n             * @param persistentData {Object} Any values that should be passed to the next scene via the \"layer-loaded\" and \"layer-live\" events.\n             */\n            \"set-persistent-scene-data\": function (data) {\n                var thisData = this.persistentData,\n                    key = '';\n                \n                for (key in data) {\n                    if (data.hasOwnProperty(key)) {\n                        thisData[key] = data[key];\n                    }\n                }\n            }\n        },\n        \n        methods: {\n            destroy: function () {\n                //data.recycle() - can't do this here since it may be in use by the next scene.\n            }\n        }\n    });\n}());\n\n\n//# sourceURL=webpack://platypus/./src/components/SceneChanger.js?");

/***/ }),

/***/ "./src/components/TiledLoader.js":
/*!***************************************!*\
  !*** ./src/components/TiledLoader.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var _AABB_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../AABB.js */ \"./src/AABB.js\");\n/* harmony import */ var _Data_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Data.js */ \"./src/Data.js\");\n/* harmony import */ var _DataMap_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../DataMap.js */ \"./src/DataMap.js\");\n/* harmony import */ var _Entity_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Entity.js */ \"./src/Entity.js\");\n/* harmony import */ var _Vector_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../Vector.js */ \"./src/Vector.js\");\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../factory.js */ \"./src/factory.js\");\n/* harmony import */ var pako__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! pako */ \"./node_modules/pako/index.js\");\n/* harmony import */ var pako__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(pako__WEBPACK_IMPORTED_MODULE_7__);\n/**\n * This component is attached to a top-level entity and, once its peer components are loaded, ingests a JSON file exported from the [Tiled map editor](http://www.mapeditor.org/) and creates the tile maps and entities. Once it has finished loading the map, it removes itself from the list of components on the entity.\n *\n * This component requires an [EntityContainer](platypus.components.EntityContainer.html) since it calls `entity.addEntity()` on the entity, provided by `EntityContainer`.\n *\n * This component looks for the following entities, and if not found will load default versions:\n\n        {\n            \"render-layer\": {\n                \"id\": \"render-layer\",\n                \"components\":[{\n                    \"type\": \"RenderTiles\",\n                    \"spriteSheet\": \"import\",\n                    \"imageMap\":    \"import\",\n                    \"entityCache\": true\n                }]\n            },\n            \"collision-layer\": {\n                \"id\": \"collision-layer\",\n                \"components\":[{\n                    \"type\": \"CollisionTiles\",\n                    \"collisionMap\": \"import\"\n                }]\n            },\n            \"image-layer\": {\n                \"id\": \"image-layer\",\n                \"components\":[{\n                    \"type\": \"RenderTiles\",\n                    \"spriteSheet\": \"import\",\n                    \"imageMap\":    \"import\"\n                }]\n            }\n        }\n\n * @namespace platypus.components\n * @class TiledLoader\n * @uses platypus.Component\n */\n/* global atob, platypus */\n\n\n\n\n\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    var FILENAME_TO_ID = /^(?:(\\w+:)\\/{2}(\\w+(?:\\.\\w+)*\\/?))?([\\/.]*?(?:[^?]+)?\\/)?(?:(([^\\/?]+)\\.(\\w+))|([^\\/?]+))(?:\\?((?:(?:[^&]*?[\\/=])?(?:((?:(?:[^\\/?&=]+)\\.(\\w+)))\\S*?)|\\S+))?)?$/,\n        maskId = 0x0fffffff,\n        maskXFlip = 0x80000000,\n        maskYFlip = 0x40000000,\n        decodeBase64 = (function () {\n            var decodeString = function (str, index) {\n                    return (((str.charCodeAt(index)) + (str.charCodeAt(index + 1) << 8) + (str.charCodeAt(index + 2) << 16) + (str.charCodeAt(index + 3) << 24 )) >>> 0);\n                },\n                decodeArray = function (arr, index) {\n                    return ((arr[index] + (arr[index + 1] << 8) + (arr[index + 2] << 16) + (arr[index + 3] << 24 )) >>> 0);\n                };\n            \n            return function (data, compression) {\n                var index = 4,\n                    arr   = [],\n                    step1 = atob(data.replace(/\\\\/g, ''));\n                    \n                if (compression === 'zlib') {\n                    step1 = Object(pako__WEBPACK_IMPORTED_MODULE_7__[\"inflate\"])(step1);\n                    while (index <= step1.length) {\n                        arr.push(decodeArray(step1, index - 4));\n                        index += 4;\n                    }\n                } else {\n                    while (index <= step1.length) {\n                        arr.push(decodeString(step1, index - 4));\n                        index += 4;\n                    }\n                }\n                \n                return arr;\n            };\n        }()),\n        decodeLayer = function (layer) {\n            if (layer.encoding === 'base64') {\n                layer.data = decodeBase64(layer.data, layer.compression);\n                layer.encoding = 'csv'; // So we won't have to decode again.\n            }\n            return layer;\n        },\n        getImageId = function (path) {\n            var result = path.match(FILENAME_TO_ID);\n\n            return result[5] || result[7];\n        },\n        finishedLoading = function (level, x, y, width, height, tileWidth, tileHeight, callback) {\n            var message = _Data_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(\n                    \"level\", null,\n                    \"world\", _AABB_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp(),\n                    \"tile\", _AABB_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp(),\n                    \"camera\", null,\n                    \"lazyLoads\", this.lazyLoads\n                );\n\n            this.lazyLoads.sort((a, b) => b.aabb.left - a.aabb.left); // Maybe a smidge faster since we can cut out once it's too far to the right.\n\n            /**\n             * Once finished loading the map, this message is triggered on the entity to notify other components of completion.\n             *\n             * @event 'world-loaded'\n             * @param message {platypus.Data} World data.\n             * @param message.level {Object} The Tiled level data used to load the level.\n             * @param message.width {number} The width of the world in world units.\n             * @param message.height {number} The height of the world in world units.\n             * @param message.tile {platypus.AABB} Dimensions of the world tiles.\n             * @param message.world {platypus.AABB} Dimensions of the world.\n             * @param message.camera {platypus.Entity} If a camera property is found on one of the loaded entities, this property will point to the entity on load that a world camera should focus on.\n             * @param message.lazyLoads {Array} List of objects representing entity definitions that will await camera focus before generating actual entities.\n             */\n            message.level = level;\n            message.camera = this.followEntity; // TODO: in 0.9.0 this should probably be removed, using something like \"child-entity-added\" instead. Currently this is particular to TiledLoader and Camera and should be generalized. - DDD 3/15/2016\n            message.width = width;\n            message.height = height;\n            message.world.setBounds(x, y, x + width, y + height);\n            message.tile.setBounds(0, 0, tileWidth, tileHeight);\n            this.owner.triggerEvent('world-loaded', message);\n            message.world.recycle();\n            message.tile.recycle();\n            message.recycle();\n            \n            if (this.lazyLoads.length) {\n                this.addEventListener(\"camera-update\", (camera) => {\n                    const\n                        lazyLoads = this.lazyLoads,\n                        viewport = _AABB_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp(camera.viewport);\n                    let i = lazyLoads.length;\n\n                    viewport.resize(viewport.width * 1.5, viewport.height * 1.5);\n\n                    while (i--) {\n                        const entity = lazyLoads[i],\n                            aabb = entity.aabb;\n\n                        if (viewport.intersects(aabb)) {\n                            aabb.recycle();\n                            entity.aabb = null;\n                            this.owner.addEntity(entity);\n                            for (let j = i + 1; j < lazyLoads.length; j++) {\n                                lazyLoads[j - 1] = lazyLoads[j];\n                            }\n                            lazyLoads.length -= 1;\n                        } else if (aabb.left > viewport.right) { // we're at the end of viable aabb's\n                            break;\n                        }\n                    }\n                });\n                if (this.backgroundLoad) {\n                    this.addEventListener('tick', function () {\n                        const\n                            lazyLoads = this.lazyLoads,\n                            i = lazyLoads.length;\n\n                        if (i) {\n                            const entity = lazyLoads.pop(i - 1),\n                                aabb = entity.aabb;\n\n                            aabb.recycle();\n                            entity.aabb = null;\n                            this.owner.addEntity(entity);\n                        }\n                    });\n                }\n            } else {\n                this.owner.removeComponent(this);\n            }\n\n            if (callback) {\n                callback();\n            }\n        },\n        getPowerOfTen = function (amount) {\n            var x = 1;\n\n            while (x < amount) {\n                x *= 10;\n            }\n\n            return x;\n        },\n        transform = {\n            x: 1,\n            y: 1,\n            id: -1\n        },\n        getProperty = function (obj, key) { // Handle Tiled map versions\n            var i = 0;\n\n            if (obj) {\n                if (Array.isArray(obj)) {\n                    i = obj.length;\n                    while (i--) {\n                        if (obj[i].name === key) {\n                            return obj[i].value;\n                        }\n                    }\n                    return null;\n                } else {\n                    return obj[key];\n                }\n            } else {\n                return null;\n            }\n        },\n        setProperty = function (obj, key, value) { // Handle Tiled map versions\n            var i = 0;\n\n            if (obj) {\n                if (Array.isArray(obj)) {\n                    i = obj.length;\n                    while (i--) {\n                        if (obj[i].name === key) {\n                            obj[i].type = typeof value;\n                            obj[i].value = value;\n                            return;\n                        }\n                    }\n                    obj.push({\n                        name: key,\n                        type: typeof value,\n                        value: value\n                    });\n                } else {\n                    obj[key] = value;\n                }\n            }\n        },\n        entityTransformCheck = function (v) {\n            var resp = transform,\n                b = !!(maskYFlip & v),\n                c = !!(maskXFlip & v);\n\n            resp.id = maskId & v;\n            resp.x = 1;\n            resp.y = 1;\n\n            if (b) {\n                resp.y = -1;\n            }\n            if (c) {\n                resp.x = -1;\n            }\n            return resp;\n        },\n        createTilesetObjectGroupReference = function (reference, tilesets) {\n            for (let i = 0; i < tilesets.length; i++) {\n                const\n                    tileset = tilesets[i],\n                    tiles = tileset.tiles;\n                \n                if (tiles) {\n                    for (let j = 0; j < tiles.length; j++) {\n                        const tile = tiles[j];\n\n                        if (tile.objectgroup) { // Could just be other information, like terrain\n                            reference.set(tile.id + tileset.firstgid, tile.objectgroup);\n                        }\n                    }\n                }\n            }\n        },\n        getEntityData = function (obj, tilesets) {\n            var x = 0,\n                gid = obj.gid || -1,\n                properties = {},\n                data = {\n                    gid: -1,\n                    transform: null,\n                    properties: properties,\n                    type: ''\n                },\n                props = null,\n                tileset = null,\n                entityTilesetIndex = 0;\n            \n            if (gid !== -1) {\n                data.transform = entityTransformCheck(gid);\n                gid = data.gid = transform.id;\n            }\n            \n            if (tilesets) {\n                for (x = 0; x < tilesets.length; x++) {\n                    if (tilesets[x].firstgid > gid) {\n                        break;\n                    } else {\n                        tileset = tilesets[x];\n                    }\n                }\n                \n                if (tileset) {\n                    entityTilesetIndex = gid - tileset.firstgid;\n                    if (tileset.tileproperties && tileset.tileproperties[entityTilesetIndex]) {\n                        props = tileset.tileproperties[entityTilesetIndex];\n                    }\n                    if (tileset.tiles && tileset.tiles[entityTilesetIndex]) {\n                        data.type = tileset.tiles[entityTilesetIndex].type || '';\n                    }\n                }\n            }\n\n            // Check Tiled data to find this object's type\n            data.type = obj.type || data.type;\n\n            if (!data.type) { // undefined entity\n                return null;\n            }\n            \n            //Copy properties from Tiled\n            if (data.transform) {\n                properties.scaleX = data.transform.x;\n                properties.scaleY = data.transform.y;\n            } else {\n                properties.scaleX = 1;\n                properties.scaleY = 1;\n            }\n            \n            mergeAndFormatProperties(props, data.properties);\n            mergeAndFormatProperties(obj.properties, data.properties);\n            \n            return data;\n        },\n        mergeAndFormatProperties = function (src, dest) {\n            var i = 0,\n                key = '';\n            \n            if (src && dest) {\n                if (Array.isArray(src)) {\n                    for (i = 0; i < src.length; i++) {\n                        setProperty(dest, src[i].name, formatProperty(src[i].value));\n                    }\n                } else {\n                    for (key in src) {\n                        if (src.hasOwnProperty(key)) {\n                            setProperty(dest, key, formatProperty(src[key]));\n                        }\n                    }\n                }\n            }\n            \n            return dest;\n        },\n        formatProperty = function (value) {\n            var numberProperty = 0;\n            \n            if (typeof value === 'string') {\n                //This is going to assume that if you pass in something that starts with a number, it is a number and converts it to one.\n                // eslint-disable-next-line radix\n                numberProperty = parseFloat(value) || parseInt(value); // to handle floats and 0x respectively.\n                if (numberProperty === 0 || (!!numberProperty)) {\n                    return numberProperty;\n                } else if (value === 'true') {\n                    return true;\n                } else if (value === 'false') {\n                    return false;\n                } else if ((value.length > 1) && (((value[0] === '{') && (value[value.length - 1] === '}')) || ((value[0] === '[') && (value[value.length - 1] === ']')))) {\n                    try {\n                        return JSON.parse(value);\n                    } catch (e) {\n                    }\n                }\n            }\n\n            return value;\n        },\n        checkLevel = function (level, ss) {\n            const\n                addObjectGroupAssets = (assets, objectGroup, tilesets) => {\n                    const objects = objectGroup.objects;\n\n                    for (let i = 0; i < objects.length; i++) {\n                        const entity = getEntityData(objects[i], tilesets);\n                        if (entity) {\n                            const entityAssets = _Entity_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].getAssetList(entity);\n                            Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"union\"])(assets, entityAssets);\n                            _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(entityAssets);\n                        }\n                    }\n                };\n\n            var i = 0,\n                tilesets = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(),\n                arr = null,\n                assets = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(),\n                data = null,\n                entity = null;\n\n            if (typeof level === 'string') {\n                level = platypus.game.settings.levels[level];\n            }\n\n            if (level) {\n                if (level.tilesets) {\n                    level.tilesets = importTilesetData(level.tilesets);\n                }\n\n                if (level.assets) { // Property added by a previous parse (so that this algorithm isn't run on the same level multiple times)\n                    Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"union\"])(assets, level.assets);\n                } else if (level.layers) {\n                    for (i = 0; i < level.layers.length; i++) {\n                        const layer = level.layers[i];\n\n                        if (layer.type === 'objectgroup') {\n                            addObjectGroupAssets(assets, layer, level.tilesets);\n                        } else if (layer.type === 'imagelayer') {\n                            Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"union\"])(assets, [layer.image]);\n                        } else {\n                            const\n                                tiles = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n\n                            // must decode first so we can check for tiles' objects\n                            decodeLayer(layer);\n\n                            // Check for relevant objectgroups in tileset\n                            Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"union\"])(tiles, layer.data); // merge used tiles into one-off list\n                            for (let j = 0; j < tiles.length; j++) {\n                                const id = maskId & tiles[j];\n                                for (let k = 0; k < level.tilesets.length; k++) {\n                                    const tiles = level.tilesets[k].tiles;\n                                    if (tiles) {\n                                        for (let l = 0; l < tiles.length; l++) {\n                                            const tile = tiles[l];\n                                            if ((tile.id === id) && tile.objectgroup) {\n                                                addObjectGroupAssets(assets, tile.objectgroup);\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n\n                            // Check for custom layer entity\n                            entity = getProperty(level.layers[i].properties, 'entity');\n                            if (entity) {\n                                data = _Data_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp('type', entity);\n                                arr = _Entity_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].getAssetList(data);\n                                Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"union\"])(assets, arr);\n                                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(arr);\n                                data.recycle();\n                            }\n                        }\n                    }\n                    if (!ss) { //We need to load the tileset images since there is not a separate spriteSheet describing them\n                        for (i = 0; i < level.tilesets.length; i++) {\n                            tilesets.push(level.tilesets[i].image);\n                        }\n                        Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"union\"])(assets, tilesets);\n                        _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(tilesets);\n                    }\n                    level.assets = Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSlice\"])(assets); // Save for later in case this level is checked again.\n                }\n            }\n            \n            return assets;\n        },\n        // These are provided but can be overwritten by entities of the same name in the configuration.\n        standardEntityLayers = {\n            \"render-layer\": {\n                \"id\": \"render-layer\",\n                \"components\": [{\n                    \"type\": \"RenderTiles\",\n                    \"spriteSheet\": \"import\",\n                    \"imageMap\": \"import\",\n                    \"entityCache\": true\n                }]\n            },\n            \"collision-layer\": {\n                \"id\": \"collision-layer\",\n                \"components\": [{\n                    \"type\": \"CollisionTiles\",\n                    \"collisionMap\": \"import\"\n                }]\n            },\n            \"image-layer\": {\n                \"id\": \"image-layer\",\n                \"components\": [{\n                    \"type\": \"RenderTiles\",\n                    \"spriteSheet\": \"import\",\n                    \"imageMap\": \"import\"\n                }]\n            }\n        },\n        importTileset = function (tileset) {\n            var key = '',\n                source = platypus.game.settings.levels[tileset.source.replace('.json', '')];\n            \n            for (key in source) {\n                if (source.hasOwnProperty(key)) {\n                    tileset[key] = source[key];\n                }\n            }\n            \n            delete tileset.source; // We remove this so we never have to rerun this import. Note that we can't simply replace the tileset properties since the tileset's firstgid property may change from level to level.\n            \n            return tileset;\n        },\n        importTilesetData = function (tilesets) {\n            var i = 0;\n            \n            for (i = 0; i < tilesets.length; i++) {\n                if (tilesets[i].source) {\n                    tilesets[i] = importTileset(tilesets[i]);\n                }\n            }\n            \n            return tilesets;\n        };\n\n    return Object(_factory_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"])({\n        id: 'TiledLoader',\n\n        properties: {\n            /**\n             * This causes the entire map to be offset automatically by an order of magnitude higher than the height and width of the world so that the number of digits below zero is constant throughout the world space. This fixes potential floating point issues when, for example, 97 is added to 928.0000000000001 giving 1025 since a significant digit was lost when going into the thousands.\n             *\n             * @property offsetMap\n             * @type Boolean\n             * @default false\n             */\n            offsetMap: false,\n            \n            /**\n             * If set to `true` and if the game is running in debug mode, this causes the collision layer to appear.\n             *\n             * @property showCollisionTiles\n             * @type Boolean\n             * @default false\n             */\n            showCollisionTiles: false,\n\n            /**\n             * If specified, the referenced images are used as the game sprite sheets instead of the images referenced in the Tiled map. This is useful for using different or better quality art from the art used in creating the Tiled map.\n             *\n             * @property images\n             * @type Array\n             * @default null\n             */\n            images: null,\n\n            /**\n             * Adds a number to each additional Tiled layer's z coordinate to maintain z-order. Defaults to 1000.\n             *\n             * @property layerIncrement\n             * @type number\n             * @default 1000\n             */\n            layerIncrement: 1000,\n\n            /**\n             * Keeps the tile maps in separate render layers. Default is 'false' to for better optimization.\n             *\n             * @property separateTiles\n             * @type boolean\n             * @default false\n             */\n            separateTiles: false,\n            \n            /**\n             * If a particular sprite sheet should be used that's not defined by the level images themselves. This is useful for making uniquely-themed variations of the same level. This is overridden by `\"spriteSheet\": \"import\"` in the \"render-layer\" Entity definition, so be sure to remove that when setting this property.\n             *\n             * @property spriteSheet\n             * @type String | Object\n             * @default null\n             */\n            spriteSheet: null,\n\n            /**\n             * Whether to continue loading `lazyLoad` entities in the background after level starts regardless of camera position. If `false`, entities with a `lazyLoad` property will only load once within camera range.\n             *\n             * @property backgroundLoad\n             * @type Boolean\n             * @default true\n             */\n            backgroundLoad: true\n        },\n\n        publicProperties: {\n            /**\n             * Specifies the JSON level to load. Available on the entity as `entity.level`.\n             *\n             * @property level\n             * @type String\n             * @default null\n             */\n            level: null,\n\n            /**\n             * Can be \"left\", \"right\", or \"center\". Defines where entities registered X position should be when spawned. Available on the entity as `entity.entityPositionX`.\n             *\n             * @property entityPositionX\n             * @type String\n             * @default \"center\"\n             */\n            entityPositionX: \"center\",\n\n            /**\n             * Can be \"top\", \"bottom\", or \"center\". Defines where entities registered Y position should be when spawned. Available on the entity as `entity.entityPositionY`.\n             *\n             * @property entityPositionY\n             * @type String\n             * @default \"bottom\"\n             */\n            entityPositionY: \"bottom\",\n\n            /**\n             * Whether to wait for a \"load-level\" event before before loading. Available on the entity as `entity.manuallyLoad`.\n             *\n             * @property manuallyLoad\n             * @type boolean\n             * @default false\n             */\n            manuallyLoad: false\n        },\n\n        initialize: function () {\n            this.assetCache = platypus.assetCache;\n            this.layerZ = 0;\n            this.followEntity = false;\n            this.lazyLoads = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n        },\n\n        events: {\n\n            /**\n             * On receiving this message, the component commences loading the Tiled map JSON definition. Once finished, it removes itself from the entity's list of components.\n             *\n             * @method 'layer-loaded'\n             * @param persistentData {Object} Data passed from the last scene into this one.\n             * @param persistentData.level {Object} A level name or definition to load if the level is not already specified.\n             * @param holds {platypus.Data} An object that handles any holds on before making the scene live.\n             * @param holds.count {Number} The number of holds to wait for before triggering \"scene-live\"\n             * @param holds.release {Function} The method to trigger to let the scene loader know that one hold has been released.\n             */\n            \"layer-loaded\": function (persistentData, holds) {\n                if (!this.manuallyLoad) {\n                    holds.count += 1;\n                    this.loadLevel({\n                        level: this.level || persistentData.level,\n                        persistentData: persistentData\n                    }, holds.release);\n                }\n            },\n\n            /**\n             * If `manuallyLoad` is set, the component will wait for this message before loading the Tiled map JSON definition.\n             *\n             * @method 'load-level'\n             * @param levelData {Object}\n             * @param levelData.level {String|Object} The level to load.\n             * @param [levelData.persistentData] {Object} Information passed from the last scene.\n             * @param callback {Function} The function to call once the level is loaded.\n             */\n            \"load-level\": function (levelData, callback) {\n                this.loadLevel(levelData, callback);\n            }\n        },\n\n        methods: {\n            createLayer: function (entityKind, layer, mapOffsetX, mapOffsetY, tileWidth, tileHeight, tilesets, tilesetObjectGroups, images, combineRenderLayer, progress) {\n                var lastSet = null,\n                    props = null,\n                    width = layer.width,\n                    height = layer.height,\n                    tHeight = layer.tileheight || tileHeight,\n                    tWidth = layer.tilewidth || tileWidth,\n                    newWidth = 0,\n                    newHeight = 0,\n                    layerHeight = 0,\n                    layerWidth = 0,\n                    tileTypes = 0,\n                    tileDefinition = JSON.parse(JSON.stringify(platypus.game.settings.entities[entityKind] || standardEntityLayers[entityKind])), //TODO: a bit of a hack to copy an object instead of overwrite values\n                    importAnimation = {},\n                    importCollision = [],\n                    importFrames = [],\n                    importRender = [],\n                    importSpriteSheet = {\n                        images: (layer.image ? [layer.image] : images),\n                        frames: importFrames,\n                        animations: importAnimation\n                    },\n                    renderTiles = false,\n                    index = 0,\n                    x = 0,\n                    y = 0,\n                    data = null,\n                    createFrames = function (frames, index, tileset, modifier) {\n                        var margin = tileset.margin || 0,\n                            spacing = tileset.spacing || 0,\n                            tileWidth = tileset.tilewidth,\n                            tileHeight = tileset.tileheight,\n                            tileWidthHalf = tileWidth / 2,\n                            tileHeightHalf = tileHeight / 2,\n                            tileWidthSpace = tileWidth + spacing,\n                            tileHeightSpace = tileHeight + spacing,\n                            margin2 = margin * 2,\n                            marginSpace = margin2 - spacing,\n                            cols = tileset.columns || (((tileset.imagewidth / tileWidthSpace) + marginSpace) >> 0),\n                            rows = /* Tiled tileset def doesn't seem to have rows */ (((tileset.imageheight / tileHeightSpace) + marginSpace) >> 0),\n                            x = 0,\n                            y = 0;\n                        \n                        // deprecated unit/image resizing\n                        tileWidth = tileWidth * modifier;\n                        tileHeight = tileHeight * modifier;\n                        tileWidthHalf = tileWidthHalf * modifier;\n                        tileHeightHalf = tileHeightHalf * modifier;\n                        tileWidthSpace = tileWidthSpace * modifier;\n                        tileHeightSpace = tileHeightSpace * modifier;\n\n                        for (y = 0; y < rows; y++) {\n                            for (x = 0; x < cols; x++) {\n                                frames.push([\n                                    margin + x * tileWidthSpace,\n                                    margin + y * tileHeightSpace,\n                                    tileWidth,\n                                    tileHeight,\n                                    index,\n                                    tileWidthHalf,\n                                    tileHeightHalf\n                                ]);\n                            }\n                        }\n                    };\n                \n                decodeLayer(layer);\n                data = layer.data;\n                mapOffsetX += layer.offsetx || 0;\n                mapOffsetY += layer.offsety || 0;\n\n                tileDefinition.properties = tileDefinition.properties || {};\n\n                //This builds in parallaxing support by allowing the addition of width and height properties into Tiled layers so they pan at a separate rate than other layers.\n                if (layer.properties) {\n\n                    layerWidth = getProperty(layer.properties, 'width');\n                    if (layerWidth) {\n                        newWidth  = parseInt(layerWidth,  10);\n                    }\n\n                    layerHeight = getProperty(layer.properties, 'height');\n                    if (layerHeight) {\n                        newHeight = parseInt(layerHeight, 10);\n                    }\n\n                    if (newWidth || newHeight) {\n                        newWidth  = newWidth  || width;\n                        newHeight = newHeight || height;\n                        data      = [];\n                        for (x = 0; x < newWidth; x++) {\n                            for (y = 0; y < newHeight; y++) {\n                                if ((x < width) && (y < height)) {\n                                    data[x + y * newWidth] = layer.data[x + y * width];\n                                } else {\n                                    data[x + y * newWidth] = 0;\n                                }\n                            }\n                        }\n                        width  = newWidth;\n                        height = newHeight;\n                    }\n                    \n                    mergeAndFormatProperties(layer.properties, tileDefinition.properties);\n                }\n\n                tileDefinition.properties.width = tWidth * width;\n                tileDefinition.properties.height = tHeight * height;\n                tileDefinition.properties.columns = width;\n                tileDefinition.properties.rows = height;\n                tileDefinition.properties.tileWidth = tWidth;\n                tileDefinition.properties.tileHeight = tHeight;\n                tileDefinition.properties.scaleX = 1;\n                tileDefinition.properties.scaleY = 1;\n                tileDefinition.properties.layerZ = this.layerZ;\n                tileDefinition.properties.left = tileDefinition.properties.x || mapOffsetX;\n                tileDefinition.properties.top = tileDefinition.properties.y || mapOffsetY;\n                tileDefinition.properties.z = tileDefinition.properties.z || this.layerZ;\n\n                if (tilesets.length) {\n                    for (x = 0; x < tilesets.length; x++) {\n                        createFrames(importFrames, x, tilesets[x], 1);\n                    }\n\n                    lastSet = tilesets[tilesets.length - 1];\n                    tileTypes = lastSet.firstgid + lastSet.tilecount;\n                    for (x = -1; x < tileTypes; x++) {\n                        importAnimation['tile' + x] = x;\n                    }\n                }\n                for (x = 0; x < width; x++) {\n                    importCollision[x] = [];\n                    importRender[x] = [];\n                    for (y = 0; y < height; y++) {\n                        index = +data[x + y * width] - 1; // -1 from original src to make it zero-based.\n                        importRender[x][y] = 'tile' + index;\n                        index += 1; // So collision map matches original src indexes. Render (above) should probably be changed at some point as well. DDD 3/30/2016\n                        importCollision[x][y] = index;\n\n                        if (tilesetObjectGroups) {\n                            const transform = entityTransformCheck(index);\n\n                            if (tilesetObjectGroups.has(transform.id)) {\n                                const // These values cause a flipped tile to find x/y by starting on the opposite side of the tile (and subtracting x/y once in the called function).\n                                    offsetX = mapOffsetX + tileWidth * (transform.x > 0 ? x : x + 1),\n                                    offsetY = mapOffsetY + tileHeight * (transform.y > 0 ? y : y + 1);\n                                    \n                                this.setUpEntities(tilesetObjectGroups.get(transform.id), offsetX, offsetY, tileWidth, tileHeight, tilesets, transform, progress);\n                            }\n                        }\n                    }\n                }\n                for (x = 0; x < tileDefinition.components.length; x++) {\n                    if (tileDefinition.components[x].type === 'RenderTiles') {\n                        renderTiles = tileDefinition.components[x];\n                    }\n                    if (tileDefinition.components[x].spriteSheet === 'import') {\n                        tileDefinition.components[x].spriteSheet = importSpriteSheet;\n                    } else if (tileDefinition.components[x].spriteSheet) {\n                        if (typeof tileDefinition.components[x].spriteSheet === 'string' && platypus.game.settings.spriteSheets[tileDefinition.components[x].spriteSheet]) {\n                            tileDefinition.components[x].spriteSheet = platypus.game.settings.spriteSheets[tileDefinition.components[x].spriteSheet];\n                        }\n                        if (!tileDefinition.components[x].spriteSheet.animations) {\n                            tileDefinition.components[x].spriteSheet.animations = importAnimation;\n                        }\n                    }\n                    if (tileDefinition.components[x].collisionMap === 'import') {\n                        tileDefinition.components[x].collisionMap = importCollision;\n                    }\n                    if (tileDefinition.components[x].imageMap === 'import') {\n                        tileDefinition.components[x].imageMap = importRender;\n                    }\n                }\n\n                if ((entityKind === 'render-layer') && (!this.separateTiles) && combineRenderLayer && (combineRenderLayer.tileHeight === tHeight) && (combineRenderLayer.tileWidth === tWidth) && (combineRenderLayer.columns === width) && (combineRenderLayer.rows === height)) {\n                    combineRenderLayer.triggerEvent('add-tiles', renderTiles);\n                    this.updateLoadingProgress(progress);\n                    return combineRenderLayer;\n                } else {\n                    props = {};\n                    if ((entityKind === 'render-layer') && this.spriteSheet) {\n                        if (typeof this.spriteSheet === 'string') {\n                            props.spriteSheet = platypus.game.settings.spriteSheets[this.spriteSheet];\n                        } else {\n                            props.spriteSheet = this.spriteSheet;\n                        }\n                        if (!props.spriteSheet.animations) {\n                            props.spriteSheet.animations = importAnimation;\n                        }\n                    }\n                    return this.owner.addEntity(new _Entity_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"](tileDefinition, {\n                        properties: props\n                    }, this.updateLoadingProgress.bind(this, progress), this.owner));\n                }\n            },\n            \n            convertImageLayer: function (imageLayer) {\n                var asset = null,\n                    i = 0,\n                    dataCells = 0,\n                    imageId = '',\n                    props = imageLayer.properties || {},\n                    repeat = getProperty(props, 'repeat'),\n                    repeatX = getProperty(props, 'repeat-x'),\n                    repeatY = getProperty(props, 'repeat-y'),\n                    tileLayer = {\n                        data: [],\n                        image: '',\n                        height: 1,\n                        name: imageLayer.name,\n                        type: 'tilelayer',\n                        width: 1,\n                        tileheight: 1,\n                        tilewidth: 1,\n                        x: imageLayer.x,\n                        y: imageLayer.y,\n                        properties: props\n                    };\n\n                if (repeat) {\n                    tileLayer.width = +repeat;\n                    tileLayer.height = +repeat;\n                }\n                if (repeatX) {\n                    tileLayer.width = +repeatX;\n                }\n                if (repeatY) {\n                    tileLayer.height = +repeatY;\n                }\n                dataCells = tileLayer.width * tileLayer.height;\n                for (i = 0; i < dataCells; i++) {\n                    tileLayer.data.push(1);\n                }\n\n                asset = this.assetCache.get(imageLayer.name);\n                if (asset) { // Prefer to have name in tiled match image id in game\n                    tileLayer.image = imageLayer.name;\n                    tileLayer.tileheight = asset.height;\n                    tileLayer.tilewidth = asset.width;\n                } else {\n                    imageId = getImageId(imageLayer.image);\n                    asset = this.assetCache.get(imageId);\n                    if (asset) {\n                        platypus.debug.warn('Component TiledLoader: Did not find a spritesheet for \"' + imageLayer.name + '\", so using \"' + imageLayer.image + '\" instead.');\n                        tileLayer.image = imageId;\n                        tileLayer.tileheight = asset.height;\n                        tileLayer.tilewidth = asset.width;\n                    } else {\n                        platypus.debug.warn('Component TiledLoader: Cannot find the \"' + imageLayer.name + '\" sprite sheet. Add it to the list of assets in config.json and give it the id \"' + imageLayer.name + '\".');\n                        tileLayer.image = imageLayer.image;\n                    }\n                }\n\n                tileLayer.tileset = {\n                    \"columns\": 1,\n                    \"image\": tileLayer.image,\n                    \"imageheight\": tileLayer.tileheight,\n                    \"imagewidth\": tileLayer.tilewidth,\n                    \"margin\": 0,\n                    \"name\": imageLayer.name,\n                    \"spacing\": 0,\n                    \"tilecount\": 1,\n                    \"tileheight\": tileLayer.tileheight,\n                    \"tilewidth\": tileLayer.tilewidth,\n                    \"type\": \"tileset\"\n                };\n                \n                return tileLayer;\n            },\n            \n            loadLevel: function (levelData, callback) {\n                var asset = null,\n                    layers = null,\n                    level = null,\n                    height = 0,\n                    i = 0,\n                    imageId = '',\n                    images = null,\n                    layer = null,\n                    layerDefinition = null,\n                    tileset = null,\n                    tilesets = null,\n                    tilesetObjectGroups = _DataMap_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].setUp(),\n                    tileWidth = 0,\n                    tileHeight = 0,\n                    progress = _Data_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp('count', 0, 'progress', 0, 'total', 0),\n                    width = 0,\n                    x = 0,\n                    y = 0;\n                \n                //format level appropriately\n                if (typeof levelData.level === 'string') {\n                    level = platypus.game.settings.levels[levelData.level];\n                } else {\n                    level = levelData.level;\n                }\n                layers = level.layers;\n                tilesets = importTilesetData(level.tilesets);\n                tileWidth = level.tilewidth;\n                tileHeight = level.tileheight;\n\n                createTilesetObjectGroupReference(tilesetObjectGroups, tilesets);\n\n                if (level.properties) {\n                    mergeAndFormatProperties(level.properties, this.owner);\n                }\n                \n                if (this.images) {\n                    images = Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSlice\"])(this.images);\n                } else {\n                    images = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n                }\n                if (images.length === 0) {\n                    for (i = 0; i < tilesets.length; i++) {\n                        tileset = tilesets[i];\n                        asset = this.assetCache.get(tileset.name);\n                        if (asset) { // Prefer to have name in tiled match image id in game\n                            images.push(tileset.name);\n                        } else {\n                            imageId = getImageId(tileset.image);\n                            asset = this.assetCache.get(imageId);\n                            if (asset) {\n                                platypus.debug.warn('Component TiledLoader: Did not find a spritesheet for \"' + tileset.name + '\", so using \"' + tileset.image + '\" instead.');\n                                images.push(imageId);\n                            } else {\n                                platypus.debug.warn('Component TiledLoader: Cannot find the \"' + tileset.name + '\" sprite sheet. Add it to the list of assets in config.json and give it the id \"' + tileset.name + '\".');\n                                images.push(tileset.image);\n                            }\n                        }\n                    }\n                }\n                \n                width = level.width * tileWidth;\n                height = level.height * tileHeight;\n\n                if (this.offsetMap) {\n                    x = getPowerOfTen(width);\n                    y = getPowerOfTen(height);\n                }\n\n                progress.total = i = layers.length;\n\n                this.finishedLoading = finishedLoading.bind(this, level, x, y, width, height, tileWidth, tileHeight, callback);\n\n                for (i = 0; i < layers.length; i++) {\n                    layerDefinition = layers[i];\n                    switch (layerDefinition.type) {\n                    case 'imagelayer':\n                        layer = this.convertImageLayer(layerDefinition);\n                        layer = this.createLayer('image-layer', layer, x, y, layer.tilewidth, layer.tileheight, [layer.tileset], null, images, layer, progress);\n                        break;\n                    case 'objectgroup':\n                        this.setUpEntities(layerDefinition, x, y, tileWidth, tileHeight, tilesets, null, progress);\n                        layer = null;\n                        this.updateLoadingProgress(progress);\n                        break;\n                    case 'tilelayer':\n                        layer = this.setupLayer(layerDefinition, layer, x, y, tileWidth, tileHeight, tilesets, tilesetObjectGroups, images, progress);\n                        break;\n                    default:\n                        platypus.debug.warn('Component TiledLoader: Platypus does not support Tiled layers of type \"' + layerDefinition.type + '\". This layer will not be loaded.');\n                        this.updateLoadingProgress(progress);\n                    }\n                    this.layerZ += this.layerIncrement;\n                }\n\n                tilesetObjectGroups.recycle();\n            },\n            \n            setUpEntities: (function () {\n                const\n                    tBoth = function (point) {\n                        return _Data_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp('x', -point.x, 'y', -point.y);\n                    },\n                    tNone = function (point) {\n                        return _Data_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp('x', point.x, 'y', point.y);\n                    },\n                    tX = function (point) {\n                        return _Data_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp('x', -point.x, 'y', point.y);\n                    },\n                    tY = function (point) {\n                        return _Data_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp('x', point.x, 'y', -point.y);\n                    },\n                    transformPoints = function (points, transformX, transformY) {\n                        const\n                            arr = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(),\n                            reverseCycle = transformX ^ transformY,\n                            transform = transformX ? transformY ? tBoth : tX : transformY ? tY : tNone;\n\n                        if (reverseCycle) {\n                            let i = points.length;\n                            while (i--) {\n                                arr.push(transform(points[i]));\n                            }\n                            arr.unshift(arr.pop()); // so the same point is at the beginning.\n                        } else {\n                            for (let i = 0; i < points.length; i++) {\n                                arr.push(transform(points[i]));\n                            }\n                        }\n\n                        return arr;\n                    },\n                    getPolyShape = function (type, points, transformX, transformY, decomposed) {\n                        const\n                            shape = {\n                                type: type,\n                                points: transformPoints(points, transformX, transformY)\n                            };\n\n                        if (decomposed) {\n                            const decomposedPoints = [];\n                            let p = 0;\n\n                            for (p = 0; p < decomposed.length; p++) {\n                                decomposedPoints.push(transformPoints(decomposed[p], transformX, transformY));\n                            }\n    \n                            shape.decomposedPolygon = decomposedPoints;\n                        }\n\n                        return shape;\n                    };\n\n                return function (layer, mapOffsetX, mapOffsetY, tileWidth, tileHeight, tilesets, transform, progress) {\n                    var clamp = 1000,\n                        widthOffset = 0,\n                        heightOffset = 0,\n                        x = 0,\n                        a = 0,\n                        v = null,\n                        obj = 0,\n                        entityDefinition = null,\n                        entityDefProps = null,\n                        entityPositionX = getProperty(layer.properties, 'entityPositionX') || this.entityPositionX,\n                        entityPositionY = getProperty(layer.properties, 'entityPositionY') || this.entityPositionY,\n                        gid = -1,\n                        smallestX = Infinity,\n                        largestX = -Infinity,\n                        smallestY = Infinity,\n                        largestY = -Infinity,\n                        polyPoints = null,\n                        fallbackWidth = 0,\n                        fallbackHeight = 0,\n                        transformX = transform ? transform.x : 1,\n                        transformY = transform ? transform.y : 1,\n                        len = layer.objects.length;\n    \n                    mapOffsetX += layer.offsetx || 0;\n                    mapOffsetY += layer.offsety || 0;\n\n                    progress.total += len;\n    \n                    for (obj = 0; obj < len; obj++) {\n                        const\n                            entity = layer.objects[obj],\n                            entityData = getEntityData(entity, tilesets);\n                        \n                        if (entityData) {\n                            const\n                                properties = entityData.properties,\n                                entityType = entityData.type,\n                                entityPackage = {\n                                    properties: properties\n                                };\n\n                            gid = entityData.gid;\n                            entityDefinition = platypus.game.settings.entities[entityType];\n                            if (entityDefinition) {\n                                entityDefProps = entityDefinition.properties || null;\n                                entityPackage.type = entityType;\n                            } else {\n                                entityDefProps = null;\n                                entityPackage.id = entityType;\n                            }\n    \n                            if (entity.polygon || entity.polyline) {\n                                //Figuring out the width of the polygon and shifting the origin so it's in the top-left.\n                                smallestX = Infinity;\n                                largestX = -Infinity;\n                                smallestY = Infinity;\n                                largestY = -Infinity;\n    \n                                polyPoints = null;\n                                if (entity.polygon) {\n                                    polyPoints = entity.polygon;\n                                } else if (entity.polyline) {\n                                    polyPoints = entity.polyline;\n                                }\n    \n                                for (x = 0; x < polyPoints.length; x++) {\n                                    if (polyPoints[x].x > largestX) {\n                                        largestX = polyPoints[x].x;\n                                    }\n                                    if (polyPoints[x].x < smallestX) {\n                                        smallestX = polyPoints[x].x;\n                                    }\n                                    if (polyPoints[x].y > largestY) {\n                                        largestY = polyPoints[x].y;\n                                    }\n                                    if (polyPoints[x].y < smallestY) {\n                                        smallestY = polyPoints[x].y;\n                                    }\n                                }\n                                properties.width = largestX - smallestX;\n                                properties.height = largestY - smallestY;\n                                properties.x = entity.x + mapOffsetX;\n                                properties.y = entity.y + mapOffsetY;\n    \n                                widthOffset = 0;\n                                heightOffset = 0;\n    \n                                if (entity.polygon) {\n                                    properties.shape = getPolyShape('polygon', polyPoints, transformX === -1, transformY === -1, properties.decomposedPolygon);\n                                } else if (entity.polyline) {\n                                    properties.shape = getPolyShape('polyline', polyPoints, transformX === -1, transformY === -1, null);\n                                }\n\n                                if (entity.rotation) {\n                                    properties.rotation = entity.rotation;\n                                }\n                            } else {\n                                fallbackWidth = tileWidth;\n                                fallbackHeight = tileHeight;\n                                widthOffset = 0;\n                                heightOffset = 0;\n                                properties.width = entity.width || 0;\n                                properties.height = entity.height || 0;\n    \n                                if (entityDefProps) {\n                                    if (typeof entityDefProps.width === 'number') {\n                                        properties.width = entityDefProps.width;\n                                        widthOffset = fallbackWidth;\n                                    }\n                                    if (typeof entityDefProps.height === 'number') {\n                                        properties.height = entityDefProps.height;\n                                        heightOffset = fallbackHeight;\n                                    }\n                                }\n    \n                                if (!entity.point) {\n                                    if (!properties.width) {\n                                        properties.width = fallbackWidth;\n                                    }\n                                    if (!properties.height) {\n                                        properties.height = fallbackHeight;\n                                    }\n                                    widthOffset = widthOffset || properties.width;\n                                    heightOffset = heightOffset || properties.height;\n                                }\n    \n                                properties.x = entity.x;\n                                properties.y = entity.y;\n    \n                                if (entity.rotation) {\n                                    const\n                                        w = properties.width / 2,\n                                        h = properties.height / 2;\n\n                                    properties.rotation = entity.rotation;\n\n                                    if (w || h) {\n                                        a = ((entity.rotation / 180) % 2) * Math.PI;\n                                        v = _Vector_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].setUp(w, -h).rotate(a);\n                                        properties.x = Math.round((properties.x + v.x - w) * clamp) / clamp;\n                                        properties.y = Math.round((properties.y + v.y + h) * clamp) / clamp;\n                                        v.recycle();\n                                    }\n                                }\n    \n                                if (entityPositionX === 'left') {\n                                    properties.regX = 0;\n                                } else if (entityPositionX === 'center') {\n                                    properties.regX = properties.width / 2;\n                                    properties.x += widthOffset / 2;\n                                } else if (entityPositionX === 'right') {\n                                    properties.regX = properties.width;\n                                    properties.x += widthOffset;\n                                }\n                                properties.x = mapOffsetX + properties.x * transformX;\n    \n                                if (gid === -1) {\n                                    properties.y += properties.height;\n                                }\n                                if (entityPositionY === 'bottom') {\n                                    properties.regY = properties.height;\n                                } else if (entityPositionY === 'center') {\n                                    properties.regY = properties.height / 2;\n                                    properties.y -= heightOffset / 2;\n                                } else if (entityPositionY === 'top') {\n                                    properties.regY = 0;\n                                    properties.y -= heightOffset;\n                                }\n                                properties.y = mapOffsetY + properties.y * transformY;\n    \n                                if (entity.ellipse) {\n                                    properties.shape = {};\n                                    properties.shape.type = 'circle';//'ellipse';\n                                    properties.shape.width = properties.width;\n                                    properties.shape.height = properties.height;\n    \n                                    // Tiled has ellipses, but Platypus only accepts circles. Setting a radius based on the average of width and height in case a non-circular ellipse is imported.\n                                    properties.shape.radius = (properties.width + properties.height) / 4;\n                                } else if (entity.width && entity.height) {\n                                    properties.shape = {};\n                                    properties.shape.type = 'rectangle';\n                                    properties.shape.width = properties.width;\n                                    properties.shape.height = properties.height;\n                                }\n                            }\n    \n                            if (entityDefProps) {\n                                properties.scaleX *= (entityDefProps.scaleX || 1);\n                                properties.scaleY *= (entityDefProps.scaleY || 1);\n                            }\n                            properties.scaleX *= transformX;\n                            properties.scaleY *= transformY;\n                            properties.layerZ = this.layerZ;\n    \n                            //Setting the z value. All values are getting added to the layerZ value.\n                            if (properties.z) {\n                                properties.z += this.layerZ;\n                            } else if (entityDefProps && (typeof entityDefProps.z === 'number')) {\n                                properties.z = this.layerZ + entityDefProps.z;\n                            } else {\n                                properties.z = this.layerZ;\n                            }\n    \n                            if (properties.lazyLoad || (entityDefProps && entityDefProps.lazyLoad)) {\n                                entityPackage.aabb = _AABB_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp(properties.x + properties.width / 2 - properties.regX, properties.y + properties.height / 2 - properties.regY, properties.width || 1, properties.height || 1);\n                                this.lazyLoads.push(entityPackage);\n                                this.updateLoadingProgress(progress);\n                            } else {\n                                const\n                                    createdEntity = this.owner.addEntity(entityPackage, this.updateLoadingProgress.bind(this, progress));\n\n                                if (createdEntity && createdEntity.camera) {\n                                    this.followEntity = {\n                                        entity: createdEntity,\n                                        mode: createdEntity.camera\n                                    }; //used by camera\n                                }\n                            }\n                        } else {\n                            this.updateLoadingProgress(progress);\n                        }\n                    }\n                };\n            }()),\n\n            setupLayer: function (layer, combineRenderLayer, mapOffsetX, mapOffsetY, tileWidth, tileHeight, tilesets, tilesetObjectGroups, images, progress) {\n                var canCombine = false,\n                    specified = getProperty(layer.properties, 'entity'),\n                    entity = specified || 'render-layer', // default\n                    entityDefinition = null,\n                    i = 0;\n                \n                // Need to check whether the entity can be combined for optimization. This combining of tile layers might be a nice addition to the compilation tools so it's not happening here.\n                entityDefinition = platypus.game.settings.entities[entity] || standardEntityLayers[entity];\n                if (entityDefinition) {\n                    i = entityDefinition.components.length;\n                    while (i--) {\n                        if (entityDefinition.components[i].type === \"RenderTiles\") {\n                            canCombine = true;\n                            break;\n                        }\n                    }\n                }\n\n                if (canCombine) {\n                    return this.createLayer(entity, layer, mapOffsetX, mapOffsetY, tileWidth, tileHeight, tilesets, tilesetObjectGroups, images, combineRenderLayer, progress);\n                } else {\n                    this.createLayer(entity, layer, mapOffsetX, mapOffsetY, tileWidth, tileHeight, tilesets, tilesetObjectGroups, images, combineRenderLayer, progress);\n                    return null;\n                }\n            },\n            \n            updateLoadingProgress: function (progress) {\n                progress.count += 1;\n                progress.progress = progress.count / progress.total;\n\n                /**\n                 * As a level is loaded, this event is triggered to show progress.\n                 *\n                 * @event 'level-loading-progress'\n                 * @param message {platypus.Data} Contains progress data.\n                 * @param message.count {Number} The number of loaded entities.\n                 * @param message.progress {Number} A fraction of count / total.\n                 * @param message.total {Number} The total number of entities being loaded by this component.\n                 */\n                this.owner.triggerEvent('level-loading-progress', progress);\n\n                if (progress.count === progress.total) {\n                    progress.recycle();\n                    this.finishedLoading();\n                }\n            },\n\n            destroy: function () {\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.lazyLoads);\n                this.lazyLoads = null;\n            }\n        },\n        \n        getAssetList: function (def, props, defaultProps, data) {\n            var ps = props || {},\n                dps = defaultProps || {},\n                ss     = def.spriteSheet || ps.spriteSheet || dps.spriteSheet,\n                images = def.images || ps.images || dps.images,\n                assets = checkLevel((data && data.level) || def.level || ps.level || dps.level, ss);\n            \n            if (ss) {\n                if (typeof ss === 'string') {\n                    Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"union\"])(assets, platypus.game.settings.spriteSheets[ss].images);\n                } else {\n                    Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"union\"])(assets, ss.images);\n                }\n            }\n            \n            if (images) {\n                Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"union\"])(assets, images);\n            }\n            \n            return assets;\n        }\n    });\n}());\n\n\n\n//# sourceURL=webpack://platypus/./src/components/TiledLoader.js?");

/***/ }),

/***/ "./src/components/Timeline.js":
/*!************************************!*\
  !*** ./src/components/Timeline.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var _Data_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Data.js */ \"./src/Data.js\");\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../factory.js */ \"./src/factory.js\");\n/**\n * Timeline enables the scheduling of events based on a linear timeline\n *\n * @class Timeline\n * @uses platypus.Component\n */\n/* global platypus */\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    var pause = function () {\n            this.active--;\n        },\n        play = function () {\n            this.active++;\n        },\n        timelineTrigger = function (timelineId) {\n            this.timelineInstances.push(this.createTimeStampedTimeline(this.timelines[timelineId]));\n        },\n        updateLogic = function (tick) {\n            var delta = tick.delta,\n                instance = null,\n                instances = this.timelineInstances,\n                i = instances.length;\n            \n            while (i--) {\n                instance = instances[i];\n                if (instance.remove) {\n                    Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSplice\"])(instances, i);\n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(instance.timeline);\n                    instance.recycle();\n                } else if (instance.active) {\n                    if (instance.timeline.length === 0) {\n                        Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSplice\"])(instances, i);\n                        _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(instance.timeline);\n                        instance.recycle();\n                    } else {\n                        this.progressTimeline(instance, delta);\n                    }\n                }\n            }\n        };\n    \n    return Object(_factory_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({\n        \n        id: 'Timeline',\n        \n        properties: {\n            /**\n             * Defines the set of timelines. Triggering the key for one of the events will run the timeline. A timeline can contain three different types integers >= 0, strings, and objects. Integers are interpreted as waits and define\n             * pauses between events. Strings are intepreted as event calls. Objects can contain several parameters: entity, event, message. The entity is the id of the entity that\n             * the event will be fired on. The event can be a string or array. If a string, it will call that event on the entity or owner. If an array, the value will be passed\n             * to the event handling system.\n             *\n             *  \"timelines\": {\n             *      \"sample-timeline-1\": [\n             *          500,\n             *          \"sample-event\",\n             *          {\"event\": \"sample-event\", \"message\": \"sample-message\"},\n             *          {\"entity\": \"entity-id-to-trigger-event-on\", \"event\": \"sample-event\"},\n             *          {\"event\": [\"sample-event\", \"sample-event-2\", {\"event\": \"sample-event-3\", \"message\": \"sample-message\"}]},\n             *      ],\n             *      \"sample-timeline-2\": [\n             *          200,\n             *          \"sample-event\"\n             *      ]\n             * }\n             *\n             * @property timelines\n             * @type Object\n             * @default {}\n             */\n            \"timelines\": {}\n        },\n        \n        initialize: function () {\n            var x = 0;\n            \n            this.timelineInstances = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n            for (x in this.timelines) {\n                if (this.timelines.hasOwnProperty(x)) {\n                    this.addEventListener(x, timelineTrigger.bind(this, x));\n                }\n            }\n        },\n\n        events: {\n            /**\n             * Checks game clock against timelines and triggers events as needed.\n             *\n             * @method 'handle-logic'\n             * @param tick.delta {Number} The length of the tick.\n             */\n            \"handle-logic\": updateLogic,\n\n            /**\n             * Stops all timelines.\n             *\n             * @method 'stop-active-timelines'\n             */\n            \"stop-active-timelines\": function () {\n                var instances = this.timelineInstances,\n                    i = instances.length;\n\n                while (i--) {\n                    instances[i].remove = true;\n                }\n            }\n        },\n        \n        methods: {\n            createTimeStampedTimeline: function (timeline) {\n                var timeStampedTimeline = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(),\n                    x = 0,\n                    timeOffset = 0,\n                    entry = null;\n                \n                for (x = 0; x < timeline.length; x++) {\n                    entry = timeline[x];\n                    if (typeof entry === 'number') {\n                        timeOffset += entry;\n                    } else {\n                        timeStampedTimeline.push(_Data_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp(\n                            \"time\", timeOffset,\n                            \"value\", entry\n                        ));\n                    }\n                }\n                timeStampedTimeline.reverse();\n                return _Data_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp(\n                    \"timeline\", timeStampedTimeline,\n                    \"time\", 0,\n                    \"active\", 1,\n                    \"pause\", pause,\n                    \"play\", play,\n                    \"remove\", false\n                );\n            },\n            progressTimeline: function (instance, delta) {\n                var timeline = instance.timeline,\n                    i = timeline.length,\n                    entry = null,\n                    value = null,\n                    triggerOn = this.owner;\n                \n                instance.time += delta;\n                \n                //Go through the timeline playing events if the time has progressed far enough to trigger them.\n                while (i--) {\n                    entry = timeline[i];\n                    if (entry.time <= instance.time) {\n                        value = entry.value;\n                        if (typeof value === 'string') {\n                            this.owner.triggerEvent(value);\n                        } else {\n                            if (value.entity) {\n                                if (this.owner.getEntityById) {\n                                    triggerOn = this.owner.getEntityById(value.entity);\n                                } else {\n                                    triggerOn = this.owner.parent.getEntityById(value.entity);\n                                }\n                                \n                                if (!triggerOn) {\n                                    platypus.debug.warn('No entity of that id');\n                                    triggerOn = this.owner;\n                                }\n                            }\n                            \n                            if (value.message) {\n                                triggerOn.triggerEvent(value.event, value.message);\n                            } else {\n                                triggerOn.trigger(value.event);\n                            }\n                        }\n                        \n                        entry.recycle();\n                        timeline.pop(); //Remove the entry.\n                        if (!instance.active) {\n                            return; //We bail until the callback.\n                        }\n                    } else {\n                        return;\n                    }\n                    \n                    entry = null;\n                    value = null;\n                    triggerOn = this.owner;\n                }\n            },\n            destroy: function () {\n                var instance = null,\n                    instances = this.timelineInstances,\n                    i = instances.length;\n                \n                while (i--) {\n                    instance = instances[i];\n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(instance.timeline);\n                    instance.recycle();\n                }\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(instances);\n                this.timelineInstances = null;\n            }\n        }\n    });\n}());\n\n//# sourceURL=webpack://platypus/./src/components/Timeline.js?");

/***/ }),

/***/ "./src/components/Tutorial.js":
/*!************************************!*\
  !*** ./src/components/Tutorial.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../factory.js */ \"./src/factory.js\");\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/**\n * Tutorial provides a framework for playing tutorials. It allows the user to define things such as under what conditions tutorials will play, how often they play, and which tutorials have priority.\n *\n * @class Tutorial\n * @uses platypus.Component\n */\n/* global platypus */\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    var entityAdded = function (entity) {\n            var entityType = null;\n                \n            for (entityType in this.watchedEntities) {\n                if (entity.type === entityType) {\n                    this.watchedEntities[entityType].push(entity);\n                }\n            }\n        },\n        entityRemoved = function (entity) {\n            var x = 0,\n                entityType = entity.type;\n\n            for (x = this.watchedEntities[entityType].length - 1; x >= 0; x--) {\n                if (this.watchedEntities[entityType][x] === entity) {\n                    this.watchedEntities[entityType].splice(x, 1);\n                    break;\n                }\n            }\n        },\n        updateLogic = function (tick) {\n            var delta = tick.delta,\n                x = 0,\n                tut = null,\n                toPlay = null,\n                toPlayIndex = -1,\n                keepChecking = false,\n                tutorial = null;\n            \n            for (x = 0; x < this.tutorials.length; x++) {\n                keepChecking = false;\n                tut = this.tutorials[x];\n\n                if (!this.playing && this.theQueue.length === 0) {\n                    keepChecking = true;\n                } else if ((!this.playing && this.theQueue.length > 0) && (tut.priority > this.theQueue[0].priority)) {\n                    keepChecking = true;\n                } else if (this.playing && (this.playing.priority < tut.priority)) {\n                    keepChecking = true;\n                } else if (tut.queue) {\n                    keepChecking = true;\n                }\n\n                if (!keepChecking) {\n                    continue;\n                }\n\n                if (this.checkRequirements(tut.requirements)) {\n                    if (tut.replayDelay && tut.replayDelayTimer > 0) {\n                        tut.replayDelayTimer -= delta;\n                        if (tut.replayDelayTimer > 0) {\n                            continue;\n                        }\n                    }\n                    \n                    if (!toPlay || toPlay.priority < tut.priority) {\n                        //TML - If we only have one item we try to play, then we may prevent certain audio from playing if it's only valid for a single tick.\n                        toPlay = tut;\n                        toPlayIndex = x;\n                    }\n                }\n            }\n\n            if (toPlay) {\n                tutorial = this.tutorials.splice(toPlayIndex, 1)[0];\n                if (this.playing) {\n                    if (tutorial.priority > this.playing.priority) {\n                        this.owner.triggerEvent('stop-audio');\n                        this.play(tutorial);\n                    } else {\n                        this.queue(tutorial);\n                    }\n                } else if (this.theQueue.length > 0) {\n                    if (tutorial.priority > this.theQueue[0].priority) {\n                        this.play(tutorial);\n                    } else {\n                        this.play(this.theQueue.splice(0, 1)[0]);\n                        this.queue(tutorial);\n                    }\n                } else {\n                    this.play(tutorial);\n                }\n            } else if (!this.playing && this.theQueue.length > 0) {\n                this.play(this.theQueue.splice(0, 1)[0]);\n            }\n        };\n\n    return Object(_factory_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        \n        id: 'Tutorial',\n        \n        properties: {\n            \n            /* An array of tutorial definition objects. These objects define what events will be called by the tutorial, the priority of the tutorial, how often and how many times it will fire, the required conditions for it to fire, and more.\n             *\n             * \"tutorialDefs\": [\n             *      {\n             *          \"events\": [\"example-vo-event\"],         //An Array of Strings. Defines the events to fire when all the conditions for this tutorial are met. If there are multiple events, one is chosen at random. All events in the array will play before any repeat.\n             *          \"priority\": 5,                          //The priorioty of the tutorial. Higher numbered tutorials interrupt lower numbered. Default: 0.\n             *          \"queue\": true,                          //Will the tutorial queue up if played while another tutorial is playing? Default: false.\n             *          \"timesToReplay\": 3,                     //The number of times a tutorial will replay. Set to 0 to make a tutorial play only once. Default: Infinity.\n             *          \"replayDelay\": 10000,                   //While the conditions are met, the tutorial will replay at this interval in milliseconds. If set to null, it will not repeat. Default: null.\n             *          \"level\": \"example-level\",               //Tutorial will only play when this level is the currently loaded level.\n             *          \"requirements\": {                       //The requirements is a collection of entities types that are watched by the tutorial to determine if the conditions to play this tutorial are true.\n             *              \"example-entity-type\": [\"example-entity-state\"]     //The requirements is a set of key-value pairs. The keys are entity types that the tutorial will watch. The values are arrays of states of that entity type which must be true for the tutorial to play.\n             *          }\n             *      }\n             * ]\n             *\n             * @property tutorialDefs\n             * @type Array [Object]\n             * @default []\n             */\n            \"tutorialDefs\": []\n        },\n         \n        initialize: function () {\n            var x = 0,\n                entityType = null,\n                tutDef = null,\n                tutorial = null;\n                \n            this.playing = null;\n            this.theQueue = [];\n            this.watchedEntities = {};\n            this.tutorials = [];\n\n                \n            for (x = 0; x < this.tutorialDefs.length; x++) {\n                tutDef = this.tutorialDefs[x];\n                tutorial = {};\n                if (!tutDef.events) {\n                    platypus.debug.warn(\"Tutorial definition lacks events.\");\n                    continue;\n                }\n                tutorial.events = Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"greenSlice\"])(tutDef.events);\n                tutorial.originalEvents = Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"greenSlice\"])(tutDef.events);\n                tutorial.priority = tutDef.priority || 0;\n                tutorial.queue = tutDef.queue || false;\n                tutorial.timesToReplay = (typeof tutDef.timesToReplay === 'number') ? tutDef.timesToReplay : Infinity;\n                tutorial.replayDelay = tutDef.replayDelay || null;\n                tutorial.replayDelayTimer = tutorial.replayDelay;\n                tutorial.level = tutDef.level;\n                tutorial.requirements = {};\n                for (entityType in tutDef.requirements) {\n                    if (tutDef.requirements.hasOwnProperty(entityType)) {\n                        tutorial.requirements[entityType] = Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"greenSlice\"])(tutDef.requirements[entityType]);\n                        if (!this.watchedEntities[entityType]) {\n                            this.watchedEntities[entityType] = [];\n                        }\n                    }\n                }\n                this.tutorials.push(tutorial);\n            }\n            \n        },\n\n        events: {// These are messages that this component listens for\n            \n            /**\n             * Checks added entity to determine if it is one of the conditions for one of the tutorials. If so, we track it.\n             *\n             * @method 'child-entity-added'\n             * @param entity {Object} The added entity.\n             */\n            \"child-entity-added\": entityAdded,\n\n            /**\n             * Checks added entity to determine if it is one of the conditions for one of the tutorials. If so, we track it.\n             *\n             * @method 'peer-entity-added'\n             * @param entity {Object} The added entity.\n             */\n            \"peer-entity-added\": entityAdded,\n\n            /**\n             * Removes entities from the watch list when they are destroyed.\n             *\n             * @method 'child-entity-removed'\n             * @param entity {Object} The removed entity.\n             */\n            \"child-entity-removed\": entityRemoved,\n\n            /**\n             * Removes entities from the watch list when they are destroyed.\n             *\n             * @method 'peer-entity-removed'\n             * @param entity {Object} The removed entity.\n             */\n            \"peer-entity-removed\": entityRemoved,\n            \n            /**\n             * Checks tutorials to determine if they should play.\n             *\n             * @method 'handle-logic'\n             * @param tick.delta {Number} The length of the tick.\n             */\n            \"handle-logic\": updateLogic,\n\n            /**\n             * Fired when audioVO finishes. Clears the playing tutorial returning it to the internal list of tutorials if it will be played again.\n             *\n             * @method 'sequence-complete'\n             */\n            \"sequence-complete\": function () {\n                if (this.playing.timesToReplay >= 0) {\n                    this.tutorials.push(this.playing);\n                }\n                this.playing = null;\n            }\n        },\n        \n        methods: {// These are internal methods that are invoked by this component.\n            play: function (tutorial) {\n                var toCall = null;\n\n                this.playing = tutorial;\n                if (this.playing.events.length === 0) {\n                    this.playing.events = Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"greenSlice\"])(this.playing.originalEvents);\n                }\n\n                toCall = this.playing.events.splice(Math.floor(Math.random() * this.playing.events.length), 1)[0];\n\n                this.owner.triggerEvent(toCall);\n\n                tutorial.timesToReplay -= 1;\n                tutorial.replayDelayTimer = tutorial.replayDelay;\n            },\n            queue: function (tutorial) {\n                var x = 0,\n                    added = false;\n\n                for (x = 0; x < this.theQueue.length; x++) {\n                    if (this.theQueue[x].priority < tutorial.priority) {\n                        this.theQueue.splice(x, 0, tutorial);\n                        added = true;\n                        break;\n                    }\n                }\n                \n                if (!added) {\n                    this.theQueue.push(tutorial);\n                }\n            },\n            checkRequirements: function (requirements) {\n                var x = 0,\n                    y = 0,\n                    entityType = null,\n                    states = null,\n                    anEntity = null,\n                    metRequirement = true;\n\n                for (entityType in requirements) { //Going through the types of entities\n                    if (requirements.hasOwnProperty(entityType)) {\n                        states = requirements[entityType];\n                        for (y = this.watchedEntities[entityType].length - 1; y >= 0; y--) {  //Going through the instances of those entities\n                            anEntity = this.watchedEntities[entityType][y];\n                            metRequirement = true;\n                            for (x = 0; x < states.length; x++) {   //Going through the required states of an entity instance\n                                if (!anEntity.state.get(states[x])) {\n                                    metRequirement = false;\n                                    break;\n                                }\n                            }\n                            if (metRequirement) {\n                                break;\n                            }\n                        }\n                        if (!metRequirement) {\n                            return false;\n                        }\n                    }\n                }\n                return true;\n            },\n            destroy: function () {\n                this.watchedEntities = null;\n                this.theQueue = null;\n                this.playing = null;\n                this.tutorials = null;\n            }\n        }\n    });\n}());\n\n\n//# sourceURL=webpack://platypus/./src/components/Tutorial.js?");

/***/ }),

/***/ "./src/components/Tween.js":
/*!*********************************!*\
  !*** ./src/components/Tween.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Data_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Data.js */ \"./src/Data.js\");\n/* harmony import */ var _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tweenjs/tween.js */ \"@tweenjs/tween.js\");\n/* harmony import */ var _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../factory.js */ \"./src/factory.js\");\n/**\n * This component takes a list of tween definitions and plays them as needed. This component requires TweenJS.\n *\n * @namespace platypus.components\n * @class Tween\n * @uses platypus.Component\n */\n/* global platypus */\n\n\n\n\n\nconst\n    Easing = _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_1___default.a.Easing,\n    Group = _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_1___default.a.Group,\n    Interpolation = _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_1___default.a.Interpolation,\n    Tween = _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_1___default.a.Tween,\n    eases = (function () {\n        const easing = {};\n\n        for (const key in Easing) {\n            if (Easing.hasOwnProperty(key)) {\n                for (const type in Easing[key]) {\n                    if (Easing[key].hasOwnProperty(type)) {\n                        easing[key + '.' + type] = Easing[key][type];\n                    }\n                }\n            }\n        }\n\n        return easing;\n    }()),\n    trigger = function () {\n        this.trigger.apply(this, arguments);\n    };\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Object(_factory_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])({\n    id: 'Tween',\n\n    properties: {\n        /**\n         * Required. A key/value list of events and an array or object representing the tween they should trigger.\n         *\n         *      {\n         *          \"begin-flying\": { // When \"begin-flying\" is triggered on this entity, the following tween begins. Tween definitions adhere to a similar structure outlined by the [TweenJS documentation](https://github.com/tweenjs/tween.js/blob/master/docs/user_guide.md).\n         *              \"target\": \"entityId\", // This defaults to the entity that this component is on, but can be the id of any entity in this layer.\n         *              \"to\": { // Specifies the values to change and what they should tween to.\n         *                  \"scaleY\": 1,\n         *                  \"y\": [400, 450, 425]\n         *              },\n         *              \"time\": 1000, // Time in MS to make transition.\n         *              \"easing\": \"Quadratic.In\", Easing function to use.\n         *              \"onUpdate\": \"flying\", // Event to trigger while transition is running.\n         *              \"onStart\": \"wave\", // Event to trigger when tween begins (after delay).\n         *              \"onStop\": \"whoa\", // Event to trigger when tween is stopped (not completed normally).\n         *              \"onComplete\": \"done\", // Event to trigger when tween is complete.\n         *              \"onRepeat\": \"going-again\", // Event to trigger when tween is beginning again.\n         *              \"chain\": \"stop-flying\", // Specifies a tween to use next.\n         *              \"repeat\": 0, // Sets how many times to repeat this tween once it completes.\n         *              \"yoyo\": false, // If this tween repeats, yoyo makes it transition back-and-forth.\n         *              \"delay\": 500, // Time in MS to delay before starting transition.\n         *              \"repeatDelay\": 0, // Time in MS that the transition should wait between repeats if it shouldn't be the `delay` value.\n         *              \"interpolation\": \"Linear\" // Interpolation method to use for an array of values.\n         *          },\n         *\n         *          \"stop-flying\": [{ // May also chain tweens by specifying an array.\n         *              \"to\": {\"y\": 100},\n         *              \"time\": 250\n         *          }, {\n         *              \"to\": {\"y\": 0},\n         *              \"time\": 250\n         *          }]\n         *      }\n         *\n         * @property events\n         * @type Object\n         * @default null\n         */\n        events: null\n    },\n    \n    initialize: function () {\n        var event = '',\n            events = this.events;\n\n        this.group = new Group();\n\n        this.waitingToChain = _Data_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp();\n        this.tweens = _Data_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp();\n\n        this.time = 0;\n        \n        if (events) {\n            for (event in events) {\n                if (events.hasOwnProperty(event)) {\n                    const tween = this.tweens[event] = this.createTweens(events[event]);\n                    this.addEventListener(event, this.runTween.bind(this, event));\n\n                    if (this.waitingToChain[event]) {\n                        const waits = this.waitingToChain[event];\n\n                        for (let i = 0; i < waits.length; i++) {\n                            waits[i].chain(tween);\n                        }\n                        _utils_array_js__WEBPACK_IMPORTED_MODULE_2__[\"arrayCache\"].recycle(waits);\n                        delete this.waitingToChain[event];\n                    }\n                }\n            }\n        }\n    },\n\n    events: {\n        /**\n         * Trigger this event to play a tween using the same spec used for a tween on this component's `events` property.\n         *\n         * @method 'tween'\n         * @param {Object|Array} tween\n         */\n        'tween': function (tween) {\n            this.runTween(tween);\n        },\n\n        /**\n         * This component listens for this event to manage tween playback.\n         *\n         * @method 'handle-logic'\n         * @param {Number} tick.delta\n         */\n        'handle-logic': function (tick) {\n            this.time += tick.delta;\n            this.group.update(this.time);\n        },\n\n        /**\n         * This event stops all running tweens on this component.\n         *\n         * @method 'stop-tween'\n         */\n        'stop-tween': function () {\n            this.group.removeAll();\n        }\n    },\n\n    methods: {\n        createTween: function (tweenDefinition, chainable) {\n            const owner = this.owner,\n                entity = tweenDefinition.target ? (typeof tweenDefinition.target === 'string' ? owner.parent.getEntityById(tweenDefinition.target) : tweenDefinition.target) : owner;\n\n            if (!entity) {\n                platypus.debug.warn('Component Tween: Could not find entity as specified by `target` - ' + tweenDefinition.target);\n                return null;\n            } else if (!tweenDefinition.to || !tweenDefinition.time) {\n                platypus.debug.warn('Component Tween: Both `time` and `to` must be specified to create tween.');\n                return null;\n            } else {\n                const tween = new Tween(entity, this.group);\n\n                tween.to(tweenDefinition.to, tweenDefinition.time);\n\n                if (tweenDefinition.onUpdate) {\n                    tween.onUpdate((typeof tweenDefinition.onUpdate !== 'function') ? trigger.bind(owner, tweenDefinition.onUpdate) : tweenDefinition.onUpdate);\n                }\n                if (tweenDefinition.onStart) {\n                    tween.onStart((typeof tweenDefinition.onStart !== 'function') ? trigger.bind(owner, tweenDefinition.onStart) : tweenDefinition.onStart);\n                }\n                if (tweenDefinition.onStop) {\n                    tween.onStop((typeof tweenDefinition.onStop !== 'function') ? trigger.bind(owner, tweenDefinition.onStop) : tweenDefinition.onStop);\n                }\n                if (tweenDefinition.onComplete) {\n                    tween.onComplete((typeof tweenDefinition.onComplete !== 'function') ? trigger.bind(owner, tweenDefinition.onComplete) : tweenDefinition.onComplete);\n                }\n                if (tweenDefinition.onRepeat) {\n                    tween.onRepeat((typeof tweenDefinition.onRepeat !== 'function') ? trigger.bind(owner, tweenDefinition.onRepeat) : tweenDefinition.onRepeat);\n                }\n\n                if (tweenDefinition.chain) {\n                    if (!chainable) {\n                        platypus.debug.warn('Component Tween: ignoring `chain` on tween since it is part of an array of tweens.');\n                    } else if (typeof tweenDefinition.chain === 'string') {\n                        if (this.tweens[tweenDefinition.chain]) {\n                            tween.chain(this.tweens[tweenDefinition.chain]);\n                        } else {\n                            if (!this.waitingToChain[tweenDefinition.chain]) {\n                                this.waitingToChain[tweenDefinition.chain] = _utils_array_js__WEBPACK_IMPORTED_MODULE_2__[\"arrayCache\"].setUp();\n                            }\n                            this.waitingToChain[tweenDefinition.chain].push(tween);\n                        }\n                    } else {\n                        tween.chain(tweenDefinition.chain);\n                    }\n                }\n\n                if (tweenDefinition.repeat) {\n                    tween.repeat(tweenDefinition.repeat);\n                }\n                if (tweenDefinition.yoyo) {\n                    tween.yoyo();\n                }\n                if (tweenDefinition.delay) {\n                    tween.delay(tweenDefinition.delay);\n                }\n                if (tweenDefinition.repeatDelay) {\n                    tween.repeatDelay(tweenDefinition.repeatDelay);\n                }\n                \n                if (tweenDefinition.interpolation) {\n                    if (typeof tweenDefinition.interpolation === 'function') {\n                        tween.interpolation(tweenDefinition.interpolation);\n                    } else if (Interpolation[tweenDefinition.interpolation]) {\n                        tween.interpolation(Interpolation[tweenDefinition.interpolation]);\n                    } else {\n                        platypus.debug.warn('Component Tween: \"' + tweenDefinition.interpolation + '\" is not a valid interpolation value; must be \"Linear\", \"Bezier\", or \"CatmullRom\".');\n                    }\n                }\n           \n                if (tweenDefinition.easing) {\n                    if (typeof tweenDefinition.easing === 'function') {\n                        tween.easing(tweenDefinition.easing);\n                    } else if (eases[tweenDefinition.easing]) {\n                        tween.easing(eases[tweenDefinition.easing]);\n                    } else {\n                        let str = '\".',\n                            join = '\", or \"';\n\n                        for (const key in eases) {\n                            if (eases.hasOwnProperty(key)) {\n                                str = join + key + str;\n                                join = '\", \"';\n                            }\n                        }\n                        platypus.debug.warn('Component Tween: \"' + tweenDefinition.easing + '\" is not a valid easing value; must be ' + str.substring(3));\n                    }\n                }\n\n                return tween;\n            }\n        },\n\n        createTweens: function (tween) {\n            if (Array.isArray(tween)) {\n                let i = tween.length,\n                    lastTween = null;\n\n                while (i--) {\n                    const newTween = this.createTween(tween[i], !lastTween);\n\n                    if (lastTween) {\n                        newTween.chain(lastTween);\n                    }\n                    lastTween = newTween;\n                }\n\n                return lastTween;\n            } else {\n                return this.createTween(tween, true);\n            }\n        },\n\n        destroy: function () {\n            this.group.removeAll();\n        },\n\n        runTween: function (tweenDefinition) {\n            var tween = typeof tweenDefinition === 'string' ? this.tweens[tweenDefinition] : this.createTweens(tweenDefinition);\n\n            if (tween) {\n                tween.start(this.time);\n            } else {\n                platypus.debug.warn('Component Tween: Unable to run requested tween.', tweenDefinition);\n            }\n        }\n    }\n}));\n\n\n//# sourceURL=webpack://platypus/./src/components/Tween.js?");

/***/ }),

/***/ "./src/components/VoiceOver.js":
/*!*************************************!*\
  !*** ./src/components/VoiceOver.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var _Async_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Async.js */ \"./src/Async.js\");\n/* harmony import */ var _AudioVO_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AudioVO.js */ \"./src/components/AudioVO.js\");\n/* harmony import */ var _RenderSprite_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./RenderSprite.js */ \"./src/components/RenderSprite.js\");\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../factory.js */ \"./src/factory.js\");\n/**\n * This component uses its definition to load an AudioVO component and a RenderSprite component. These work in an interconnected way to render animations corresponding to one or more audio tracks.\n *\n * In addition to its own properties, this component also accepts all properties accepted by [RenderSprite](platypus.components.RenderSprite.html) and [AudioVO](platypus.components.AudioVO.html) and passes them along when it creates those components.\n *\n * @namespace platypus.components\n * @class VoiceOver\n * @uses platypus.Component\n * @uses platypus.AudioVO\n * @uses platypus.RenderSprite\n */\n/* global platypus */\n\n\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    var getEventName = function (msg, VO) {\n            if (VO === ' ') {\n                return msg + 'default';\n            } else {\n                return msg + VO;\n            }\n        },\n        componentInit = function (Component, definition, callback) {\n            this.owner.addComponent(new Component(this.owner, definition, callback));\n        },\n        createAudioDefinition = function (sound, events, message, frameLength) {\n            var i          = 0,\n                key        = '',\n                definition = {},\n                time       = 0,\n                lastFrame  = '',\n                thisFrame  = '',\n                voice = sound.voice,\n                mouthCues = sound.mouthCues;\n\n            if (typeof sound === 'string') {\n                definition.sound = sound;\n                definition.events = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n            } else if (typeof sound.sound === 'string') {\n                definition.sound = sound.sound;\n                if (sound.events) {\n                    definition.events = Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSlice\"])(sound.events);\n                } else {\n                    definition.events = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n                }\n            } else {\n                for (key in sound.sound) {\n                    if (sound.sound.hasOwnProperty(key)) {\n                        definition[key] = sound.sound[key];\n                    }\n                }\n\n                if (definition.events) {\n                    definition.events = Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSlice\"])(definition.events);\n                } else {\n                    definition.events = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n                }\n            }\n\n            if (!voice && !mouthCues && platypus.game.settings.mouthCues) {\n                mouthCues = platypus.game.settings.mouthCues[definition.sound.substring(definition.sound.lastIndexOf('/') + 1)];\n            }\n\n            if (voice) {\n                voice += ' ';\n\n                for (i = 0; i < voice.length; i++) {\n                    thisFrame = voice[i];\n                    if (thisFrame !== lastFrame) {\n                        lastFrame = thisFrame;\n                        definition.events.push({\n                            \"time\": time,\n                            \"event\": getEventName(message, thisFrame)\n                        });\n                    }\n                    time += frameLength;\n                }\n            } else if (mouthCues) {\n                for (i = 0; i < mouthCues.length; i++) {\n                    thisFrame = mouthCues[i];\n                    definition.events.push({\n                        \"time\": thisFrame.start * 1000,\n                        \"event\": getEventName(message, thisFrame.value)\n                    });\n                    time += frameLength;\n                }\n            }\n\n            return definition;\n        },\n        createVO = function (sound, events, message, frameLength) {\n            var i = 0,\n                definitions = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n\n            if (!events[' ']) {\n                events[' '] = events.default;\n            }\n\n            if (Array.isArray(sound)) {\n                for (i = 0; i < sound.length; i++) {\n                    if (typeof sound[i] === 'number') {\n                        definitions.push(sound[i]);\n                    } else {\n                        definitions.push(createAudioDefinition(sound[i], events, message, frameLength));\n                    }\n                }\n                return definitions;\n            } else {\n                return createAudioDefinition(sound, events, message, frameLength);\n            }\n        };\n\n    return Object(_factory_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])({\n        id: 'VoiceOver',\n        \n        properties: {\n            /**\n             * Sets the pairing between letters in the voice-over strings and the animation frame to play.\n             *\n             *       \"animationMap\": {\n             *         \"default\": \"mouth-closed\"\n             *         // Required. Specifies animation of default position.\n             *\n             *         \"w\": \"mouth-o\",\n             *         \"a\": \"mouth-aah\",\n             *         \"t\": \"mouth-t\"\n             *         // Optional. Also list single characters that should map to a given voice-over animation frame.\n             *       }\n             *\n             * @property animationMap\n             * @type Object\n             * @default: {\"default\": \"default\"}\n             */\n            animationMap: {\"default\": \"default\"},\n\n            /**\n             * Specifies the type of component to add to handle VO lip-sync animation.\n             *\n             * @property renderComponent\n             * @type String\n             * @default 'renderSprite'\n             */\n            renderComponent: '',\n\n            /**\n             * Specifies how long a described voice-over frame should last in milliseconds.\n             *\n             * @property frameLength\n             * @type Number\n             * @default 100\n             */\n            frameLength: 100,\n\n            /**\n             * Specifies the prefix that messages between the render and Audio components should use. This will cause the audio to trigger events like \"i-say-w\" and \"i-say-a\" (characters listed in the animationMap), that the RenderSprite uses to show the proper frame.\n             *\n             * @property messagePrefix\n             * @type String\n             * @default \"\"\n             */\n            messagePrefix: \"\",\n\n            /**\n             * This maps events to audio clips and voice over strings.\n             *\n             *      \"voiceOverMap\": {\n             *          \"message-triggered\": [{\n             *              \"sound\": \"audio-id\",\n             *              // Required. This is the audio clip to play when \"message-triggered\" is triggered. It may be a string as shown or an object of key/value pairs as described in an [[audio]] component definition.\n             *              \"voice\": \"waat\"\n             *              // Optional. This string defines the voice-over sequence according to the frames defined by animationMap. Each character lasts the length specified by \"frameLength\" above. If not specified, voice will be the default frame.\n             *          }]\n             *      }\n             *\n             * @property voiceOverMap\n             * @type Object\n             * @default {}\n             */\n            voiceOverMap: {}\n        },\n\n        initialize: function (definition, callback) {\n            var i = '',\n                componentInits = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(),\n                audioDefinition     = {\n                    audioMap: {},\n                    aliases: definition.aliases\n                },\n                animationDefinition = {\n                    acceptInput: definition.acceptInput,\n                    aliases: definition.aliases,\n                    animation: definition.animation,\n                    animationMap: {},\n                    eventBased: true, // VO triggers events for changing lip-sync frames.\n                    flip: definition.flip,\n                    hidden: definition.hidden,\n                    interactive: definition.interactive,\n                    mask: definition.mask,\n                    mirror: definition.mirror,\n                    offsetZ: definition.offsetZ,\n                    regX: definition.regX,\n                    regY: definition.regY,\n                    restart: definition.restart,\n                    scaleX: definition.scaleX,\n                    scaleY: definition.scaleY,\n                    spriteSheet: definition.spriteSheet,\n                    stateBased: definition.stateBased || false\n                };\n            \n            if (this.messagePrefix) {\n                this.message = this.messagePrefix + '-';\n            } else {\n                this.message = '';\n            }\n            \n            for (i in this.animationMap) {\n                if (this.animationMap.hasOwnProperty(i)) {\n                    animationDefinition.animationMap[getEventName(this.message, i)] = this.animationMap[i];\n                }\n            }\n            animationDefinition.animationMap.default = this.animationMap.default;\n            if (this.renderComponent) {\n                componentInits.push(componentInit.bind(this, platypus.components[this.renderComponent], animationDefinition));\n            } else {\n                componentInits.push(componentInit.bind(this, _RenderSprite_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"], animationDefinition));\n            }\n\n            for (i in this.voiceOverMap) {\n                if (this.voiceOverMap.hasOwnProperty(i)) {\n                    audioDefinition.audioMap[i] = createVO(this.voiceOverMap[i], this.animationMap, this.message, this.frameLength);\n                }\n            }\n            componentInits.push(componentInit.bind(this, _AudioVO_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"], audioDefinition));\n\n            _Async_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp(componentInits, callback);\n\n            _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(componentInits);\n\n            return true;\n        },\n\n        events: {\n            /**\n             * On receiving this message, this component removes itself from the entity. (It creates the [[RenderSprite]] and [[AudioVO]] components in its constructor.)\n             *\n             * @method 'load'\n             */\n            \"load\": function () {\n                this.owner.removeComponent(this);\n            }\n        },\n        \n        getAssetList: function (component, props, defaultProps) {\n            var ss = component.spriteSheet || props.spriteSheet || (defaultProps && defaultProps.spriteSheet);\n            \n            if (typeof ss === 'string') {\n                return Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSlice\"])(platypus.game.settings.spriteSheets[ss].images);\n            } else if (ss) {\n                return Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSlice\"])(ss.images);\n            } else {\n                return _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n            }\n        }\n    });\n}());\n\n\n//# sourceURL=webpack://platypus/./src/components/VoiceOver.js?");

/***/ }),

/***/ "./src/components/XHR.js":
/*!*******************************!*\
  !*** ./src/components/XHR.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../factory.js */ \"./src/factory.js\");\n/**\n * This component provides component-based XHR communication with a server.\n *\n * @namespace platypus.components\n * @class XHR\n * @uses platypus.Component\n */\n/* global window */\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    var XMLHttpRequest = window.XMLHttpRequest;\n\n    return Object(_factory_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        id: 'XHR',\n        \n        properties: {\n            /**\n             * Sets the XHR method to use.\n             *\n             * @property method\n             * @type String\n             * @default \"GET\"\n             */\n            method: \"GET\",\n            \n            /**\n             * Sets the path to connect to the server.\n             *\n             * @property path\n             * @type String\n             * @default \"\"\n             */\n            path: \"\",\n            \n            /**\n             * Sets the XHR response type.\n             *\n             * @property responseType\n             * @type String\n             * @default \"text\"\n             */\n            responseType: \"text\",\n            \n            /**\n             * Whether cookies should be retained on cross-domain calls.\n             *\n             * @property withCredentials\n             * @type boolean\n             * @default false\n             */\n            withCredentials: false\n        },\n        \n        initialize: function (definition) {\n            this.setProperties(definition);\n        },\n\n        events: {// These are messages that this component listens for\n            /**\n             * On receiving this message, this component makes a request from the server using the provided information. Note that properties set here will reset the properties set by this component's JSON definition.\n             *\n             * @method 'request'\n             * @param message {Object}\n             * @param message.method {String} XHR method to use: must be \"GET\" or \"POST\".\n             * @param message.path {String} The path to the server resource.\n             * @param [message.responseType=\"text\"] {String} Response type expected.\n             * @param [message.data] {Object} An object of string key/value pairs to be transmitted to the server.\n             * @param message.onload {Function} A function that should be run on receiving a response from the server. This defaults to triggering a \"response\" message containing the responseText value.\n             */\n            \"request\": function (resp) {\n                this.setProperties(resp);\n                \n                if (this.method === \"GET\") {\n                    this.get();\n                } else if (this.method === \"POST\") {\n                    this.post();\n                } else {\n                    throw \"Method must be GET or POST\";\n                }\n            }\n        },\n        \n        methods: {// These are methods that are called on the component\n            setProperties: function (properties) {\n                var key     = '',\n                    divider = '',\n                    props   = properties || this;\n                \n                this.method       = props.method       || this.method       || \"GET\";\n                this.path         = props.path         || this.path         || null;\n                this.responseType = props.responseType || this.responseType || \"text\";\n                this.withCredentials = props.withCredentials || this.withCredentials || false;\n                \n                if ((props !== this) && props.data) {\n                    this.data = '';\n                    for (key in props.data) {\n                        if (props.data.hasOwnProperty(key)) {\n                            this.data += divider + key + '=' + props.data[key];\n                            divider = '&';\n                        }\n                    }\n                } else {\n                    this.data = '';\n                }\n                \n                this.onload = props.onload || this.onload || function () {\n                    if (this.status === 200) {\n                        /**\n                         * This message is triggered on receiving a response from the server (if \"onload\" is not set by the original \"request\" message).\n                         *\n                         * @event 'response'\n                         * @param message {String} The message contains the responseText returned by the server.\n                         */\n                        this.owner.triggerEvent('response', this.responseText);\n                    }\n                }.bind(this);\n            },\n            get: function () {\n                var xhr  = new XMLHttpRequest(),\n                    path = this.path;\n                \n                if (this.data) {\n                    path += '?' + this.data;\n                }\n                \n                xhr.open(this.method, path, true);\n                xhr.withCredentials = this.withCredentials;\n                xhr.responseType = this.responseType;\n                xhr.onload = this.onload;\n                xhr.send();\n            },\n            post: function () {\n                var xhr = new XMLHttpRequest();\n                \n                xhr.open(this.method, this.path, true);\n                xhr.withCredentials = this.withCredentials;\n                xhr.responseType = this.responseType;\n                xhr.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\");\n                xhr.onload = this.onload;\n                xhr.send(this.data);\n            }\n        }\n    });\n}());\n\n\n//# sourceURL=webpack://platypus/./src/components/XHR.js?");

/***/ }),

/***/ "./src/config/development.js":
/*!***********************************!*\
  !*** ./src/config/development.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* global module, require */\nconst pkg = __webpack_require__(/*! ../../package.json */ \"./package.json\");\n\nmodule.exports = {\n    dev: true,\n    buildDate: new Date().toGMTString(),\n    version: pkg.version + '-dev'\n};\n\n//# sourceURL=webpack://platypus/./src/config/development.js?");

/***/ }),

/***/ "./src/factory.js":
/*!************************!*\
  !*** ./src/factory.js ***!
  \************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var _Component_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Component.js */ \"./src/Component.js\");\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! config */ \"./src/config/development.js\");\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(config__WEBPACK_IMPORTED_MODULE_2__);\n/**\n * The component factory takes in component definitions and creates component classes that can be used to create components by entities.  It adds properties and methods that are common to all components so that component definitions can focus on unique properties and methods.\n *\n * To create an extended component class, use the following syntax:\n *\n *      platypus.createComponentClass(componentDefinition, prototype);\n *\n *  * `componentDefinition` is list of key/value pairs that describe the component's behavior.\n *  * `prototype` is an optional prototype that this component extends.\n * See ComponentExample.js for an example componentDefinition that can be sent into this component class factory.\n *\n */\n/* global platypus */\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    var debug = config__WEBPACK_IMPORTED_MODULE_2___default.a.dev,\n        priority = 0,\n        doNothing = function () {},\n        setupProperty = function (property, component, owner) {\n            Object.defineProperty(component, property, {\n                get: function () {\n                    return owner[property];\n                },\n                set: function (value) {\n                    owner[property] = value;\n                },\n                enumerable: true\n            });\n        };\n        \n    return function (componentDefinition) {\n        var func  = null,\n            proto = null;\n        \n        class NewComponent extends _Component_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\n            constructor (owner, definition, callback) {\n                var prop  = '',\n                    func  = '',\n                    name  = '',\n                    alias = '';\n                    \n                super(componentDefinition.id, owner);\n\n                // Set up properties, prioritizing component settings, entity settings, and finally defaults.\n                if (componentDefinition.properties) {\n                    for (prop in componentDefinition.properties) {\n                        if (componentDefinition.properties.hasOwnProperty(prop)) {\n                            if (definition && (typeof definition[prop] !== 'undefined')) {\n                                this[prop] = definition[prop];\n                            } else if (typeof this.owner[prop] !== 'undefined') {\n                                this[prop] = this.owner[prop];\n                            } else {\n                                this[prop] = componentDefinition.properties[prop];\n                            }\n                        }\n                    }\n                }\n\n                // These component properties are equivalent with `entity.property`\n                if (componentDefinition.publicProperties) {\n                    for (prop in componentDefinition.publicProperties) {\n                        if (componentDefinition.publicProperties.hasOwnProperty(prop)) {\n                            setupProperty(prop, this, owner);\n                            if (definition && (typeof definition[prop] !== 'undefined')) {\n                                this[prop] = definition[prop];\n                            } else if (typeof this.owner[prop] !== 'undefined') {\n                                this[prop] = this.owner[prop];\n                            } else {\n                                this[prop] = componentDefinition.publicProperties[prop];\n                            }\n                        }\n                    }\n                }\n\n                if (componentDefinition.events) {\n                    priority -= 1; // So event priority remains in order of component addition.\n                    for (func in componentDefinition.events) {\n                        if (componentDefinition.events.hasOwnProperty(func)) {\n                            this.addEventListener(func, componentDefinition.events[func], priority);\n                            if (definition && definition.aliases) {\n                                for (alias in definition.aliases) {\n                                    if (definition.aliases.hasOwnProperty(alias) && (definition.aliases[alias] === func)) {\n                                        this.addEventListener(alias, componentDefinition.events[func], priority);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n\n                if (componentDefinition.publicMethods) {\n                    for (func in componentDefinition.publicMethods) {\n                        if (componentDefinition.publicMethods.hasOwnProperty(func)) {\n                            name = func;\n                            if (definition && definition.aliases) {\n                                for (alias in definition.aliases) {\n                                    if (definition.aliases.hasOwnProperty(alias) && (definition.aliases[alias] === func)) {\n                                        name = alias;\n                                    }\n                                }\n                            }\n                            this.addMethod(name, componentDefinition.publicMethods[func]);\n                        }\n                    }\n                }\n\n                if (!this.initialize(definition, callback) && callback) { // whether the callback will be used; if not, we run immediately.\n                    callback();\n                }\n            }\n        }\n        \n        proto = NewComponent.prototype;\n\n        proto.initialize = componentDefinition.initialize || doNothing;\n        \n        // This can be overridden by a \"toJSON\" method in the component definition. This is by design.\n        proto.toJSON = (function () {\n            var validating = false,\n                valid = function (value, depthArray) {\n                    var depth = null,\n                        root = false,\n                        key = '',\n                        invalid = false,\n                        i = 0,\n                        type = typeof value;\n                    \n                    if (!validating) { // prevents endless validation during recursion.\n                        validating = true;\n                        root = true;\n                    }\n\n                    if (type === 'function') {\n                        invalid = true;\n                    } else if ((type === 'object') && (value !== null)) {\n                        if (value.toJSON) { // We know it's valid but we run this for the depth check to make sure that there is no recursion.\n                            depth = depthArray ? Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSlice\"])(depthArray) : _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n                            depth.push(value);\n                            if (!valid(value.toJSON(), depth)) {\n                                invalid = true;\n                            }\n                        } else if (Array.isArray(value)) {\n                            i = value.length;\n                            while (i--) {\n                                if (depthArray && depthArray.indexOf(value[i]) >= 0) {\n                                    invalid = true;\n                                    break;\n                                }\n                                depth = depthArray ? Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSlice\"])(depthArray) : _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n                                depth.push(value[i]);\n                                if (!valid(value[i], depth)) {\n                                    invalid = true;\n                                    break;\n                                }\n                            }\n                        } else {\n                            for (key in value) {\n                                if (value.hasOwnProperty(key)) {\n                                    if (depthArray && depthArray.indexOf(value[key]) >= 0) {\n                                        invalid = true;\n                                        break;\n                                    }\n                                    depth = depthArray ? Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSlice\"])(depthArray) : _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n                                    depth.push(value[key]);\n                                    if (!valid(value[key], depth)) {\n                                        invalid = true;\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n                    }\n\n                    if (depthArray) {\n                        _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(depthArray);\n                    }\n\n                    if (root) {\n                        validating = false;\n                    }\n\n                    return !invalid;\n                };\n\n            // We only perform validation in debug mode since it may impact performance.\n            if (debug) {\n                return function (propertiesDefinition) {\n                    var properties = componentDefinition.properties,\n                        publicProperties = componentDefinition.publicProperties,\n                        component = {\n                            type: this.type\n                        },\n                        key = '';\n                    \n                    for (key in properties) {\n                        if (properties.hasOwnProperty(key) && (properties[key] !== this[key])) {\n                            if (!validating && !valid(this[key])) {\n                                platypus.debug.warn('Component \"' + this.type + '\" includes a non-JSON property value for \"' + key + '\" (type \"' + (typeof this[key]) + '\"). You may want to create a custom `toJSON` method for this component.', this[key]);\n                            }\n                            component[key] = this[key];\n                        }\n                    }\n\n                    for (key in publicProperties) {\n                        if (publicProperties.hasOwnProperty(key) && (publicProperties[key] !== this.owner[key]) && (typeof propertiesDefinition[key] === 'undefined')) {\n                            if (!validating && !valid(this.owner[key])) {\n                                platypus.debug.warn('Component \"' + this.type + '\" includes a non-JSON public property value for \"' + key + '\" (type \"' + (typeof this.owner[key]) + '\"). You may want to create a custom `toJSON` method for this component.', this.owner[key]);\n                            }\n                            propertiesDefinition[key] = this.owner[key];\n                        }\n                    }\n\n                    return component;\n                };\n            } else {\n                return function (propertiesDefinition) {\n                    var properties = componentDefinition.properties,\n                        publicProperties = componentDefinition.publicProperties,\n                        component = {\n                            type: this.type\n                        },\n                        key = '';\n                    \n                    for (key in properties) {\n                        if (properties.hasOwnProperty(key) && (properties[key] !== this[key])) {\n                            component[key] = this[key];\n                        }\n                    }\n\n                    for (key in publicProperties) {\n                        if (publicProperties.hasOwnProperty(key) && (publicProperties[key] !== this.owner[key])) {\n                            propertiesDefinition[key] = this.owner[key];\n                        }\n                    }\n\n                    return component;\n                };\n            }\n        }());\n\n        if (componentDefinition.methods) {\n            for (func in componentDefinition.methods) {\n                if (componentDefinition.methods.hasOwnProperty(func)) {\n                    if (func === 'destroy') {\n                        proto._destroy = componentDefinition.methods[func];\n                    } else {\n                        proto[func] = componentDefinition.methods[func];\n                    }\n                }\n            }\n        }\n        if (componentDefinition.publicMethods) {\n            for (func in componentDefinition.publicMethods) {\n                if (componentDefinition.publicMethods.hasOwnProperty(func)) {\n                    proto[func] = componentDefinition.publicMethods[func];\n                }\n            }\n        }\n\n        if (componentDefinition.getAssetList) {\n            NewComponent.getAssetList = componentDefinition.getAssetList;\n        }\n\n        return NewComponent;\n    };\n}());\n\n\n//# sourceURL=webpack://platypus/./src/factory.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! exports provided: recycle, AABB, ActionState, Application, Async, CollisionData, CollisionDataContainer, CollisionShape, Component, Data, DataMap, Entity, Game, Messenger, PIXIAnimation, StateMap, Vector, createComponentClass, default, arrayCache, union, greenSlice, greenSplice, greenSplit */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var _AssetManager_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AssetManager.js */ \"./src/AssetManager.js\");\n/* harmony import */ var springroll__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! springroll */ \"springroll\");\n/* harmony import */ var springroll__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(springroll__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _Game_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Game.js */ \"./src/Game.js\");\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! config */ \"./src/config/development.js\");\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(config__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./factory.js */ \"./src/factory.js\");\n/* harmony import */ var _components_Interactive_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./components/Interactive.js */ \"./src/components/Interactive.js\");\n/* harmony import */ var _components_AIChaser_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./components/AIChaser.js */ \"./src/components/AIChaser.js\");\n/* harmony import */ var _components_AIPacer_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./components/AIPacer.js */ \"./src/components/AIPacer.js\");\n/* harmony import */ var _components_AudioMusic_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./components/AudioMusic.js */ \"./src/components/AudioMusic.js\");\n/* harmony import */ var _components_AudioSFX_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./components/AudioSFX.js */ \"./src/components/AudioSFX.js\");\n/* harmony import */ var _components_AudioVO_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./components/AudioVO.js */ \"./src/components/AudioVO.js\");\n/* harmony import */ var _components_Camera_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./components/Camera.js */ \"./src/components/Camera.js\");\n/* harmony import */ var _components_CameraFollowMe_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./components/CameraFollowMe.js */ \"./src/components/CameraFollowMe.js\");\n/* harmony import */ var _components_CollisionBasic_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./components/CollisionBasic.js */ \"./src/components/CollisionBasic.js\");\n/* harmony import */ var _components_CollisionFilter_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./components/CollisionFilter.js */ \"./src/components/CollisionFilter.js\");\n/* harmony import */ var _components_CollisionGroup_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./components/CollisionGroup.js */ \"./src/components/CollisionGroup.js\");\n/* harmony import */ var _components_CollisionTiles_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./components/CollisionTiles.js */ \"./src/components/CollisionTiles.js\");\n/* harmony import */ var _components_ComponentSwitcher_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./components/ComponentSwitcher.js */ \"./src/components/ComponentSwitcher.js\");\n/* harmony import */ var _components_Counter_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./components/Counter.js */ \"./src/components/Counter.js\");\n/* harmony import */ var _components_EntityContainer_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./components/EntityContainer.js */ \"./src/components/EntityContainer.js\");\n/* harmony import */ var _components_EntityController_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./components/EntityController.js */ \"./src/components/EntityController.js\");\n/* harmony import */ var _components_HandlerCollision_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./components/HandlerCollision.js */ \"./src/components/HandlerCollision.js\");\n/* harmony import */ var _components_HandlerController_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./components/HandlerController.js */ \"./src/components/HandlerController.js\");\n/* harmony import */ var _components_HandlerLogic_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./components/HandlerLogic.js */ \"./src/components/HandlerLogic.js\");\n/* harmony import */ var _components_HandlerRender_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./components/HandlerRender.js */ \"./src/components/HandlerRender.js\");\n/* harmony import */ var _components_LevelBuilder_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./components/LevelBuilder.js */ \"./src/components/LevelBuilder.js\");\n/* harmony import */ var _components_LogicAngularMovement_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./components/LogicAngularMovement.js */ \"./src/components/LogicAngularMovement.js\");\n/* harmony import */ var _components_LogicAttachment_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./components/LogicAttachment.js */ \"./src/components/LogicAttachment.js\");\n/* harmony import */ var _components_LogicButton_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./components/LogicButton.js */ \"./src/components/LogicButton.js\");\n/* harmony import */ var _components_LogicCarrier_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./components/LogicCarrier.js */ \"./src/components/LogicCarrier.js\");\n/* harmony import */ var _components_LogicDestroyMe_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./components/LogicDestroyMe.js */ \"./src/components/LogicDestroyMe.js\");\n/* harmony import */ var _components_LogicDirectionalMovement_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./components/LogicDirectionalMovement.js */ \"./src/components/LogicDirectionalMovement.js\");\n/* harmony import */ var _components_LogicDragDrop_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./components/LogicDragDrop.js */ \"./src/components/LogicDragDrop.js\");\n/* harmony import */ var _components_LogicImpactLaunch_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./components/LogicImpactLaunch.js */ \"./src/components/LogicImpactLaunch.js\");\n/* harmony import */ var _components_LogicPacingPlatform_js__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./components/LogicPacingPlatform.js */ \"./src/components/LogicPacingPlatform.js\");\n/* harmony import */ var _components_LogicPortable_js__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./components/LogicPortable.js */ \"./src/components/LogicPortable.js\");\n/* harmony import */ var _components_LogicPortal_js__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./components/LogicPortal.js */ \"./src/components/LogicPortal.js\");\n/* harmony import */ var _components_LogicPushable_js__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./components/LogicPushable.js */ \"./src/components/LogicPushable.js\");\n/* harmony import */ var _components_LogicRebounder_js__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./components/LogicRebounder.js */ \"./src/components/LogicRebounder.js\");\n/* harmony import */ var _components_LogicRegionSpawner_js__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./components/LogicRegionSpawner.js */ \"./src/components/LogicRegionSpawner.js\");\n/* harmony import */ var _components_LogicRotationalMovement_js__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./components/LogicRotationalMovement.js */ \"./src/components/LogicRotationalMovement.js\");\n/* harmony import */ var _components_LogicSpawner_js__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./components/LogicSpawner.js */ \"./src/components/LogicSpawner.js\");\n/* harmony import */ var _components_LogicStateMachine_js__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./components/LogicStateMachine.js */ \"./src/components/LogicStateMachine.js\");\n/* harmony import */ var _components_LogicSwitch_js__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ./components/LogicSwitch.js */ \"./src/components/LogicSwitch.js\");\n/* harmony import */ var _components_LogicTeleportee_js__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ./components/LogicTeleportee.js */ \"./src/components/LogicTeleportee.js\");\n/* harmony import */ var _components_LogicTeleporter_js__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! ./components/LogicTeleporter.js */ \"./src/components/LogicTeleporter.js\");\n/* harmony import */ var _components_LogicTimer_js__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! ./components/LogicTimer.js */ \"./src/components/LogicTimer.js\");\n/* harmony import */ var _components_LogicWindUpRacer_js__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! ./components/LogicWindUpRacer.js */ \"./src/components/LogicWindUpRacer.js\");\n/* harmony import */ var _components_Motion_js__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! ./components/Motion.js */ \"./src/components/Motion.js\");\n/* harmony import */ var _components_Mover_js__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! ./components/Mover.js */ \"./src/components/Mover.js\");\n/* harmony import */ var _components_Node_js__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! ./components/Node.js */ \"./src/components/Node.js\");\n/* harmony import */ var _components_NodeMap_js__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(/*! ./components/NodeMap.js */ \"./src/components/NodeMap.js\");\n/* harmony import */ var _components_NodeResident_js__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(/*! ./components/NodeResident.js */ \"./src/components/NodeResident.js\");\n/* harmony import */ var _components_Orientation_js__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(/*! ./components/Orientation.js */ \"./src/components/Orientation.js\");\n/* harmony import */ var _components_RandomEvents_js__WEBPACK_IMPORTED_MODULE_54__ = __webpack_require__(/*! ./components/RandomEvents.js */ \"./src/components/RandomEvents.js\");\n/* harmony import */ var _components_RelativePosition_js__WEBPACK_IMPORTED_MODULE_55__ = __webpack_require__(/*! ./components/RelativePosition.js */ \"./src/components/RelativePosition.js\");\n/* harmony import */ var _components_RelayFamily_js__WEBPACK_IMPORTED_MODULE_56__ = __webpack_require__(/*! ./components/RelayFamily.js */ \"./src/components/RelayFamily.js\");\n/* harmony import */ var _components_RelayGame_js__WEBPACK_IMPORTED_MODULE_57__ = __webpack_require__(/*! ./components/RelayGame.js */ \"./src/components/RelayGame.js\");\n/* harmony import */ var _components_RelayLinker_js__WEBPACK_IMPORTED_MODULE_58__ = __webpack_require__(/*! ./components/RelayLinker.js */ \"./src/components/RelayLinker.js\");\n/* harmony import */ var _components_RelayParent_js__WEBPACK_IMPORTED_MODULE_59__ = __webpack_require__(/*! ./components/RelayParent.js */ \"./src/components/RelayParent.js\");\n/* harmony import */ var _components_RelaySelf_js__WEBPACK_IMPORTED_MODULE_60__ = __webpack_require__(/*! ./components/RelaySelf.js */ \"./src/components/RelaySelf.js\");\n/* harmony import */ var _components_RenderAnimator_js__WEBPACK_IMPORTED_MODULE_61__ = __webpack_require__(/*! ./components/RenderAnimator.js */ \"./src/components/RenderAnimator.js\");\n/* harmony import */ var _components_RenderContainer_js__WEBPACK_IMPORTED_MODULE_62__ = __webpack_require__(/*! ./components/RenderContainer.js */ \"./src/components/RenderContainer.js\");\n/* harmony import */ var _components_RenderDebug_js__WEBPACK_IMPORTED_MODULE_63__ = __webpack_require__(/*! ./components/RenderDebug.js */ \"./src/components/RenderDebug.js\");\n/* harmony import */ var _components_RenderDestroyMe_js__WEBPACK_IMPORTED_MODULE_64__ = __webpack_require__(/*! ./components/RenderDestroyMe.js */ \"./src/components/RenderDestroyMe.js\");\n/* harmony import */ var _components_RenderProgress_js__WEBPACK_IMPORTED_MODULE_65__ = __webpack_require__(/*! ./components/RenderProgress.js */ \"./src/components/RenderProgress.js\");\n/* harmony import */ var _components_RenderSpine_js__WEBPACK_IMPORTED_MODULE_66__ = __webpack_require__(/*! ./components/RenderSpine.js */ \"./src/components/RenderSpine.js\");\n/* harmony import */ var _components_RenderSprite_js__WEBPACK_IMPORTED_MODULE_67__ = __webpack_require__(/*! ./components/RenderSprite.js */ \"./src/components/RenderSprite.js\");\n/* harmony import */ var _components_RenderText_js__WEBPACK_IMPORTED_MODULE_68__ = __webpack_require__(/*! ./components/RenderText.js */ \"./src/components/RenderText.js\");\n/* harmony import */ var _components_RenderTiles_js__WEBPACK_IMPORTED_MODULE_69__ = __webpack_require__(/*! ./components/RenderTiles.js */ \"./src/components/RenderTiles.js\");\n/* harmony import */ var _components_SceneChanger_js__WEBPACK_IMPORTED_MODULE_70__ = __webpack_require__(/*! ./components/SceneChanger.js */ \"./src/components/SceneChanger.js\");\n/* harmony import */ var _components_TiledLoader_js__WEBPACK_IMPORTED_MODULE_71__ = __webpack_require__(/*! ./components/TiledLoader.js */ \"./src/components/TiledLoader.js\");\n/* harmony import */ var _components_Timeline_js__WEBPACK_IMPORTED_MODULE_72__ = __webpack_require__(/*! ./components/Timeline.js */ \"./src/components/Timeline.js\");\n/* harmony import */ var _components_Tutorial_js__WEBPACK_IMPORTED_MODULE_73__ = __webpack_require__(/*! ./components/Tutorial.js */ \"./src/components/Tutorial.js\");\n/* harmony import */ var _components_Tween_js__WEBPACK_IMPORTED_MODULE_74__ = __webpack_require__(/*! ./components/Tween.js */ \"./src/components/Tween.js\");\n/* harmony import */ var _components_VoiceOver_js__WEBPACK_IMPORTED_MODULE_75__ = __webpack_require__(/*! ./components/VoiceOver.js */ \"./src/components/VoiceOver.js\");\n/* harmony import */ var _components_XHR_js__WEBPACK_IMPORTED_MODULE_76__ = __webpack_require__(/*! ./components/XHR.js */ \"./src/components/XHR.js\");\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_77__ = __webpack_require__(/*! ./utils/array.js */ \"./src/utils/array.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"arrayCache\", function() { return _utils_array_js__WEBPACK_IMPORTED_MODULE_77__[\"arrayCache\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"union\", function() { return _utils_array_js__WEBPACK_IMPORTED_MODULE_77__[\"union\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"greenSlice\", function() { return _utils_array_js__WEBPACK_IMPORTED_MODULE_77__[\"greenSlice\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"greenSplice\", function() { return _utils_array_js__WEBPACK_IMPORTED_MODULE_77__[\"greenSplice\"]; });\n\n/* harmony import */ var _utils_string_js__WEBPACK_IMPORTED_MODULE_78__ = __webpack_require__(/*! ./utils/string.js */ \"./src/utils/string.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"greenSplit\", function() { return _utils_string_js__WEBPACK_IMPORTED_MODULE_78__[\"greenSplit\"]; });\n\n/* harmony import */ var recycle__WEBPACK_IMPORTED_MODULE_79__ = __webpack_require__(/*! recycle */ \"./node_modules/recycle/recycle.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"recycle\", function() { return recycle__WEBPACK_IMPORTED_MODULE_79__[\"default\"]; });\n\n/* harmony import */ var _AABB_js__WEBPACK_IMPORTED_MODULE_80__ = __webpack_require__(/*! ./AABB.js */ \"./src/AABB.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"AABB\", function() { return _AABB_js__WEBPACK_IMPORTED_MODULE_80__[\"default\"]; });\n\n/* harmony import */ var _ActionState_js__WEBPACK_IMPORTED_MODULE_81__ = __webpack_require__(/*! ./ActionState.js */ \"./src/ActionState.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ActionState\", function() { return _ActionState_js__WEBPACK_IMPORTED_MODULE_81__[\"default\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Application\", function() { return springroll__WEBPACK_IMPORTED_MODULE_1__[\"Application\"]; });\n\n/* harmony import */ var _Async_js__WEBPACK_IMPORTED_MODULE_82__ = __webpack_require__(/*! ./Async.js */ \"./src/Async.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Async\", function() { return _Async_js__WEBPACK_IMPORTED_MODULE_82__[\"default\"]; });\n\n/* harmony import */ var _CollisionData_js__WEBPACK_IMPORTED_MODULE_83__ = __webpack_require__(/*! ./CollisionData.js */ \"./src/CollisionData.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"CollisionData\", function() { return _CollisionData_js__WEBPACK_IMPORTED_MODULE_83__[\"default\"]; });\n\n/* harmony import */ var _CollisionDataContainer_js__WEBPACK_IMPORTED_MODULE_84__ = __webpack_require__(/*! ./CollisionDataContainer.js */ \"./src/CollisionDataContainer.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"CollisionDataContainer\", function() { return _CollisionDataContainer_js__WEBPACK_IMPORTED_MODULE_84__[\"default\"]; });\n\n/* harmony import */ var _CollisionShape_js__WEBPACK_IMPORTED_MODULE_85__ = __webpack_require__(/*! ./CollisionShape.js */ \"./src/CollisionShape.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"CollisionShape\", function() { return _CollisionShape_js__WEBPACK_IMPORTED_MODULE_85__[\"default\"]; });\n\n/* harmony import */ var _Component_js__WEBPACK_IMPORTED_MODULE_86__ = __webpack_require__(/*! ./Component.js */ \"./src/Component.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Component\", function() { return _Component_js__WEBPACK_IMPORTED_MODULE_86__[\"default\"]; });\n\n/* harmony import */ var _Data_js__WEBPACK_IMPORTED_MODULE_87__ = __webpack_require__(/*! ./Data.js */ \"./src/Data.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Data\", function() { return _Data_js__WEBPACK_IMPORTED_MODULE_87__[\"default\"]; });\n\n/* harmony import */ var _DataMap_js__WEBPACK_IMPORTED_MODULE_88__ = __webpack_require__(/*! ./DataMap.js */ \"./src/DataMap.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"DataMap\", function() { return _DataMap_js__WEBPACK_IMPORTED_MODULE_88__[\"default\"]; });\n\n/* harmony import */ var _Entity_js__WEBPACK_IMPORTED_MODULE_89__ = __webpack_require__(/*! ./Entity.js */ \"./src/Entity.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Entity\", function() { return _Entity_js__WEBPACK_IMPORTED_MODULE_89__[\"default\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Game\", function() { return _Game_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]; });\n\n/* harmony import */ var _Messenger_js__WEBPACK_IMPORTED_MODULE_90__ = __webpack_require__(/*! ./Messenger.js */ \"./src/Messenger.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Messenger\", function() { return _Messenger_js__WEBPACK_IMPORTED_MODULE_90__[\"default\"]; });\n\n/* harmony import */ var _PIXIAnimation_js__WEBPACK_IMPORTED_MODULE_91__ = __webpack_require__(/*! ./PIXIAnimation.js */ \"./src/PIXIAnimation.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"PIXIAnimation\", function() { return _PIXIAnimation_js__WEBPACK_IMPORTED_MODULE_91__[\"default\"]; });\n\n/* harmony import */ var _StateMap_js__WEBPACK_IMPORTED_MODULE_92__ = __webpack_require__(/*! ./StateMap.js */ \"./src/StateMap.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"StateMap\", function() { return _StateMap_js__WEBPACK_IMPORTED_MODULE_92__[\"default\"]; });\n\n/* harmony import */ var _Vector_js__WEBPACK_IMPORTED_MODULE_93__ = __webpack_require__(/*! ./Vector.js */ \"./src/Vector.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Vector\", function() { return _Vector_js__WEBPACK_IMPORTED_MODULE_93__[\"default\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"createComponentClass\", function() { return _factory_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]; });\n\n/* eslint-disable sort-imports */\n/**\n * @module platypus\n * @namespace platypus\n */\n/* global global, navigator, window */\n\n\n\n\n\n\n\n// Components\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// Classes\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// Component creator\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    var platypus = global.platypus = {},\n        debugWrapper = springroll__WEBPACK_IMPORTED_MODULE_1__[\"Debugger\"] ? function (method, ...args) {\n            springroll__WEBPACK_IMPORTED_MODULE_1__[\"Debugger\"].log(method, ...args);\n        } : function (method, ...args) {\n            window.console[method](...args);\n        },\n        log = config__WEBPACK_IMPORTED_MODULE_3___default.a.dev ? debugWrapper : function () {},\n        uagent    = navigator.userAgent.toLowerCase(),\n        isEdge    = (uagent.search('edge')    > -1),\n        isIPod    = (uagent.search('ipod')    > -1),\n        isIPhone  = (uagent.search('iphone')  > -1),\n        isIPad    = (uagent.search('ipad')    > -1),\n        isAndroid = (uagent.search('android') > -1),\n        isSilk    = (uagent.search('silk')    > -1),\n        isIOS     = isIPod || isIPhone  || isIPad,\n        isMobile  = isIOS  || isAndroid || isSilk;\n\n    platypus.components = {\n        \"Interactive\": _components_Interactive_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"],\n        \"AIChaser\": _components_AIChaser_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"],\n        \"AIPacer\": _components_AIPacer_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"],\n        \"AudioMusic\": _components_AudioMusic_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"],\n        \"AudioSFX\": _components_AudioSFX_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"],\n        \"AudioVO\": _components_AudioVO_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"],\n        \"Camera\": _components_Camera_js__WEBPACK_IMPORTED_MODULE_11__[\"default\"],\n        \"CameraFollowMe\": _components_CameraFollowMe_js__WEBPACK_IMPORTED_MODULE_12__[\"default\"],\n        \"CollisionBasic\": _components_CollisionBasic_js__WEBPACK_IMPORTED_MODULE_13__[\"default\"],\n        \"CollisionFilter\": _components_CollisionFilter_js__WEBPACK_IMPORTED_MODULE_14__[\"default\"],\n        \"CollisionGroup\": _components_CollisionGroup_js__WEBPACK_IMPORTED_MODULE_15__[\"default\"],\n        \"CollisionTiles\": _components_CollisionTiles_js__WEBPACK_IMPORTED_MODULE_16__[\"default\"],\n        \"ComponentSwitcher\": _components_ComponentSwitcher_js__WEBPACK_IMPORTED_MODULE_17__[\"default\"],\n        \"Counter\": _components_Counter_js__WEBPACK_IMPORTED_MODULE_18__[\"default\"],\n        \"EntityContainer\": _components_EntityContainer_js__WEBPACK_IMPORTED_MODULE_19__[\"default\"],\n        \"EntityController\": _components_EntityController_js__WEBPACK_IMPORTED_MODULE_20__[\"default\"],\n        \"HandlerCollision\": _components_HandlerCollision_js__WEBPACK_IMPORTED_MODULE_21__[\"default\"],\n        \"HandlerController\": _components_HandlerController_js__WEBPACK_IMPORTED_MODULE_22__[\"default\"],\n        \"HandlerLogic\": _components_HandlerLogic_js__WEBPACK_IMPORTED_MODULE_23__[\"default\"],\n        \"HandlerRender\": _components_HandlerRender_js__WEBPACK_IMPORTED_MODULE_24__[\"default\"],\n        \"LevelBuilder\": _components_LevelBuilder_js__WEBPACK_IMPORTED_MODULE_25__[\"default\"],\n        \"LogicAngularMovement\": _components_LogicAngularMovement_js__WEBPACK_IMPORTED_MODULE_26__[\"default\"],\n        \"LogicAttachment\": _components_LogicAttachment_js__WEBPACK_IMPORTED_MODULE_27__[\"default\"],\n        \"LogicButton\": _components_LogicButton_js__WEBPACK_IMPORTED_MODULE_28__[\"default\"],\n        \"LogicCarrier\": _components_LogicCarrier_js__WEBPACK_IMPORTED_MODULE_29__[\"default\"],\n        \"LogicDestroyMe\": _components_LogicDestroyMe_js__WEBPACK_IMPORTED_MODULE_30__[\"default\"],\n        \"LogicDirectionalMovement\": _components_LogicDirectionalMovement_js__WEBPACK_IMPORTED_MODULE_31__[\"default\"],\n        \"LogicDragDrop\": _components_LogicDragDrop_js__WEBPACK_IMPORTED_MODULE_32__[\"default\"],\n        \"LogicImpactLaunch\": _components_LogicImpactLaunch_js__WEBPACK_IMPORTED_MODULE_33__[\"default\"],\n        \"LogicPacingPlatform\": _components_LogicPacingPlatform_js__WEBPACK_IMPORTED_MODULE_34__[\"default\"],\n        \"LogicPortable\": _components_LogicPortable_js__WEBPACK_IMPORTED_MODULE_35__[\"default\"],\n        \"LogicPortal\": _components_LogicPortal_js__WEBPACK_IMPORTED_MODULE_36__[\"default\"],\n        \"LogicPushable\": _components_LogicPushable_js__WEBPACK_IMPORTED_MODULE_37__[\"default\"],\n        \"LogicRebounder\": _components_LogicRebounder_js__WEBPACK_IMPORTED_MODULE_38__[\"default\"],\n        \"LogicRegionSpawner\": _components_LogicRegionSpawner_js__WEBPACK_IMPORTED_MODULE_39__[\"default\"],\n        \"LogicRotationalMovement\": _components_LogicRotationalMovement_js__WEBPACK_IMPORTED_MODULE_40__[\"default\"],\n        \"LogicSpawner\": _components_LogicSpawner_js__WEBPACK_IMPORTED_MODULE_41__[\"default\"],\n        \"LogicStateMachine\": _components_LogicStateMachine_js__WEBPACK_IMPORTED_MODULE_42__[\"default\"],\n        \"LogicSwitch\": _components_LogicSwitch_js__WEBPACK_IMPORTED_MODULE_43__[\"default\"],\n        \"LogicTeleportee\": _components_LogicTeleportee_js__WEBPACK_IMPORTED_MODULE_44__[\"default\"],\n        \"LogicTeleporter\": _components_LogicTeleporter_js__WEBPACK_IMPORTED_MODULE_45__[\"default\"],\n        \"LogicTimer\": _components_LogicTimer_js__WEBPACK_IMPORTED_MODULE_46__[\"default\"],\n        \"LogicWindUpRacer\": _components_LogicWindUpRacer_js__WEBPACK_IMPORTED_MODULE_47__[\"default\"],\n        \"Motion\": _components_Motion_js__WEBPACK_IMPORTED_MODULE_48__[\"default\"],\n        \"Mover\": _components_Mover_js__WEBPACK_IMPORTED_MODULE_49__[\"default\"],\n        \"Node\": _components_Node_js__WEBPACK_IMPORTED_MODULE_50__[\"default\"],\n        \"NodeMap\": _components_NodeMap_js__WEBPACK_IMPORTED_MODULE_51__[\"default\"],\n        \"NodeResident\": _components_NodeResident_js__WEBPACK_IMPORTED_MODULE_52__[\"default\"],\n        \"Orientation\": _components_Orientation_js__WEBPACK_IMPORTED_MODULE_53__[\"default\"],\n        \"RandomEvents\": _components_RandomEvents_js__WEBPACK_IMPORTED_MODULE_54__[\"default\"],\n        \"RelativePosition\": _components_RelativePosition_js__WEBPACK_IMPORTED_MODULE_55__[\"default\"],\n        \"RelayFamily\": _components_RelayFamily_js__WEBPACK_IMPORTED_MODULE_56__[\"default\"],\n        \"RelayGame\": _components_RelayGame_js__WEBPACK_IMPORTED_MODULE_57__[\"default\"],\n        \"RelayLinker\": _components_RelayLinker_js__WEBPACK_IMPORTED_MODULE_58__[\"default\"],\n        \"RelayParent\": _components_RelayParent_js__WEBPACK_IMPORTED_MODULE_59__[\"default\"],\n        \"RelaySelf\": _components_RelaySelf_js__WEBPACK_IMPORTED_MODULE_60__[\"default\"],\n        \"RenderAnimator\": _components_RenderAnimator_js__WEBPACK_IMPORTED_MODULE_61__[\"default\"],\n        \"RenderContainer\": _components_RenderContainer_js__WEBPACK_IMPORTED_MODULE_62__[\"default\"],\n        \"RenderDebug\": _components_RenderDebug_js__WEBPACK_IMPORTED_MODULE_63__[\"default\"],\n        \"RenderDestroyMe\": _components_RenderDestroyMe_js__WEBPACK_IMPORTED_MODULE_64__[\"default\"],\n        \"RenderProgress\": _components_RenderProgress_js__WEBPACK_IMPORTED_MODULE_65__[\"default\"],\n        \"RenderSpine\": _components_RenderSpine_js__WEBPACK_IMPORTED_MODULE_66__[\"default\"],\n        \"RenderSprite\": _components_RenderSprite_js__WEBPACK_IMPORTED_MODULE_67__[\"default\"],\n        \"RenderText\": _components_RenderText_js__WEBPACK_IMPORTED_MODULE_68__[\"default\"],\n        \"RenderTiles\": _components_RenderTiles_js__WEBPACK_IMPORTED_MODULE_69__[\"default\"],\n        \"SceneChanger\": _components_SceneChanger_js__WEBPACK_IMPORTED_MODULE_70__[\"default\"],\n        \"TiledLoader\": _components_TiledLoader_js__WEBPACK_IMPORTED_MODULE_71__[\"default\"],\n        \"Timeline\": _components_Timeline_js__WEBPACK_IMPORTED_MODULE_72__[\"default\"],\n        \"Tutorial\": _components_Tutorial_js__WEBPACK_IMPORTED_MODULE_73__[\"default\"],\n        \"Tween\": _components_Tween_js__WEBPACK_IMPORTED_MODULE_74__[\"default\"],\n        \"VoiceOver\": _components_VoiceOver_js__WEBPACK_IMPORTED_MODULE_75__[\"default\"],\n        \"XHR\": _components_XHR_js__WEBPACK_IMPORTED_MODULE_76__[\"default\"]\n    };\n    platypus.createComponentClass = _factory_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"];\n\n    /**\n     * This is an object of boolean key/value pairs describing the current browser's properties.\n     * @property supports\n     * @type Object\n     **/\n    platypus.supports = {\n        touch: (window.ontouchstart !== 'undefined'),\n        edge: isEdge,\n        iPod: isIPod,\n        iPhone: isIPhone,\n        iPad: isIPad,\n        safari: (uagent.search('safari')  > -1) && !isEdge,\n        ie: (uagent.search('msie')    > -1) || (uagent.search('trident') > -1),\n        firefox: (uagent.search('firefox') > -1),\n        android: isAndroid,\n        chrome: (uagent.search('chrome')  > -1) && !isEdge,\n        silk: isSilk,\n        iOS: isIOS,\n        mobile: isMobile,\n        desktop: !isMobile\n    };\n    \n    /**\n     * This method defines platypus.debug and uses springroll.Debug if available. If springroll.Debug is not loaded, platypus.debug provides inactive stubs for console methods.\n     *\n     * @property debug\n     * @type Object\n     */\n    platypus.debug = {\n        general: log.bind(null, 'log'),\n        log: log.bind(null, 'log'),\n        warn: log.bind(null, 'warn'),\n        debug: log.bind(null, 'debug'),\n        error: log.bind(null, 'error'),\n        olive: log.bind(null, 'log') // Backwards compatibility - need to deprecate.\n    };\n\n    platypus.assetCache = new _AssetManager_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n\n    /**\n     * The version string for this release.\n     * @property version\n     * @type String\n     * @static\n     **/\n    platypus.version = config__WEBPACK_IMPORTED_MODULE_3___default.a.version;\n\n    /**\n     * The build date for this release in UTC format.\n     * @property buildDate\n     * @type String\n     * @static\n     **/\n    platypus.buildDate = config__WEBPACK_IMPORTED_MODULE_3___default.a.buildDate;\n\n    platypus.Game = _Game_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"];\n\n    return platypus;\n}());\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack://platypus/./src/index.js?");

/***/ }),

/***/ "./src/polyfills/Map.js":
/*!******************************!*\
  !*** ./src/polyfills/Map.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/**\n * @namespace window\n */\n/**\n * This class defines a limited polyfill for Map. If the browser supports Map, this class is not used.\n *\n * @class Map\n */\n/* global window */\n/* harmony default export */ __webpack_exports__[\"default\"] = (function (Object) {\n    var mapDefinition = null,\n        Map = null,\n        proto = null;\n    \n    if (!window.Map) {\n        mapDefinition = {\n            value: null\n        };\n        Map = function () {\n            /**\n             * This is an object containing a list of key/value pairs. This property should not be used directly.\n             *\n             * @property map\n             * @type Object\n             * @private\n             * @default {}\n             */\n            mapDefinition.value = {};\n            Object.defineProperty(this, 'map', mapDefinition);\n        };\n        proto = Map.prototype;\n\n        Object.defineProperties(proto, {\n\n            /**\n             * Returns the value of the provided key.\n             *\n             * @method get\n             * @param key {String} The key to lookup.\n             * @return value {any} The value of the provded key.\n             */\n            get: {\n                value: function (key) {\n                    return this.map[key];\n                }\n            },\n\n            /**\n             * Determines whether the provided key is available in this Map.\n             *\n             * @method has\n             * @param key {String} The key to lookup.\n             * @return value {Boolean} Whether the key is listed in this Map.\n             */\n            has: {\n                value: function (key) {\n                    return this.map.hasOwnProperty(key);\n                }\n            },\n\n            /**\n             * Sets a value to a key in the Map.\n             *\n             * @method set\n             * @param key {String} The key to associate with the provided value.\n             * @param value {any} The value to be stored by the Map.\n             * @chainable\n             */\n            set: {\n                value: function (key, value) {\n                    this.map[key] = value;\n                    return this;\n                }\n            },\n            \n            /**\n             * Deletes a key (and value) from the Map.\n             *\n             * @method delete\n             * @param key {String} The key to delete from the Map.\n             * @return value {any} The value of the key is returned.\n             */\n            delete: {\n                value: function (key) {\n                    var value = this.map[key];\n                    \n                    delete this.map[key];\n                    return value;\n                }\n            }\n        });\n        \n        window.Map = Map;\n    }\n}(Object));\n\n//# sourceURL=webpack://platypus/./src/polyfills/Map.js?");

/***/ }),

/***/ "./src/sayHello.js":
/*!*************************!*\
  !*** ./src/sayHello.js ***!
  \*************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pixi.js */ \"pixi.js\");\n/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(pixi_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var _utils_string_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/string.js */ \"./src/utils/string.js\");\n/* global console, document, platypus */\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n    var getPortion = function (num, max) {\n            var min = 204;\n        \n            return Math.floor(min * num / max);\n        },\n        getStyle = function (title, version) {\n            var max = 0,\n                min = 0,\n                style = 'color: #ffffff; line-height: 1.5em; border-radius: 6px;',\n                r = 0,\n                g = 0,\n                b = 0,\n                v = null;\n                \n            if (version) {\n                v = Object(_utils_string_js__WEBPACK_IMPORTED_MODULE_2__[\"greenSplit\"])(version, '.');\n            }\n            \n            if (version && (v.length === 3)) {\n                r = parseInt(v[0], 10);\n                g = parseInt(v[1], 10);\n                b = parseInt(v[2], 10);\n            } else {\n                r = title.charCodeAt(0) || 0;\n                g = title.charCodeAt(1) || 0;\n                b = title.charCodeAt(2) || 0;\n                min = Math.min(r, g, b);\n                r -= min;\n                g -= min;\n                b -= min;\n            }\n            \n            if (v) {\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].recycle(v);\n            }\n            \n            max = Math.max(r, g, b, 1);\n\n            return style + ' background-color: rgb(' + getPortion(r, max) + ',' + getPortion(g, max) + ',' + getPortion(b, max) + ');';\n        },\n        getVersions = function (text, title, arr) {\n            var i = 0,\n                str = '',\n                versions = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp(text);\n            \n            for (i = 0; i < arr.length; i++) {\n                str = arr[i];\n                versions.push(getStyle(str, str.substr(str.lastIndexOf(' ') - str.length + 1)), 'line-height: 1.5em;');\n            }\n            \n            return versions;\n        };\n\n    // Over-riding the pixi.js hello since we're creating our own.\n    pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"utils\"].skipHello();\n    \n    return function (app) {\n        var options = app.options,\n            authorTag = document.getElementsByName('author'),\n            docAuth = authorTag.length ? authorTag[0].getAttribute('content') || '' : '',\n            author  = (docAuth ? 'by ' + docAuth : ''),\n            title   = options.name || app.name || document.title || '',\n            engine  = 'Platypus ' + platypus.version,\n            version = options.version || '(?)',\n            using   = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp(),\n            usingV  = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp(),\n            sr      = platypus.springroll, //TODO: Figure out how to detect SR.\n            supports = platypus.supports;\n        \n        if (sr) {\n            using.push('SpringRoll ' + sr.version);\n        }\n        \n        using.push('Pixi.js ' + pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"VERSION\"]);\n        \n        if (version !== '(?)') {\n            title += ' ' + version;\n        }\n        \n        if (supports.firefox || supports.chrome) {\n            console.log('%c ' + title + ' %c ' + author, getStyle(title, title.substr(title.lastIndexOf(' ') - title.length + 1)), 'line-height: 1.5em;');\n            using.push(engine);\n            usingV = getVersions('Using %c ' + using.join(' %c %c ') + ' %c ', title, using);\n            console.log.apply(console, usingV);\n            _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].recycle(usingV);\n        } else {\n            console.log('--- \"' + title + '\" ' + author + ' - Using ' + using.join(', ') + ', and ' + engine + ' ---');\n        }\n\n        _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].recycle(using);\n    };\n}());\n\n//# sourceURL=webpack://platypus/./src/sayHello.js?");

/***/ }),

/***/ "./src/utils/array.js":
/*!****************************!*\
  !*** ./src/utils/array.js ***!
  \****************************/
/*! exports provided: arrayCache, union, greenSlice, greenSplice */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"arrayCache\", function() { return arrayCache; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"union\", function() { return union; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"greenSlice\", function() { return greenSlice; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"greenSplice\", function() { return greenSplice; });\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! config */ \"./src/config/development.js\");\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(config__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var recycle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! recycle */ \"./node_modules/recycle/recycle.js\");\n/**\n * @namespace window\n */\n\n\n\nconst arrayCache = recycle__WEBPACK_IMPORTED_MODULE_1__[\"default\"].add(Array, 'Array', null, null, false, config__WEBPACK_IMPORTED_MODULE_0___default.a.dev);\n\n/**\n * Merges items from one array into the other, making sure to not duplicate identical entries.\n *\n * @method union\n * @param arrayTo {Array} The array into which items will be inserted.\n * @param ...arrayFrom {Array} The array(s) containing items to be merged.\n * @return Array\n */\nfunction union (arrayTo, ...arrayFrom) {\n\n    for (let i = 0; i < arrayFrom.length; i++) {\n        const incoming = arrayFrom[i];\n\n        if (incoming && incoming.length) {\n            for (let j = 0; j < incoming.length; j++) {\n                if (arrayTo.indexOf(incoming[j]) === -1) {\n                    arrayTo.push(incoming[j]);\n                }\n            }\n        }\n    }\n    \n    return arrayTo;\n}\n\n/**\n * Slices, but uses a recycled array. Note that this slice does not accept parameters and makes a shallow copy of the original array.\n *\n * @method greenSlice\n * @param array {Array} The array to copy.\n * @return Array\n */\nfunction greenSlice (array) {\n    const\n        arr = arrayCache.setUp(),\n        len = array.length;\n        \n    for (let i = 0; i < len; i++) {\n        arr[i] = array[i];\n    }\n    \n    return arr;\n}\n\n/**\n * Splices, but only removes a single item and returns the item itself, not an array.\n *\n * @method greenSplice\n * @param array {Array} The array from which an item is to be extracted.\n * @param index {Number} The index of the item to extract.\n * @return {any}\n */\nfunction greenSplice (array, index) {\n    const\n        item = array[index],\n        len = array.length;\n        \n    if ((index < 0) || (index >= len)) {\n        return null;\n    }\n    \n    for (let i = index + 1; i < len; i++) {\n        array[i - 1] = array[i];\n    }\n    \n    if (len) {\n        array.length -= 1;\n    }\n    \n    return item;\n}\n\n//# sourceURL=webpack://platypus/./src/utils/array.js?");

/***/ }),

/***/ "./src/utils/string.js":
/*!*****************************!*\
  !*** ./src/utils/string.js ***!
  \*****************************/
/*! exports provided: greenSplit */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"greenSplit\", function() { return greenSplit; });\n/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./array.js */ \"./src/utils/array.js\");\n/**\n * @namespace window\n */\n\n\n/**\n * Splits a string, but populates an array from the array cache instead of creating a new one.\n *\n * @method greenSplit\n * @param str {String} String to split.\n * @param [splitter] {String} String demarking where to split. If not provided, each character in the split string becomes an array item.\n * @return Array\n */\nfunction greenSplit (str, splitter) {\n    var str = str.toString(),\n        d = 0,\n        i = 0,\n        arr = _array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\n    \n    if (splitter) {\n        i = str.indexOf(splitter);\n        d = splitter.length;\n\n        while (i >= 0) {\n            arr.push(str.substr(0, i));\n            str = str.substr(i + d);\n            i = str.indexOf(splitter);\n        }\n        \n        arr.push(str);\n    } else {\n        i = str.length;\n        d = i - 1;\n\n        while (i--) {\n            arr.push(str[d - i]);\n        }\n    }\n    \n    return arr;\n}\n\n//# sourceURL=webpack://platypus/./src/utils/string.js?");

/***/ }),

/***/ "@tweenjs/tween.js":
/*!************************************!*\
  !*** external "@tweenjs/tween.js" ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = @tweenjs/tween.js;\n\n//# sourceURL=webpack://platypus/external_%22@tweenjs/tween.js%22?");

/***/ }),

/***/ "pixi-sound":
/*!*****************************!*\
  !*** external "pixi-sound" ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = pixi-sound;\n\n//# sourceURL=webpack://platypus/external_%22pixi-sound%22?");

/***/ }),

/***/ "pixi.js":
/*!**************************!*\
  !*** external "pixi.js" ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = pixi.js;\n\n//# sourceURL=webpack://platypus/external_%22pixi.js%22?");

/***/ }),

/***/ "springroll":
/*!*****************************!*\
  !*** external "springroll" ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = springroll;\n\n//# sourceURL=webpack://platypus/external_%22springroll%22?");

/***/ })

/******/ });