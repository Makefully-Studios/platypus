<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="../assets/css/yui-cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/x-icon" href="../assets/favicon.ico">
    <script src="../assets/js/yui-source.js"></script>
	<title>platypus v2.0.0 API Documentation : src\components\Camera.js</title>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><a href="https://github.com/PBS-KIDS/Platypus"><img src="..\assets\platypus-title.png" title="platypus"></a></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Documentation for: 2.0.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/platypus.AABB.html">platypus.AABB</a></li>
                                <li><a href="../classes/platypus.ActionState.html">platypus.ActionState</a></li>
                                <li><a href="../classes/platypus.AssetManager.html">platypus.AssetManager</a></li>
                                <li><a href="../classes/platypus.Async.html">platypus.Async</a></li>
                                <li><a href="../classes/platypus.CollisionData.html">platypus.CollisionData</a></li>
                                <li><a href="../classes/platypus.CollisionDataContainer.html">platypus.CollisionDataContainer</a></li>
                                <li><a href="../classes/platypus.CollisionShape.html">platypus.CollisionShape</a></li>
                                <li><a href="../classes/platypus.Component.html">platypus.Component</a></li>
                                <li><a href="../classes/platypus.components.AIChaser.html">platypus.components.AIChaser</a></li>
                                <li><a href="../classes/platypus.components.AIPacer.html">platypus.components.AIPacer</a></li>
                                <li><a href="../classes/platypus.components.AudioMusic.html">platypus.components.AudioMusic</a></li>
                                <li><a href="../classes/platypus.components.AudioSFX.html">platypus.components.AudioSFX</a></li>
                                <li><a href="../classes/platypus.components.AudioVO.html">platypus.components.AudioVO</a></li>
                                <li><a href="../classes/platypus.components.Camera.html">platypus.components.Camera</a></li>
                                <li><a href="../classes/platypus.components.CameraFollowMe.html">platypus.components.CameraFollowMe</a></li>
                                <li><a href="../classes/platypus.components.CollisionBasic.html">platypus.components.CollisionBasic</a></li>
                                <li><a href="../classes/platypus.components.CollisionFilter.html">platypus.components.CollisionFilter</a></li>
                                <li><a href="../classes/platypus.components.CollisionGroup.html">platypus.components.CollisionGroup</a></li>
                                <li><a href="../classes/platypus.components.CollisionTiles.html">platypus.components.CollisionTiles</a></li>
                                <li><a href="../classes/platypus.components.ComponentSwitcher.html">platypus.components.ComponentSwitcher</a></li>
                                <li><a href="../classes/platypus.components.Counter.html">platypus.components.Counter</a></li>
                                <li><a href="../classes/platypus.components.EntityContainer.html">platypus.components.EntityContainer</a></li>
                                <li><a href="../classes/platypus.components.EntityController.html">platypus.components.EntityController</a></li>
                                <li><a href="../classes/platypus.components.HandlerCollision.html">platypus.components.HandlerCollision</a></li>
                                <li><a href="../classes/platypus.components.HandlerController.html">platypus.components.HandlerController</a></li>
                                <li><a href="../classes/platypus.components.HandlerLogic.html">platypus.components.HandlerLogic</a></li>
                                <li><a href="../classes/platypus.components.HandlerRender.html">platypus.components.HandlerRender</a></li>
                                <li><a href="../classes/platypus.components.Interactive.html">platypus.components.Interactive</a></li>
                                <li><a href="../classes/platypus.components.LevelBuilder.html">platypus.components.LevelBuilder</a></li>
                                <li><a href="../classes/platypus.components.LogicAngularMovement.html">platypus.components.LogicAngularMovement</a></li>
                                <li><a href="../classes/platypus.components.LogicAttachment.html">platypus.components.LogicAttachment</a></li>
                                <li><a href="../classes/platypus.components.LogicButton.html">platypus.components.LogicButton</a></li>
                                <li><a href="../classes/platypus.components.LogicCarrier.html">platypus.components.LogicCarrier</a></li>
                                <li><a href="../classes/platypus.components.LogicDestroyMe.html">platypus.components.LogicDestroyMe</a></li>
                                <li><a href="../classes/platypus.components.LogicDirectionalMovement.html">platypus.components.LogicDirectionalMovement</a></li>
                                <li><a href="../classes/platypus.components.LogicDragDrop.html">platypus.components.LogicDragDrop</a></li>
                                <li><a href="../classes/platypus.components.LogicPortable.html">platypus.components.LogicPortable</a></li>
                                <li><a href="../classes/platypus.components.LogicRotationalMovement.html">platypus.components.LogicRotationalMovement</a></li>
                                <li><a href="../classes/platypus.components.LogicTimer.html">platypus.components.LogicTimer</a></li>
                                <li><a href="../classes/platypus.components.LogicWindUpRacer.html">platypus.components.LogicWindUpRacer</a></li>
                                <li><a href="../classes/platypus.components.Motion.html">platypus.components.Motion</a></li>
                                <li><a href="../classes/platypus.components.Mover.html">platypus.components.Mover</a></li>
                                <li><a href="../classes/platypus.components.NodeMap.html">platypus.components.NodeMap</a></li>
                                <li><a href="../classes/platypus.components.NodeResident.html">platypus.components.NodeResident</a></li>
                                <li><a href="../classes/platypus.components.Orientation.html">platypus.components.Orientation</a></li>
                                <li><a href="../classes/platypus.components.RandomEvents.html">platypus.components.RandomEvents</a></li>
                                <li><a href="../classes/platypus.components.RelativePosition.html">platypus.components.RelativePosition</a></li>
                                <li><a href="../classes/platypus.components.RelayFamily.html">platypus.components.RelayFamily</a></li>
                                <li><a href="../classes/platypus.components.RelayGame.html">platypus.components.RelayGame</a></li>
                                <li><a href="../classes/platypus.components.RelayLinker.html">platypus.components.RelayLinker</a></li>
                                <li><a href="../classes/platypus.components.RelayParent.html">platypus.components.RelayParent</a></li>
                                <li><a href="../classes/platypus.components.RelaySelf.html">platypus.components.RelaySelf</a></li>
                                <li><a href="../classes/platypus.components.RenderAnimator.html">platypus.components.RenderAnimator</a></li>
                                <li><a href="../classes/platypus.components.RenderContainer.html">platypus.components.RenderContainer</a></li>
                                <li><a href="../classes/platypus.components.RenderDebug.html">platypus.components.RenderDebug</a></li>
                                <li><a href="../classes/platypus.components.RenderDestroyMe.html">platypus.components.RenderDestroyMe</a></li>
                                <li><a href="../classes/platypus.components.RenderProgress.html">platypus.components.RenderProgress</a></li>
                                <li><a href="../classes/platypus.components.RenderSpine.html">platypus.components.RenderSpine</a></li>
                                <li><a href="../classes/platypus.components.RenderSprite.html">platypus.components.RenderSprite</a></li>
                                <li><a href="../classes/platypus.components.RenderText.html">platypus.components.RenderText</a></li>
                                <li><a href="../classes/platypus.components.RenderTiles.html">platypus.components.RenderTiles</a></li>
                                <li><a href="../classes/platypus.components.SceneChanger.html">platypus.components.SceneChanger</a></li>
                                <li><a href="../classes/platypus.components.TiledLoader.html">platypus.components.TiledLoader</a></li>
                                <li><a href="../classes/platypus.components.Timeline.html">platypus.components.Timeline</a></li>
                                <li><a href="../classes/platypus.components.Tutorial.html">platypus.components.Tutorial</a></li>
                                <li><a href="../classes/platypus.components.Tween.html">platypus.components.Tween</a></li>
                                <li><a href="../classes/platypus.components.VoiceOver.html">platypus.components.VoiceOver</a></li>
                                <li><a href="../classes/platypus.components.XHR.html">platypus.components.XHR</a></li>
                                <li><a href="../classes/platypus.Data.html">platypus.Data</a></li>
                                <li><a href="../classes/platypus.DataMap.html">platypus.DataMap</a></li>
                                <li><a href="../classes/platypus.Entity.html">platypus.Entity</a></li>
                                <li><a href="../classes/platypus.EntityLinker.html">platypus.EntityLinker</a></li>
                                <li><a href="../classes/platypus.Game.html">platypus.Game</a></li>
                                <li><a href="../classes/platypus.Gamepad.html">platypus.Gamepad</a></li>
                                <li><a href="../classes/platypus.Messenger.html">platypus.Messenger</a></li>
                                <li><a href="../classes/platypus.PIXIAnimation.html">platypus.PIXIAnimation</a></li>
                                <li><a href="../classes/platypus.SFXPlayer.html">platypus.SFXPlayer</a></li>
                                <li><a href="../classes/platypus.StateMap.html">platypus.StateMap</a></li>
                                <li><a href="../classes/platypus.Storage.html">platypus.Storage</a></li>
                                <li><a href="../classes/platypus.Vector.html">platypus.Vector</a></li>
                                <li><a href="../classes/platypus.VOPlayer.html">platypus.VOPlayer</a></li>
                                <li><a href="../classes/window.Map.html">window.Map</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/platypus.html">platypus</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
            <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <script>
                        	var name = src\components\Camera.js      
                        </script>
                        <h1 class="file-heading">File:src\components\Camera.js</h1>
                        
                        <div class="file">
                            <pre class="code prettyprint linenums">
                        /**
                         * This component controls the game camera deciding where and how it should move. The camera also broadcasts messages when the window resizes or its orientation changes.
                         *
                         * @namespace platypus.components
                         * @class Camera
                         * @uses platypus.Component
                        */
                        /*global platypus, window */
                        import AABB from &#x27;../AABB.js&#x27;;
                        import {Container} from &#x27;pixi.js&#x27;;
                        import Data from &#x27;../Data.js&#x27;;
                        import TweenJS from &#x27;@tweenjs/tween.js&#x27;;
                        import Vector from &#x27;../Vector.js&#x27;;
                        import createComponentClass from &#x27;../factory.js&#x27;;
                        
                        export default (function () {
                            var DPR = window.devicePixelRatio || 1,
                                anchorBound = function (anchorAABB, entityOffsetX, entityOffsetY, entity) {
                                    var aabb = AABB.setUp(entity.x + entityOffsetX, entity.y + entityOffsetY, entity.width, entity.height),
                                        x = anchorAABB.x,
                                        y = anchorAABB.y;
                        
                                    if (aabb.top &lt; anchorAABB.top) {
                                        y -= (anchorAABB.top - aabb.top);
                                    } else if (aabb.bottom &gt; anchorAABB.bottom) {
                                        y += (anchorAABB.bottom - aabb.bottom);
                                    }
                                    
                                    if (aabb.left &lt; anchorAABB.left) {
                                        x -= (anchorAABB.left - aabb.left);
                                    } else if (aabb.right &gt; anchorAABB.right) {
                                        x += (anchorAABB.right - aabb.right);
                                    }
                                    
                                    aabb.recycle();
                                    
                                    return this.move(x, y, 0);
                                },
                                doNothing = function () {
                                    return false;
                                },
                        
                                // These fix coords for touch events filling in for pointer events from the PIXI InteractiveManager
                                getClientX = function (event) {
                                    if (!event.clientX) {
                                        if (event.touches &amp;&amp; event.touches[0] &amp;&amp; event.touches[0].clientX) {
                                            return event.touches[0].clientX;
                                        }
                                        return 0;
                                    }
                                    return event.clientX;
                                },
                                getClientY = function (event) {
                                    if (!event.clientY) {
                                        if (event.touches &amp;&amp; event.touches[0] &amp;&amp; event.touches[0].clientY) {
                                            return event.touches[0].clientY;
                                        }
                                        return 0;
                                    }
                                    return event.clientY;
                                };
                            
                            return createComponentClass({
                                id: &#x27;Camera&#x27;,
                                properties: {
                                    /**
                                     * Number specifying width of viewport in world coordinates.
                                     *
                                     * @property width
                                     * @type number
                                     * @default 0
                                     **/
                                    &quot;width&quot;: 0,
                                     
                                    /**
                                     * Number specifying height of viewport in world coordinates.
                                     *
                                     * @property height
                                     * @type number
                                     * @default 0
                                     **/
                                    &quot;height&quot;: 0,
                                    
                                    /**
                                     * Specifies whether the camera should be draggable via the mouse by setting to &#x27;pan&#x27;.
                                     *
                                     * @property mode
                                     * @type String
                                     * @default &#x27;static&#x27;
                                     **/
                                    &quot;mode&quot;: &quot;static&quot;,
                                    
                                    /**
                                     * Whether camera overflows to cover the whole canvas or remains contained within its aspect ratio&#x27;s boundary.
                                     *
                                     * @property overflow
                                     * @type boolean
                                     * @default false
                                     */
                                    &quot;overflow&quot;: false,
                                    
                                    /**
                                     * Boolean value that determines whether the camera should stretch the world viewport when window is resized. Defaults to false which maintains the proper aspect ratio.
                                     *
                                     * @property stretch
                                     * @type boolean
                                     * @default: false
                                     */
                                    &quot;stretch&quot;: false,
                                    
                                    /**
                                     * Sets how many units the followed entity can move before the camera will re-center. This should be lowered for small-value coordinate systems such as Box2D.
                                     *
                                     * @property threshold
                                     * @type number
                                     * @default 1
                                     **/
                                    &quot;threshold&quot;: 1,
                                    
                                    /**
                                     * Whether, when following an entity, the camera should rotate to match the entity&#x27;s orientation.
                                     *
                                     * @property rotate
                                     * @type boolean
                                     * @default false
                                     **/
                                    &quot;rotate&quot;: false,
                        
                                    /**
                                     * Number specifying the horizontal center of viewport in world coordinates.
                                     *
                                     * @property x
                                     * @type number
                                     * @default 0
                                     **/
                                    &quot;x&quot;: 0,
                                     
                                    /**
                                     * Number specifying the vertical center of viewport in world coordinates.
                                     *
                                     * @property y
                                     * @type number
                                     * @default 0
                                     **/
                                    &quot;y&quot;: 0
                                },
                                publicProperties: {
                                    /**
                                     * The entity&#x27;s canvas element is used to determine the window size of the camera.
                                     *
                                     * @property canvas
                                     * @type DOMElement Canvas
                                     * @default null
                                     */
                                    &quot;canvas&quot;: null,
                                    
                                    /**
                                     * Sets how quickly the camera should pan to a new position in the horizontal direction.
                                     *
                                     * @property transitionX
                                     * @type number
                                     * @default 400
                                     **/
                                    &quot;transitionX&quot;: 400,
                                    
                                    /**
                                     * Sets how quickly the camera should pan to a new position in the vertical direction.
                                     *
                                     * @property transitionY
                                     * @type number
                                     * @default 600
                                     **/
                                    &quot;transitionY&quot;: 600,
                                     
                                    /**
                                     * Sets how quickly the camera should rotate to a new orientation.
                                     *
                                     * @property transitionAngle
                                     * @type number
                                     * @default: 600
                                     **/
                                    &quot;transitionAngle&quot;: 600,
                        
                                    /**
                                     * Sets the z-order of this layer relative to other loaded layers.
                                     *
                                     * @property z
                                     * @type Number
                                     * @default 0
                                     */
                                    &quot;z&quot;: 0
                                },
                                initialize: function (definition) {
                                    var worldVP = AABB.setUp(this.x, this.y, this.width, this.height),
                                        worldCamera = Data.setUp(
                                            &quot;viewport&quot;, worldVP,
                                            &quot;orientation&quot;, definition.orientation || 0
                                        );
                        
                                    //The dimensions of the camera in the window
                                    this.viewport = AABB.setUp(0, 0, 0, 0);
                                    
                                    //The dimensions of the camera in the game world
                                    this.worldCamera = worldCamera;
                        
                                    //Message object defined here so it&#x27;s reusable
                                    this.worldDimensions = AABB.setUp();
                                    this.message = Data.setUp(
                                        &quot;viewport&quot;, AABB.setUp(),
                                        &quot;scaleX&quot;, 0,
                                        &quot;scaleY&quot;, 0,
                                        &quot;orientation&quot;, 0,
                                        &quot;stationary&quot;, false,
                                        &quot;world&quot;, this.worldDimensions
                                    );
                                    this.cameraLoadedMessage = Data.setUp(
                                        &quot;viewport&quot;, this.message.viewport,
                                        &quot;world&quot;, this.worldDimensions
                                    );
                            
                                    //Whether the map has finished loading.
                                    this.worldIsLoaded = false;
                                    
                                    this.following = null;
                                    this.state = &#x27;static&#x27;;//&#x27;roaming&#x27;;
                                    if (this.mode === &#x27;pan&#x27;) {
                                        this.state = &#x27;mouse-pan&#x27;;
                                    }
                                    
                                    //FOLLOW MODE VARIABLES
                                    
                                    //--Bounding
                                    this.boundingBox = AABB.setUp(worldVP.x, worldVP.y, worldVP.width / 2, worldVP.height / 2);
                                    
                                    //Forward Follow
                                    this.lastX = worldVP.x;
                                    this.lastY = worldVP.y;
                                    this.lastOrientation = worldCamera.orientation;
                                    this.forwardX = 0;
                                    this.forwardY = 0;
                                    this.forwardAngle = 0;
                                    this.averageOffsetX = 0;
                                    this.averageOffsetY = 0;
                                    this.averageOffsetAngle = 0;
                                    this.offsetX = 0;
                                    this.offsetY = 0;
                                    this.offsetAngle = 0;
                                    this.forwardFollower = Data.setUp(
                                        &quot;x&quot;, this.lastX,
                                        &quot;y&quot;, this.lastY,
                                        &quot;orientation&quot;, this.lastOrientation
                                    );
                                    
                                    this.lastFollow = Data.setUp(
                                        &quot;entity&quot;, null,
                                        &quot;mode&quot;, null,
                                        &quot;offsetX&quot;, 0,
                                        &quot;offsetY&quot;, 0,
                                        &quot;begin&quot;, 0
                                    );
                                    
                                    this.xMagnitude = 0;
                                    this.yMagnitude = 0;
                                    this.xWaveLength = 0;
                                    this.yWaveLength = 0;
                                    this.xShakeTime = 0;
                                    this.yShakeTime = 0;
                                    this.shakeTime = 0;
                                    this.shakeIncrementor = 0;
                                    
                                    this.direction = true;
                                    this.stationary = false;
                                    
                                    this.viewportUpdate = false;
                                    
                                    if (this.owner.container) {
                                        this.parentContainer = this.owner.container;
                                    } else if (this.owner.stage) {
                                        this.canvas = this.canvas || platypus.game.canvas; //TODO: Probably need to find a better way to handle resizing - DDD 10/4/2015
                                        this.parentContainer = this.owner.stage;
                                        this.owner.width  = this.canvas.width;
                                        this.owner.height = this.canvas.height;
                                    } else {
                                        platypus.debug.warn(&#x27;Camera: There appears to be no Container on this entity for the camera to display.&#x27;);
                                    }
                                    this.container = new Container();
                                    this.container.zIndex = this.z;
                                    this.container.visible = false;
                                    this.parentContainer.addChild(this.container);
                                    this.movedCamera = false;
                                },
                                events: {
                                    /**
                                     * Sets up the camera window size on load.
                                     *
                                     * @method &#x27;load&#x27;
                                     */
                                    &quot;load&quot;: function () {
                                        this.resize();
                                    },
                                    
                                    /**
                                     * On receiving this message, the camera begins viewing the world.
                                     *
                                     * @method &#x27;render-world&#x27;
                                     * @param data {Object} Information about the world.
                                     * @param data.world {PIXI.Container} The container containing world entities.
                                     */
                                    &quot;render-world&quot;: function (data) {
                                        this.world = data.world;
                                        this.container.addChild(this.world);
                                    },
                                    
                                    /**
                                     * The viewport is flagged to update when children are added.
                                     *
                                     * @method &#x27;child-entity-added&#x27;
                                     * @param entity {platypus.Entity} Expects an entity as the message object.
                                      **/
                                    &quot;child-entity-added&quot;: function (entity) {
                                        this.viewportUpdate = true;
                                        
                                        if (this.worldIsLoaded) {
                                            /**
                                             * On receiving a &quot;world-loaded&quot; message, the camera broadcasts the world size to all children in the world.
                                             *
                                             * @event &#x27;camera-loaded&#x27;
                                             * @param message
                                             * @param message.world {platypus.AABB} The dimensions of the world map.
                                             **/
                                            entity.triggerEvent(&#x27;camera-loaded&#x27;, this.cameraLoadedMessage);
                                        }
                                    },
                        
                                    /**
                                     * Triggers &quot;camera-update&quot; on newly changed entities.
                                     *
                                     * @method &#x27;child-entity-updated&#x27;
                                     * @param entity {platypus.Entity} Expects an entity as the message object to determine whether to trigger &#x60;camera-update&#x60; on it.
                                     **/
                                    &quot;child-entity-updated&quot;: function (entity) {
                                        this.viewportUpdate = true;
                                        
                                        if (this.worldIsLoaded) {
                                            entity.triggerEvent(&#x27;camera-update&#x27;, this.message);
                                        }
                                    },
                        
                                    /**
                                     * On receiving this message, the camera updates its world location and size as necessary. An example of this message is triggered by the [TiledLoader](platypus.components.TiledLoader.html) component.
                                     *
                                     * @method &#x27;world-loaded&#x27;
                                     * @param message {Object}
                                     * @param [message.width] {number} The width of the loaded world.
                                     * @param [message.height] {number} The height of the loaded world.
                                     * @param [message.camera] {platypus.Entity} An entity that the camera should follow in the loaded world.
                                     **/
                                    &quot;world-loaded&quot;: function (values) {
                                        var msg = this.message;
                                        
                                        msg.viewport.set(this.worldCamera.viewport);
                                        this.worldDimensions.set(values.world);
                                        
                                        this.worldIsLoaded = true;
                                        if (values.camera) {
                                            this.follow(values.camera);
                                        }
                                        if (this.owner.triggerEventOnChildren) {
                                            this.owner.triggerEventOnChildren(&#x27;camera-loaded&#x27;, this.cameraLoadedMessage);
                                        }
                                        this.updateMovementMethods();
                                    },
                                    
                                    /**
                                     * If mouse dragging should cause the camera to move, this listens for the beginning of the drag motion.
                                     *
                                     * @method &#x27;pointerdown&#x27;
                                     * @param event {Object} The pointer event.
                                     **/
                                    &quot;pointerdown&quot;: function (event) {
                                        var worldVP = this.worldCamera.viewport;
                        
                                        if (this.state === &#x27;mouse-pan&#x27;) {
                                            if (!this.mouseVector) {
                                                this.mouseVector = Vector.setUp();
                                                this.mouseWorldOrigin = Vector.setUp();
                                            }
                                            this.mouse = this.mouseVector;
                                            this.mouse.x = getClientX(event.event);
                                            this.mouse.y = getClientY(event.event);
                                            this.mouseWorldOrigin.x = worldVP.x;
                                            this.mouseWorldOrigin.y = worldVP.y;
                                            event.pixiEvent.stopPropagation();
                                        }
                                    },
                                    
                                    /**
                                     * If mouse dragging should cause the camera to move, this listens the drag motion.
                                     *
                                     * @method &#x27;pressmove&#x27;
                                     * @param event {Object} The pointer event.
                                     **/
                                    &quot;pressmove&quot;: function (event) {
                                        if (this.mouse) {
                                            if (this.move(this.mouseWorldOrigin.x + ((this.mouse.x - getClientX(event.event)) * DPR) / this.world.transform.worldTransform.a, this.mouseWorldOrigin.y + ((this.mouse.y - getClientY(event.event)) * DPR) / this.world.transform.worldTransform.d)) {
                                                this.viewportUpdate = true;
                                                this.movedCamera = true;
                                                event.pixiEvent.stopPropagation();
                                            }
                                        }
                                    },
                        
                                    /**
                                     * If mouse dragging should cause the camera to move, this listens for the end of the drag motion.
                                     *
                                     * @method &#x27;pressup&#x27;
                                     * @param event {Object} The pointer event.
                                     **/
                                    &quot;pressup&quot;: function (event) {
                                        if (this.mouse) {
                                            this.mouse = null;
                                            if (this.movedCamera) {
                                                this.movedCamera = false;
                                                event.pixiEvent.stopPropagation();
                                            }
                                        }
                                    },
                                    
                                    /**
                                     * On a &quot;tick&quot; step event, the camera updates its location according to its current state.
                                     *
                                     * @method &#x27;tick&#x27;
                                     * @param message {Object}
                                     * @param message.delta {Number} If necessary, the current camera update function may require the length of the tick to adjust movement rate.
                                     **/
                                    &quot;tick&quot;: function (resp) {
                                        if ((this.state === &#x27;following&#x27;) &amp;&amp; this.followingFunction(this.following, resp.delta)) {
                                            this.viewportUpdate = true;
                                        }
                                        
                                        // Need to update owner&#x27;s size information for changes to canvas size
                                        if (this.canvas) {
                                            this.owner.width  = this.canvas.width;
                                            this.owner.height = this.canvas.height;
                                        }
                                        
                                        // Check for owner resizing
                                        if ((this.owner.width !== this.lastWidth) || (this.owner.height !== this.lastHeight)) {
                                            this.resize();
                                            this.lastWidth = this.owner.width;
                                            this.lastHeight = this.owner.height;
                                        }
                        
                                        if (this.shakeIncrementor &lt; this.shakeTime) {
                                            const viewport = this.worldCamera.viewport;
                        
                                            this.viewportUpdate = true;
                                            this.shakeIncrementor += resp.delta;
                                            this.shakeIncrementor = Math.min(this.shakeIncrementor, this.shakeTime);
                                            
                                            if (this.shakeIncrementor &lt; this.xShakeTime) {
                                                viewport.moveX(viewport.x + Math.sin((this.shakeIncrementor / this.xWaveLength) * (Math.PI * 2)) * this.xMagnitude);
                                            }
                                            
                                            if (this.shakeIncrementor &lt; this.yShakeTime) {
                                                viewport.moveY(viewport.y + Math.sin((this.shakeIncrementor / this.yWaveLength) * (Math.PI * 2)) * this.yMagnitude);
                                            }
                                        }
                        
                                        this.updateViewport();
                                        
                                        if (this.lastFollow.begin) {
                                            if (this.lastFollow.begin &lt; Date.now()) {
                                                this.follow(this.lastFollow);
                                            }
                                        }
                        
                                        if (this.container.zIndex !== this.z) {
                                            this.container.zIndex = this.z;
                                        }
                                    },
                                    
                                    /**
                                    * The camera listens for this event to change its world viewport size.
                                    *
                                    * @method &#x27;resize-camera&#x27;
                                    * @param [dimensions] {Object} List of key/value pairs describing new viewport size
                                    * @param dimensions.width {number} Width of the camera viewport
                                    * @param dimensions.height {number} Height of the camera viewport
                                    * @param dimensions.time {number} Time in millseconds over which to tween the scale change.
                                    * @param [forceUpdate] {Boolean} Whether to update graphics.
                                    **/
                                    &quot;resize-camera&quot;: function (dimensions = {}, forceUpdate = false) {
                                        const
                                            {width, height, time, ease} = dimensions,
                                            forcedUpdate = forceUpdate || dimensions.forceUpdate;
                        
                                        if (time) {
                                            const
                                                tween = new TweenJS.Tween(this);
                                            
                                            tween.to({width, height}, time);
                                            if (ease) {
                                                tween.easing(ease);
                                            }
                                            tween.onUpdate(() =&gt; {
                                                this.resize();
                                            }).start();
                                        } else {
                                            if (width &amp;&amp; height) {
                                                this.width = dimensions.width;
                                                this.height = dimensions.height;
                                            }
                                            if (this.canvas) {
                                                this.owner.width  = this.canvas.width;
                                                this.owner.height = this.canvas.height;
                                            }
                                            this.resize();
                                        }
                                        if (forcedUpdate) {
                                            this.updateViewport();
                                            this.owner.triggerEvent(&#x27;render-update&#x27;);
                                        }
                                    },
                        
                                    /**
                                     * The camera listens for this event to change its position in the world.
                                     *
                                     * @method &#x27;relocate&#x27;
                                     * @param location {Vector|Object} List of key/value pairs describing new location
                                     * @param location.x {Number} New position along the x-axis.
                                     * @param location.y {Number} New position along the y-axis.
                                     * @param [location.time] {Number} The time to transition to the new location.
                                     * @param [location.ease] {Function} The ease function to use. Defaults to a linear transition.
                                     */
                                    &quot;relocate&quot;: (function () {
                                        var move = function (v) {
                                                if (this.move(v.x, v.y)) {
                                                    this.viewportUpdate = true;
                                                }
                                            },
                                            stop = function () {
                                                this.recycle();
                                            };
                        
                                        return function (location) {
                                            if (location.time) {
                                                const
                                                    worldVP = this.worldCamera.viewport,
                                                    v = Vector.setUp(worldVP.x, worldVP.y),
                                                    tween = new TweenJS.Tween(v);
                                                
                                                tween.to({x: location.x, y: location.y}, location.time);
                                                if (location.ease) {
                                                    tween.easing(location.ease);
                                                }
                                                tween.onUpdate(move.bind(this, v)).onStop(stop.bind(v)).start();
                                            } else if (this.move(location.x, location.y)) {
                                                this.viewportUpdate = true;
                                            }
                                        };
                                    }()),
                                    
                                    /**
                                    * On receiving this message, the camera begins following the requested object.
                                    *
                                    * @method &#x27;follow&#x27;
                                    * @param message {Object}
                                    * @param message.mode {String} Can be &quot;locked&quot;, &quot;forward&quot;, &quot;bounding&quot;, &quot;anchor-bound&quot;, or &quot;static&quot;. &quot;static&quot; suspends following, but the other three settings require that the entity parameter be defined. Also set the bounding area parameters if sending &quot;bounding&quot; as the following method and the movement parameters if sending &quot;forward&quot; as the following method.
                                    * @param [message.entity] {platypus.Entity} The entity that the camera should commence following.
                                    * @param [message.top] {number} The top of a bounding box following an entity.
                                    * @param [message.left] {number} The left of a bounding box following an entity.
                                    * @param [message.width] {number} The width of a bounding box following an entity.
                                    * @param [message.height] {number} The height of a bounding box following an entity.
                                    * @param [message.movementX] {number} Movement multiplier for focusing the camera ahead of a moving entity in the horizontal direction.
                                    * @param [message.movementY] {number} Movement multiplier for focusing the camera ahead of a moving entity in the vertical direction.
                                    * @param [message.offsetX] {number} How far to offset the camera from the entity horizontally.
                                    * @param [message.offsetY] {number} How far to offset the camera from the entity vertically.
                                    * @param [message.time] {number} How many milliseconds to follow the entity.
                                    **/
                                    &quot;follow&quot;: function (def) {
                                        this.follow(def);
                                    },
                                    
                                    /**
                                    * On receiving this message, the camera will shake around its target location.
                                    *
                                    * @method &#x27;shake&#x27;
                                    * @param shake {Object}
                                    * @param [shake.xMagnitude] {number} How much to move along the x axis.
                                    * @param [shake.yMagnitude] {number} How much to move along the y axis.
                                    * @param [shake.xFrequency] {number} How quickly to shake along the x axis.
                                    * @param [shake.yFrequency] {number} How quickly to shake along the y axis.
                                    * @param [shake.time] {number} How long the camera should shake.
                                    **/
                                    &quot;shake&quot;: function (shakeDef) {
                                        var def = shakeDef || {},
                                            xMag    = def.xMagnitude || 0,
                                            yMag    = def.yMagnitude || 0,
                                            xFreq   = def.xFrequency || 0, //Cycles per second
                                            yFreq   = def.yFrequency || 0, //Cycles per second
                                            second  = 1000,
                                            time    = def.time || 0;
                                        
                                        this.viewportUpdate = true;
                                        
                                        this.shakeIncrementor = 0;
                                        
                                        this.xMagnitude = xMag;
                                        this.yMagnitude = yMag;
                                        
                                        if (xFreq === 0) {
                                            this.xWaveLength = 1;
                                            this.xShakeTime = 0;
                                        } else {
                                            this.xWaveLength = (second / xFreq);
                                            this.xShakeTime = Math.ceil(time / this.xWaveLength) * this.xWaveLength;
                                        }
                                        
                                        if (yFreq === 0) {
                                            this.yWaveLength = 1;
                                            this.yShakeTime = 0;
                                        } else {
                                            this.yWaveLength = (second / yFreq);
                                            this.yShakeTime = Math.ceil(time / this.yWaveLength) * this.yWaveLength;
                                        }
                                        
                                        this.shakeTime = Math.max(this.xShakeTime, this.yShakeTime);
                                    }
                                },
                                
                                methods: {
                                    follow: function (def) {
                                        var portion = 0.1;
                                        
                                        if (def.time) { //save current follow
                                            if (!this.lastFollow.begin) {
                                                this.lastFollow.entity = this.following;
                                                this.lastFollow.mode   = this.mode;
                                                this.lastFollow.offsetX = this.offsetX;
                                                this.lastFollow.offsetY = this.offsetY;
                                            }
                                            this.lastFollow.begin  = Date.now() + def.time;
                                        } else if (this.lastFollow.begin) {
                                            this.lastFollow.begin = 0;
                                        }
                                        
                                        this.mode = def.mode;
                                        
                                        switch (def.mode) {
                                        case &#x27;locked&#x27;:
                                            this.state = &#x27;following&#x27;;
                                            this.following = def.entity;
                                            this.followingFunction = this.lockedFollow;
                                            this.offsetX = def.offsetX || 0;
                                            this.offsetY = def.offsetY || 0;
                                            this.offsetAngle = def.offsetAngle || 0;
                                            break;
                                        case &#x27;forward&#x27;:
                                            this.state = &#x27;following&#x27;;
                                            this.followFocused   = false;
                                            this.following       = def.entity;
                                            this.lastX           = def.entity.x - def.offsetX || 0;
                                            this.lastY           = def.entity.y - def.offsetY || 0;
                                            this.lastOrientation = def.entity.orientation || 0;
                                            this.forwardX  = def.movementX || (this.transitionX * portion);
                                            this.forwardY  = def.movementY || (this.transitionY * portion);
                                            this.averageOffsetX = 0;
                                            this.averageOffsetY = 0;
                                            this.averageOffsetAngle = 0;
                                            this.offsetX = def.offsetX || 0;
                                            this.offsetY = def.offsetY || 0;
                                            this.offsetAngle = def.offsetAngle || 0;
                                            this.followingFunction = this.forwardFollow;
                                            break;
                                        case &#x27;bounding&#x27;:
                                            this.state = &#x27;following&#x27;;
                                            this.following = def.entity;
                                            this.offsetX = def.offsetX || 0;
                                            this.offsetY = def.offsetY || 0;
                                            this.offsetAngle = def.offsetAngle || 0;
                                            this.boundingBox.setAll(def.x, def.y, def.width, def.height);
                                            this.followingFunction = this.boundingFollow;
                                            break;
                                        case &#x27;anchor-bound&#x27;:
                                            this.state = &#x27;following&#x27;;
                                            this.following = def.entity;
                                            this.followingFunction = anchorBound.bind(this, def.anchorAABB, def.offsetX || 0, def.offsetY || 0);
                                            break;
                                        case &#x27;pan&#x27;:
                                            this.state = &#x27;mouse-pan&#x27;;
                                            this.following = null;
                                            this.followingFunction = null;
                                            if (def &amp;&amp; (typeof def.x === &#x27;number&#x27;) &amp;&amp; (typeof def.y === &#x27;number&#x27;)) {
                                                this.move(def.x, def.y, def.orientation || 0);
                                                this.viewportUpdate = true;
                                            }
                                            break;
                                        default:
                                            this.state = &#x27;static&#x27;;
                                            this.following = null;
                                            this.followingFunction = null;
                                            if (def &amp;&amp; (typeof def.x === &#x27;number&#x27;) &amp;&amp; (typeof def.y === &#x27;number&#x27;)) {
                                                this.move(def.x, def.y, def.orientation || 0);
                                                this.viewportUpdate = true;
                                            }
                                            break;
                                        }
                                        
                                        if (def.begin) { // get rid of last follow
                                            def.begin = 0;
                                        }
                        
                                    },
                                    
                                    move: function (x, y, newOrientation) {
                                        var moved = this.moveX(x);
                                        moved = this.moveY(y) || moved;
                                        if (this.rotate) {
                                            moved = this.reorient(newOrientation || 0) || moved;
                                        }
                                        return moved;
                                    },
                                    
                                    moveX: doNothing,
                                    
                                    moveY: doNothing,
                                    
                                    reorient: function (newOrientation) {
                                        var errMargin = 0.0001,
                                            worldCamera = this.worldCamera;
                                        
                                        if (Math.abs(worldCamera.orientation - newOrientation) &gt; errMargin) {
                                            worldCamera.orientation = newOrientation;
                                            return true;
                                        }
                                        return false;
                                    },
                                    
                                    lockedFollow: (function () {
                                        var min = Math.min,
                                            getTransitionalPoint = function (a, b, ratio) {
                                                // Find point between two points according to ratio.
                                                return ratio * b + (1 - ratio) * a;
                                            },
                                            getRatio = function (transition, time) {
                                                // Look at the target transition time (in milliseconds) and set up ratio accordingly.
                                                if (transition) {
                                                    return min(time / transition, 1);
                                                } else {
                                                    return 1;
                                                }
                                            };
                                        
                                        return function (entity, time) {
                                            var worldCamera = this.worldCamera,
                                                worldVP = worldCamera.viewport,
                                                x = getTransitionalPoint(worldVP.x, entity.x + this.offsetX, getRatio(this.transitionX, time)),
                                                y = getTransitionalPoint(worldVP.y, entity.y + this.offsetY, getRatio(this.transitionY, time));
                        
                                            if (this.rotate) { // Only run the orientation calculations if we need them.
                                                return this.move(x, y, getTransitionalPoint(worldCamera.orientation, -(entity.orientation || 0), getRatio(this.transitionAngle, time)));
                                            } else {
                                                return this.move(x, y, 0);
                                            }
                                        };
                                    }()),
                                    
                                    forwardFollow: function (entity, time) {
                                        var avgFraction = 0.9,
                                            avgFractionFlip = 1 - avgFraction,
                                            ff = this.forwardFollower,
                                            moved  = false,
                                            ms = 15,
                                            standardizeTimeDistance = ms / time, //This allows the camera to pan appropriately on slower devices or longer ticks
                                            worldCamera = this.worldCamera,
                                            worldVP = worldCamera.viewport,
                                            x = entity.x + this.offsetX,
                                            y = entity.y + this.offsetY,
                                            a = (entity.orientation || 0) + this.offsetAngle;
                                        
                                        if (this.followFocused &amp;&amp; (this.lastX === x) &amp;&amp; (this.lastY === y)) {
                                            return this.lockedFollow(ff, time);
                                        } else {
                                            // span over last 10 ticks to prevent jerkiness
                                            this.averageOffsetX *= avgFraction;
                                            this.averageOffsetY *= avgFraction;
                                            this.averageOffsetX += avgFractionFlip * (x - this.lastX) * standardizeTimeDistance;
                                            this.averageOffsetY += avgFractionFlip * (y - this.lastY) * standardizeTimeDistance;
                        
                                            if (Math.abs(this.averageOffsetX) &gt; (worldVP.width / (this.forwardX * 2))) {
                                                this.averageOffsetX = 0;
                                            }
                                            if (Math.abs(this.averageOffsetY) &gt; (worldVP.height / (this.forwardY * 2))) {
                                                this.averageOffsetY = 0;
                                            }
                                            
                                            if (this.rotate) {
                                                this.averageOffsetAngle *= avgFraction;
                                                this.averageOffsetAngle += avgFractionFlip * (a - this.lastOrientation) * standardizeTimeDistance;
                                                if (Math.abs(this.averageOffsetAngle) &gt; (worldCamera.orientation / (this.forwardAngle * 2))) {
                                                    this.averageOffsetAngle = 0;
                                                }
                                            }
                        
                                            ff.x = this.averageOffsetX * this.forwardX + x;
                                            ff.y = this.averageOffsetY * this.forwardY + y;
                                            ff.orientation = this.averageOffsetAngle * this.forwardAngle + a;
                                            
                                            this.lastX = x;
                                            this.lastY = y;
                                            this.lastOrientation = a;
                                            
                                            moved = this.lockedFollow(ff, time);
                        
                                            if (!this.followFocused &amp;&amp; !moved) {
                                                this.followFocused = true;
                                            }
                                            
                                            return moved;
                                        }
                                        
                                        
                                    },
                                    
                                    boundingFollow: function (entity, time) {
                                        var x = 0,
                                            y = 0,
                                            ratioX  = (this.transitionX ? Math.min(time / this.transitionX, 1) : 1),
                                            iratioX = 1 - ratioX,
                                            ratioY  = (this.transitionY ? Math.min(time / this.transitionY, 1) : 1),
                                            iratioY = 1 - ratioY,
                                            worldVP = this.worldCamera.viewport;
                                        
                                        this.boundingBox.move(worldVP.x, worldVP.y);
                                        
                                        if (entity.x &gt; this.boundingBox.right) {
                                            x = entity.x - this.boundingBox.halfWidth;
                                        } else if (entity.x &lt; this.boundingBox.left) {
                                            x = entity.x + this.boundingBox.halfWidth;
                                        }
                                        
                                        if (entity.y &gt; this.boundingBox.bottom) {
                                            y = entity.y - this.boundingBox.halfHeight;
                                        } else if (entity.y &lt; this.boundingBox.top) {
                                            y = entity.y + this.boundingBox.halfHeight;
                                        }
                                        
                                        if (x !== 0) {
                                            x = this.moveX(ratioX * x + iratioX * worldVP.x);
                                        }
                                        
                                        if (y !== 0) {
                                            y = this.moveY(ratioY * y + iratioY * worldVP.y);
                                        }
                                        
                                        return x || y;
                                    },
                                    
                                    resize: function () {
                                        var worldAspectRatio = this.width / this.height,
                                            windowAspectRatio = this.owner.width / this.owner.height,
                                            worldVP = this.worldCamera.viewport;
                                        
                                        //The dimensions of the camera in the window
                                        this.viewport.setAll(this.owner.width / 2, this.owner.height / 2, this.owner.width, this.owner.height);
                                        
                                        if (!this.stretch) {
                                            if (windowAspectRatio &gt; worldAspectRatio) {
                                                if (this.overflow) {
                                                    worldVP.resize(this.height * windowAspectRatio, this.height);
                                                } else {
                                                    this.viewport.resize(this.viewport.height * worldAspectRatio, this.viewport.height);
                                                }
                                            } else if (this.overflow) {
                                                worldVP.resize(this.width, this.width / windowAspectRatio);
                                            } else {
                                                this.viewport.resize(this.viewport.width, this.viewport.width / worldAspectRatio);
                                            }
                                        }
                                        
                                        this.worldPerWindowUnitWidth  = worldVP.width  / this.viewport.width;
                                        this.worldPerWindowUnitHeight = worldVP.height / this.viewport.height;
                                        this.windowPerWorldUnitWidth  = this.viewport.width  / worldVP.width;
                                        this.windowPerWorldUnitHeight = this.viewport.height / worldVP.height;
                                        
                                        this.container.setTransform(this.viewport.x - this.viewport.halfWidth, this.viewport.y - this.viewport.halfHeight);
                                        
                                        this.viewportUpdate = true;
                                        
                                        this.updateMovementMethods();
                                    },
                                    
                                    updateMovementMethods: (function () {
                                        // This is used to change movement modes as needed rather than doing a check every tick to determine movement type. - DDD 2/29/2016
                                        var doNot = doNothing,
                                            centerX = function () {
                                                var world = this.worldDimensions;
                                                
                                                this.worldCamera.viewport.moveX(world.width / 2 + world.left);
                                                this.moveX = doNot;
                                                return true;
                                            },
                                            centerY = function () {
                                                var world = this.worldDimensions;
                                                
                                                this.worldCamera.viewport.moveY(world.height / 2 + world.top);
                                                this.moveY = doNot;
                                                return true;
                                            },
                                            containX = function (x) {
                                                var aabb = this.worldCamera.viewport,
                                                    d = this.worldDimensions,
                                                    w = d.width,
                                                    l = d.left;
                                                
                                                if (Math.abs(aabb.x - x) &gt; this.threshold) {
                                                    if (x + aabb.halfWidth &gt; w + l) {
                                                        aabb.moveX(w - aabb.halfWidth + l);
                                                    } else if (x &lt; aabb.halfWidth + l) {
                                                        aabb.moveX(aabb.halfWidth + l);
                                                    } else {
                                                        aabb.moveX(x);
                                                    }
                                                    return true;
                                                }
                                                return false;
                                            },
                                            containY = function (y) {
                                                var aabb = this.worldCamera.viewport,
                                                    d = this.worldDimensions,
                                                    h = d.height,
                                                    t = d.top;
                                                
                                                if (Math.abs(aabb.y - y) &gt; this.threshold) {
                                                    if (y + aabb.halfHeight &gt; h + t) {
                                                        aabb.moveY(h - aabb.halfHeight + t);
                                                    } else if (y &lt; aabb.halfHeight + t) {
                                                        aabb.moveY(aabb.halfHeight + t);
                                                    } else {
                                                        aabb.moveY(y);
                                                    }
                                                    return true;
                                                }
                                                return false;
                                            },
                                            allX = function (x) {
                                                var aabb = this.worldCamera.viewport;
                                                
                                                if (Math.abs(aabb.x - x) &gt; this.threshold) {
                                                    aabb.moveX(x);
                                                    return true;
                                                }
                                                return false;
                                            },
                                            allY = function (y) {
                                                var aabb = this.worldCamera.viewport;
                                                
                                                if (Math.abs(aabb.y - y) &gt; this.threshold) {
                                                    aabb.moveY(y);
                                                    return true;
                                                }
                                                return false;
                                            };
                                        
                                        return function () {
                                            var threshold = this.threshold,
                                                worldVP = this.worldCamera.viewport,
                                                world = this.worldDimensions,
                                                w = world.width,
                                                h = world.height;
                                            
                                            if (!w) {
                                                this.moveX = allX;
                                            } else if (w &lt; worldVP.width) {
                                                this.moveX = centerX;
                                            } else {
                                                this.moveX = containX;
                                            }
                        
                                            if (!h) {
                                                this.moveY = allY;
                                            } else if (h &lt; worldVP.height) {
                                                this.moveY = centerY;
                                            } else {
                                                this.moveY = containY;
                                            }
                        
                                            // Make sure camera is correctly contained:
                                            this.threshold = -1; // forces update
                                            this.moveX(worldVP.x);
                                            this.moveY(worldVP.y);
                                            this.threshold = threshold;
                                        };
                                    }()),
                        
                                    updateViewport: function () {
                                        const
                                            msg       = this.message,
                                            viewport  = msg.viewport,
                                            worldCamera = this.worldCamera;
                                        
                                        if (this.viewportUpdate) {
                                            this.viewportUpdate = false;
                                            this.stationary = false;
                                            msg.stationary = false;
                                            
                                            viewport.set(worldCamera.viewport);
                        
                                            // Set up the rest of the camera message:
                                            msg.scaleX         = this.windowPerWorldUnitWidth;
                                            msg.scaleY         = this.windowPerWorldUnitHeight;
                                            msg.orientation    = worldCamera.orientation;
                                            
                                            // Transform the world to appear within camera
                                            this.world.setTransform(-viewport.x, -viewport.y, 1, 1, 0);
                                            this.container.setTransform(viewport.halfWidth * msg.scaleX, viewport.halfHeight * msg.scaleY, msg.scaleX, msg.scaleY, msg.orientation);
                                            this.container.visible = true;
                        
                                            /**
                                             * This component fires &quot;camera-update&quot; when the position of the camera in the world has changed. This event is triggered on both the entity (typically a layer) as well as children of the entity.
                                             *
                                             * @event &#x27;camera-update&#x27;
                                             * @param message {Object}
                                             * @param message.world {platypus.AABB} The dimensions of the world map.
                                             * @param message.orientation {Number} Number describing the orientation of the camera.
                                             * @param message.scaleX {Number} Number of window pixels that comprise a single world coordinate on the x-axis.
                                             * @param message.scaleY {Number} Number of window pixels that comprise a single world coordinate on the y-axis.
                                             * @param message.viewport {platypus.AABB} An AABB describing the world viewport area.
                                             * @param message.stationary {Boolean} Whether the camera is moving.
                                             **/
                                            this.owner.triggerEvent(&#x27;camera-update&#x27;, msg);
                                            if (this.owner.triggerEventOnChildren) {
                                                this.owner.triggerEventOnChildren(&#x27;camera-update&#x27;, msg);
                                            }
                                        } else if (!this.stationary) {
                                            this.stationary = true;
                                            msg.stationary = true;
                        
                                            this.owner.triggerEvent(&#x27;camera-update&#x27;, msg);
                                            if (this.owner.triggerEventOnChildren) {
                                                this.owner.triggerEventOnChildren(&#x27;camera-update&#x27;, msg);
                                            }
                                        }
                                    },
                                    
                                    destroy: function () {
                                        this.parentContainer.removeChild(this.container);
                                        this.parentContainer = null;
                                        this.container = null;
                                        if (this.mouseVector) {
                                            this.mouseVector.recycle();
                                            this.mouseWorldOrigin.recycle();
                                        }
                                        
                                        this.boundingBox.recycle();
                                        this.viewport.recycle();
                                        this.worldCamera.viewport.recycle();
                                        this.worldCamera.recycle();
                                        this.message.viewport.recycle();
                                        this.message.recycle();
                                        this.cameraLoadedMessage.recycle();
                                        this.worldDimensions.recycle();
                            
                                        this.forwardFollower.recycle();
                                        this.lastFollow.recycle();
                                    }
                                },
                        
                                publicMethods: {
                                    /**
                                     * Returns whether a particular display object intersects the camera&#x27;s viewport on the canvas.
                                     *
                                     * @method isOnCanvas
                                     * @param bounds {PIXI.Rectangle|Object} The bounds of the display object.
                                     * @param bounds.height {Number} The height of the display object.
                                     * @param bounds.width {Number} The width of the display object.
                                     * @param bounds.x {Number} The left edge of the display object.
                                     * @param bounds.y {Number} The top edge of the display object.
                                     * @return {Boolean} Whether the display object intersects the camera&#x27;s bounds.
                                     */
                                    isOnCanvas: function (bounds) {
                                        var canvas = this.canvas;
                        
                                        return !bounds || !((bounds.x + bounds.width &lt; 0) || (bounds.x &gt; canvas.width) || (bounds.y + bounds.height &lt; 0) || (bounds.y &gt; canvas.height));
                                    },
                        
                                    /**
                                     * Returns a world coordinate corresponding to a provided window coordinate.
                                     *
                                     * @method windowToWorld
                                     * @param windowVector {platypus.Vector} A vector describing a window position.
                                     * @param withOffset {Boolean} Whether to provide a world position relative to the camera&#x27;s location.
                                     * @param vector {platypus.Vector} If provided, this is used as the return vector.
                                     * @return {platypus.Vector} A vector describing a world position.
                                     */
                                    windowToWorld: function (windowVector, withOffset, vector) {
                                        var worldVector = vector || Vector.setUp();
                                        
                                        worldVector.x = windowVector.x * this.worldPerWindowUnitWidth;
                                        worldVector.y = windowVector.y * this.worldPerWindowUnitHeight;
                                        
                                        if (withOffset !== false) {
                                            worldVector.x += this.worldCamera.viewport.left;
                                            worldVector.y += this.worldCamera.viewport.top;
                                        }
                        
                                        return worldVector;
                                    },
                                    
                                    /**
                                     * Returns a window coordinate corresponding to a provided world coordinate.
                                     *
                                     * @method worldToWindow
                                     * @param worldVector {platypus.Vector} A vector describing a world position.
                                     * @param withOffset {Boolean} Whether to provide a window position relative to the camera&#x27;s location.
                                     * @param vector {platypus.Vector} If provided, this is used as the return vector.
                                     * @return {platypus.Vector} A vector describing a window position.
                                     */
                                    worldToWindow: function (worldVector, withOffset, vector) {
                                        var windowVector = vector || Vector.setUp();
                        
                                        windowVector.x = worldVector.x * this.windowPerWorldUnitWidth;
                                        windowVector.y = worldVector.y * this.windowPerWorldUnitHeight;
                                        
                                        if (withOffset !== false) {
                                            windowVector.x += this.viewport.x;
                                            windowVector.y += this.viewport.y;
                                        }
                        
                                        return windowVector;
                                    }
                                }
                            });
                        }());
                        
                            </pre>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
