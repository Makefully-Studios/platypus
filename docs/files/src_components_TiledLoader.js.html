<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="../assets/css/yui-cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/x-icon" href="../assets/favicon.ico">
    <script src="../assets/js/yui-source.js"></script>
	<title>platypus v2.0.0 API Documentation : src\components\TiledLoader.js</title>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><a href="https://github.com/PBS-KIDS/Platypus"><img src="..\assets\platypus-title.png" title="platypus"></a></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Documentation for: 2.0.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/platypus.AABB.html">platypus.AABB</a></li>
                                <li><a href="../classes/platypus.ActionState.html">platypus.ActionState</a></li>
                                <li><a href="../classes/platypus.AssetManager.html">platypus.AssetManager</a></li>
                                <li><a href="../classes/platypus.Async.html">platypus.Async</a></li>
                                <li><a href="../classes/platypus.CollisionData.html">platypus.CollisionData</a></li>
                                <li><a href="../classes/platypus.CollisionDataContainer.html">platypus.CollisionDataContainer</a></li>
                                <li><a href="../classes/platypus.CollisionShape.html">platypus.CollisionShape</a></li>
                                <li><a href="../classes/platypus.Component.html">platypus.Component</a></li>
                                <li><a href="../classes/platypus.components.AIChaser.html">platypus.components.AIChaser</a></li>
                                <li><a href="../classes/platypus.components.AIPacer.html">platypus.components.AIPacer</a></li>
                                <li><a href="../classes/platypus.components.AudioMusic.html">platypus.components.AudioMusic</a></li>
                                <li><a href="../classes/platypus.components.AudioSFX.html">platypus.components.AudioSFX</a></li>
                                <li><a href="../classes/platypus.components.AudioVO.html">platypus.components.AudioVO</a></li>
                                <li><a href="../classes/platypus.components.Camera.html">platypus.components.Camera</a></li>
                                <li><a href="../classes/platypus.components.CameraFollowMe.html">platypus.components.CameraFollowMe</a></li>
                                <li><a href="../classes/platypus.components.CollisionBasic.html">platypus.components.CollisionBasic</a></li>
                                <li><a href="../classes/platypus.components.CollisionFilter.html">platypus.components.CollisionFilter</a></li>
                                <li><a href="../classes/platypus.components.CollisionGroup.html">platypus.components.CollisionGroup</a></li>
                                <li><a href="../classes/platypus.components.CollisionTiles.html">platypus.components.CollisionTiles</a></li>
                                <li><a href="../classes/platypus.components.ComponentSwitcher.html">platypus.components.ComponentSwitcher</a></li>
                                <li><a href="../classes/platypus.components.Counter.html">platypus.components.Counter</a></li>
                                <li><a href="../classes/platypus.components.EntityContainer.html">platypus.components.EntityContainer</a></li>
                                <li><a href="../classes/platypus.components.EntityController.html">platypus.components.EntityController</a></li>
                                <li><a href="../classes/platypus.components.HandlerCollision.html">platypus.components.HandlerCollision</a></li>
                                <li><a href="../classes/platypus.components.HandlerController.html">platypus.components.HandlerController</a></li>
                                <li><a href="../classes/platypus.components.HandlerLogic.html">platypus.components.HandlerLogic</a></li>
                                <li><a href="../classes/platypus.components.HandlerRender.html">platypus.components.HandlerRender</a></li>
                                <li><a href="../classes/platypus.components.Interactive.html">platypus.components.Interactive</a></li>
                                <li><a href="../classes/platypus.components.LevelBuilder.html">platypus.components.LevelBuilder</a></li>
                                <li><a href="../classes/platypus.components.LogicAngularMovement.html">platypus.components.LogicAngularMovement</a></li>
                                <li><a href="../classes/platypus.components.LogicAttachment.html">platypus.components.LogicAttachment</a></li>
                                <li><a href="../classes/platypus.components.LogicButton.html">platypus.components.LogicButton</a></li>
                                <li><a href="../classes/platypus.components.LogicCarrier.html">platypus.components.LogicCarrier</a></li>
                                <li><a href="../classes/platypus.components.LogicDestroyMe.html">platypus.components.LogicDestroyMe</a></li>
                                <li><a href="../classes/platypus.components.LogicDirectionalMovement.html">platypus.components.LogicDirectionalMovement</a></li>
                                <li><a href="../classes/platypus.components.LogicDragDrop.html">platypus.components.LogicDragDrop</a></li>
                                <li><a href="../classes/platypus.components.LogicPortable.html">platypus.components.LogicPortable</a></li>
                                <li><a href="../classes/platypus.components.LogicRotationalMovement.html">platypus.components.LogicRotationalMovement</a></li>
                                <li><a href="../classes/platypus.components.LogicTimer.html">platypus.components.LogicTimer</a></li>
                                <li><a href="../classes/platypus.components.LogicWindUpRacer.html">platypus.components.LogicWindUpRacer</a></li>
                                <li><a href="../classes/platypus.components.Motion.html">platypus.components.Motion</a></li>
                                <li><a href="../classes/platypus.components.Mover.html">platypus.components.Mover</a></li>
                                <li><a href="../classes/platypus.components.NodeMap.html">platypus.components.NodeMap</a></li>
                                <li><a href="../classes/platypus.components.NodeResident.html">platypus.components.NodeResident</a></li>
                                <li><a href="../classes/platypus.components.Orientation.html">platypus.components.Orientation</a></li>
                                <li><a href="../classes/platypus.components.RandomEvents.html">platypus.components.RandomEvents</a></li>
                                <li><a href="../classes/platypus.components.RelativePosition.html">platypus.components.RelativePosition</a></li>
                                <li><a href="../classes/platypus.components.RelayFamily.html">platypus.components.RelayFamily</a></li>
                                <li><a href="../classes/platypus.components.RelayGame.html">platypus.components.RelayGame</a></li>
                                <li><a href="../classes/platypus.components.RelayLinker.html">platypus.components.RelayLinker</a></li>
                                <li><a href="../classes/platypus.components.RelayParent.html">platypus.components.RelayParent</a></li>
                                <li><a href="../classes/platypus.components.RelaySelf.html">platypus.components.RelaySelf</a></li>
                                <li><a href="../classes/platypus.components.RenderAnimator.html">platypus.components.RenderAnimator</a></li>
                                <li><a href="../classes/platypus.components.RenderContainer.html">platypus.components.RenderContainer</a></li>
                                <li><a href="../classes/platypus.components.RenderDebug.html">platypus.components.RenderDebug</a></li>
                                <li><a href="../classes/platypus.components.RenderDestroyMe.html">platypus.components.RenderDestroyMe</a></li>
                                <li><a href="../classes/platypus.components.RenderProgress.html">platypus.components.RenderProgress</a></li>
                                <li><a href="../classes/platypus.components.RenderSpine.html">platypus.components.RenderSpine</a></li>
                                <li><a href="../classes/platypus.components.RenderSprite.html">platypus.components.RenderSprite</a></li>
                                <li><a href="../classes/platypus.components.RenderText.html">platypus.components.RenderText</a></li>
                                <li><a href="../classes/platypus.components.RenderTiles.html">platypus.components.RenderTiles</a></li>
                                <li><a href="../classes/platypus.components.SceneChanger.html">platypus.components.SceneChanger</a></li>
                                <li><a href="../classes/platypus.components.TiledLoader.html">platypus.components.TiledLoader</a></li>
                                <li><a href="../classes/platypus.components.Timeline.html">platypus.components.Timeline</a></li>
                                <li><a href="../classes/platypus.components.Tutorial.html">platypus.components.Tutorial</a></li>
                                <li><a href="../classes/platypus.components.Tween.html">platypus.components.Tween</a></li>
                                <li><a href="../classes/platypus.components.VoiceOver.html">platypus.components.VoiceOver</a></li>
                                <li><a href="../classes/platypus.components.XHR.html">platypus.components.XHR</a></li>
                                <li><a href="../classes/platypus.Data.html">platypus.Data</a></li>
                                <li><a href="../classes/platypus.DataMap.html">platypus.DataMap</a></li>
                                <li><a href="../classes/platypus.Entity.html">platypus.Entity</a></li>
                                <li><a href="../classes/platypus.EntityLinker.html">platypus.EntityLinker</a></li>
                                <li><a href="../classes/platypus.Game.html">platypus.Game</a></li>
                                <li><a href="../classes/platypus.Gamepad.html">platypus.Gamepad</a></li>
                                <li><a href="../classes/platypus.Messenger.html">platypus.Messenger</a></li>
                                <li><a href="../classes/platypus.PIXIAnimation.html">platypus.PIXIAnimation</a></li>
                                <li><a href="../classes/platypus.SFXPlayer.html">platypus.SFXPlayer</a></li>
                                <li><a href="../classes/platypus.StateMap.html">platypus.StateMap</a></li>
                                <li><a href="../classes/platypus.Storage.html">platypus.Storage</a></li>
                                <li><a href="../classes/platypus.Vector.html">platypus.Vector</a></li>
                                <li><a href="../classes/platypus.VOPlayer.html">platypus.VOPlayer</a></li>
                                <li><a href="../classes/window.Map.html">window.Map</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/platypus.html">platypus</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
            <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <script>
                        	var name = src\components\TiledLoader.js      
                        </script>
                        <h1 class="file-heading">File:src\components\TiledLoader.js</h1>
                        
                        <div class="file">
                            <pre class="code prettyprint linenums">
                        /**
                         * This component is attached to a top-level entity and, once its peer components are loaded, ingests a JSON file exported from the [Tiled map editor](http://www.mapeditor.org/) and creates the tile maps and entities. Once it has finished loading the map, it removes itself from the list of components on the entity.
                         *
                         * This component requires an [EntityContainer](platypus.components.EntityContainer.html) since it calls &#x60;entity.addEntity()&#x60; on the entity, provided by &#x60;EntityContainer&#x60;.
                         *
                         * This component looks for the following entities, and if not found will load default versions:
                        
                                {
                                    &quot;render-layer&quot;: {
                                        &quot;id&quot;: &quot;render-layer&quot;,
                                        &quot;components&quot;:[{
                                            &quot;type&quot;: &quot;RenderTiles&quot;,
                                            &quot;spriteSheet&quot;: &quot;import&quot;,
                                            &quot;imageMap&quot;:    &quot;import&quot;,
                                            &quot;entityCache&quot;: true
                                        }]
                                    },
                                    &quot;collision-layer&quot;: {
                                        &quot;id&quot;: &quot;collision-layer&quot;,
                                        &quot;components&quot;:[{
                                            &quot;type&quot;: &quot;CollisionTiles&quot;,
                                            &quot;collisionMap&quot;: &quot;import&quot;
                                        }]
                                    },
                                    &quot;image-layer&quot;: {
                                        &quot;id&quot;: &quot;image-layer&quot;,
                                        &quot;components&quot;:[{
                                            &quot;type&quot;: &quot;RenderTiles&quot;,
                                            &quot;spriteSheet&quot;: &quot;import&quot;,
                                            &quot;imageMap&quot;:    &quot;import&quot;
                                        }]
                                    }
                                }
                        
                         * @namespace platypus.components
                         * @class TiledLoader
                         * @uses platypus.Component
                         */
                        /* global atob, platypus */
                        import {arrayCache, greenSlice, union} from &#x27;../utils/array.js&#x27;;
                        import AABB from &#x27;../AABB.js&#x27;;
                        import Data from &#x27;../Data.js&#x27;;
                        import DataMap from &#x27;../DataMap.js&#x27;;
                        import Entity from &#x27;../Entity.js&#x27;;
                        import EntityLinker from &#x27;../EntityLinker&#x27;;
                        import Vector from &#x27;../Vector.js&#x27;;
                        import createComponentClass from &#x27;../factory.js&#x27;;
                        import {inflate} from &#x27;pako&#x27;;
                        
                        export default (function () {
                            var FILENAME_TO_ID = /^(?:(\w+:)\/{2}(\w+(?:\.\w+)*\/?))?([\/.]*?(?:[^?]+)?\/)?(?:(([^\/?]+)\.(\w+))|([^\/?]+))(?:\?((?:(?:[^&amp;]*?[\/=])?(?:((?:(?:[^\/?&amp;=]+)\.(\w+)))\S*?)|\S+))?)?$/,
                                maskId = 0x0fffffff,
                                maskXFlip = 0x80000000,
                                maskYFlip = 0x40000000,
                                decodeBase64 = (function () {
                                    var decodeString = function (str, index) {
                                            return (((str.charCodeAt(index)) + (str.charCodeAt(index + 1) &lt;&lt; 8) + (str.charCodeAt(index + 2) &lt;&lt; 16) + (str.charCodeAt(index + 3) &lt;&lt; 24 )) &gt;&gt;&gt; 0);
                                        },
                                        decodeArray = function (arr, index) {
                                            return ((arr[index] + (arr[index + 1] &lt;&lt; 8) + (arr[index + 2] &lt;&lt; 16) + (arr[index + 3] &lt;&lt; 24 )) &gt;&gt;&gt; 0);
                                        };
                                    
                                    return function (data, compression) {
                                        var index = 4,
                                            arr   = [],
                                            step1 = atob(data.replace(/\\/g, &#x27;&#x27;));
                                            
                                        if (compression === &#x27;zlib&#x27;) {
                                            step1 = inflate(step1);
                                            while (index &lt;= step1.length) {
                                                arr.push(decodeArray(step1, index - 4));
                                                index += 4;
                                            }
                                        } else {
                                            while (index &lt;= step1.length) {
                                                arr.push(decodeString(step1, index - 4));
                                                index += 4;
                                            }
                                        }
                                        
                                        return arr;
                                    };
                                }()),
                                decodeLayer = function (layer) {
                                    if (layer.encoding === &#x27;base64&#x27;) {
                                        layer.data = decodeBase64(layer.data, layer.compression);
                                        layer.encoding = &#x27;csv&#x27;; // So we won&#x27;t have to decode again.
                                    }
                                    return layer;
                                },
                                getImageId = function (path) {
                                    var result = path.match(FILENAME_TO_ID);
                        
                                    return result[5] || result[7];
                                },
                                finishedLoading = function (level, x, y, width, height, tileWidth, tileHeight, callback) {
                                    const
                                        message = Data.setUp(
                                            &quot;level&quot;, null,
                                            &quot;world&quot;, AABB.setUp(),
                                            &quot;tile&quot;, AABB.setUp(),
                                            &quot;camera&quot;, null,
                                            &quot;lazyLoads&quot;, this.lazyLoads
                                        ),
                                        lazyLoad = (entity) =&gt; {
                                            const
                                                aabb = entity.aabb,
                                                entityLinker = entity.entityLinker;
                        
                                            aabb.recycle();
                                            entity.aabb = null;
                                            entity.entityLinker = null;
                                            entityLinker.linkEntity(this.owner.addEntity(entity));
                                        };
                        
                                    this.lazyLoads.sort((a, b) =&gt; b.aabb.left - a.aabb.left); // Maybe a smidge faster since we can cut out once it&#x27;s too far to the right.
                        
                                    /**
                                     * Once finished loading the map, this message is triggered on the entity to notify other components of completion.
                                     *
                                     * @event &#x27;world-loaded&#x27;
                                     * @param message {platypus.Data} World data.
                                     * @param message.level {Object} The Tiled level data used to load the level.
                                     * @param message.width {number} The width of the world in world units.
                                     * @param message.height {number} The height of the world in world units.
                                     * @param message.tile {platypus.AABB} Dimensions of the world tiles.
                                     * @param message.world {platypus.AABB} Dimensions of the world.
                                     * @param message.camera {platypus.Entity} If a camera property is found on one of the loaded entities, this property will point to the entity on load that a world camera should focus on.
                                     * @param message.lazyLoads {Array} List of objects representing entity definitions that will await camera focus before generating actual entities.
                                     */
                                    message.level = level;
                                    message.camera = this.followEntity; // TODO: in 0.9.0 this should probably be removed, using something like &quot;child-entity-added&quot; instead. Currently this is particular to TiledLoader and Camera and should be generalized. - DDD 3/15/2016
                                    message.width = width;
                                    message.height = height;
                                    message.world.setBounds(x, y, x + width, y + height);
                                    message.tile.setBounds(0, 0, tileWidth, tileHeight);
                                    this.owner.triggerEvent(&#x27;world-loaded&#x27;, message);
                                    message.world.recycle();
                                    message.tile.recycle();
                                    message.recycle();
                                    
                                    if (this.lazyLoads.length) {
                                        this.addEventListener(&quot;camera-update&quot;, (camera) =&gt; {
                                            const
                                                lazyLoads = this.lazyLoads,
                                                viewport = AABB.setUp(camera.viewport);
                                            let i = lazyLoads.length;
                        
                                            viewport.resize(viewport.width * 1.5, viewport.height * 1.5);
                        
                                            while (i--) {
                                                const entity = lazyLoads[i],
                                                    aabb = entity.aabb;
                        
                                                if (viewport.intersects(aabb)) {
                                                    lazyLoad(entity);
                                                    for (let j = i + 1; j &lt; lazyLoads.length; j++) {
                                                        lazyLoads[j - 1] = lazyLoads[j];
                                                    }
                                                    lazyLoads.length -= 1;
                                                } else if (aabb.left &gt; viewport.right) { // we&#x27;re at the end of viable aabb&#x27;s
                                                    break;
                                                }
                                            }
                                        });
                                        if (this.backgroundLoad) {
                                            this.addEventListener(&#x27;tick&#x27;, function () {
                                                const
                                                    lazyLoads = this.lazyLoads,
                                                    i = lazyLoads.length;
                        
                                                if (i) {
                                                    lazyLoad(lazyLoads.pop(i - 1));
                                                }
                                            });
                                        }
                                    } else {
                                        this.owner.removeComponent(this);
                                    }
                        
                                    if (callback) {
                                        callback();
                                    }
                                },
                                getPowerOfTen = function (amount) {
                                    var x = 1;
                        
                                    while (x &lt; amount) {
                                        x *= 10;
                                    }
                        
                                    return x;
                                },
                                transform = {
                                    x: 1,
                                    y: 1,
                                    id: -1
                                },
                                getProperty = (...args) =&gt; {
                                    const obj = getPropertyObject(...args);
                        
                                    return obj &amp;&amp; obj.value;
                                },
                                getPropertyObject = (obj, key) =&gt; { // Handle Tiled map versions
                                    if (obj) {
                                        if (Array.isArray(obj)) {
                                            let i = obj.length;
                                            while (i--) {
                                                if (obj[i].name === key) {
                                                    return obj[i];
                                                }
                                            }
                                            return null;
                                        } else {
                                            platypus.debug.warn(&#x27;This Tiled map version is deprecated.&#x27;);
                                            return {
                                                name: key,
                                                type: typeof obj[key],
                                                value: obj[key]
                                            };
                                        }
                                    } else {
                                        return null;
                                    }
                                },
                                setProperty = (obj, key, value) =&gt; { // Handle Tiled map versions
                                    var i = 0;
                        
                                    if (obj) {
                                        if (Array.isArray(obj)) {
                                            i = obj.length;
                                            while (i--) {
                                                if (obj[i].name === key) {
                                                    obj[i].type = typeof value;
                                                    obj[i].value = value;
                                                    return;
                                                }
                                            }
                                            obj.push({
                                                name: key,
                                                type: typeof value,
                                                value: value
                                            });
                                        } else {
                                            obj[key] = value;
                                        }
                                    }
                                },
                                entityTransformCheck = function (v) {
                                    var resp = transform,
                                        b = !!(maskYFlip &amp; v),
                                        c = !!(maskXFlip &amp; v);
                        
                                    resp.id = maskId &amp; v;
                                    resp.x = 1;
                                    resp.y = 1;
                        
                                    if (b) {
                                        resp.y = -1;
                                    }
                                    if (c) {
                                        resp.x = -1;
                                    }
                                    return resp;
                                },
                                createTilesetObjectGroupReference = function (reference, tilesets) {
                                    for (let i = 0; i &lt; tilesets.length; i++) {
                                        const
                                            tileset = tilesets[i],
                                            tiles = tileset.tiles;
                                        
                                        if (tiles) {
                                            for (let j = 0; j &lt; tiles.length; j++) {
                                                const tile = tiles[j];
                        
                                                if (tile.objectgroup) { // Could just be other information, like terrain
                                                    reference.set(tile.id + tileset.firstgid, tile.objectgroup);
                                                }
                                            }
                                        }
                                    }
                                },
                                getEntityData = function (obj, tilesets, entityLinker) {
                                    var x = 0,
                                        gid = obj.gid || -1,
                                        properties = {},
                                        data = {
                                            gid: -1,
                                            transform: null,
                                            properties: properties,
                                            type: &#x27;&#x27;
                                        },
                                        props = null;
                                    
                                    if (gid !== -1) {
                                        data.transform = entityTransformCheck(gid);
                                        gid = data.gid = transform.id;
                                    }
                                    
                                    if (tilesets) {
                                        let tileset = null;
                        
                                        for (x = 0; x &lt; tilesets.length; x++) {
                                            if (tilesets[x].firstgid &gt; gid) {
                                                break;
                                            } else {
                                                tileset = tilesets[x];
                                            }
                                        }
                                        
                                        if (tileset &amp;&amp; tileset.tiles) {
                                            const
                                                tiles = tileset.tiles,
                                                entityTilesetIndex = gid - tileset.firstgid;
                        
                                            for (let i = 0; i &lt; tiles.length; i++) {
                                                const tile = tiles[i];
                                                if (tile.id === entityTilesetIndex) {
                                                    props = tile.properties || null;
                                                    data.type = tile.type || &#x27;&#x27;;
                                                    break;
                                                }
                                            }
                                        }
                                    }
                        
                                    // Check Tiled data to find this object&#x27;s type
                                    data.type = obj.type || data.type;
                        
                                    if (!data.type) { // undefined entity
                                        return null;
                                    }
                                    
                                    //Copy properties from Tiled
                                    if (data.transform) {
                                        properties.scaleX = data.transform.x;
                                        properties.scaleY = data.transform.y;
                                    } else {
                                        properties.scaleX = 1;
                                        properties.scaleY = 1;
                                    }
                                    
                                    if (entityLinker) {
                                        entityLinker.linkObject(data.properties.tiledId = obj.id);
                                    }
                                    mergeAndFormatProperties(props, data.properties, entityLinker);
                                    mergeAndFormatProperties(obj.properties, data.properties, entityLinker);
                                    
                                    return data;
                                },
                                mergeAndFormatProperties = function (src, dest, entityLinker) {
                                    var i = 0,
                                        key = &#x27;&#x27;;
                                    
                                    if (src &amp;&amp; dest) {
                                        if (Array.isArray(src)) {
                                            for (i = 0; i &lt; src.length; i++) {
                                                setProperty(dest, src[i].name, formatPropertyObject(src[i], entityLinker));
                                            }
                                        } else {
                                            for (key in src) {
                                                if (src.hasOwnProperty(key)) {
                                                    setProperty(dest, key, formatProperty(src[key]));
                                                }
                                            }
                                        }
                                    }
                                    
                                    return dest;
                                },
                                formatProperty = function (value) {
                                    var numberProperty = 0;
                                    
                                    if (typeof value === &#x27;string&#x27;) {
                                        //This is going to assume that if you pass in something that starts with a number, it is a number and converts it to one.
                                        // eslint-disable-next-line radix
                                        numberProperty = parseFloat(value) || parseInt(value); // to handle floats and 0x respectively.
                                        if (numberProperty === 0 || (!!numberProperty)) {
                                            return numberProperty;
                                        } else if (value === &#x27;true&#x27;) {
                                            return true;
                                        } else if (value === &#x27;false&#x27;) {
                                            return false;
                                        } else if ((value.length &gt; 1) &amp;&amp; (((value[0] === &#x27;{&#x27;) &amp;&amp; (value[value.length - 1] === &#x27;}&#x27;)) || ((value[0] === &#x27;[&#x27;) &amp;&amp; (value[value.length - 1] === &#x27;]&#x27;)))) {
                                            try {
                                                return JSON.parse(value);
                                            } catch (e) {
                                            }
                                        }
                                    }
                        
                                    return value;
                                },
                                formatPropertyObject = function ({name, value, type}, entityLinker) {
                                    switch (type) {
                                    case &#x27;color&#x27;:
                                        break;
                                    case &#x27;object&#x27;:
                                        if (entityLinker &amp;&amp; value !== 0) {
                                            return entityLinker.getEntity(value, name); // if unfound, entityLinker saves this request and will try to fulfill it once the entity is added.
                                        } else {
                                            return null;
                                        }
                                    case &#x27;string&#x27;:
                                        if ((value.length &gt; 1) &amp;&amp; (((value[0] === &#x27;{&#x27;) &amp;&amp; (value[value.length - 1] === &#x27;}&#x27;)) || ((value[0] === &#x27;[&#x27;) &amp;&amp; (value[value.length - 1] === &#x27;]&#x27;)))) {
                                            try {
                                                return JSON.parse(value);
                                            } catch (e) {
                                            }
                                        }
                                        break;
                                    case &#x27;bool&#x27;:
                                    case &#x27;float&#x27;:
                                    case &#x27;file&#x27;:
                                    case &#x27;int&#x27;:
                                    default:
                                        break;
                                    }
                                    
                                    return value;
                                },
                                checkLevel = function (level, ss) {
                                    const
                                        addObjectGroupAssets = (assets, objectGroup, tilesets) =&gt; {
                                            const objects = objectGroup.objects;
                        
                                            for (let i = 0; i &lt; objects.length; i++) {
                                                const entity = getEntityData(objects[i], tilesets);
                                                if (entity) {
                                                    const entityAssets = Entity.getAssetList(entity);
                                                    union(assets, entityAssets);
                                                    arrayCache.recycle(entityAssets);
                                                }
                                            }
                                        };
                        
                                    var i = 0,
                                        tilesets = arrayCache.setUp(),
                                        arr = null,
                                        assets = arrayCache.setUp(),
                                        data = null;
                        
                                    if (typeof level === &#x27;string&#x27;) {
                                        level = platypus.game.settings.levels[level];
                                    }
                        
                                    if (level) {
                                        if (level.tilesets) {
                                            level.tilesets = importTilesetData(level.tilesets);
                                        }
                        
                                        if (level.assets) { // Property added by a previous parse (so that this algorithm isn&#x27;t run on the same level multiple times)
                                            union(assets, level.assets);
                                        } else if (level.layers) {
                                            for (i = 0; i &lt; level.layers.length; i++) {
                                                const layer = level.layers[i];
                        
                                                if (layer.type === &#x27;objectgroup&#x27;) {
                                                    addObjectGroupAssets(assets, layer, level.tilesets);
                                                } else if (layer.type === &#x27;imagelayer&#x27;) {
                                                    // Check for custom layer entity
                                                    const entityType = getProperty(layer.properties, &#x27;entity&#x27;);
                                                    if (entityType) {
                                                        data = Data.setUp(&#x27;type&#x27;, entityType, &#x27;properties&#x27;, mergeAndFormatProperties(layer.properties, {}));
                                                        arr = Entity.getAssetList(data);
                                                        union(assets, arr);
                                                        arrayCache.recycle(arr);
                                                        data.recycle();
                                                    } else {
                                                        union(assets, [layer.image]);
                                                    }
                                                } else {
                                                    const
                                                        entityType = getProperty(level.layers[i].properties, &#x27;entity&#x27;),
                                                        tiles = arrayCache.setUp();
                        
                                                    // must decode first so we can check for tiles&#x27; objects
                                                    decodeLayer(layer);
                        
                                                    // Check for relevant objectgroups in tileset
                                                    union(tiles, layer.data); // merge used tiles into one-off list
                                                    for (let j = 0; j &lt; tiles.length; j++) {
                                                        const id = maskId &amp; tiles[j];
                                                        for (let k = 0; k &lt; level.tilesets.length; k++) {
                                                            const tiles = level.tilesets[k].tiles;
                                                            if (tiles) {
                                                                for (let l = 0; l &lt; tiles.length; l++) {
                                                                    const tile = tiles[l];
                                                                    if ((tile.id === id) &amp;&amp; tile.objectgroup) {
                                                                        addObjectGroupAssets(assets, tile.objectgroup);
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                        
                                                    // Check for custom layer entity
                                                    if (entityType) {
                                                        data = Data.setUp(&#x27;type&#x27;, entityType);
                                                        arr = Entity.getAssetList(data);
                                                        union(assets, arr);
                                                        arrayCache.recycle(arr);
                                                        data.recycle();
                                                    }
                                                }
                                            }
                                            if (!ss) { //We need to load the tileset images since there is not a separate spriteSheet describing them
                                                for (i = 0; i &lt; level.tilesets.length; i++) {
                                                    tilesets.push(level.tilesets[i].image);
                                                }
                                                union(assets, tilesets);
                                                arrayCache.recycle(tilesets);
                                            }
                                            level.assets = greenSlice(assets); // Save for later in case this level is checked again.
                                        }
                                    }
                                    
                                    return assets;
                                },
                                // These are provided but can be overwritten by entities of the same name in the configuration.
                                standardEntityLayers = {
                                    &quot;render-layer&quot;: {
                                        &quot;id&quot;: &quot;render-layer&quot;,
                                        &quot;components&quot;: [{
                                            &quot;type&quot;: &quot;RenderTiles&quot;,
                                            &quot;spriteSheet&quot;: &quot;import&quot;,
                                            &quot;imageMap&quot;: &quot;import&quot;,
                                            &quot;entityCache&quot;: true
                                        }]
                                    },
                                    &quot;collision-layer&quot;: {
                                        &quot;id&quot;: &quot;collision-layer&quot;,
                                        &quot;components&quot;: [{
                                            &quot;type&quot;: &quot;CollisionTiles&quot;,
                                            &quot;collisionMap&quot;: &quot;import&quot;
                                        }]
                                    },
                                    &quot;image-layer&quot;: {
                                        &quot;id&quot;: &quot;image-layer&quot;,
                                        &quot;components&quot;: [{
                                            &quot;type&quot;: &quot;RenderTiles&quot;,
                                            &quot;spriteSheet&quot;: &quot;import&quot;,
                                            &quot;imageMap&quot;: &quot;import&quot;
                                        }]
                                    }
                                },
                                importTileset = function (tileset) {
                                    var key = &#x27;&#x27;,
                                        source = platypus.game.settings.levels[tileset.source.replace(&#x27;.json&#x27;, &#x27;&#x27;)];
                                    
                                    for (key in source) {
                                        if (source.hasOwnProperty(key)) {
                                            tileset[key] = source[key];
                                        }
                                    }
                                    
                                    delete tileset.source; // We remove this so we never have to rerun this import. Note that we can&#x27;t simply replace the tileset properties since the tileset&#x27;s firstgid property may change from level to level.
                                    
                                    return tileset;
                                },
                                importTilesetData = function (tilesets) {
                                    var i = 0;
                                    
                                    for (i = 0; i &lt; tilesets.length; i++) {
                                        if (tilesets[i].source) {
                                            tilesets[i] = importTileset(tilesets[i]);
                                        }
                                    }
                                    
                                    return tilesets;
                                };
                        
                            return createComponentClass({
                                id: &#x27;TiledLoader&#x27;,
                        
                                properties: {
                                    /**
                                     * This causes the entire map to be offset automatically by an order of magnitude higher than the height and width of the world so that the number of digits below zero is constant throughout the world space. This fixes potential floating point issues when, for example, 97 is added to 928.0000000000001 giving 1025 since a significant digit was lost when going into the thousands.
                                     *
                                     * @property offsetMap
                                     * @type Boolean
                                     * @default false
                                     */
                                    offsetMap: false,
                                    
                                    /**
                                     * If set to &#x60;true&#x60; and if the game is running in debug mode, this causes the collision layer to appear.
                                     *
                                     * @property showCollisionTiles
                                     * @type Boolean
                                     * @default false
                                     */
                                    showCollisionTiles: false,
                        
                                    /**
                                     * If specified, the referenced images are used as the game sprite sheets instead of the images referenced in the Tiled map. This is useful for using different or better quality art from the art used in creating the Tiled map.
                                     *
                                     * @property images
                                     * @type Array
                                     * @default null
                                     */
                                    images: null,
                        
                                    /**
                                     * Adds a number to each additional Tiled layer&#x27;s z coordinate to maintain z-order. Defaults to 1000.
                                     *
                                     * @property layerIncrement
                                     * @type number
                                     * @default 1000
                                     */
                                    layerIncrement: 1000,
                        
                                    /**
                                     * Keeps the tile maps in separate render layers. Default is &#x27;false&#x27; to for better optimization.
                                     *
                                     * @property separateTiles
                                     * @type boolean
                                     * @default false
                                     */
                                    separateTiles: false,
                                    
                                    /**
                                     * If a particular sprite sheet should be used that&#x27;s not defined by the level images themselves. This is useful for making uniquely-themed variations of the same level. This is overridden by &#x60;&quot;spriteSheet&quot;: &quot;import&quot;&#x60; in the &quot;render-layer&quot; Entity definition, so be sure to remove that when setting this property.
                                     *
                                     * @property spriteSheet
                                     * @type String | Object
                                     * @default null
                                     */
                                    spriteSheet: null,
                        
                                    /**
                                     * Whether to continue loading &#x60;lazyLoad&#x60; entities in the background after level starts regardless of camera position. If &#x60;false&#x60;, entities with a &#x60;lazyLoad&#x60; property will only load once within camera range.
                                     *
                                     * @property backgroundLoad
                                     * @type Boolean
                                     * @default true
                                     */
                                    backgroundLoad: true
                                },
                        
                                publicProperties: {
                                    /**
                                     * Specifies the JSON level to load. Available on the entity as &#x60;entity.level&#x60;.
                                     *
                                     * @property level
                                     * @type String
                                     * @default null
                                     */
                                    level: null,
                        
                                    /**
                                     * Can be &quot;left&quot;, &quot;right&quot;, or &quot;center&quot;. Defines where entities registered X position should be when spawned. Available on the entity as &#x60;entity.entityPositionX&#x60;.
                                     *
                                     * @property entityPositionX
                                     * @type String
                                     * @default &quot;center&quot;
                                     */
                                    entityPositionX: &quot;center&quot;,
                        
                                    /**
                                     * Can be &quot;top&quot;, &quot;bottom&quot;, or &quot;center&quot;. Defines where entities registered Y position should be when spawned. Available on the entity as &#x60;entity.entityPositionY&#x60;.
                                     *
                                     * @property entityPositionY
                                     * @type String
                                     * @default &quot;bottom&quot;
                                     */
                                    entityPositionY: &quot;bottom&quot;,
                        
                                    /**
                                     * Whether to wait for a &quot;load-level&quot; event before before loading. Available on the entity as &#x60;entity.manuallyLoad&#x60;.
                                     *
                                     * @property manuallyLoad
                                     * @type boolean
                                     * @default false
                                     */
                                    manuallyLoad: false
                                },
                        
                                initialize: function () {
                                    this.assetCache = platypus.assetCache;
                                    this.layerZ = 0;
                                    this.followEntity = false;
                                    this.lazyLoads = arrayCache.setUp();
                                },
                        
                                events: {
                        
                                    /**
                                     * On receiving this message, the component commences loading the Tiled map JSON definition. Once finished, it removes itself from the entity&#x27;s list of components.
                                     *
                                     * @method &#x27;layer-loaded&#x27;
                                     * @param persistentData {Object} Data passed from the last scene into this one.
                                     * @param persistentData.level {Object} A level name or definition to load if the level is not already specified.
                                     * @param holds {platypus.Data} An object that handles any holds on before making the scene live.
                                     * @param holds.count {Number} The number of holds to wait for before triggering &quot;scene-live&quot;
                                     * @param holds.release {Function} The method to trigger to let the scene loader know that one hold has been released.
                                     */
                                    &quot;layer-loaded&quot;: function (persistentData, holds) {
                                        if (!this.manuallyLoad) {
                                            holds.count += 1;
                                            this.loadLevel({
                                                level: this.level || persistentData.level,
                                                persistentData: persistentData
                                            }, holds.release);
                                        }
                                    },
                        
                                    /**
                                     * If &#x60;manuallyLoad&#x60; is set, the component will wait for this message before loading the Tiled map JSON definition.
                                     *
                                     * @method &#x27;load-level&#x27;
                                     * @param levelData {Object}
                                     * @param levelData.level {String|Object} The level to load.
                                     * @param [levelData.persistentData] {Object} Information passed from the last scene.
                                     * @param callback {Function} The function to call once the level is loaded.
                                     */
                                    &quot;load-level&quot;: function (levelData, callback) {
                                        this.loadLevel(levelData, callback);
                                    }
                                },
                        
                                methods: {
                                    createLayer: function (entityKind, layer, mapOffsetX, mapOffsetY, tileWidth, tileHeight, tilesets, tilesetObjectGroups, images, combineRenderLayer, progress, entityLinker) {
                                        var lastSet = null,
                                            props = null,
                                            width = layer.width,
                                            height = layer.height,
                                            tHeight = layer.tileheight || tileHeight,
                                            tWidth = layer.tilewidth || tileWidth,
                                            newWidth = 0,
                                            newHeight = 0,
                                            layerHeight = 0,
                                            layerWidth = 0,
                                            tileTypes = 0,
                                            tileDefinition = JSON.parse(JSON.stringify(platypus.game.settings.entities[entityKind] || standardEntityLayers[entityKind])), //TODO: a bit of a hack to copy an object instead of overwrite values
                                            importAnimation = {},
                                            importCollision = [],
                                            importFrames = [],
                                            importRender = [],
                                            importSpriteSheet = {
                                                images: (layer.image ? [layer.image] : images),
                                                frames: importFrames,
                                                animations: importAnimation
                                            },
                                            renderTiles = false,
                                            index = 0,
                                            data = null,
                                            createFrames = function (frames, index, tileset, modifier) {
                                                var margin = tileset.margin || 0,
                                                    spacing = tileset.spacing || 0,
                                                    tileWidth = tileset.tilewidth,
                                                    tileHeight = tileset.tileheight,
                                                    tileWidthHalf = tileWidth / 2,
                                                    tileHeightHalf = tileHeight / 2,
                                                    tileWidthSpace = tileWidth + spacing,
                                                    tileHeightSpace = tileHeight + spacing,
                                                    margin2 = margin * 2,
                                                    marginSpace = margin2 - spacing,
                                                    cols = tileset.columns || (((tileset.imagewidth / tileWidthSpace) + marginSpace) &gt;&gt; 0),
                                                    rows = /* Tiled tileset def doesn&#x27;t seem to have rows */ (((tileset.imageheight / tileHeightSpace) + marginSpace) &gt;&gt; 0);
                                                
                                                // deprecated unit/image resizing
                                                tileWidth = tileWidth * modifier;
                                                tileHeight = tileHeight * modifier;
                                                tileWidthHalf = tileWidthHalf * modifier;
                                                tileHeightHalf = tileHeightHalf * modifier;
                                                tileWidthSpace = tileWidthSpace * modifier;
                                                tileHeightSpace = tileHeightSpace * modifier;
                        
                                                for (let y = 0; y &lt; rows; y++) {
                                                    for (let x = 0; x &lt; cols; x++) {
                                                        frames.push([
                                                            margin + x * tileWidthSpace,
                                                            margin + y * tileHeightSpace,
                                                            tileWidth,
                                                            tileHeight,
                                                            index,
                                                            tileWidthHalf,
                                                            tileHeightHalf
                                                        ]);
                                                    }
                                                }
                                            };
                                        
                                        decodeLayer(layer);
                                        data = layer.data;
                                        mapOffsetX += layer.offsetx || 0;
                                        mapOffsetY += layer.offsety || 0;
                        
                                        tileDefinition.properties = tileDefinition.properties || {};
                        
                                        entityLinker.linkObject(tileDefinition.properties.tiledId = layer.id);
                        
                                        //This builds in parallaxing support by allowing the addition of width and height properties into Tiled layers so they pan at a separate rate than other layers.
                                        if (layer.properties) {
                        
                                            layerWidth = getProperty(layer.properties, &#x27;width&#x27;);
                                            if (layerWidth) {
                                                newWidth  = parseInt(layerWidth,  10);
                                            }
                        
                                            layerHeight = getProperty(layer.properties, &#x27;height&#x27;);
                                            if (layerHeight) {
                                                newHeight = parseInt(layerHeight, 10);
                                            }
                        
                                            if (newWidth || newHeight) {
                                                newWidth  = newWidth  || width;
                                                newHeight = newHeight || height;
                                                data      = [];
                                                for (let x = 0; x &lt; newWidth; x++) {
                                                    for (let y = 0; y &lt; newHeight; y++) {
                                                        if ((x &lt; width) &amp;&amp; (y &lt; height)) {
                                                            data[x + y * newWidth] = layer.data[x + y * width];
                                                        } else {
                                                            data[x + y * newWidth] = 0;
                                                        }
                                                    }
                                                }
                                                width  = newWidth;
                                                height = newHeight;
                                            }
                                            
                                            mergeAndFormatProperties(layer.properties, tileDefinition.properties, entityLinker);
                                        }
                        
                                        tileDefinition.properties.width = tWidth * width;
                                        tileDefinition.properties.height = tHeight * height;
                                        tileDefinition.properties.columns = width;
                                        tileDefinition.properties.rows = height;
                                        tileDefinition.properties.tileWidth = tWidth;
                                        tileDefinition.properties.tileHeight = tHeight;
                                        tileDefinition.properties.scaleX = 1;
                                        tileDefinition.properties.scaleY = 1;
                                        tileDefinition.properties.layerZ = this.layerZ;
                                        tileDefinition.properties.left = tileDefinition.properties.x || mapOffsetX;
                                        tileDefinition.properties.top = tileDefinition.properties.y || mapOffsetY;
                                        tileDefinition.properties.z = tileDefinition.properties.z || this.layerZ;
                        
                                        if (tilesets.length) {
                                            for (let x = 0; x &lt; tilesets.length; x++) {
                                                createFrames(importFrames, x, tilesets[x], 1);
                                            }
                        
                                            lastSet = tilesets[tilesets.length - 1];
                                            tileTypes = lastSet.firstgid + lastSet.tilecount;
                                            for (let x = -1; x &lt; tileTypes; x++) {
                                                importAnimation[&#x27;tile&#x27; + x] = x;
                                            }
                                        }
                                        for (let x = 0; x &lt; width; x++) {
                                            importCollision[x] = [];
                                            importRender[x] = [];
                                            for (let y = 0; y &lt; height; y++) {
                                                index = +data[x + y * width] - 1; // -1 from original src to make it zero-based.
                                                importRender[x][y] = &#x27;tile&#x27; + index;
                                                index += 1; // So collision map matches original src indexes. Render (above) should probably be changed at some point as well. DDD 3/30/2016
                                                importCollision[x][y] = index;
                        
                                                if (tilesetObjectGroups) {
                                                    const transform = entityTransformCheck(index);
                        
                                                    if (tilesetObjectGroups.has(transform.id)) {
                                                        const // These values cause a flipped tile to find x/y by starting on the opposite side of the tile (and subtracting x/y once in the called function).
                                                            offsetX = mapOffsetX + tileWidth * (transform.x &gt; 0 ? x : x + 1),
                                                            offsetY = mapOffsetY + tileHeight * (transform.y &gt; 0 ? y : y + 1);
                                                            
                                                        this.setUpEntities(tilesetObjectGroups.get(transform.id), offsetX, offsetY, tileWidth, tileHeight, tilesets, transform, progress, entityLinker);
                                                    }
                                                }
                                            }
                                        }
                                        for (let x = 0; x &lt; tileDefinition.components.length; x++) {
                                            if (tileDefinition.components[x].type === &#x27;RenderTiles&#x27;) {
                                                renderTiles = tileDefinition.components[x];
                                            }
                                            if (tileDefinition.components[x].spriteSheet === &#x27;import&#x27;) {
                                                tileDefinition.components[x].spriteSheet = importSpriteSheet;
                                            } else if (tileDefinition.components[x].spriteSheet) {
                                                if (typeof tileDefinition.components[x].spriteSheet === &#x27;string&#x27; &amp;&amp; platypus.game.settings.spriteSheets[tileDefinition.components[x].spriteSheet]) {
                                                    tileDefinition.components[x].spriteSheet = platypus.game.settings.spriteSheets[tileDefinition.components[x].spriteSheet];
                                                }
                                                if (!tileDefinition.components[x].spriteSheet.animations) {
                                                    tileDefinition.components[x].spriteSheet.animations = importAnimation;
                                                }
                                            }
                                            if (tileDefinition.components[x].collisionMap === &#x27;import&#x27;) {
                                                tileDefinition.components[x].collisionMap = importCollision;
                                            }
                                            if (tileDefinition.components[x].imageMap === &#x27;import&#x27;) {
                                                tileDefinition.components[x].imageMap = importRender;
                                            }
                                        }
                        
                                        if ((entityKind === &#x27;render-layer&#x27;) &amp;&amp; (!this.separateTiles) &amp;&amp; combineRenderLayer &amp;&amp; (combineRenderLayer.tileHeight === tHeight) &amp;&amp; (combineRenderLayer.tileWidth === tWidth) &amp;&amp; (combineRenderLayer.columns === width) &amp;&amp; (combineRenderLayer.rows === height)) {
                                            combineRenderLayer.triggerEvent(&#x27;add-tiles&#x27;, renderTiles);
                                            this.updateLoadingProgress(progress);
                                            return combineRenderLayer;
                                        } else {
                                            props = {};
                                            if ((entityKind === &#x27;render-layer&#x27;) &amp;&amp; this.spriteSheet) {
                                                if (typeof this.spriteSheet === &#x27;string&#x27;) {
                                                    props.spriteSheet = platypus.game.settings.spriteSheets[this.spriteSheet];
                                                } else {
                                                    props.spriteSheet = this.spriteSheet;
                                                }
                                                if (!props.spriteSheet.animations) {
                                                    props.spriteSheet.animations = importAnimation;
                                                }
                                            }
                                            return entityLinker.linkEntity(this.owner.addEntity(new Entity(tileDefinition, {
                                                properties: props
                                            }, this.updateLoadingProgress.bind(this, progress), this.owner)));
                                        }
                                    },
                                    
                                    convertImageLayer: function (imageLayer) {
                                        var asset = null,
                                            i = 0,
                                            dataCells = 0,
                                            imageId = &#x27;&#x27;,
                                            props = imageLayer.properties || {},
                                            repeat = getProperty(props, &#x27;repeat&#x27;),
                                            repeatX = getProperty(props, &#x27;repeat-x&#x27;),
                                            repeatY = getProperty(props, &#x27;repeat-y&#x27;),
                                            tileLayer = {
                                                data: [],
                                                image: &#x27;&#x27;,
                                                height: 1,
                                                name: imageLayer.name,
                                                offsetx: imageLayer.offsetx,
                                                offsety: imageLayer.offsety,
                                                type: &#x27;tilelayer&#x27;,
                                                width: 1,
                                                tileheight: 1,
                                                tilewidth: 1,
                                                x: imageLayer.x,
                                                y: imageLayer.y,
                                                properties: props
                                            };
                        
                                        if (repeat) {
                                            tileLayer.width = +repeat;
                                            tileLayer.height = +repeat;
                                        }
                                        if (repeatX) {
                                            tileLayer.width = +repeatX;
                                        }
                                        if (repeatY) {
                                            tileLayer.height = +repeatY;
                                        }
                                        dataCells = tileLayer.width * tileLayer.height;
                                        for (i = 0; i &lt; dataCells; i++) {
                                            tileLayer.data.push(1);
                                        }
                        
                                        asset = this.assetCache.get(imageLayer.name);
                                        if (asset) { // Prefer to have name in tiled match image id in game
                                            tileLayer.image = imageLayer.name;
                                            tileLayer.tileheight = asset.height;
                                            tileLayer.tilewidth = asset.width;
                                        } else {
                                            imageId = getImageId(imageLayer.image);
                                            asset = this.assetCache.get(imageId);
                                            if (asset) {
                                                platypus.debug.warn(&#x27;Component TiledLoader: Did not find a spritesheet for &quot;&#x27; + imageLayer.name + &#x27;&quot;, so using &quot;&#x27; + imageLayer.image + &#x27;&quot; instead.&#x27;);
                                                tileLayer.image = imageId;
                                                tileLayer.tileheight = asset.height;
                                                tileLayer.tilewidth = asset.width;
                                            } else {
                                                platypus.debug.warn(&#x27;Component TiledLoader: Cannot find the &quot;&#x27; + imageLayer.name + &#x27;&quot; sprite sheet. Add it to the list of assets in config.json and give it the id &quot;&#x27; + imageLayer.name + &#x27;&quot;.&#x27;);
                                                tileLayer.image = imageLayer.image;
                                            }
                                        }
                        
                                        tileLayer.tileset = {
                                            &quot;columns&quot;: 1,
                                            &quot;image&quot;: tileLayer.image,
                                            &quot;imageheight&quot;: tileLayer.tileheight,
                                            &quot;imagewidth&quot;: tileLayer.tilewidth,
                                            &quot;margin&quot;: 0,
                                            &quot;name&quot;: imageLayer.name,
                                            &quot;spacing&quot;: 0,
                                            &quot;tilecount&quot;: 1,
                                            &quot;tileheight&quot;: tileLayer.tileheight,
                                            &quot;tilewidth&quot;: tileLayer.tilewidth,
                                            &quot;type&quot;: &quot;tileset&quot;
                                        };
                                        
                                        return tileLayer;
                                    },
                                    
                                    loadLevel: function (levelData, callback) {
                                        const
                                            entityLinker = EntityLinker.setUp();
                        
                                        var asset = null,
                                            layers = null,
                                            level = null,
                                            height = 0,
                                            i = 0,
                                            imageId = &#x27;&#x27;,
                                            images = null,
                                            layer = null,
                                            layerDefinition = null,
                                            tileset = null,
                                            tilesets = null,
                                            tilesetObjectGroups = DataMap.setUp(),
                                            tileWidth = 0,
                                            tileHeight = 0,
                                            progress = Data.setUp(&#x27;count&#x27;, 0, &#x27;progress&#x27;, 0, &#x27;total&#x27;, 0),
                                            width = 0,
                                            x = 0,
                                            y = 0;
                                        
                                        //format level appropriately
                                        if (typeof levelData.level === &#x27;string&#x27;) {
                                            level = platypus.game.settings.levels[levelData.level];
                                        } else {
                                            level = levelData.level;
                                        }
                                        layers = level.layers;
                                        tilesets = importTilesetData(level.tilesets);
                                        tileWidth = level.tilewidth;
                                        tileHeight = level.tileheight;
                        
                                        createTilesetObjectGroupReference(tilesetObjectGroups, tilesets);
                        
                                        if (level.properties) {
                                            entityLinker.linkObject(this.owner.tiledId = 0); // Level
                                            mergeAndFormatProperties(level.properties, this.owner, entityLinker);
                                            entityLinker.linkEntity(this.owner);
                                        }
                                        
                                        if (this.images) {
                                            images = greenSlice(this.images);
                                        } else {
                                            images = arrayCache.setUp();
                                        }
                                        if (images.length === 0) {
                                            for (i = 0; i &lt; tilesets.length; i++) {
                                                tileset = tilesets[i];
                                                asset = this.assetCache.get(tileset.name);
                                                if (asset) { // Prefer to have name in tiled match image id in game
                                                    images.push(tileset.name);
                                                } else {
                                                    imageId = getImageId(tileset.image);
                                                    asset = this.assetCache.get(imageId);
                                                    if (asset) {
                                                        platypus.debug.warn(&#x27;Component TiledLoader: Did not find a spritesheet for &quot;&#x27; + tileset.name + &#x27;&quot;, so using &quot;&#x27; + tileset.image + &#x27;&quot; instead.&#x27;);
                                                        images.push(imageId);
                                                    } else {
                                                        platypus.debug.warn(&#x27;Component TiledLoader: Cannot find the &quot;&#x27; + tileset.name + &#x27;&quot; sprite sheet. Add it to the list of assets in config.json and give it the id &quot;&#x27; + tileset.name + &#x27;&quot;.&#x27;);
                                                        images.push(tileset.image);
                                                    }
                                                }
                                            }
                                        }
                                        
                                        width = level.width * tileWidth;
                                        height = level.height * tileHeight;
                        
                                        if (this.offsetMap) {
                                            x = getPowerOfTen(width);
                                            y = getPowerOfTen(height);
                                        }
                        
                                        progress.total = i = layers.length;
                        
                                        this.finishedLoading = finishedLoading.bind(this, level, x, y, width, height, tileWidth, tileHeight, callback);
                        
                                        for (i = 0; i &lt; layers.length; i++) {
                                            layerDefinition = layers[i];
                                            switch (layerDefinition.type) {
                                            case &#x27;imagelayer&#x27;:
                                                layer = this.convertImageLayer(layerDefinition);
                                                layer = this.createLayer(getProperty(layer.properties, &#x27;entity&#x27;) || &#x27;image-layer&#x27;, layer, x, y, layer.tilewidth, layer.tileheight, [layer.tileset], null, images, layer, progress, entityLinker);
                                                break;
                                            case &#x27;objectgroup&#x27;:
                                                this.setUpEntities(layerDefinition, x, y, tileWidth, tileHeight, tilesets, null, progress, entityLinker);
                                                layer = null;
                                                this.updateLoadingProgress(progress);
                                                break;
                                            case &#x27;tilelayer&#x27;:
                                                layer = this.setupLayer(layerDefinition, layer, x, y, tileWidth, tileHeight, tilesets, tilesetObjectGroups, images, progress, entityLinker);
                                                break;
                                            default:
                                                platypus.debug.warn(&#x27;Component TiledLoader: Platypus does not support Tiled layers of type &quot;&#x27; + layerDefinition.type + &#x27;&quot;. This layer will not be loaded.&#x27;);
                                                this.updateLoadingProgress(progress);
                                            }
                                            this.layerZ += this.layerIncrement;
                                        }
                        
                                        tilesetObjectGroups.recycle();
                                    },
                                    
                                    setUpEntities: (function () {
                                        const
                                            tBoth = function (point) {
                                                return Data.setUp(&#x27;x&#x27;, -point.x, &#x27;y&#x27;, -point.y);
                                            },
                                            tNone = function (point) {
                                                return Data.setUp(&#x27;x&#x27;, point.x, &#x27;y&#x27;, point.y);
                                            },
                                            tX = function (point) {
                                                return Data.setUp(&#x27;x&#x27;, -point.x, &#x27;y&#x27;, point.y);
                                            },
                                            tY = function (point) {
                                                return Data.setUp(&#x27;x&#x27;, point.x, &#x27;y&#x27;, -point.y);
                                            },
                                            transformPoints = function (points, transformX, transformY) {
                                                const
                                                    arr = arrayCache.setUp(),
                                                    reverseCycle = transformX ^ transformY,
                                                    transform = transformX ? transformY ? tBoth : tX : transformY ? tY : tNone;
                        
                                                if (reverseCycle) {
                                                    let i = points.length;
                                                    while (i--) {
                                                        arr.push(transform(points[i]));
                                                    }
                                                    arr.unshift(arr.pop()); // so the same point is at the beginning.
                                                } else {
                                                    for (let i = 0; i &lt; points.length; i++) {
                                                        arr.push(transform(points[i]));
                                                    }
                                                }
                        
                                                return arr;
                                            },
                                            getPolyShape = function (type, points, transformX, transformY, decomposed) {
                                                const
                                                    shape = {
                                                        type: type,
                                                        points: transformPoints(points, transformX, transformY)
                                                    };
                        
                                                if (decomposed) {
                                                    const decomposedPoints = [];
                                                    let p = 0;
                        
                                                    for (p = 0; p &lt; decomposed.length; p++) {
                                                        decomposedPoints.push(transformPoints(decomposed[p], transformX, transformY));
                                                    }
                            
                                                    shape.decomposedPolygon = decomposedPoints;
                                                }
                        
                                                return shape;
                                            };
                        
                                        return function (layer, mapOffsetX, mapOffsetY, tileWidth, tileHeight, tilesets, transform, progress, entityLinker) {
                                            var clamp = 1000,
                                                widthOffset = 0,
                                                heightOffset = 0,
                                                x = 0,
                                                a = 0,
                                                v = null,
                                                obj = 0,
                                                entityDefinition = null,
                                                entityDefProps = null,
                                                entityPositionX = getProperty(layer.properties, &#x27;entityPositionX&#x27;) || this.entityPositionX,
                                                entityPositionY = getProperty(layer.properties, &#x27;entityPositionY&#x27;) || this.entityPositionY,
                                                gid = -1,
                                                smallestX = Infinity,
                                                largestX = -Infinity,
                                                smallestY = Infinity,
                                                largestY = -Infinity,
                                                polyPoints = null,
                                                fallbackWidth = 0,
                                                fallbackHeight = 0,
                                                transformX = transform ? transform.x : 1,
                                                transformY = transform ? transform.y : 1,
                                                len = layer.objects.length;
                            
                                            mapOffsetX += layer.offsetx || 0;
                                            mapOffsetY += layer.offsety || 0;
                        
                                            progress.total += len;
                            
                                            for (obj = 0; obj &lt; len; obj++) {
                                                const
                                                    entity = layer.objects[obj],
                                                    entityData = getEntityData(entity, tilesets, entityLinker);
                                                
                                                if (entityData) {
                                                    const
                                                        properties = entityData.properties,
                                                        entityType = entityData.type,
                                                        entityPackage = {
                                                            properties: properties
                                                        };
                        
                                                    gid = entityData.gid;
                                                    entityDefinition = platypus.game.settings.entities[entityType];
                                                    if (entityDefinition) {
                                                        entityDefProps = entityDefinition.properties || null;
                                                        entityPackage.type = entityType;
                                                    } else {
                                                        entityDefProps = null;
                                                        entityPackage.id = entityType;
                                                    }
                            
                                                    if (entity.polygon || entity.polyline) {
                                                        //Figuring out the width of the polygon and shifting the origin so it&#x27;s in the top-left.
                                                        smallestX = Infinity;
                                                        largestX = -Infinity;
                                                        smallestY = Infinity;
                                                        largestY = -Infinity;
                            
                                                        polyPoints = null;
                                                        if (entity.polygon) {
                                                            polyPoints = entity.polygon;
                                                        } else if (entity.polyline) {
                                                            polyPoints = entity.polyline;
                                                        }
                            
                                                        for (x = 0; x &lt; polyPoints.length; x++) {
                                                            if (polyPoints[x].x &gt; largestX) {
                                                                largestX = polyPoints[x].x;
                                                            }
                                                            if (polyPoints[x].x &lt; smallestX) {
                                                                smallestX = polyPoints[x].x;
                                                            }
                                                            if (polyPoints[x].y &gt; largestY) {
                                                                largestY = polyPoints[x].y;
                                                            }
                                                            if (polyPoints[x].y &lt; smallestY) {
                                                                smallestY = polyPoints[x].y;
                                                            }
                                                        }
                                                        properties.width = largestX - smallestX;
                                                        properties.height = largestY - smallestY;
                                                        properties.x = entity.x + mapOffsetX;
                                                        properties.y = entity.y + mapOffsetY;
                            
                                                        widthOffset = 0;
                                                        heightOffset = 0;
                            
                                                        if (entity.polygon) {
                                                            properties.shape = getPolyShape(&#x27;polygon&#x27;, polyPoints, transformX === -1, transformY === -1, properties.decomposedPolygon);
                                                        } else if (entity.polyline) {
                                                            properties.shape = getPolyShape(&#x27;polyline&#x27;, polyPoints, transformX === -1, transformY === -1, null);
                                                        }
                        
                                                        if (entity.rotation) {
                                                            properties.rotation = entity.rotation;
                                                        }
                                                    } else {
                                                        fallbackWidth = tileWidth;
                                                        fallbackHeight = tileHeight;
                                                        widthOffset = 0;
                                                        heightOffset = 0;
                                                        properties.width = entity.width || 0;
                                                        properties.height = entity.height || 0;
                            
                                                        if (entityDefProps) {
                                                            if (typeof entityDefProps.width === &#x27;number&#x27;) {
                                                                properties.width = entityDefProps.width;
                                                                widthOffset = fallbackWidth;
                                                            }
                                                            if (typeof entityDefProps.height === &#x27;number&#x27;) {
                                                                properties.height = entityDefProps.height;
                                                                heightOffset = fallbackHeight;
                                                            }
                                                        }
                            
                                                        if (!entity.point) {
                                                            if (!properties.width) {
                                                                properties.width = fallbackWidth;
                                                            }
                                                            if (!properties.height) {
                                                                properties.height = fallbackHeight;
                                                            }
                                                            widthOffset = widthOffset || properties.width;
                                                            heightOffset = heightOffset || properties.height;
                                                        }
                            
                                                        properties.x = entity.x;
                                                        properties.y = entity.y;
                            
                                                        if (entity.rotation) {
                                                            const
                                                                w = properties.width / 2,
                                                                h = properties.height / 2;
                        
                                                            properties.rotation = entity.rotation;
                        
                                                            if (w || h) {
                                                                a = ((entity.rotation / 180) % 2) * Math.PI;
                                                                v = Vector.setUp(w, -h).rotate(a);
                                                                properties.x = Math.round((properties.x + v.x - w) * clamp) / clamp;
                                                                properties.y = Math.round((properties.y + v.y + h) * clamp) / clamp;
                                                                v.recycle();
                                                            }
                                                        }
                            
                                                        if (entityPositionX === &#x27;left&#x27;) {
                                                            properties.regX = 0;
                                                        } else if (entityPositionX === &#x27;center&#x27;) {
                                                            properties.regX = properties.width / 2;
                                                            properties.x += widthOffset / 2;
                                                        } else if (entityPositionX === &#x27;right&#x27;) {
                                                            properties.regX = properties.width;
                                                            properties.x += widthOffset;
                                                        }
                                                        properties.x = mapOffsetX + properties.x * transformX;
                            
                                                        if (gid === -1) {
                                                            properties.y += properties.height;
                                                        }
                                                        if (entityPositionY === &#x27;bottom&#x27;) {
                                                            properties.regY = properties.height;
                                                        } else if (entityPositionY === &#x27;center&#x27;) {
                                                            properties.regY = properties.height / 2;
                                                            properties.y -= heightOffset / 2;
                                                        } else if (entityPositionY === &#x27;top&#x27;) {
                                                            properties.regY = 0;
                                                            properties.y -= heightOffset;
                                                        }
                                                        properties.y = mapOffsetY + properties.y * transformY;
                            
                                                        if (entity.ellipse) {
                                                            properties.shape = {};
                                                            properties.shape.type = &#x27;circle&#x27;;//&#x27;ellipse&#x27;;
                                                            properties.shape.width = properties.width;
                                                            properties.shape.height = properties.height;
                            
                                                            // Tiled has ellipses, but Platypus only accepts circles. Setting a radius based on the average of width and height in case a non-circular ellipse is imported.
                                                            properties.shape.radius = (properties.width + properties.height) / 4;
                                                        } else if (entity.width &amp;&amp; entity.height) {
                                                            properties.shape = {};
                                                            properties.shape.type = &#x27;rectangle&#x27;;
                                                            properties.shape.width = properties.width;
                                                            properties.shape.height = properties.height;
                                                        }
                                                    }
                            
                                                    if (entityDefProps) {
                                                        properties.scaleX *= (entityDefProps.scaleX || 1);
                                                        properties.scaleY *= (entityDefProps.scaleY || 1);
                                                    }
                                                    properties.scaleX *= transformX;
                                                    properties.scaleY *= transformY;
                                                    properties.layerZ = this.layerZ;
                            
                                                    //Setting the z value. All values are getting added to the layerZ value.
                                                    if (properties.z) {
                                                        properties.z += this.layerZ;
                                                    } else if (entityDefProps &amp;&amp; (typeof entityDefProps.z === &#x27;number&#x27;)) {
                                                        properties.z = this.layerZ + entityDefProps.z;
                                                    } else {
                                                        properties.z = this.layerZ;
                                                    }
                            
                                                    if (properties.lazyLoad || (entityDefProps &amp;&amp; entityDefProps.lazyLoad)) {
                                                        entityPackage.aabb = AABB.setUp(properties.x + properties.width / 2 - properties.regX, properties.y + properties.height / 2 - properties.regY, properties.width || 1, properties.height || 1);
                                                        entityPackage.entityLinker = entityLinker;
                                                        this.lazyLoads.push(entityPackage);
                                                        this.updateLoadingProgress(progress);
                                                    } else {
                                                        const
                                                            createdEntity = this.owner.addEntity(entityPackage, this.updateLoadingProgress.bind(this, progress));
                                                        
                                                        entityLinker.linkEntity(createdEntity);
                        
                                                        if (createdEntity &amp;&amp; createdEntity.camera) {
                                                            this.followEntity = {
                                                                entity: createdEntity,
                                                                mode: createdEntity.camera
                                                            }; //used by camera
                                                        }
                                                    }
                                                } else {
                                                    this.updateLoadingProgress(progress);
                                                }
                                            }
                                        };
                                    }()),
                        
                                    setupLayer: function (layer, combineRenderLayer, mapOffsetX, mapOffsetY, tileWidth, tileHeight, tilesets, tilesetObjectGroups, images, progress, entityLinker) {
                                        var canCombine = false,
                                            specified = getProperty(layer.properties, &#x27;entity&#x27;),
                                            entity = specified || &#x27;render-layer&#x27;, // default
                                            entityDefinition = null,
                                            i = 0;
                                        
                                        // Need to check whether the entity can be combined for optimization. This combining of tile layers might be a nice addition to the compilation tools so it&#x27;s not happening here.
                                        entityDefinition = platypus.game.settings.entities[entity] || standardEntityLayers[entity];
                                        if (entityDefinition) {
                                            i = entityDefinition.components.length;
                                            while (i--) {
                                                if (entityDefinition.components[i].type === &quot;RenderTiles&quot;) {
                                                    canCombine = true;
                                                    break;
                                                }
                                            }
                                        }
                        
                                        if (canCombine) {
                                            return this.createLayer(entity, layer, mapOffsetX, mapOffsetY, tileWidth, tileHeight, tilesets, tilesetObjectGroups, images, combineRenderLayer, progress, entityLinker);
                                        } else {
                                            this.createLayer(entity, layer, mapOffsetX, mapOffsetY, tileWidth, tileHeight, tilesets, tilesetObjectGroups, images, combineRenderLayer, progress, entityLinker);
                                            return null;
                                        }
                                    },
                                    
                                    updateLoadingProgress: function (progress) {
                                        progress.count += 1;
                                        progress.progress = progress.count / progress.total;
                        
                                        /**
                                         * As a level is loaded, this event is triggered to show progress.
                                         *
                                         * @event &#x27;level-loading-progress&#x27;
                                         * @param message {platypus.Data} Contains progress data.
                                         * @param message.count {Number} The number of loaded entities.
                                         * @param message.progress {Number} A fraction of count / total.
                                         * @param message.total {Number} The total number of entities being loaded by this component.
                                         */
                                        this.owner.triggerEvent(&#x27;level-loading-progress&#x27;, progress);
                        
                                        if (progress.count === progress.total) {
                                            progress.recycle();
                                            this.finishedLoading();
                                        }
                                    },
                        
                                    destroy: function () {
                                        arrayCache.recycle(this.lazyLoads);
                                        this.lazyLoads = null;
                                    }
                                },
                                
                                getAssetList: function (def, props, defaultProps, data) {
                                    var ps = props || {},
                                        dps = defaultProps || {},
                                        ss     = def.spriteSheet || ps.spriteSheet || dps.spriteSheet,
                                        images = def.images || ps.images || dps.images,
                                        assets = checkLevel((data &amp;&amp; data.level) || def.level || ps.level || dps.level, ss);
                                    
                                    if (ss) {
                                        if (typeof ss === &#x27;string&#x27;) {
                                            union(assets, platypus.game.settings.spriteSheets[ss].images);
                                        } else {
                                            union(assets, ss.images);
                                        }
                                    }
                                    
                                    if (images) {
                                        union(assets, images);
                                    }
                                    
                                    return assets;
                                }
                            });
                        }());
                        
                        
                            </pre>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
