<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="../assets/css/yui-cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/x-icon" href="../assets/favicon.ico">
    <script src="../assets/js/yui-source.js"></script>
	<title>platypus v0.11.11 API Documentation : src\components\RenderContainer.js</title>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><a href="https://github.com/PBS-KIDS/Platypus"><img src="..\assets\platypus-title.png" title="platypus"></a></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Documentation for: 0.11.11</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/platypus.AABB.html">platypus.AABB</a></li>
                                <li><a href="../classes/platypus.ActionState.html">platypus.ActionState</a></li>
                                <li><a href="../classes/platypus.Async.html">platypus.Async</a></li>
                                <li><a href="../classes/platypus.CollisionData.html">platypus.CollisionData</a></li>
                                <li><a href="../classes/platypus.CollisionDataContainer.html">platypus.CollisionDataContainer</a></li>
                                <li><a href="../classes/platypus.CollisionShape.html">platypus.CollisionShape</a></li>
                                <li><a href="../classes/platypus.Component.html">platypus.Component</a></li>
                                <li><a href="../classes/platypus.components.AIChaser.html">platypus.components.AIChaser</a></li>
                                <li><a href="../classes/platypus.components.AIPacer.html">platypus.components.AIPacer</a></li>
                                <li><a href="../classes/platypus.components.AudioSFX.html">platypus.components.AudioSFX</a></li>
                                <li><a href="../classes/platypus.components.AudioVO.html">platypus.components.AudioVO</a></li>
                                <li><a href="../classes/platypus.components.Camera.html">platypus.components.Camera</a></li>
                                <li><a href="../classes/platypus.components.CameraFollowMe.html">platypus.components.CameraFollowMe</a></li>
                                <li><a href="../classes/platypus.components.CollisionBasic.html">platypus.components.CollisionBasic</a></li>
                                <li><a href="../classes/platypus.components.CollisionFilter.html">platypus.components.CollisionFilter</a></li>
                                <li><a href="../classes/platypus.components.CollisionGroup.html">platypus.components.CollisionGroup</a></li>
                                <li><a href="../classes/platypus.components.CollisionTiles.html">platypus.components.CollisionTiles</a></li>
                                <li><a href="../classes/platypus.components.ComponentSwitcher.html">platypus.components.ComponentSwitcher</a></li>
                                <li><a href="../classes/platypus.components.Counter.html">platypus.components.Counter</a></li>
                                <li><a href="../classes/platypus.components.EntityContainer.html">platypus.components.EntityContainer</a></li>
                                <li><a href="../classes/platypus.components.EntityController.html">platypus.components.EntityController</a></li>
                                <li><a href="../classes/platypus.components.EventRender.html">platypus.components.EventRender</a></li>
                                <li><a href="../classes/platypus.components.HandlerCollision.html">platypus.components.HandlerCollision</a></li>
                                <li><a href="../classes/platypus.components.HandlerController.html">platypus.components.HandlerController</a></li>
                                <li><a href="../classes/platypus.components.HandlerLogic.html">platypus.components.HandlerLogic</a></li>
                                <li><a href="../classes/platypus.components.HandlerRender.html">platypus.components.HandlerRender</a></li>
                                <li><a href="../classes/platypus.components.Interactive.html">platypus.components.Interactive</a></li>
                                <li><a href="../classes/platypus.components.LevelBuilder.html">platypus.components.LevelBuilder</a></li>
                                <li><a href="../classes/platypus.components.LogicAngularMovement.html">platypus.components.LogicAngularMovement</a></li>
                                <li><a href="../classes/platypus.components.LogicAttachment.html">platypus.components.LogicAttachment</a></li>
                                <li><a href="../classes/platypus.components.LogicButton.html">platypus.components.LogicButton</a></li>
                                <li><a href="../classes/platypus.components.LogicCarrier.html">platypus.components.LogicCarrier</a></li>
                                <li><a href="../classes/platypus.components.LogicDestroyMe.html">platypus.components.LogicDestroyMe</a></li>
                                <li><a href="../classes/platypus.components.LogicDirectionalMovement.html">platypus.components.LogicDirectionalMovement</a></li>
                                <li><a href="../classes/platypus.components.LogicPortable.html">platypus.components.LogicPortable</a></li>
                                <li><a href="../classes/platypus.components.LogicRotationalMovement.html">platypus.components.LogicRotationalMovement</a></li>
                                <li><a href="../classes/platypus.components.LogicWindUpRacer.html">platypus.components.LogicWindUpRacer</a></li>
                                <li><a href="../classes/platypus.components.Motion.html">platypus.components.Motion</a></li>
                                <li><a href="../classes/platypus.components.Mover.html">platypus.components.Mover</a></li>
                                <li><a href="../classes/platypus.components.NodeMap.html">platypus.components.NodeMap</a></li>
                                <li><a href="../classes/platypus.components.NodeResident.html">platypus.components.NodeResident</a></li>
                                <li><a href="../classes/platypus.components.Orientation.html">platypus.components.Orientation</a></li>
                                <li><a href="../classes/platypus.components.RandomEvents.html">platypus.components.RandomEvents</a></li>
                                <li><a href="../classes/platypus.components.RelayFamily.html">platypus.components.RelayFamily</a></li>
                                <li><a href="../classes/platypus.components.RelayGame.html">platypus.components.RelayGame</a></li>
                                <li><a href="../classes/platypus.components.RelayLinker.html">platypus.components.RelayLinker</a></li>
                                <li><a href="../classes/platypus.components.RelayParent.html">platypus.components.RelayParent</a></li>
                                <li><a href="../classes/platypus.components.RelaySelf.html">platypus.components.RelaySelf</a></li>
                                <li><a href="../classes/platypus.components.RenderAnimation.html">platypus.components.RenderAnimation</a></li>
                                <li><a href="../classes/platypus.components.RenderContainer.html">platypus.components.RenderContainer</a></li>
                                <li><a href="../classes/platypus.components.RenderDebug.html">platypus.components.RenderDebug</a></li>
                                <li><a href="../classes/platypus.components.RenderDestroyMe.html">platypus.components.RenderDestroyMe</a></li>
                                <li><a href="../classes/platypus.components.RenderProgress.html">platypus.components.RenderProgress</a></li>
                                <li><a href="../classes/platypus.components.RenderSpine.html">platypus.components.RenderSpine</a></li>
                                <li><a href="../classes/platypus.components.RenderSprite.html">platypus.components.RenderSprite</a></li>
                                <li><a href="../classes/platypus.components.RenderText.html">platypus.components.RenderText</a></li>
                                <li><a href="../classes/platypus.components.RenderTiles.html">platypus.components.RenderTiles</a></li>
                                <li><a href="../classes/platypus.components.SceneChanger.html">platypus.components.SceneChanger</a></li>
                                <li><a href="../classes/platypus.components.StateRender.html">platypus.components.StateRender</a></li>
                                <li><a href="../classes/platypus.components.TiledLoader.html">platypus.components.TiledLoader</a></li>
                                <li><a href="../classes/platypus.components.Timeline.html">platypus.components.Timeline</a></li>
                                <li><a href="../classes/platypus.components.Tutorial.html">platypus.components.Tutorial</a></li>
                                <li><a href="../classes/platypus.components.VoiceOver.html">platypus.components.VoiceOver</a></li>
                                <li><a href="../classes/platypus.components.XHR.html">platypus.components.XHR</a></li>
                                <li><a href="../classes/platypus.Data.html">platypus.Data</a></li>
                                <li><a href="../classes/platypus.DataMap.html">platypus.DataMap</a></li>
                                <li><a href="../classes/platypus.Entity.html">platypus.Entity</a></li>
                                <li><a href="../classes/platypus.Game.html">platypus.Game</a></li>
                                <li><a href="../classes/platypus.Messenger.html">platypus.Messenger</a></li>
                                <li><a href="../classes/platypus.PIXIAnimation.html">platypus.PIXIAnimation</a></li>
                                <li><a href="../classes/platypus.PlatypusPlugin.html">platypus.PlatypusPlugin</a></li>
                                <li><a href="../classes/platypus.Scene.html">platypus.Scene</a></li>
                                <li><a href="../classes/platypus.StateMap.html">platypus.StateMap</a></li>
                                <li><a href="../classes/platypus.Vector.html">platypus.Vector</a></li>
                                <li><a href="../classes/window.Array.html">window.Array</a></li>
                                <li><a href="../classes/window.Map.html">window.Map</a></li>
                                <li><a href="../classes/window.String.html">window.String</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/platypus.html">platypus</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
            <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <script>
                        	var name = src\components\RenderContainer.js      
                        </script>
                        <h1 class="file-heading">File:src\components\RenderContainer.js</h1>
                        
                        <div class="file">
                            <pre class="code prettyprint linenums">
                        /**
                         * This component is attached to entities that will appear in the game world. It creates a PIXI Container to contain all other display objects on the entity and keeps the container updates with the entity&#x27;s location and other dynamic properties.
                         *
                         * @namespace platypus.components
                         * @class RenderContainer
                         * @uses platypus.Component
                         * @since 0.11.0
                         */
                        /* global include, platypus */
                        (function () {
                            &#x27;use strict&#x27;;
                            
                            var AABB = include(&#x27;platypus.AABB&#x27;),
                                CanvasRenderer = include(&#x27;PIXI.CanvasRenderer&#x27;),
                                ColorMatrixFilter = include(&#x27;PIXI.filters.ColorMatrixFilter&#x27;),
                                Container = include(&#x27;PIXI.Container&#x27;),
                                Data = include(&#x27;platypus.Data&#x27;),
                                Graphics = include(&#x27;PIXI.Graphics&#x27;),
                                Interactive = include(&#x27;platypus.components.Interactive&#x27;),
                                Matrix = include(&#x27;PIXI.Matrix&#x27;),
                                pixiMatrix = new Matrix(),
                                castValue = function (color) {
                                    if (color === null) {
                                        return color;
                                    }
                                    if ((typeof color === &#x27;string&#x27;) &amp;&amp; (color[0] === &#x27;#&#x27;)) {
                                        color = &#x27;0x&#x27; + color.substring(1);
                                    }
                                    return +color;
                                },
                                processGraphics = (function () {
                                    var process = function (gfx, value) {
                                        var i = 0,
                                            paren  = value.indexOf(&#x27;(&#x27;),
                                            func   = value.substring(0, paren),
                                            values = value.substring(paren + 1, value.indexOf(&#x27;)&#x27;));
                        
                                        if (values.length) {
                                            values = values.greenSplit(&#x27;,&#x27;);
                                            i = values.length;
                                            while (i--) {
                                                values[i] = +values[i];
                                            }
                                            gfx[func].apply(gfx, values);
                                            values.recycle();
                                        } else {
                                            gfx[func]();
                                        }
                                    };
                        
                                    return function (gfx, value) {
                                        var i = 0,
                                            arr = value.greenSplit(&#x27;.&#x27;);
                        
                                        for (i = 0; i &lt; arr.length; i++) {
                                            process(gfx, arr[i]);
                                        }
                                        
                                        arr.recycle();
                                    };
                                }());
                            
                            return platypus.createComponentClass({
                                
                                id: &#x27;RenderContainer&#x27;,
                                
                                properties: {
                                    /**
                                     * Optional. A mask definition that determines where the image should clip. A string can also be used to create more complex shapes via the PIXI graphics API like: &quot;mask&quot;: &quot;r(10,20,40,40).dc(30,10,12)&quot;. Defaults to no mask or, if simply set to true, a rectangle using the entity&#x27;s dimensions.
                                     *
                                     *  &quot;mask&quot;: {
                                     *      &quot;x&quot;: 10,
                                     *      &quot;y&quot;: 10,
                                     *      &quot;width&quot;: 40,
                                     *      &quot;height&quot;: 40
                                     *  },
                                     *
                                     *  -OR-
                                     *
                                     *  &quot;mask&quot;: &quot;r(10,20,40,40).dc(30,10,12)&quot;
                                     *
                                     * @property mask
                                     * @type Object
                                     * @default null
                                     */
                                    mask: null,
                        
                                    /**
                                     * Defines whether the entity will respond to touch and click events. Setting this value will create an Interactive component on this entity with these properties. For example:
                                     *
                                     *  &quot;interactive&quot;: {
                                     *      &quot;hover&quot;: false,
                                     *      &quot;hitArea&quot;: {
                                     *          &quot;x&quot;: 10,
                                     *          &quot;y&quot;: 10,
                                     *          &quot;width&quot;: 40,
                                     *          &quot;height&quot;: 40
                                     *      }
                                     *  }
                                     *
                                     * @property interactive
                                     * @type Boolean|Object
                                     * @default false
                                     * @since 0.9.0
                                     */
                                    interactive: false,
                        
                                    /**
                                     * Optional. Whether this object can be rotated. It&#x27;s rotational angle is set by setting the this.owner.rotation value on the entity.
                                     *
                                     * @property rotate
                                     * @type Boolean
                                     * @default false
                                     */
                                    rotate: false,
                        
                                    /**
                                     * Whether this object can be mirrored over X. To mirror it over X set the this.owner.rotation value to be &gt; 90  and &lt; 270.
                                     *
                                     * @property mirror
                                     * @type Boolean
                                     * @default false
                                     */
                                    mirror: false,
                        
                                    /**
                                     * Optional. Whether this object can be flipped over Y. To flip it over Y set the this.owner.rotation to be &gt; 180.
                                     *
                                     * @property flip
                                     * @type Boolean
                                     * @default false
                                     */
                                    flip: false,
                        
                                    /**
                                     * Optional. Whether this object is visible or not. To change the visible value dynamically set this.owner.state.visible to true or false.
                                     *
                                     * @property visible
                                     * @type Boolean
                                     * @default false
                                     */
                                    visible: true,
                        
                                    /**
                                     * Optional. Whether this sprite should be cached into an entity with a &#x60;RenderTiles&#x60; component (like &quot;render-layer&quot;). The &#x60;RenderTiles&#x60; component must have its &quot;entityCache&quot; property set to &#x60;true&#x60;. Warning! This is a one-direction setting and will remove this component from the entity once the current frame has been cached.
                                     *
                                     * @property cache
                                     * @type Boolean
                                     * @default false
                                     */
                                    cache: false,
                        
                                    /**
                                     * Optional. Ignores the opacity of the owner.
                                     *
                                     * @property ignoreOpacity
                                     * @type Boolean
                                     * @default false
                                     */
                                    ignoreOpacity: false
                                },
                        
                                publicProperties: {
                                    /**
                                     * Prevents sprite from becoming invisible out of frame and losing mouse input connection.
                                     *
                                     * @property dragMode
                                     * @type Boolean
                                     * @default false
                                     * @since 0.8.3
                                     */
                                    dragMode: false,
                        
                                    /**
                                     * Determines the container this entity should use for rendering. Defaults to the top-most layer.
                                     *
                                     * @property renderGroup
                                     * @type String
                                     * @default &quot;&quot;
                                     * @since 0.11.10
                                     */
                                    renderGroup: &#x27;&#x27;,
                        
                                    /**
                                     * Optional. The rotation of the sprite in degrees. All sprites on the same entity are rotated the same amount unless they ignore the rotation value by setting &#x27;rotate&#x27; to false.
                                     *
                                     * @property rotation
                                     * @type Number
                                     * @default 0
                                     */
                                    rotation: 0,
                        
                                    /**
                                     * Optional. The X scaling factor for the image. Defaults to 1.
                                     *
                                     * @property scaleX
                                     * @type Number
                                     * @default 1
                                     */
                                    scaleX: 1,
                        
                                    /**
                                     * Optional. The Y scaling factor for the image. Defaults to 1.
                                     *
                                     * @property scaleY
                                     * @type Number
                                     * @default 1
                                     */
                                    scaleY: 1,
                        
                                    /**
                                     * Optional. The X skew factor of the sprite. Defaults to 0.
                                     *
                                     * @property skewX
                                     * @type Number
                                     * @default 0
                                     */
                                    skewX: 0,
                        
                                    /**
                                     * Optional. The Y skew factor for the image. Defaults to 0.
                                     *
                                     * @property skewY
                                     * @type Number
                                     * @default 0
                                     */
                                    skewY: 0,
                        
                                    /**
                                     * Optional. The tint applied to the sprite. Tint may be specified by number or text. For example, to give the sprite a red tint, set to 0xff0000 or &quot;#ff0000&quot;. Tint will be stored as a number even when set using text. Defaults to no tint.
                                     *
                                     * @property tint
                                     * @type Number|String
                                     * @default null
                                     */
                                    tint: null,
                        
                                    /**
                                     * Optional. The x position of the entity. Defaults to 0.
                                     *
                                     * @property x
                                     * @type Number
                                     * @default 0
                                     */
                                    x: 0,
                                    
                                    /**
                                     * Optional. The y position of the entity. Defaults to 0.
                                     *
                                     * @property y
                                     * @type Number
                                     * @default 0
                                     */
                                    y: 0,
                                    
                                    /**
                                     * Optional. The z position of the entity. Defaults to 0.
                                     *
                                     * @property z
                                     * @type Number
                                     * @default 0
                                     */
                                    z: 0
                                },
                                
                                initialize: function () {
                                    var container = this.container = this.owner.container = new Container(),
                                        definition = null,
                                        initialTint = this.tint;
                        
                                    this.rootContainer = null;
                                    this.parentContainer = null;
                                    this.renderGroups = null;
                                    this.wasVisible = this.visible;
                                    this.lastX = this.owner.x;
                                    this.lastY = this.owner.y;
                                    this.camera = AABB.setUp();
                                    this.isOnCamera = true;
                                    this.needsCameraCheck = true;
                        
                                    this._tint = null;
                        
                                    // This should be simplified once PIXI supports a &#x60;tint&#x60; property on PIXI.Container: https://github.com/pixijs/pixi.js/issues/2328
                                    if (platypus.game.app.display.renderer instanceof CanvasRenderer) {
                                        Object.defineProperty(this.owner, &#x27;tint&#x27;, {
                                            get: function () {
                                                return this._tint;
                                            }.bind(this),
                                            set: function (value) {
                                                var children = this.container.children,
                                                    i = children.length,
                                                    color = castValue(value);
                        
                                                if (color === this._tint) {
                                                    return;
                                                }
                        
                                                while (i--) {
                                                    children[i].tint = color;
                                                }
                                                this._tint = color;
                                            }.bind(this)
                                        });
                                    } else {
                                        Object.defineProperty(this.owner, &#x27;tint&#x27;, {
                                            get: function () {
                                                return this._tint;
                                            }.bind(this),
                                            set: function (value) {
                                                var filters = this.container.filters,
                                                    matrix = null,
                                                    color = castValue(value);
                        
                                                if (color === this._tint) {
                                                    return;
                                                }
                        
                                                if (color === null) {
                                                    if (filters) {
                                                        this.container.filters = null;
                                                    }
                                                } else {
                                                    if (!filters) {
                                                        filters = this.container.filters = Array.setUp(new ColorMatrixFilter());
                                                    }
                                                    matrix = filters[0].matrix;
                                                    matrix[0] = (color &amp; 0xff0000) / 0xff0000; // Red
                                                    matrix[6] = (color &amp; 0xff00) / 0xff00; // Green
                                                    matrix[12] = (color &amp; 0xff) / 0xff; // Blue
                                                }
                        
                                                this._tint = color;
                                            }.bind(this)
                                        });
                                    }
                        
                                    this.storedRenderGroup = this.renderGroup;
                                    this._renderGroup = null;
                                    Object.defineProperty(this.owner, &#x27;renderGroup&#x27;, {
                                        get: function () {
                                            return this._renderGroup;
                                        }.bind(this),
                                        set: function (value) {
                                            var groups = this.renderGroups,
                                                i = groups.length,
                                                container = null,
                                                mask = null;
                        
                                            if (value === this._renderGroup) {
                                                return;
                                            }
                        
                                            this._renderGroup = value;
                        
                                            if (this.mask) {
                                                mask = this.mask;
                                                this.setMask();
                                            }
                        
                                            while (i--) {
                                                if (groups[i].name === value) {
                                                    groups[i].addChild(this.container);
                                                    groups[i].reorder = true;
                                                    if (mask) {
                                                        this.setMask(mask);
                                                    }
                                                    return;
                                                }
                                            }
                        
                                            container = new Container();
                                            container.name = value;
                                            container.z = this.owner.z;
                                            groups.push(container);
                                            this.rootContainer.addChild(container);
                                            this.rootContainer.reorder = true;
                                            container.addChild(this.container);
                                            if (mask) {
                                                this.setMask(mask);
                                            }
                                        }.bind(this)
                                    });
                                
                                    if (initialTint !== null) {
                                        this.tint = initialTint; // feed initial tint through setter.
                                    }
                        
                                    if (this.interactive) {
                                        definition = Data.setUp(
                                            &#x27;container&#x27;, container,
                                            &#x27;hitArea&#x27;, this.interactive.hitArea,
                                            &#x27;hover&#x27;, this.interactive.hover
                                        );
                                        this.owner.addComponent(new Interactive(this.owner, definition));
                                        definition.recycle();
                                    }
                        
                                    if (this.cache) {
                                        this.updateSprite(false);
                                        this.owner.cacheRender = this.container;
                                    }
                                },
                                
                                events: {
                                    /**
                                     * On receiving a &quot;cache&quot; event, this component triggers &quot;cache-sprite&quot; to cache its rendering into the background. This is an optimization for static images to reduce render calls.
                                     *
                                     * @method &#x27;cache&#x27;
                                     */
                                    &quot;cache&quot;: function () {
                                        this.updateSprite(false);
                                        this.owner.cacheRender = this.container;
                                        this.cache = true;
                                        if (this.owner.parent &amp;&amp; this.owner.parent.triggerEventOnChildren) {
                                            /**
                                             * On receiving a &quot;cache&quot; event, this component triggers &quot;cache-sprite&quot; to cache its rendering into the background. This is an optimization for static images to reduce render calls.
                                             *
                                             * @event &#x27;cache-sprite&#x27;
                                             * @param entity {platypus.Entity} This component&#x27;s owner.
                                             */
                                            this.owner.parent.triggerEventOnChildren(&#x27;cache-sprite&#x27;, this.owner);
                                        } else {
                                            platypus.debug.warn(&#x27;Unable to cache sprite for &#x27; + this.owner.type);
                                        }
                                    },
                        
                                    /**
                                     * Listens for this event to determine whether this sprite is visible.
                                     *
                                     * @method &#x27;camera-update&#x27;
                                     * @param camera.viewport {platypus.AABB} Camera position and size.
                                     */
                                    &quot;camera-update&quot;: function (camera) {
                                        this.camera.set(camera.viewport);
                                        
                                        // Set visiblity of sprite if within camera bounds
                                        this.needsCameraCheck = true;
                                    },
                                    
                                    /**
                                     * A setup message used to add the sprite to the stage. On receiving this message, the component sets its parent container to the stage contained in the message if it doesn&#x27;t already have one.
                                     *
                                     * @method &#x27;handle-render-load&#x27;
                                     * @param handlerData {Object} Data from the render handler
                                     * @param handlerData.container {PIXI.Container} The parent container.
                                     */
                                    &quot;handle-render-load&quot;: function (handlerData) {
                                        if (!this.rootContainer &amp;&amp; handlerData &amp;&amp; handlerData.container) {
                                            this.addStage(handlerData.container, handlerData.renderGroups);
                                            this.updateSprite(true); // Initial set up in case position, etc is needed prior to the first &quot;render&quot; event.
                                        }
                                    },
                                    
                                    /**
                                     * The render update message updates the sprite. If a sprite doesn&#x27;t have a container, it&#x27;s removed.
                                     *
                                     * @method &#x27;handle-render&#x27;
                                     * @param renderData {Object} Data from the render handler
                                     * @param renderData.container {PIXI.Container} The parent container.
                                     */
                                    &quot;handle-render&quot;: function (renderData) {
                                        if (!this.container) { // If this component&#x27;s removal is pending
                                            return;
                                        } else if (!this.rootContainer &amp;&amp; renderData &amp;&amp; renderData.container) {
                                            this.addStage(renderData.container, renderData.renderGroups);
                                        }
                        
                                        this.updateSprite(true);
                                    },
                                    
                                    /**
                                     * This event makes the sprite invisible.
                                     *
                                     * @method &#x27;hide-sprite&#x27;
                                     */
                                    &quot;hide-sprite&quot;: function () {
                                        this.visible = false;
                                    },
                        
                                    /**
                                     * This event makes the sprite visible.
                                     *
                                     * @method &#x27;show-sprite&#x27;
                                     */
                                    &quot;show-sprite&quot;: function () {
                                        this.visible = true;
                                    },
                                    
                                    /**
                                     * Defines the mask on the container/sprite. If no mask is specified, the mask is set to null.
                                     *
                                     * @method &#x27;set-mask&#x27;
                                     * @param mask {Object} The mask. This can specified the same way as the &#x27;mask&#x27; parameter on the component.
                                     */
                                    &quot;set-mask&quot;: function (mask) {
                                        this.setMask(mask);
                                    }
                                },
                                
                                methods: {
                                    addStage: function (stage, renderGroups) {
                                        if (stage) {
                                            this.rootContainer = stage;
                                            this.renderGroups = renderGroups;
                                            this.renderGroup = this.storedRenderGroup;
                        
                                            //Handle mask
                                            if (this.mask) {
                                                this.setMask(this.mask);
                                            }
                        
                                            /**
                                             * This event is triggered once the RenderSprite is ready to handle interactivity.
                                             *
                                             * @event &#x27;input-on&#x27;
                                             */
                                            this.owner.triggerEvent(&#x27;input-on&#x27;);
                                            return stage;
                                        } else {
                                            return null;
                                        }
                                    },
                                    
                                    updateSprite: (function () {
                                        var sort = function (a, b) {
                                            return a.z - b.z;
                                        };
                                        
                                        return function (uncached) {
                                            var x = 0,
                                                y = 0,
                                                o = this.owner.orientationMatrix,
                                                rotation = 0,
                                                matrix = pixiMatrix,
                                                mirrored = 1,
                                                flipped  = 1,
                                                angle    = null;
                                            
                                            x = this.owner.x;
                                            y = this.owner.y;
                                            if (this.rotate) {
                                                rotation = this.rotation;
                                            }
                                            if (this.container.z !== this.owner.z) {
                                                if (this.parentContainer) {
                                                    this.parentContainer.reorder = true;
                                                }
                                                this.container.z = this.owner.z;
                                            }
                        
                                            if (!this.ignoreOpacity &amp;&amp; (this.owner.opacity || (this.owner.opacity === 0))) {
                                                this.container.alpha = this.owner.opacity;
                                            }
                                            
                                            if (this.container.reorder) {
                                                this.container.reorder = false;
                                                this.container.children.sort(sort);
                                                this.needsCameraCheck = true; // reorder is set when adding children, so force another camera check.
                                            }
                                            
                                            if (this.mirror || this.flip) {
                                                angle = this.rotation % 360;
                                                
                                                if (this.mirror &amp;&amp; (angle &gt; 90) &amp;&amp; (angle &lt; 270)) {
                                                    mirrored = -1;
                                                }
                                                
                                                if (this.flip &amp;&amp; (angle &lt; 180)) {
                                                    flipped = -1;
                                                }
                                            }
                                            
                                            if (o) { // This is a 3x3 2D matrix describing an affine transformation.
                                                matrix.a = o[0][0];
                                                matrix.b = o[1][0];
                                                matrix.tx = x + o[0][2];
                                                matrix.c = o[0][1];
                                                matrix.d = o[1][1];
                                                matrix.ty = y + o[1][2];
                                                this.container.transform.setFromMatrix(matrix);
                                            } else {
                                                this.container.setTransform(x, y, this.scaleX * mirrored, this.scaleY * flipped, (rotation ? (rotation / 180) * Math.PI : 0), this.skewX, this.skewY);
                                            }
                                            
                                            // Set isCameraOn of sprite if within camera bounds
                                            if (!this.needsCameraCheck) {
                                                this.needsCameraCheck = (this.lastX !== this.owner.x) || (this.lastY !== this.owner.y);
                                            }
                                            if (uncached &amp;&amp; this.container &amp;&amp; (this.needsCameraCheck || (!this.wasVisible &amp;&amp; this.visible))) {
                                                this.isOnCamera = this.owner.parent.isOnCanvas(this.container.getBounds(false));
                                                this.needsCameraCheck = false;
                                            }
                                            
                                            this.lastX = this.owner.x;
                                            this.lastY = this.owner.y;
                                            this.wasVisible = this.visible;
                                            this.container.visible = (this.visible &amp;&amp; this.isOnCamera) || this.dragMode;
                                        };
                                    }()),
                                    
                                    setMask: function (shape) {
                                        var gfx = null;
                                        
                                        if (this.mask &amp;&amp; this.parentContainer) {
                                            this.parentContainer.removeChild(this.mask);
                                        }
                                        
                                        if (!shape) {
                                            this.mask = this.container.mask = null;
                                            return;
                                        }
                                        
                                        if (shape instanceof Graphics) {
                                            gfx = shape;
                                        } else {
                                            gfx = new Graphics();
                                            gfx.beginFill(0x000000, 1);
                                            if (typeof shape === &#x27;string&#x27;) {
                                                processGraphics(gfx, shape);
                                            } else if (shape.radius) {
                                                gfx.dc(shape.x || 0, shape.y || 0, shape.radius);
                                            } else if (shape.width &amp;&amp; shape.height) {
                                                gfx.r(shape.x || 0, shape.y || 0, shape.width, shape.height);
                                            }
                                            gfx.endFill();
                                        }
                                        
                                        gfx.isMask = true;
                        
                                        this.mask = this.container.mask = gfx;
                                        this.mask.z = 0; //TML 12-4-16 - Masks don&#x27;t need a Z, but this makes it play nice with the Z-ordering in HandlerRender.
                        
                                        if (this.parentContainer) {
                                            this.parentContainer.addChild(this.mask);
                                        }
                                    },
                                    
                                    destroy: function () {
                                        this.camera.recycle();
                                        if (this.parentContainer &amp;&amp; !this.container.mouseTarget) {
                                            this.parentContainer.removeChild(this.container);
                                            this.parentContainer = null;
                                        } else if (!this.cache) {
                                            this.container.destroy();
                                        }
                                        this.container = null;
                                    }
                                }
                            });
                        }());
                        
                            </pre>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
