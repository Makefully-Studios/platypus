<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="../assets/css/yui-cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/x-icon" href="../assets/favicon.ico">
    <script src="../assets/js/yui-source.js"></script>
	<title>platypus v2.0.0 API Documentation : src\components\RenderContainer.js</title>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><a href="https://github.com/PBS-KIDS/Platypus"><img src="..\assets\platypus-title.png" title="platypus"></a></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Documentation for: 2.0.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/platypus.AABB.html">platypus.AABB</a></li>
                                <li><a href="../classes/platypus.ActionState.html">platypus.ActionState</a></li>
                                <li><a href="../classes/platypus.AssetManager.html">platypus.AssetManager</a></li>
                                <li><a href="../classes/platypus.Async.html">platypus.Async</a></li>
                                <li><a href="../classes/platypus.CollisionData.html">platypus.CollisionData</a></li>
                                <li><a href="../classes/platypus.CollisionDataContainer.html">platypus.CollisionDataContainer</a></li>
                                <li><a href="../classes/platypus.CollisionShape.html">platypus.CollisionShape</a></li>
                                <li><a href="../classes/platypus.Component.html">platypus.Component</a></li>
                                <li><a href="../classes/platypus.components.AIChaser.html">platypus.components.AIChaser</a></li>
                                <li><a href="../classes/platypus.components.AIPacer.html">platypus.components.AIPacer</a></li>
                                <li><a href="../classes/platypus.components.AudioMusic.html">platypus.components.AudioMusic</a></li>
                                <li><a href="../classes/platypus.components.AudioSFX.html">platypus.components.AudioSFX</a></li>
                                <li><a href="../classes/platypus.components.AudioVO.html">platypus.components.AudioVO</a></li>
                                <li><a href="../classes/platypus.components.Camera.html">platypus.components.Camera</a></li>
                                <li><a href="../classes/platypus.components.CameraFollowMe.html">platypus.components.CameraFollowMe</a></li>
                                <li><a href="../classes/platypus.components.CollisionBasic.html">platypus.components.CollisionBasic</a></li>
                                <li><a href="../classes/platypus.components.CollisionFilter.html">platypus.components.CollisionFilter</a></li>
                                <li><a href="../classes/platypus.components.CollisionGroup.html">platypus.components.CollisionGroup</a></li>
                                <li><a href="../classes/platypus.components.CollisionTiles.html">platypus.components.CollisionTiles</a></li>
                                <li><a href="../classes/platypus.components.ComponentSwitcher.html">platypus.components.ComponentSwitcher</a></li>
                                <li><a href="../classes/platypus.components.Counter.html">platypus.components.Counter</a></li>
                                <li><a href="../classes/platypus.components.EntityContainer.html">platypus.components.EntityContainer</a></li>
                                <li><a href="../classes/platypus.components.EntityController.html">platypus.components.EntityController</a></li>
                                <li><a href="../classes/platypus.components.HandlerCollision.html">platypus.components.HandlerCollision</a></li>
                                <li><a href="../classes/platypus.components.HandlerController.html">platypus.components.HandlerController</a></li>
                                <li><a href="../classes/platypus.components.HandlerLogic.html">platypus.components.HandlerLogic</a></li>
                                <li><a href="../classes/platypus.components.HandlerRender.html">platypus.components.HandlerRender</a></li>
                                <li><a href="../classes/platypus.components.Interactive.html">platypus.components.Interactive</a></li>
                                <li><a href="../classes/platypus.components.LevelBuilder.html">platypus.components.LevelBuilder</a></li>
                                <li><a href="../classes/platypus.components.LogicAngularMovement.html">platypus.components.LogicAngularMovement</a></li>
                                <li><a href="../classes/platypus.components.LogicAttachment.html">platypus.components.LogicAttachment</a></li>
                                <li><a href="../classes/platypus.components.LogicButton.html">platypus.components.LogicButton</a></li>
                                <li><a href="../classes/platypus.components.LogicCarrier.html">platypus.components.LogicCarrier</a></li>
                                <li><a href="../classes/platypus.components.LogicDestroyMe.html">platypus.components.LogicDestroyMe</a></li>
                                <li><a href="../classes/platypus.components.LogicDirectionalMovement.html">platypus.components.LogicDirectionalMovement</a></li>
                                <li><a href="../classes/platypus.components.LogicDragDrop.html">platypus.components.LogicDragDrop</a></li>
                                <li><a href="../classes/platypus.components.LogicPortable.html">platypus.components.LogicPortable</a></li>
                                <li><a href="../classes/platypus.components.LogicRotationalMovement.html">platypus.components.LogicRotationalMovement</a></li>
                                <li><a href="../classes/platypus.components.LogicTimer.html">platypus.components.LogicTimer</a></li>
                                <li><a href="../classes/platypus.components.LogicWindUpRacer.html">platypus.components.LogicWindUpRacer</a></li>
                                <li><a href="../classes/platypus.components.Motion.html">platypus.components.Motion</a></li>
                                <li><a href="../classes/platypus.components.Mover.html">platypus.components.Mover</a></li>
                                <li><a href="../classes/platypus.components.NodeMap.html">platypus.components.NodeMap</a></li>
                                <li><a href="../classes/platypus.components.NodeResident.html">platypus.components.NodeResident</a></li>
                                <li><a href="../classes/platypus.components.Orientation.html">platypus.components.Orientation</a></li>
                                <li><a href="../classes/platypus.components.RandomEvents.html">platypus.components.RandomEvents</a></li>
                                <li><a href="../classes/platypus.components.RelativePosition.html">platypus.components.RelativePosition</a></li>
                                <li><a href="../classes/platypus.components.RelayFamily.html">platypus.components.RelayFamily</a></li>
                                <li><a href="../classes/platypus.components.RelayGame.html">platypus.components.RelayGame</a></li>
                                <li><a href="../classes/platypus.components.RelayLinker.html">platypus.components.RelayLinker</a></li>
                                <li><a href="../classes/platypus.components.RelayParent.html">platypus.components.RelayParent</a></li>
                                <li><a href="../classes/platypus.components.RelaySelf.html">platypus.components.RelaySelf</a></li>
                                <li><a href="../classes/platypus.components.RenderAnimator.html">platypus.components.RenderAnimator</a></li>
                                <li><a href="../classes/platypus.components.RenderContainer.html">platypus.components.RenderContainer</a></li>
                                <li><a href="../classes/platypus.components.RenderDebug.html">platypus.components.RenderDebug</a></li>
                                <li><a href="../classes/platypus.components.RenderDestroyMe.html">platypus.components.RenderDestroyMe</a></li>
                                <li><a href="../classes/platypus.components.RenderProgress.html">platypus.components.RenderProgress</a></li>
                                <li><a href="../classes/platypus.components.RenderSpine.html">platypus.components.RenderSpine</a></li>
                                <li><a href="../classes/platypus.components.RenderSprite.html">platypus.components.RenderSprite</a></li>
                                <li><a href="../classes/platypus.components.RenderText.html">platypus.components.RenderText</a></li>
                                <li><a href="../classes/platypus.components.RenderTiles.html">platypus.components.RenderTiles</a></li>
                                <li><a href="../classes/platypus.components.SceneChanger.html">platypus.components.SceneChanger</a></li>
                                <li><a href="../classes/platypus.components.TiledLoader.html">platypus.components.TiledLoader</a></li>
                                <li><a href="../classes/platypus.components.Timeline.html">platypus.components.Timeline</a></li>
                                <li><a href="../classes/platypus.components.Tutorial.html">platypus.components.Tutorial</a></li>
                                <li><a href="../classes/platypus.components.Tween.html">platypus.components.Tween</a></li>
                                <li><a href="../classes/platypus.components.VoiceOver.html">platypus.components.VoiceOver</a></li>
                                <li><a href="../classes/platypus.components.XHR.html">platypus.components.XHR</a></li>
                                <li><a href="../classes/platypus.Data.html">platypus.Data</a></li>
                                <li><a href="../classes/platypus.DataMap.html">platypus.DataMap</a></li>
                                <li><a href="../classes/platypus.Entity.html">platypus.Entity</a></li>
                                <li><a href="../classes/platypus.EntityLinker.html">platypus.EntityLinker</a></li>
                                <li><a href="../classes/platypus.Game.html">platypus.Game</a></li>
                                <li><a href="../classes/platypus.Gamepad.html">platypus.Gamepad</a></li>
                                <li><a href="../classes/platypus.Messenger.html">platypus.Messenger</a></li>
                                <li><a href="../classes/platypus.PIXIAnimation.html">platypus.PIXIAnimation</a></li>
                                <li><a href="../classes/platypus.SFXPlayer.html">platypus.SFXPlayer</a></li>
                                <li><a href="../classes/platypus.StateMap.html">platypus.StateMap</a></li>
                                <li><a href="../classes/platypus.Storage.html">platypus.Storage</a></li>
                                <li><a href="../classes/platypus.Vector.html">platypus.Vector</a></li>
                                <li><a href="../classes/platypus.VOPlayer.html">platypus.VOPlayer</a></li>
                                <li><a href="../classes/window.Map.html">window.Map</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/platypus.html">platypus</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
            <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <script>
                        	var name = src\components\RenderContainer.js      
                        </script>
                        <h1 class="file-heading">File:src\components\RenderContainer.js</h1>
                        
                        <div class="file">
                            <pre class="code prettyprint linenums">
                        /**
                         * This component is attached to entities that will appear in the game world. It creates a PIXI Container to contain all other display objects on the entity and keeps the container updates with the entity&#x27;s location and other dynamic properties.
                         *
                         * @namespace platypus.components
                         * @class RenderContainer
                         * @uses platypus.Component
                         */
                        /* global platypus */
                        import {Container, Graphics, Matrix, filters} from &#x27;pixi.js&#x27;;
                        import AABB from &#x27;../AABB.js&#x27;;
                        import Data from &#x27;../Data.js&#x27;;
                        import Interactive from &#x27;./Interactive.js&#x27;;
                        import {arrayCache} from &#x27;../utils/array.js&#x27;;
                        import createComponentClass from &#x27;../factory.js&#x27;;
                        import {greenSplit} from &#x27;../utils/string.js&#x27;;
                        
                        export default (function () {
                            var ColorMatrixFilter = filters.ColorMatrixFilter,
                                pixiMatrix = new Matrix(),
                                castValue = function (color) {
                                    if (color === null) {
                                        return color;
                                    }
                                    if ((typeof color === &#x27;string&#x27;) &amp;&amp; (color[0] === &#x27;#&#x27;)) {
                                        color = &#x27;0x&#x27; + color.substring(1);
                                    }
                                    return +color;
                                },
                                magSqr = function (x, y) {
                                    return x * x + y * y;
                                },
                                processGraphics = (function () {
                                    var process = function (gfx, value) {
                                        var i = 0,
                                            paren  = value.indexOf(&#x27;(&#x27;),
                                            func   = value.substring(0, paren),
                                            values = value.substring(paren + 1, value.indexOf(&#x27;)&#x27;)),
                                            polyRay = false;
                        
                                        if (values.length) {
                                            if (values[0] === &#x27;[&#x27;) {
                                                values = values.substring(1, values.length - 1);
                                                polyRay = true;
                                            }
                                            values = greenSplit(values, &#x27;,&#x27;);
                                            i = values.length;
                                            while (i--) {
                                                values[i] = +values[i];
                                            }
                                            if (polyRay) {
                                                gfx[func](values);
                                            } else {
                                                gfx[func].apply(gfx, values);
                                                arrayCache.recycle(values); // cannot recycle polygon above since it&#x27;s used by the polygon shape.
                                            }
                                        } else {
                                            gfx[func]();
                                        }
                                    };
                        
                                    return function (gfx, value) {
                                        var i = 0,
                                            arr = greenSplit(value, &#x27;.&#x27;);
                        
                                        for (i = 0; i &lt; arr.length; i++) {
                                            process(gfx, arr[i]);
                                        }
                                        
                                        arrayCache.recycle(arr);
                                    };
                                }());
                            
                            return createComponentClass({
                                
                                id: &#x27;RenderContainer&#x27;,
                                
                                properties: {
                                    /**
                                     * Optional. A mask definition that determines where the image should clip. A string can also be used to create more complex shapes via the PIXI graphics API like: &quot;mask&quot;: &quot;r(10,20,40,40).drawCircle(30,10,12)&quot;. Defaults to no mask or, if simply set to true, a rectangle using the entity&#x27;s dimensions. Note that the mask is in world coordinates by default. To make the mask local to the entity&#x27;s coordinates, set &#x60;localMask&#x60; to &#x60;true&#x60; in the RenderContainer properties.
                                     *
                                     *  &quot;mask&quot;: {
                                     *      &quot;x&quot;: 10,
                                     *      &quot;y&quot;: 10,
                                     *      &quot;width&quot;: 40,
                                     *      &quot;height&quot;: 40
                                     *  },
                                     *
                                     *  -OR-
                                     *
                                     *  &quot;mask&quot;: &quot;r(10,20,40,40).drawCircle(30,10,12)&quot;
                                     *
                                     * @property mask
                                     * @type Object
                                     * @default null
                                     */
                                    mask: null,
                        
                                    /**
                                     * Defines whether the entity will respond to touch and click events. Setting this value will create an Interactive component on this entity with these properties. For example:
                                     *
                                     *  &quot;interactive&quot;: {
                                     *      &quot;hover&quot;: false,
                                     *      &quot;hitArea&quot;: {
                                     *          &quot;x&quot;: 10,
                                     *          &quot;y&quot;: 10,
                                     *          &quot;width&quot;: 40,
                                     *          &quot;height&quot;: 40
                                     *      }
                                     *  }
                                     *
                                     * @property interactive
                                     * @type Boolean|Object
                                     * @default false
                                     */
                                    interactive: false,
                        
                                    /**
                                     * Whether to render objects to their new position over time instead of instantaneously if there has been a time adjustment. Time is in milliseconds.
                                     *
                                     * @property interpolation
                                     * @type Number
                                     * @default 0
                                     */
                                    interpolation: 0,
                        
                                    /**
                                     * Optional. What field this object should use to rotate.
                                     *
                                     * @property rotate
                                     * @type String
                                     * @default &#x27;rotation&#x27;
                                     */
                                    rotate: &#x27;rotation&#x27;,
                        
                                    /**
                                     * Whether this object can be mirrored over X. To mirror it over X set the this.owner.rotation value to be &gt; 90  and &lt; 270.
                                     *
                                     * @property mirror
                                     * @type Boolean
                                     * @default false
                                     */
                                    mirror: false,
                        
                                    /**
                                     * Optional. Whether this object can be flipped over Y. To flip it over Y set the this.owner.rotation to be &gt; 180.
                                     *
                                     * @property flip
                                     * @type Boolean
                                     * @default false
                                     */
                                    flip: false,
                        
                                    /**
                                     * Optional. Whether this object is visible or not. To change the visible value dynamically set this.owner.state.visible to true or false.
                                     *
                                     * @property visible
                                     * @type Boolean
                                     * @default false
                                     */
                                    visible: true,
                        
                                    /**
                                     * Optional. Whether this sprite should be cached into an entity with a &#x60;RenderTiles&#x60; component (like &quot;render-layer&quot;). The &#x60;RenderTiles&#x60; component must have its &quot;entityCache&quot; property set to &#x60;true&#x60;. Warning! This is a one-direction setting and will remove this component from the entity once the current frame has been cached.
                                     *
                                     * @property cache
                                     * @type Boolean
                                     * @default false
                                     */
                                    cache: false,
                        
                                    /**
                                     * Optional. Ignores the opacity of the owner.
                                     *
                                     * @property ignoreOpacity
                                     * @type Boolean
                                     * @default false
                                     */
                                    ignoreOpacity: false,
                        
                                    /**
                                     * Whether the mask should be relative to the entity&#x27;s coordinates.
                                     *
                                     * @property localMask
                                     * @type boolean
                                     * @default false
                                     */
                                    localMask: false
                                },
                        
                                publicProperties: {
                                    /**
                                     * Prevents sprite from becoming invisible out of frame and losing mouse input connection.
                                     *
                                     * @property dragMode
                                     * @type Boolean
                                     * @default false
                                     */
                                    dragMode: false,
                        
                                    /**
                                     * The entity or id of the entity that will act as the parent container. If not set, the entity will be rendered in the layer&#x27;s container.
                                     *
                                     * @property renderParent
                                     * @type String|Object
                                     * @default null
                                     */
                                    renderParent: null,
                        
                                    /**
                                     * Optional. The rotation of the sprite in degrees. All sprites on the same entity are rotated the same amount unless they ignore the rotation value by setting &#x27;rotate&#x27; to &quot;&quot;.
                                     *
                                     * Boolean values for the &quot;rotate&quot; property has been deprecated. Use &quot;rotation&quot; or &quot;orientationMatrix&quot; to specify the source of rotation for the render container.
                                     *
                                     * @property rotation
                                     * @type Number
                                     * @default 0
                                     */
                                    rotation: 0,
                        
                                    /**
                                     * Optional. The X scaling factor for the image. Defaults to 1.
                                     *
                                     * @property scaleX
                                     * @type Number
                                     * @default 1
                                     */
                                    scaleX: 1,
                        
                                    /**
                                     * Optional. The Y scaling factor for the image. Defaults to 1.
                                     *
                                     * @property scaleY
                                     * @type Number
                                     * @default 1
                                     */
                                    scaleY: 1,
                        
                                    /**
                                     * Optional. The X skew factor of the sprite. Defaults to 0.
                                     *
                                     * @property skewX
                                     * @type Number
                                     * @default 0
                                     */
                                    skewX: 0,
                        
                                    /**
                                     * Optional. The Y skew factor for the image. Defaults to 0.
                                     *
                                     * @property skewY
                                     * @type Number
                                     * @default 0
                                     */
                                    skewY: 0,
                        
                                    /**
                                     * Optional. The tint applied to the sprite. Tint may be specified by number or text. For example, to give the sprite a red tint, set to 0xff0000 or &quot;#ff0000&quot;. Tint will be stored as a number even when set using text. Defaults to no tint.
                                     *
                                     * @property tint
                                     * @type Number|String
                                     * @default null
                                     */
                                    tint: null,
                        
                                    /**
                                     * Optional. The x position of the entity. Defaults to 0.
                                     *
                                     * @property x
                                     * @type Number
                                     * @default 0
                                     */
                                    x: 0,
                                    
                                    /**
                                     * Optional. The y position of the entity. Defaults to 0.
                                     *
                                     * @property y
                                     * @type Number
                                     * @default 0
                                     */
                                    y: 0,
                                    
                                    /**
                                     * Optional. The z position of the entity. Defaults to 0.
                                     *
                                     * @property z
                                     * @type Number
                                     * @default 0
                                     */
                                    z: 0
                                },
                                
                                initialize: function () {
                                    const
                                        owner = this.owner,
                                        container = this.container = this.owner.container = new Container(),
                                        initialTint = this.tint;
                        
                                    container.sortableChildren = true;
                        
                                    if (this.rotate === true) {
                                        this.rotate = &#x27;rotation&#x27;;
                                        platypus.debug.warn(&#x27;RenderContainer: Boolean values for the &quot;rotate&quot; property has been deprecated. Use &quot;rotation&quot;, &quot;orientationMatrix&quot;, or &quot;&quot; to specify the source of rotation for the render container. This property defaults to &quot;rotation&quot;.&#x27;);
                                    }
                        
                                    this.parentContainer = null;
                                    this.wasVisible = this.visible;
                                    this.lastX = owner.x;
                                    this.lastY = owner.y;
                                    this.camera = AABB.setUp();
                                    this.isOnCamera = true;
                                    this.needsCameraCheck = true;
                        
                                    this._tint = null;
                        
                                    /**
                                     * The render update message updates the sprite.
                                     *
                                     * @method &#x27;handle-render&#x27;
                                     * @param [tick.tick.timeShift] {Boolean} Whether there has been a shift in time requiring interpolation.
                                     */
                                    if (this.interpolation) { // handle interpolation if timeline changes.
                                        const
                                            updateUsingOwnerXY = () =&gt; {
                                                this.updateSprite(true, this.owner.x, this.owner.y);
                                            },
                                            updateUsingInterpolationXY = () =&gt; {
                                                const
                                                    owner = this.owner,
                                                    interpolationDist = magSqr(this.lastX - owner.x, this.lastY - owner.y);
                            
                                                if (!interpolationTime || interpolationDist &lt; 1.5) {
                                                    interpolationTime = 0;
                                                    update = updateUsingOwnerXY;
                                                    update();
                                                } else {
                                                    const
                                                        ratio = Math.min((interpolationTime / interpolation), (lastInterpolationDistance / interpolationDist)),
                                                        alt = 1 - ratio;
                                                    
                                                    interpolationTime = Math.max(0, interpolationTime - 5);
                                                    fromX = this.lastX;
                                                    fromY = this.lastY;
                                                    lastInterpolationDistance = interpolationDist;
                        
                                                    this.updateSprite(true, owner.x * alt + fromX * ratio, owner.y * alt + fromY * ratio);
                                                }
                                            },
                                            interpolation = this.interpolation;
                                        let interpolationTime = 0,
                                            lastInterpolationDistance = 0,
                                            fromX = 0,
                                            fromY = 0,
                                            update = updateUsingOwnerXY;
                        
                                        this.addEventListener(&#x27;handle-render&#x27;, function (tick) {
                                            if (tick.tick.timeShift) {
                                                fromX = this.lastX;
                                                fromY = this.lastY;
                                                lastInterpolationDistance = magSqr(this.lastX - this.owner.x, this.lastY - this.owner.y);
                                                interpolationTime = lastInterpolationDistance &gt; 1.5 ? interpolation : 0;
                                                update = updateUsingInterpolationXY;
                                            } else {
                                                update();
                                            }
                                        });
                                    } else {
                                        this.addEventListener(&#x27;handle-render&#x27;, function () {
                                            this.updateSprite(true, this.owner.x, this.owner.y);
                                        });
                                    }
                                    this.interpolate = Data.setUp(
                                        &#x27;x&#x27;, 0,
                                        &#x27;y&#x27;, 0
                                    );
                                    this.interpolationTime = 0;
                        
                                    Object.defineProperty(owner, &#x27;tint&#x27;, {
                                        get: function () {
                                            return this._tint;
                                        }.bind(this),
                                        set: function (value) {
                                            var filters = this.container.filters,
                                                matrix = null,
                                                color = castValue(value);
                        
                                            if (color === this._tint) {
                                                return;
                                            }
                        
                                            if (color === null) {
                                                if (filters) {
                                                    this.container.filters = null;
                                                }
                                            } else {
                                                if (!filters) {
                                                    filters = this.container.filters = arrayCache.setUp(new ColorMatrixFilter());
                                                }
                                                matrix = filters[0].matrix;
                                                matrix[0] = (color &amp; 0xff0000) / 0xff0000; // Red
                                                matrix[6] = (color &amp; 0xff00) / 0xff00; // Green
                                                matrix[12] = (color &amp; 0xff) / 0xff; // Blue
                                            }
                        
                                            this._tint = color;
                                        }.bind(this)
                                    });
                                
                                    if (initialTint !== null) {
                                        this.tint = initialTint; // feed initial tint through setter.
                                    }
                        
                                    if (this.interactive) {
                                        const
                                            definition = Data.setUp(
                                                &#x27;container&#x27;, container,
                                                &#x27;hitArea&#x27;, this.interactive.hitArea,
                                                &#x27;hover&#x27;, this.interactive.hover
                                            );
                                        owner.addComponent(new Interactive(owner, definition));
                                        definition.recycle();
                                    }
                        
                                    if (this.cache) {
                                        this.updateSprite(false, owner.x, owner.y);
                                        this.owner.cacheRender = this.container;
                                    }
                        
                                    if (this.mask &amp;&amp; this.localMask) {
                                        this.setMask(this.mask);
                                    }
                                },
                                
                                events: {
                                    /**
                                     * On receiving a &quot;cache&quot; event, this component triggers &quot;cache-sprite&quot; to cache its rendering into the background. This is an optimization for static images to reduce render calls.
                                     *
                                     * @method &#x27;cache&#x27;
                                     */
                                    &quot;cache&quot;: function () {
                                        const owner = this.owner;
                        
                                        this.updateSprite(false, owner.x, owner.y);
                                        owner.cacheRender = this.container;
                                        this.cache = true;
                                        if (owner.parent.triggerEventOnChildren) {
                                            /**
                                             * On receiving a &quot;cache&quot; event, this component triggers &quot;cache-sprite&quot; to cache its rendering into the background. This is an optimization for static images to reduce render calls.
                                             *
                                             * @event &#x27;cache-sprite&#x27;
                                             * @param entity {platypus.Entity} This component&#x27;s owner.
                                             */
                                            owner.parent.triggerEventOnChildren(&#x27;cache-sprite&#x27;, owner);
                                        } else {
                                            platypus.debug.warn(&#x27;Unable to cache sprite for &#x27; + owner.type);
                                        }
                                    },
                        
                                    /**
                                     * Listens for this event to determine whether this sprite is visible.
                                     *
                                     * @method &#x27;camera-update&#x27;
                                     * @param camera.viewport {platypus.AABB} Camera position and size.
                                     */
                                    &quot;camera-update&quot;: function (camera) {
                                        this.camera.set(camera.viewport);
                                        
                                        // Set visiblity of sprite if within camera bounds
                                        this.needsCameraCheck = true;
                                    },
                                    
                                    /**
                                     * A setup message used to add the sprite to the stage. On receiving this message, the component sets its parent container to the stage contained in the message if it doesn&#x27;t already have one.
                                     *
                                     * @method &#x27;handle-render-load&#x27;
                                     * @param data.renderGroups {Array of PIXI.Container} Containers to categorize display of groups of entities.
                                     */
                                    &quot;handle-render-load&quot;: function () {
                                        const owner = this.owner;
                        
                                        /**
                                         * This event is triggered once the RenderSprite is ready to handle interactivity.
                                         *
                                         * @event &#x27;input-on&#x27;
                                         */
                                        owner.triggerEvent(&#x27;input-on&#x27;);
                                        this.updateSprite(true, owner.x, owner.y);
                                    },
                                    
                                    /**
                                     * This event makes the sprite invisible.
                                     *
                                     * @method &#x27;hide-sprite&#x27;
                                     */
                                    &quot;hide-sprite&quot;: function () {
                                        this.visible = false;
                                    },
                        
                                    /**
                                     * This event makes the sprite visible.
                                     *
                                     * @method &#x27;show-sprite&#x27;
                                     */
                                    &quot;show-sprite&quot;: function () {
                                        this.visible = true;
                                    },
                                    
                                    /**
                                     * Defines the mask on the container/sprite. If no mask is specified, the mask is set to null.
                                     *
                                     * @method &#x27;set-mask&#x27;
                                     * @param mask {Object} The mask. This can specified the same way as the &#x27;mask&#x27; parameter on the component.
                                     */
                                    &quot;set-mask&quot;: function (mask) {
                                        this.setMask(mask);
                                    }
                                },
                                
                                methods: {
                                    updateSprite: function (uncached, x, y) {
                                        const
                                            matrix = pixiMatrix,
                                            rotation = (this.rotate === &#x27;rotation&#x27;) &amp;&amp; this.rotation || 0;
                                        let mirrored = 1,
                                            flipped  = 1;
                                        
                                        if (this.container.zIndex !== this.owner.z) {
                                            this.container.zIndex = this.owner.z;
                                        }
                        
                                        if (!this.ignoreOpacity &amp;&amp; (this.owner.opacity || (this.owner.opacity === 0))) {
                                            this.container.alpha = this.owner.opacity;
                                        }
                                        
                                        if (this.mirror || this.flip) {
                                            const angle = this.rotation % 360;
                                            
                                            if (this.mirror &amp;&amp; (angle &gt; 90) &amp;&amp; (angle &lt; 270)) {
                                                mirrored = -1;
                                            }
                                            
                                            if (this.flip &amp;&amp; (angle &lt; 180)) {
                                                flipped = -1;
                                            }
                                        }
                                        
                                        if (this.rotate === &#x27;orientationMatrix&#x27;) { // This is a 3x3 2D matrix describing an affine transformation.
                                            const o = this.owner.orientationMatrix;
                        
                                            matrix.a = o[0][0];
                                            matrix.b = o[1][0];
                                            matrix.tx = x + o[0][2];
                                            matrix.c = o[0][1];
                                            matrix.d = o[1][1];
                                            matrix.ty = y + o[1][2];
                                            this.container.transform.setFromMatrix(matrix);
                                        } else {
                                            this.container.setTransform(x, y, this.scaleX * mirrored, this.scaleY * flipped, (rotation ? (rotation / 180) * Math.PI : 0), this.skewX, this.skewY);
                                        }
                                        
                                        if (this.parentContainer &amp;&amp; this.parentContainer.parentUpdated) {
                                            this.needsCameraCheck = true;
                                        }
                                        if (this.container) {
                                            if (this.container.childUpdated) {
                                                this.needsCameraCheck = true;
                                                this.container.childUpdated = false;
                                            }
                                            this.container.parentUpdated = false;
                                        }
                                        // Set isCameraOn of sprite if within camera bounds
                                        if (!this.needsCameraCheck) {
                                            this.needsCameraCheck = (this.lastX !== this.owner.x) || (this.lastY !== this.owner.y);
                                        }
                                        if (uncached &amp;&amp; this.container &amp;&amp; (this.needsCameraCheck || (!this.wasVisible &amp;&amp; this.visible))) {
                                            this.isOnCamera = this.owner.parent.isOnCanvas(this.container.getBounds(false));
                                            this.needsCameraCheck = false;
                                            if (this.parentContainer) {
                                                this.parentContainer.childUpdated = true;
                                            }
                                            this.container.parentUpdated = true;
                                        }
                                        
                                        this.lastX = x;
                                        this.lastY = y;
                                        this.wasVisible = this.visible;
                                        this.container.visible = (this.visible &amp;&amp; this.isOnCamera) || this.dragMode;
                                    },
                                    
                                    setMask: function (shape) {
                                        var gfx = null;
                                        
                                        if (this.mask) {
                                            if (this.localMask) {
                                                this.container.removeChild(this.mask);
                                            } else if (this.parentContainer) {
                                                this.parentContainer.removeChild(this.mask);
                                            }
                                        }
                                        
                                        if (!shape) {
                                            this.mask = this.container.mask = null;
                                            return;
                                        }
                                        
                                        if (shape.isMask || (shape instanceof Graphics)) {
                                            gfx = shape;
                                        } else {
                                            gfx = new Graphics();
                                            gfx.beginFill(0x000000, 1);
                                            if (typeof shape === &#x27;string&#x27;) {
                                                processGraphics(gfx, shape);
                                            } else if (shape.radius) {
                                                gfx.drawCircle(shape.x || 0, shape.y || 0, shape.radius);
                                            } else if (shape instanceof AABB) {
                                                gfx.drawRect(shape.left, shape.top, shape.width, shape.height);
                                            } else if (shape.width &amp;&amp; shape.height) {
                                                gfx.drawRect(shape.x || 0, shape.y || 0, shape.width, shape.height);
                                            }
                                            gfx.endFill();
                                        }
                                        
                                        gfx.isMask = true;
                        
                                        this.mask = this.container.mask = gfx;
                                        this.mask.z = 0; //TML 12-4-16 - Masks don&#x27;t need a Z, but this makes it play nice with the Z-ordering in HandlerRender.
                        
                                        if (this.localMask) {
                                            this.container.addChild(this.mask);
                                        } else if (this.parentContainer) {
                                            this.parentContainer.addChild(this.mask);
                                        }
                                    },
                                    
                                    destroy: function () {
                                        this.camera.recycle();
                                        if (this.parentContainer &amp;&amp; !this.container.mouseTarget) {
                                            this.parentContainer.removeChild(this.container);
                                            this.parentContainer = null;
                                        } else if (!this.cache) {
                                            this.container.destroy();
                                        }
                                        this.container = null;
                        
                                        this.interpolate.recycle();
                                        this.interpolate = null;
                                    }
                                },
                            
                                publicMethods: {
                                    /**
                                     * Remove this entity&#x27;s container from the containing rendering container.
                                     *
                                     * @method removeFromParentContainer
                                     */
                                    removeFromParentContainer: function () {
                                        if (this.parentContainer) {
                                            if (this.mask &amp;&amp; !this.localMask) {
                                                this.setMask();
                                            }
                        
                                            this.parentContainer.removeChild(this.container);
                                        }
                                    },
                                    
                                    /**
                                     * Add this entity&#x27;s container to a rendering container.
                                     *
                                     * @method addToParentContainer
                                     * @param {Container} container Container to add this to.
                                     */
                                    addToParentContainer: function (container) {
                                        this.parentContainer = container;
                                        this.parentContainer.addChild(this.container);
                        
                                        if (this.mask &amp;&amp; !this.localMask) {
                                            this.setMask(this.mask);
                                        }
                                    }
                                }
                            });
                        }());
                        
                            </pre>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
