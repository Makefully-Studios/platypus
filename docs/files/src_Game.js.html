<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="../assets/css/yui-cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/x-icon" href="../assets/favicon.ico">
    <script src="../assets/js/yui-source.js"></script>
	<title>platypus v2.0.0 API Documentation : src\Game.js</title>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><a href="https://github.com/PBS-KIDS/Platypus"><img src="..\assets\platypus-title.png" title="platypus"></a></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Documentation for: 2.0.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/platypus.AABB.html">platypus.AABB</a></li>
                                <li><a href="../classes/platypus.ActionState.html">platypus.ActionState</a></li>
                                <li><a href="../classes/platypus.AssetManager.html">platypus.AssetManager</a></li>
                                <li><a href="../classes/platypus.Async.html">platypus.Async</a></li>
                                <li><a href="../classes/platypus.CollisionData.html">platypus.CollisionData</a></li>
                                <li><a href="../classes/platypus.CollisionDataContainer.html">platypus.CollisionDataContainer</a></li>
                                <li><a href="../classes/platypus.CollisionShape.html">platypus.CollisionShape</a></li>
                                <li><a href="../classes/platypus.Component.html">platypus.Component</a></li>
                                <li><a href="../classes/platypus.components.AIChaser.html">platypus.components.AIChaser</a></li>
                                <li><a href="../classes/platypus.components.AIPacer.html">platypus.components.AIPacer</a></li>
                                <li><a href="../classes/platypus.components.AudioMusic.html">platypus.components.AudioMusic</a></li>
                                <li><a href="../classes/platypus.components.AudioSFX.html">platypus.components.AudioSFX</a></li>
                                <li><a href="../classes/platypus.components.AudioVO.html">platypus.components.AudioVO</a></li>
                                <li><a href="../classes/platypus.components.Camera.html">platypus.components.Camera</a></li>
                                <li><a href="../classes/platypus.components.CameraFollowMe.html">platypus.components.CameraFollowMe</a></li>
                                <li><a href="../classes/platypus.components.CollisionBasic.html">platypus.components.CollisionBasic</a></li>
                                <li><a href="../classes/platypus.components.CollisionFilter.html">platypus.components.CollisionFilter</a></li>
                                <li><a href="../classes/platypus.components.CollisionGroup.html">platypus.components.CollisionGroup</a></li>
                                <li><a href="../classes/platypus.components.CollisionTiles.html">platypus.components.CollisionTiles</a></li>
                                <li><a href="../classes/platypus.components.ComponentSwitcher.html">platypus.components.ComponentSwitcher</a></li>
                                <li><a href="../classes/platypus.components.Counter.html">platypus.components.Counter</a></li>
                                <li><a href="../classes/platypus.components.EntityContainer.html">platypus.components.EntityContainer</a></li>
                                <li><a href="../classes/platypus.components.EntityController.html">platypus.components.EntityController</a></li>
                                <li><a href="../classes/platypus.components.HandlerCollision.html">platypus.components.HandlerCollision</a></li>
                                <li><a href="../classes/platypus.components.HandlerController.html">platypus.components.HandlerController</a></li>
                                <li><a href="../classes/platypus.components.HandlerLogic.html">platypus.components.HandlerLogic</a></li>
                                <li><a href="../classes/platypus.components.HandlerRender.html">platypus.components.HandlerRender</a></li>
                                <li><a href="../classes/platypus.components.Interactive.html">platypus.components.Interactive</a></li>
                                <li><a href="../classes/platypus.components.LevelBuilder.html">platypus.components.LevelBuilder</a></li>
                                <li><a href="../classes/platypus.components.LogicAngularMovement.html">platypus.components.LogicAngularMovement</a></li>
                                <li><a href="../classes/platypus.components.LogicAttachment.html">platypus.components.LogicAttachment</a></li>
                                <li><a href="../classes/platypus.components.LogicButton.html">platypus.components.LogicButton</a></li>
                                <li><a href="../classes/platypus.components.LogicCarrier.html">platypus.components.LogicCarrier</a></li>
                                <li><a href="../classes/platypus.components.LogicDestroyMe.html">platypus.components.LogicDestroyMe</a></li>
                                <li><a href="../classes/platypus.components.LogicDirectionalMovement.html">platypus.components.LogicDirectionalMovement</a></li>
                                <li><a href="../classes/platypus.components.LogicDragDrop.html">platypus.components.LogicDragDrop</a></li>
                                <li><a href="../classes/platypus.components.LogicPortable.html">platypus.components.LogicPortable</a></li>
                                <li><a href="../classes/platypus.components.LogicRotationalMovement.html">platypus.components.LogicRotationalMovement</a></li>
                                <li><a href="../classes/platypus.components.LogicTimer.html">platypus.components.LogicTimer</a></li>
                                <li><a href="../classes/platypus.components.LogicWindUpRacer.html">platypus.components.LogicWindUpRacer</a></li>
                                <li><a href="../classes/platypus.components.Motion.html">platypus.components.Motion</a></li>
                                <li><a href="../classes/platypus.components.Mover.html">platypus.components.Mover</a></li>
                                <li><a href="../classes/platypus.components.NodeMap.html">platypus.components.NodeMap</a></li>
                                <li><a href="../classes/platypus.components.NodeResident.html">platypus.components.NodeResident</a></li>
                                <li><a href="../classes/platypus.components.Orientation.html">platypus.components.Orientation</a></li>
                                <li><a href="../classes/platypus.components.RandomEvents.html">platypus.components.RandomEvents</a></li>
                                <li><a href="../classes/platypus.components.RelativePosition.html">platypus.components.RelativePosition</a></li>
                                <li><a href="../classes/platypus.components.RelayFamily.html">platypus.components.RelayFamily</a></li>
                                <li><a href="../classes/platypus.components.RelayGame.html">platypus.components.RelayGame</a></li>
                                <li><a href="../classes/platypus.components.RelayLinker.html">platypus.components.RelayLinker</a></li>
                                <li><a href="../classes/platypus.components.RelayParent.html">platypus.components.RelayParent</a></li>
                                <li><a href="../classes/platypus.components.RelaySelf.html">platypus.components.RelaySelf</a></li>
                                <li><a href="../classes/platypus.components.RenderAnimator.html">platypus.components.RenderAnimator</a></li>
                                <li><a href="../classes/platypus.components.RenderContainer.html">platypus.components.RenderContainer</a></li>
                                <li><a href="../classes/platypus.components.RenderDebug.html">platypus.components.RenderDebug</a></li>
                                <li><a href="../classes/platypus.components.RenderDestroyMe.html">platypus.components.RenderDestroyMe</a></li>
                                <li><a href="../classes/platypus.components.RenderProgress.html">platypus.components.RenderProgress</a></li>
                                <li><a href="../classes/platypus.components.RenderSpine.html">platypus.components.RenderSpine</a></li>
                                <li><a href="../classes/platypus.components.RenderSprite.html">platypus.components.RenderSprite</a></li>
                                <li><a href="../classes/platypus.components.RenderText.html">platypus.components.RenderText</a></li>
                                <li><a href="../classes/platypus.components.RenderTiles.html">platypus.components.RenderTiles</a></li>
                                <li><a href="../classes/platypus.components.SceneChanger.html">platypus.components.SceneChanger</a></li>
                                <li><a href="../classes/platypus.components.TiledLoader.html">platypus.components.TiledLoader</a></li>
                                <li><a href="../classes/platypus.components.Timeline.html">platypus.components.Timeline</a></li>
                                <li><a href="../classes/platypus.components.Tutorial.html">platypus.components.Tutorial</a></li>
                                <li><a href="../classes/platypus.components.Tween.html">platypus.components.Tween</a></li>
                                <li><a href="../classes/platypus.components.VoiceOver.html">platypus.components.VoiceOver</a></li>
                                <li><a href="../classes/platypus.components.XHR.html">platypus.components.XHR</a></li>
                                <li><a href="../classes/platypus.Data.html">platypus.Data</a></li>
                                <li><a href="../classes/platypus.DataMap.html">platypus.DataMap</a></li>
                                <li><a href="../classes/platypus.Entity.html">platypus.Entity</a></li>
                                <li><a href="../classes/platypus.EntityLinker.html">platypus.EntityLinker</a></li>
                                <li><a href="../classes/platypus.Game.html">platypus.Game</a></li>
                                <li><a href="../classes/platypus.Gamepad.html">platypus.Gamepad</a></li>
                                <li><a href="../classes/platypus.Messenger.html">platypus.Messenger</a></li>
                                <li><a href="../classes/platypus.PIXIAnimation.html">platypus.PIXIAnimation</a></li>
                                <li><a href="../classes/platypus.SFXPlayer.html">platypus.SFXPlayer</a></li>
                                <li><a href="../classes/platypus.StateMap.html">platypus.StateMap</a></li>
                                <li><a href="../classes/platypus.Storage.html">platypus.Storage</a></li>
                                <li><a href="../classes/platypus.Vector.html">platypus.Vector</a></li>
                                <li><a href="../classes/platypus.VOPlayer.html">platypus.VOPlayer</a></li>
                                <li><a href="../classes/window.Map.html">window.Map</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/platypus.html">platypus</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
            <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <script>
                        	var name = src\Game.js      
                        </script>
                        <h1 class="file-heading">File:src\Game.js</h1>
                        
                        <div class="file">
                            <pre class="code prettyprint linenums">
                        /**
                         * This class is used to create the &#x60;platypus.game&#x60; object and loads the Platypus game as described by the game configuration files.
                         *
                         * Configuration definition typically takes something like the following structures, but is highly dependent on the particular components used in a given game:
                         *
                         *     {
                         *         &quot;atlases&quot;: {}, // Keyed list of Spine atlases.
                         *         &quot;captions&quot;: {}, // Keyed list of captions for closed captioning.
                         *         &quot;entities&quot;: {}, // Keyed list of entity definitions.
                         *         &quot;levels&quot;: {}, // Keyed list of Tiled levels.
                         *         &quot;mouthCues&quot;: {}, // Keyed list of Rhubarb mouth cues for lip synch.
                         *         &quot;scenes&quot;: {}, // Keyed list of scene definitions.
                         *         &quot;skeletons&quot;: {}, // Keyed list of Spine skeletons.
                         *         &quot;spriteSheets&quot;: {} // Keyed list of sprite sheet definitions.
                         *     }
                         *
                         * Options may include any of these:
                         *
                         *     {
                         *         audio: &#x27;&#x27;, // Relative path to audio assets (like &quot;assets/audio/&quot;).
                         *         canvasId: &#x27;&#x27;, // HTML element ID for the canvas to draw to. If specified but unfound, will create a canvas with this ID.
                         *         display: {}, // Display options are passed directly to PixiJS for setting up the renderer.
                         *         features: { // Features supported for the Springroll application. Defaults are listed below.
                         *             sfx: true,
                         *             vo: true,
                         *             music: true,
                         *             sound: true,
                         *             captions: true
                         *         },
                         *         images: &#x27;&#x27;, // Relative path to graphical assets (like &quot;assets/images/&quot;).
                         *         name: &#x27;&#x27;, // Name of game. Used for local storage keys and displayed in the console on run.
                         *         storageKeys: [] // Array of keys to create in local storage on first run so game code may assume they exist.
                         *         version: &#x27;&#x27; // Version of the game. This is displayed in the console on run.
                         *     }
                         *
                         * @namespace platypus
                         * @class Game
                         * @constructor
                         * @param definition {Object} Collection of configuration settings, typically from config.json.
                         * @param options {Object} Options describing the display options, Springroll features, etc.
                         * @param [onFinishedLoading] {Function} An optional function to run once the game has begun.
                         * @return {platypus.Game} Returns the instantiated game.
                         */
                        /* global document, platypus, window */
                        import {Application, CaptionPlayer, ScaleManager, TextRenderer} from &#x27;springroll&#x27;;
                        import {Container, Renderer, Ticker} from &#x27;pixi.js&#x27;;
                        import {arrayCache, greenSlice, greenSplice, union} from &#x27;./utils/array.js&#x27;;
                        import Async from &#x27;./Async.js&#x27;;
                        import Data from &#x27;./Data.js&#x27;;
                        import Entity from &#x27;./Entity.js&#x27;;
                        import Messenger from &#x27;./Messenger.js&#x27;;
                        import SFXPlayer from &#x27;./SFXPlayer.js&#x27;;
                        import Sound from &#x27;pixi-sound&#x27;;
                        import Storage from &#x27;./Storage.js&#x27;;
                        import TweenJS from &#x27;@tweenjs/tween.js&#x27;;
                        import VOPlayer from &#x27;./VOPlayer.js&#x27;;
                        import config from &#x27;config&#x27;;
                        import sayHello from &#x27;./sayHello.js&#x27;;
                        
                        export default (function () {
                            const XMLHttpRequest = window.XMLHttpRequest,
                                getJSON = function (path, callback) {
                                    var xhr = new XMLHttpRequest();
                                    
                                    xhr.open(&#x27;GET&#x27;, path, true);
                                    xhr.responseType = &#x27;text&#x27;;
                                    xhr.onload = function () {
                                        var obj = null;
                                        
                                        if (xhr.status === 200) {
                                            try {
                                                obj = JSON.parse(xhr.responseText);
                                            } catch (e) {
                                                platypus.debug.warn(&#x27;Error parsing &quot;&#x27; + path + &#x27;&quot;: &#x27; + e.message);
                                            }
                                        } else {
                                            platypus.debug.warn(&#x27;Error opening &quot;&#x27; + path + &#x27;&quot;: &#x27; + xhr.description);
                                        }
                                        
                                        callback(obj);
                                    };
                                    xhr.send();
                                },
                                loadJSONLinks = function (obj, callback) {
                                    var i = 0,
                                        key = &#x27;&#x27;,
                                        callbacks = 0,
                                        resolve = function () {
                                            callbacks -= 1;
                                            if (!callbacks) {
                                                callback(obj);
                                            }
                                        },
                                        assign = function (obj, i, callback) {
                                            loadJSONLinks(obj[i], function (result) {
                                                obj[i] = result;
                                                callback(result);
                                            });
                                        };
                                    
                                    if (obj) {
                                        if (Array.isArray(obj)) {
                                            callbacks = obj.length;
                                            if (callbacks) {
                                                for (i = 0; i &lt; obj.length; i++) {
                                                    assign(obj, i, resolve);
                                                }
                                            } else {
                                                callback(obj);
                                            }
                                            return;
                                        } else if (typeof obj === &#x27;object&#x27;) {
                                            if (obj.src &amp;&amp; (obj.src.length &gt; 5) &amp;&amp; (obj.src.substring(obj.src.length - 5).toLowerCase() === &#x27;.json&#x27;)) {
                                                loadJSONLinks(obj.src, function (result) {
                                                    if (obj.src !== result) {
                                                        obj = result;
                                                    }
                                                    callback(obj);
                                                });
                                            } else {
                                                for (key in obj) {
                                                    if (obj.hasOwnProperty(key)) {
                                                        callbacks += 1;
                                                    }
                                                }
                                                if (callbacks) {
                                                    for (key in obj) {
                                                        if (obj.hasOwnProperty(key)) {
                                                            assign(obj, key, resolve);
                                                        }
                                                    }
                                                } else {
                                                    callback(obj);
                                                }
                                            }
                                            return;
                                        } else if ((typeof obj === &#x27;string&#x27;) &amp;&amp; (obj.length &gt; 5) &amp;&amp; (obj.substring(obj.length - 5).toLowerCase() === &#x27;.json&#x27;)) {
                                            getJSON(obj, function (result) {
                                                if (typeof result === &#x27;object&#x27;) {
                                                    loadJSONLinks(result, callback);
                                                } else {
                                                    callback(result);
                                                }
                                            });
                                            return;
                                        }
                                    }
                                    
                                    callback(obj);
                                },
                                setUpFPS = function (ticker, canvas) {
                                    var framerate = document.createElement(&quot;div&quot;),
                                        framerateTimer = 0;
                        
                                    framerate.id = &quot;framerate&quot;;
                                    framerate.innerHTML = &quot;FPS: 00.000&quot;;
                                    canvas.parentNode.insertBefore(framerate, canvas);
                        
                                    ticker.add(function () {
                                        framerateTimer += this.deltaMS;
                        
                                        // Only update the framerate every second
                                        if (framerateTimer &gt;= 1000) {
                                            framerate.innerHTML = &quot;FPS: &quot; + this.FPS.toFixed(3);
                                            framerateTimer = 0;
                                        }
                                    }.bind(ticker));
                                };
                        
                            class Game extends Messenger {
                                constructor (definition, options, onFinishedLoading) {
                                    const
                                        displayOptions = options.display || {},
                                        load = function (displayOptions, settings) {
                                            const
                                                dpi = window.devicePixelRatio || 1,
                                                ticker = Ticker.shared;
                                                
                                            platypus.game = this; //Make this instance the only Game instance.
                                            
                                            if (config.dev) {
                                                settings.debug = true;
                                            }
                                            
                                            this.settings = settings;
                        
                                            if (settings.captions) {
                                                const captionsElement = document.getElementById(&quot;captions&quot;) || (function (canvas) {
                                                    const element = document.createElement(&#x27;div&#x27;);
                                                    
                                                    element.setAttribute(&#x27;id&#x27;, &#x27;captions&#x27;);
                                                    canvas.parentNode.insertBefore(element, canvas);
                                                    return element;
                                                }(this.canvas));
                                                this.voPlayer.captions = new CaptionPlayer(settings.captions, new TextRenderer(captionsElement));
                                            }
                        
                                            this.stage = new Container();
                                            this.stage.sortableChildren = true;
                                            this.renderer = new Renderer({
                                                width: this.canvas.width,
                                                height: this.canvas.height,
                                                view: this.canvas,
                                                transparent: !!displayOptions.transparent,
                                                antialias: !!displayOptions.antiAlias,
                                                preserveDrawingBuffer: !!displayOptions.preserveDrawingBuffer,
                                                clearBeforeRender: !!displayOptions.clearView,
                                                backgroundColor: displayOptions.backgroundColor || 0,
                                                autoResize: false
                                            });
                        
                                            if (displayOptions.aspectRatio) { // Aspect ratio may be a single value like &quot;4:3&quot; or &quot;4:3-2:1&quot; for a range
                                                const
                                                    aspectRatioRange = displayOptions.aspectRatio.split(&#x27;-&#x27;),
                                                    ratioArray1 = aspectRatioRange[0].split(&#x27;:&#x27;),
                                                    ratioArray2 = aspectRatioRange[aspectRatioRange.length - 1].split(&#x27;:&#x27;),
                                                    ratio1 = ratioArray1[0] / ratioArray1[1],
                                                    ratio2 = ratioArray2[0] / ratioArray2[1],
                                                    smallRatio = Math.min(ratio1, ratio2),
                                                    largeRatio = Math.max(ratio1, ratio2);
                        
                                                this.scaleManager = new ScaleManager(({width, height/*, ratio*/}) =&gt; {
                                                    const
                                                        renderer = this.renderer,
                                                        frame = document.getElementById(&#x27;content&#x27;),
                                                        newHeight = (width / smallRatio) &gt;&gt; 0,
                                                        newWidth = (height * largeRatio) &gt;&gt; 0;
                                                    let h = height * dpi,
                                                        w = width * dpi;
                                        
                                                    if (height &gt; newHeight) {
                                                        frame.style.height = newHeight + &#x27;px&#x27;;
                                                        frame.style.top = (((height - newHeight) / 2) &gt;&gt; 0) + &#x27;px&#x27;;
                                                        frame.style.width = &#x27;&#x27;;
                                                        frame.style.left = &#x27;&#x27;;
                                                        h = newHeight * dpi;
                                                    } else if (width &gt; newWidth) {
                                                        frame.style.width = newWidth + &#x27;px&#x27;;
                                                        frame.style.left = (((width - newWidth) / 2) &gt;&gt; 0) + &#x27;px&#x27;;
                                                        frame.style.height = &#x27;&#x27;;
                                                        frame.style.top = &#x27;&#x27;;
                                                        w = newWidth * dpi;
                                                    } else {
                                                        frame.style.height = &#x27;&#x27;;
                                                        frame.style.top = &#x27;&#x27;;
                                                        frame.style.width = &#x27;&#x27;;
                                                        frame.style.left = &#x27;&#x27;;
                                                    }
                        
                                                    renderer.resize(w, h);
                                                    renderer.render(this.stage); // to prevent flickering from canvas adjustment.
                                                });
                                            } else {
                                                this.scaleManager = new ScaleManager(({width, height/*, ratio*/}) =&gt; {
                                                    const
                                                        renderer = this.renderer;
                        
                                                    renderer.resize(width * dpi, height * dpi);
                                                    renderer.render(this.stage); // to prevent flickering from canvas adjustment.
                                                });
                                            }
                                            this.scaleManager.onResize({ // Run once to resize content div.
                                                width: window.innerWidth,
                                                height: window.innerHeight
                                            });
                        
                                            if (onFinishedLoading) {
                                                onFinishedLoading(this);
                                            }
                        
                                            if (!settings.hideHello) {
                                                sayHello(this);
                                            }
                        
                                            platypus.debug.general(&quot;Game config loaded.&quot;, settings);
                        
                                            //Add Debug tools
                                            window.getEntityById = function (id) {
                                                return this.getEntityById(id);
                                            }.bind(this);
                            
                                            window.getEntitiesByType = function (type) {
                                                return this.getEntitiesByType(type);
                                            }.bind(this);
                                            
                                            window.getVisibleSprites = function (c, a) {
                                                var i = 0;
                                                
                                                a = a || arrayCache.setUp();
                                                c = c || this.stage;
                                                
                                                if (!c.texture &amp;&amp; c.visible) {
                                                    for (i = 0; i &lt; c.children.length; i++) {
                                                        window.getVisibleSprites(c.children[i], a);
                                                    }
                                                    return a;
                                                } else if (c.visible) {
                                                    a.push(c);
                                                    return a;
                                                }
                                                return a;
                                            }.bind(this);
                        
                                            this.ticker = ticker;
                                            this.tickInstance = this.tick.bind(this, ticker, {
                                                delta: 0, // standard, backwards-compatible parameter for &#x60;deltaMS&#x60;
                                                deltaMS: 0, // MS from last frame (matches above)
                                                deltaTime: 0, // PIXI ticker frame value
                                                elapsed: 0 // MS since game start (minus pauses)
                                            });
                        
                                            // START GAME!
                                            ticker.add(this.tickInstance);
                                            this.paused = false;
                        
                                            if (config.dev) {
                                                setUpFPS(ticker, this.canvas);
                                            }
                                        };
                                    let canvas = null;
                                    
                                    super();
                        
                                    if (!definition) {
                                        platypus.debug.warn(&#x27;No game definition is supplied. Game not created.&#x27;);
                                        return;
                                    }
                        
                                    this.options = options;
                        
                                    // Get or set canvas.
                                    if (options.canvasId) {
                                        canvas = window.document.getElementById(options.canvasId);
                                    }
                                    if (!canvas) {
                                        canvas = window.document.createElement(&#x27;canvas&#x27;);
                                        window.document.body.appendChild(canvas);
                                        if (options.canvasId) {
                                            canvas.setAttribute(&#x27;id&#x27;, options.canvasId);
                                        }
                                    }
                                    canvas.width = canvas.offsetWidth;
                                    canvas.height = canvas.offsetHeight;
                        
                                    // Fix for MS Edge so that &quot;no-drag&quot; icon doesn&#x27;t appear on drag.
                                    canvas.ondragstart = function () {
                                        return false;
                                    };
                        
                                    this.canvas = canvas;
                        
                                    this.voPlayer = new VOPlayer(this, platypus.assetCache);
                                    this.voPlayer.trackSound = platypus.supports.iOS;
                        
                                    this.sfxPlayer = new SFXPlayer();
                                    this.musicPlayer = new SFXPlayer();
                                    
                                    this.springroll = (function () {
                                        const
                                            springroll = new Application({
                                                features: options.features || {
                                                    sfx: true,
                                                    vo: true,
                                                    music: true,
                                                    sound: true,
                                                    captions: true
                                                }
                                            }),
                                            state = springroll.state;
                                        
                                        state.pause.subscribe(function (current) {
                                            if (current) {
                                                if (!this.paused) {
                                                    this.ticker.remove(this.tickInstance);
                                                    this.paused = true;
                                                    Sound.pauseAll();
                                                }
                                            } else {
                                                if (this.paused) {
                                                    this.ticker.add(this.tickInstance);
                                                    this.paused = false;
                                                    Sound.resumeAll();
                                                }
                                            }
                                        }.bind(this));
                                        
                                        state.soundVolume.subscribe(function () {
                                            /* SR seems to trigger this too aggressively, in that it already calls mute/unmute on the comprising sfx/music/vo channels. We rely on the others instead. */
                                        });
                                        
                                        state.musicVolume.subscribe((current) =&gt; {
                                            platypus.game.musicPlayer.setVolume(current);
                                        });
                                        
                                        state.voVolume.subscribe(function (current) {
                                            platypus.game.voPlayer.setVolume(current);
                                        });
                        
                                        state.captionsMuted.subscribe(function (current) {
                                            platypus.game.voPlayer.setCaptionMute(current);
                                        });
                                        
                                        state.sfxVolume.subscribe(function (current) {
                                            platypus.game.sfxPlayer.setVolume(current);
                                        });
                        
                                        this.storage = new Storage(springroll, options);
                        
                                        return springroll;
                                    }.bind(this))();
                        
                                    this.layers = arrayCache.setUp();
                                    this.sceneLayers = arrayCache.setUp();
                                    this.loading = arrayCache.setUp();
                                    this.loadingQueue = arrayCache.setUp();
                        
                                    if (typeof definition === &#x27;string&#x27;) {
                                        loadJSONLinks(definition, load.bind(this, displayOptions));
                                    } else {
                                        load.bind(this)(displayOptions, definition);
                                    }
                                }
                                
                                /**
                                 * This method causes the game to tick once.
                                 *
                                 * @method tick
                                 * @param ticker {PIXI.Ticker} The ticker being used to set the game tick.
                                 * @param tickMessage {Object} Event tracking tick data.
                                 * @param deltaTime {number} The time elapsed since the last tick.
                                 **/
                                tick (ticker, tickMessage, deltaTime) {
                                    const loading = this.loading;
                        
                                    tickMessage.delta = tickMessage.deltaMS = ticker.deltaMS;
                                    tickMessage.deltaTime = deltaTime;
                                    tickMessage.elapsed += ticker.deltaMS;
                        
                                    // If layers need to be loaded, load them!
                                    if (loading.length) {
                                        for (let i = 0; i &lt; loading.length; i++) {
                                            loading[i]();
                                        }
                                        loading.length = 0;
                                    }
                        
                                    TweenJS.update();
                        
                                    /**
                                     * This event is triggered on the game as well as each layer currently loaded.
                                     *
                                     * @method tick
                                     * @param tickMessage {Object} Event tracking tick data. This object is re-used for subsequent ticks.
                                     * @param tickMessage.delta {Number} Time in MS passed since last tick.
                                     * @param tickMessage.elapsed {Number} Time in MS passed since game load.
                                     **/
                                    this.triggerEvent(&#x27;tick&#x27;, tickMessage);
                                    this.triggerOnChildren(&#x27;tick&#x27;, tickMessage);
                                    this.renderer.render(this.stage);
                                }
                        
                                /**
                                 * This method is used by external objects to trigger messages on the layers as well as internal entities broadcasting messages across the scope of the scene.
                                 *
                                 * @method triggerOnChildren
                                 * @param {String} eventId This is the message to process.
                                 * @param {*} event This is a message object or other value to pass along to component functions.
                                 **/
                                triggerOnChildren (...args) {
                                    const layers = this.layers;
                        
                                    for (let i = 0; i &lt; layers.length; i++) {
                                        layers[i].trigger(...args);
                                    }
                                }
                                
                                /**
                                 * Loads one or more layers.
                                 *
                                 * If one layer is specified, it will complete loading if no other layers are already loading. If other layers are presently loading, it will complete as soon as other layers are complete.
                                 *
                                 * If an array of layers is specified, all layers must finish loading before any receive a completion event.
                                 *
                                 * @method load
                                 * @param layerId {Array|String} The layer(s) to load.
                                 * @param data {Object} A list of key/value pairs describing options or settings for the loading scene.
                                 * @param isScene {Boolean} Whether the layers from a previous scene should be replaced by these layers.
                                 * @param progressIdOrFunction {String|Function} Whether to report progress. A string sets the id of progress events whereas a function is called directly with progress.
                                **/
                                load (layerId, data, isScene, progressIdOrFunction) {
                                    this.loadingQueue.push(layerId);
                                    // Delay load so it doesn&#x27;t begin a scene mid-tick.
                                    this.loading.push(() =&gt; {
                                        const
                                            layers = Array.isArray(layerId) ? greenSlice(layerId) : arrayCache.setUp(layerId),
                                            assets = arrayCache.setUp(),
                                            properties = arrayCache.setUp(),
                                            loader = arrayCache.setUp((callback) =&gt; {
                                                const
                                                    queue = this.loadingQueue,
                                                    index = queue.indexOf(layerId);
                        
                                                // Make sure previous layers have already gone live.
                                                if (index === 0) {
                                                    queue.shift();
                                                    callback();
                                                    while (typeof queue[0] === &#x27;function&#x27;) {
                                                        const prevCallback = queue[0];
                                                        queue.shift();
                                                        prevCallback();
                                                    }
                                                } else { // Not the next in line, so we&#x27;ll handle this later. (ie bracket above on another group of layers completion)
                                                    queue[index] = callback;
                                                }
                                            }),
                                            getDefinition = (layer) =&gt; {
                                                const id = layer ? layer.type || layer : null;
                        
                                                let layerDefinition = null;
                                                
                                                if (!id) {
                                                    platypus.debug.warn(&#x27;Game: A layer id or layer definition must be provided to load a layer.&#x27;);
                                                    return null;
                                                } else if (typeof id === &#x27;string&#x27;) {
                                                    if (!this.settings.entities[id]) {
                                                        platypus.debug.warn(&#x27;Game: A layer with the id &quot;&#x27; + id + &#x27;&quot; has not been defined in the game settings.&#x27;);
                                                        return null;
                                                    }
                                                    layerDefinition = this.settings.entities[id];
                                                } else {
                                                    layerDefinition = layer;
                                                }
                        
                                                return layerDefinition;
                                            },
                                            loadAssets = function (layerDefinitions, properties, data, assetLists, progressCallback, completeCallback) {
                                                const assets = arrayCache.setUp();
                                
                                                for (let i = 0; i &lt; layerDefinitions.length; i++) {
                                                    const
                                                        props = Data.setUp(properties[i]),
                                                        arr = assetLists[i] = Entity.getAssetList(layerDefinitions[i], props, data);
                        
                                                    for (let j = 0; j &lt; arr.length; j++) {
                                                        assets.push(arr[j]); // We don&#x27;t union so that we can remove individual layers as needed and their asset dependencies.
                                                    }
                                                    props.recycle();
                                                }
                        
                                                platypus.assetCache.load(assets, progressCallback, completeCallback);
                                            },
                                            loadLayer = function (layers, assetLists, index, layerDefinition, properties, data, completeCallback) {
                                                const props = Data.setUp(properties);
                                
                                                props.stage = this.stage;
                                                props.parent = this;
                        
                                                if (layerDefinition) { // Load layer
                                                    const
                                                        holds = Data.setUp(&#x27;count&#x27;, 1, &#x27;release&#x27;, () =&gt; {
                                                            holds.count -= 1;
                                                            if (!holds.count) { // All holds have been released
                                                                holds.recycle();
                                                                
                                                                completeCallback();
                                                            }
                                                        }),
                                                        layer = new Entity(layerDefinition, {
                                                            properties: props
                                                        }, (entity) =&gt; {
                                                            layers[index] = entity;
                                                            holds.release();
                                                        });
                                
                                                    layer.unloadLayer = () =&gt; {
                                                        const
                                                            release = () =&gt; {
                                                                holds -= 1;
                                                                if (holds === 0) {
                                                                    // Delay load so it doesn&#x27;t end a layer mid-tick.
                                                                    window.setTimeout(() =&gt; {
                                                                        /**
                                                                         * This event is triggered on the layers once the Scene is over.
                                                                         *
                                                                         * @event &#x27;layer-unloaded&#x27;
                                                                         */
                                                                        layer.triggerEvent(&#x27;layer-unloaded&#x27;);
                            
                                                                        platypus.debug.olive(&#x27;Layer unloaded: &#x27; + layer.id);
                                                            
                                                                        greenSplice(this.layers, this.layers.indexOf(layer));
                            
                                                                        layer.destroy();
                                                                        platypus.assetCache.unload(assetLists[index]);
                                                                        arrayCache.recycle(assetLists[index]);
                                                                    }, 1);
                                                                }
                                                            };
                                                        let holds = 1;
                            
                                                        /**
                                                         * This event is triggered on the layer to allow children of the layer to place a hold on the closing until they&#x27;re ready.
                                                         *
                                                         * @event &#x27;unload-layer&#x27;
                                                         * @param data {Object} A list of key-value pairs of data sent into this Scene from the previous Scene.
                                                         * @param hold {Function} Calling this function places a hold; &#x60;release&#x60; must be called to release this hold and unload the layer.
                                                         * @param release {Function} Calling this function releases a previous hold.
                                                         */
                                                        layer.triggerEvent(&#x27;unload-layer&#x27;, () =&gt; {
                                                            holds += 1;
                                                        }, release);
                            
                                                        platypus.debug.olive(&#x27;Layer unloading: &#x27; + layer.id);
                                                        release();
                                                    };
                                                    
                                                    /**
                                                     * This event is triggered on the layers once all assets have been readied and the layer is created.
                                                     *
                                                     * @event &#x27;layer-loaded&#x27;
                                                     * @param data {Object} A list of key-value pairs of data sent into this Scene from the previous Scene.
                                                     */
                                                    layer.triggerEvent(&#x27;layer-loaded&#x27;, data, holds);
                                                }
                                            },
                                            progressHandler = progressIdOrFunction ? ((typeof progressIdOrFunction === &#x27;string&#x27;) ? function (progress, ratio) {
                                                progress.progress = ratio;
                                                this.triggerOnChildren(&#x27;load-progress&#x27;, progress);
                                            }.bind(this, Data.setUp(
                                                &#x27;id&#x27;, progressIdOrFunction,
                                                &#x27;progress&#x27;, 0
                                            )) : progressIdOrFunction) : null;
                        
                                        for (let i = 0; i &lt; layers.length; i++) {
                                            const
                                                layer = layers[i],
                                                layerDefinition = getDefinition(layer),
                                                layerProps = (layer &amp;&amp; layer.type &amp;&amp; layer.properties) || null;
                        
                                            loader.push(loadLayer.bind(this, layers, assets, i, layerDefinition, layerProps, data));
                                            layers[i] = layerDefinition;
                                            properties[i] = layerProps;
                                        }
                        
                                        loadAssets(layers, properties, data, assets, progressHandler, () =&gt; {
                                            Async.setUp(loader, () =&gt; {
                                                for (let i = 0; i &lt; layers.length; i++) {
                                                    const layer = layers[i];
                        
                                                    this.layers.push(layer);
                        
                                                    if (isScene) {
                                                        this.sceneLayers.push(layer);
                                                    }
                        
                                                    platypus.debug.olive(&#x27;Layer live: &#x27; + layer.id);
                            
                                                    /**
                                                     * This event is triggered on each newly-live layer once it is finished loading and ready to display.
                                                     *
                                                     * @event &#x27;layer-live&#x27;
                                                     * @param data {Object} A list of key-value pairs of data sent into this Scene from the previous Scene.
                                                     */
                                                    layer.triggerEvent(&#x27;layer-live&#x27;, data);
                                                }
                                            });
                                        });
                                    });
                                }
                        
                                /**
                                 * Loads a scene.
                                 *
                                 * @method loadScene
                                 * @param layersOrId {Array|Object|String} The list of layers, an object with a &#x60;layers&#x60; Array property, or scene id to load.
                                 * @param data {Object} A list of key/value pairs describing options or settings for the loading scene.
                                 * @param progressIdOrFunction {String|Function} Whether to report progress. A string sets the id of progress events whereas a function is called directly with progress.
                                 **/
                                loadScene (layersOrId, data, progressIdOrFunction = &#x27;scene&#x27;) {
                                    const sceneLayers = this.sceneLayers;
                                    let layers = layersOrId;
                                    
                                    if (typeof layers === &#x27;string&#x27;) {
                                        layers = this.settings.scenes &amp;&amp; this.settings.scenes[layers];
                                    }
                        
                                    if (!layers) {
                                        platypus.debug.warn(&#x27;Game: &quot;&#x27; + layersOrId + &#x27;&quot; is an invalid scene.&#x27;);
                                        return;
                                    }
                        
                                    if (layers.layers) { // Object containing a list of layers.
                                        layers = layers.layers;
                                    }
                                    
                                    while (sceneLayers.length) {
                                        this.unload(sceneLayers[0]);
                                    }
                        
                                    this.load(layers, data, true, progressIdOrFunction);
                                }
                                
                                /**
                                 * Unloads a layer.
                                 *
                                 * @method unload
                                 * @param layer {String|Object} The layer to unload.
                                **/
                                unload (layer) {
                                    let layerToUnload = layer,
                                        sceneIndex = 0;
                        
                                    if (typeof layerToUnload === &#x27;string&#x27;) {
                                        for (let i = 0; i &lt; this.layers.length; i++) {
                                            if (this.layers[i].type === layerToUnload) {
                                                layerToUnload = this.layers[i];
                                                break;
                                            }
                                        }
                                    }
                        
                                    sceneIndex = this.sceneLayers.indexOf(layerToUnload); // remove scene entry if it exists
                                    if (sceneIndex &gt;= 0) {
                                        greenSplice(this.sceneLayers, sceneIndex);
                                    }
                        
                                    layerToUnload.unloadLayer();
                                }
                                
                                /**
                                 * This method will return the first entity it finds with a matching id.
                                 *
                                 * @method getEntityById
                                 * @param {string} id The entity id to find.
                                 * @return {Entity} Returns the entity that matches the specified entity id.
                                 **/
                                getEntityById (id) {
                                    var i = 0,
                                        selection = null;
                                    
                                    for (i = 0; i &lt; this.layers.length; i++) {
                                        if (this.layers[i].id === id) {
                                            return this.layers[i];
                                        }
                                        if (this.layers[i].getEntityById) {
                                            selection = this.layers[i].getEntityById(id);
                                            if (selection) {
                                                return selection;
                                            }
                                        }
                                    }
                                    return null;
                                }
                        
                                /**
                                 * This method will return all game entities that match the provided type.
                                 *
                                 * @method getEntitiesByType
                                 * @param {String} type The entity type to find.
                                 * @return entities {Array} Returns the entities that match the specified entity type.
                                 **/
                                getEntitiesByType (type) {
                                    var i = 0,
                                        selection = null,
                                        entities  = arrayCache.setUp();
                                    
                                    for (i = 0; i &lt; this.layers.length; i++) {
                                        if (this.layers[i].type === type) {
                                            entities.push(this.layers[i]);
                                        }
                                        if (this.layers[i].getEntitiesByType) {
                                            selection = this.layers[i].getEntitiesByType(type);
                                            union(entities, selection);
                                            arrayCache.recycle(selection);
                                        }
                                    }
                                    return entities;
                                }
                                
                                /**
                                * This method destroys the game.
                                *
                                * @method destroy
                                **/
                                destroy () {
                                    const layers = this.layers;
                        
                                    for (let i = 0; i &lt; layers.length; i++) {
                                        layers[i].destroy();
                                    }
                                    layers.recycle();
                                }
                            }
                            
                            return Game;
                        }());
                            </pre>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
